// name:     Bug2871.mos [BUG #2871]
// keywords: check that the initial environment is cloned when is returned
// status:   correct
//
// Checks that the intial environment is cloned when returned (as the env now has destructive updates)
//

loadModel(Modelica, {"3.2.1"}); getErrorString();

existClass(Modelica.Fluid.Vessels.OpenTank);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
getIconAnnotation(Modelica.Fluid.Pipes.StaticPipe);
getInheritanceCount(Modelica.Fluid.Pipes.StaticPipe);
getNthInheritedClass(Modelica.Fluid.Pipes.StaticPipe, 1);
getClassRestriction(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe);
getIconAnnotation(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe);
getInheritanceCount(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe);
getNthInheritedClass(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe, 1);
getClassRestriction(Modelica.Fluid.Interfaces.PartialTwoPort);
getIconAnnotation(Modelica.Fluid.Interfaces.PartialTwoPort);
getInheritanceCount(Modelica.Fluid.Interfaces.PartialTwoPort);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getComponents(Modelica.Fluid.Interfaces.PartialTwoPort, useQuotes = true);
getComponentAnnotations(Modelica.Fluid.Interfaces.PartialTwoPort);
isConnector(Modelica.Fluid.Interfaces.FluidPort_a);
getIconAnnotation(Modelica.Fluid.Interfaces.FluidPort_a);
getInheritanceCount(Modelica.Fluid.Interfaces.FluidPort_a);
getNthInheritedClass(Modelica.Fluid.Interfaces.FluidPort_a, 1);
isConnector(Modelica.Fluid.Interfaces.FluidPort_b);
getIconAnnotation(Modelica.Fluid.Interfaces.FluidPort_b);
getInheritanceCount(Modelica.Fluid.Interfaces.FluidPort_b);
getComponents(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe, useQuotes = true);
getComponentAnnotations(Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe);
getComponents(Modelica.Fluid.Pipes.StaticPipe, useQuotes = true);
getComponentAnnotations(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getConnectionCount(Modelica.Icons.Example);
getConnectionCount(Modelica.Fluid.Examples.Tanks.ThreeTanks);
getNthConnection(Modelica.Fluid.Examples.Tanks.ThreeTanks, 1);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getNthConnectionAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, 1);
getNthConnection(Modelica.Fluid.Examples.Tanks.ThreeTanks, 2);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getNthConnectionAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, 2);
getNthConnection(Modelica.Fluid.Examples.Tanks.ThreeTanks, 3);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getClassRestriction(Modelica.Fluid.Vessels.OpenTank);
existClass(Modelica.Fluid.Vessels.OpenTank);
getNthConnectionAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, 3);
getNthConnection(Modelica.Fluid.Examples.Tanks.ThreeTanks, 4);
getClassRestriction(Modelica.Fluid.Vessels.OpenTank);
existClass(Modelica.Fluid.Vessels.OpenTank);
getNthConnectionAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, 4);
getNthConnection(Modelica.Fluid.Examples.Tanks.ThreeTanks, 5);
getClassRestriction(Modelica.Fluid.Pipes.StaticPipe);
existClass(Modelica.Fluid.Pipes.StaticPipe);
getClassRestriction(Modelica.Fluid.Vessels.OpenTank);
existClass(Modelica.Fluid.Vessels.OpenTank);
getNthConnectionAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, 5);
getNamedAnnotation(Modelica.Fluid.Examples.Tanks.ThreeTanks, preferredView);
isExperiment(Modelica.Fluid.Examples.Tanks.ThreeTanks);
getSimulationOptions(Modelica.Fluid.Examples.Tanks.ThreeTanks, defaultTolerance=0.0001);
setCommandLineOptions("+profiling=none"); getErrorString();
instantiateModel(Modelica.Fluid.Examples.Tanks.ThreeTanks); getErrorString();

// Result:
// true
// ""
// true
// "model"
// {}
// 1
// Modelica.Fluid.Pipes.BaseClasses.PartialStraightPipe
// "model"
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {95, 95, 95}, LinePattern.None, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 40}, {100, -40}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 127, 255}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-100, 44}, {100, -44}}, 0)}}
// 1
// Modelica.Fluid.Interfaces.PartialTwoPort
// "model"
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {0, 128, 255}, {0, 128, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{20, -70}, {60, -85}, {20, -100}, {20, -70}}, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {255, 255, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{20, -75}, {50, -85}, {20, -95}, {20, -75}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{55, -85}, {-60, -85}}, {0, 128, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-149, -114}, {151, -154}}, "%name", 0, TextAlignment.Center), Ellipse(false, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-110, 26}, {-90, -24}}, 0, 360), Ellipse(false, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 25}, {110, -25}}, 0, 360)}}
// 0
// true
// {{"Modelica.Fluid.System","system","System wide properties", "public", "false", "false", "false", "false", "unspecified", "outer", "unspecified","{}"},{"Boolean","allowFlowReversal","= true to allow flow reversal, false restricts to design direction (port_a -> port_b)", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.Fluid.Interfaces.FluidPort_a","port_a","Fluid connector a (positive design flow direction is from port_a to port_b)", "public", "false", "false", "false", "false", "unspecified", "none", "unspecified","{}"},{"Modelica.Fluid.Interfaces.FluidPort_b","port_b","Fluid connector b (positive design flow direction is from port_a to port_b)", "public", "false", "false", "false", "false", "unspecified", "none", "unspecified","{}"},{"Boolean","port_a_exposesState","= true if port_a exposes the state of a fluid volume", "protected", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Boolean","port_b_exposesState","= true if port_b.p exposes the state of a fluid volume", "protected", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Boolean","showDesignFlowDirection","= false to hide the arrow in the model icon", "protected", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"}}
// {{},{Dialog("Assumptions","",true,-,false,-,-,-,-,"",false), Evaluate=true},{Placement(true,-,-,-110.0,-10.0,-90.0,10.0,-,-,-,-,-,-,-,)},{Placement(true,-,-,110.0,-10.0,90.0,10.0,-,-,-,110.0,-10.0,90.0,10.0,)},{},{},{}}
// true
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 127, 255}, {0, 127, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {100, -100}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 127, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {100, -100}}, 0, 360)}}
// 1
// Modelica.Fluid.Interfaces.FluidPort
// true
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 127, 255}, {0, 127, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {100, -100}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 127, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {100, -100}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 127, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 80}, {80, -80}}, 0, 360)}}
// 1
// {{"Real","nParallel","Number of identical parallel pipes", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Length","length","Length", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Boolean","isCircular","= true if cross sectional area is circular", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Diameter","diameter","Diameter of circular pipe", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Area","crossArea","Inner cross section area", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Length","perimeter","Inner perimeter", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Height","roughness","Average height of surface asperities (default: smooth steel pipe)", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Volume","V","volume size", "public", "true", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.SIunits.Length","height_ab","Height(port_b) - Height(port_a)", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"}}
// {{Dialog("General","Geometry",true,-,false,-,-,-,-,"",false)},{Dialog("General","Geometry",true,-,false,-,-,-,-,"",false)},{},{Dialog("General","Geometry",true,-,false,-,-,-,-,"",false)},{Dialog("General","Geometry",false,-,false,-,-,-,-,"",false)},{Dialog("General","Geometry",false,-,false,-,-,-,-,"",false)},{Dialog("General","Geometry",true,-,false,-,-,-,-,"",false)},{},{Dialog("General","Static head",true,-,false,-,-,-,-,"",false)}}
// {{"Modelica.Fluid.Pipes.StaticPipe.Medium.AbsolutePressure","p_a_start","Start value of pressure at port a", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.Fluid.Pipes.StaticPipe.Medium.AbsolutePressure","p_b_start","Start value of pressure at port b", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.Fluid.Pipes.StaticPipe.Medium.MassFlowRate","m_flow_start","Start value for mass flow rate", "public", "false", "false", "false", "false", "parameter", "none", "unspecified","{}"},{"Modelica.Fluid.Pipes.StaticPipe.FlowModel","flowModel","Flow model", "public", "false", "false", "false", "false", "unspecified", "none", "unspecified","{}"}}
// {{Dialog("Initialization","",true,-,false,-,-,-,-,"",false)},{Dialog("Initialization","",true,-,false,-,-,-,-,"",false)},{Evaluate=true, Dialog("Initialization","",true,-,false,-,-,-,-,"",false)},{Placement(true,-,-,-38.0,-18.0,38.0,18.0,-,-,-,-,-,-,-,)}}
// true
// true
// 0
// 5
// {"pipe1.port_a","pipe2.port_a",""}
// "model"
// true
// "model"
// true
// {Line(true, {0.0, 0.0}, 0, {{-60, -20}, {-60, -40}, {0, -40}, {0, -30}, {0, -20}}, {0, 127, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}
// {"pipe2.port_a","pipe3.port_a",""}
// "model"
// true
// "model"
// true
// {Line(true, {0.0, 0.0}, 0, {{0, -20}, {0, -20}, {0, -40}, {60, -40}, {60, -30}}, {0, 127, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}
// {"pipe3.port_b","tank3.ports[1]",""}
// "model"
// true
// "model"
// true
// {Line(true, {0.0, 0.0}, 0, {{60, -10}, {60, -10}, {60, 10}}, {0, 127, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}
// {"pipe1.port_b","tank1.ports[1]",""}
// "model"
// true
// {Line(true, {0.0, 0.0}, 0, {{-60, 0}, {-60, 10}, {-60, 20}}, {0, 127, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}
// {"pipe2.port_b","tank2.ports[1]",""}
// "model"
// true
// "model"
// true
// {Line(true, {0.0, 0.0}, 0, {{0, 0}, {0, 20}}, {0, 127, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}
// {}
// true
// (0.0,200.0,0.0001,500,0.4)
// true
// ""
// "function Modelica.Fluid.Interfaces.FluidPort_a$pipe1$port_a.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_a$pipe1$port_a.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe1$port_a.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_a$pipe1$port_a.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe1$port_a.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Interfaces.FluidPort_a$pipe2$port_a.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_a$pipe2$port_a.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe2$port_a.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_a$pipe2$port_a.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe2$port_a.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Interfaces.FluidPort_a$pipe3$port_a.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_a$pipe3$port_a.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe3$port_a.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_a$pipe3$port_a.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_a$pipe3$port_a.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe1$port_b.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_b$pipe1$port_b.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe1$port_b.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe1$port_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe1$port_b.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe2$port_b.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_b$pipe2$port_b.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe2$port_b.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe2$port_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe2$port_b.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe3$port_b.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Interfaces.FluidPort_b$pipe3$port_b.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe3$port_b.Medium.FluidConstants;
//
// function Modelica.Fluid.Interfaces.FluidPort_b$pipe3$port_b.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Interfaces.FluidPort_b$pipe3$port_b.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density(Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.setState_pTX(p, T, X));
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.pressure \"Return pressure\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
// algorithm
//   p := state.p;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.pressure;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.setState_pTX \"Return thermodynamic state from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState(p, T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.setState_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric \"Calculate mass flow rate as function of pressure drop due to friction\"
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") \"Inner cross section area\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   output Real dm_flow_ddp_fric \"Derivative of mass flow rate with dp_fric\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dRe_ddp \"dRe/ddp\";
//   protected Real aux1;
//   protected Real aux2;
// algorithm
//   if dp_fric >= 0.0 then
//     rho := rho_a;
//     mu := mu_a;
//   else
//     rho := rho_b;
//     mu := mu_b;
//   end if;
//   lambda2 := 2.0 * abs(dp_fric) * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   aux1 := 2.0 * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   Re := 0.015625 * lambda2;
//   dRe_ddp := 0.015625 * aux1;
//   if Re > Re1 then
//     Re := (-2.0) * sqrt(lambda2) * log10(2.51 / sqrt(lambda2) + 0.27 * Delta);
//     aux2 := sqrt(aux1 * abs(dp_fric));
//     dRe_ddp := 0.4342944819032518 * (2.51 / ((2.51 / aux2 + 0.27 * Delta) * abs(dp_fric)) - log(2.51 / aux2 + 0.27 * Delta) * aux1 / aux2);
//     if Re < Re2 then
//       (Re, dRe_ddp) := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
//     end if;
//   end if;
//   m_flow := crossArea * mu * (if dp_fric >= 0.0 then Re else -Re) / diameter;
//   dm_flow_ddp_fric := crossArea * mu * dRe_ddp / diameter;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative \"Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)\"
//   input Real lambda2 \"Known independent variable\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   output Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Unknown return variable\";
//   output Real dRe_ddp \"Derivative of return value\";
//   protected Real y1d = 1.0;
//   protected Real y;
//   protected Real dy_dx \"Derivative in transformed space\";
//   protected Real x = log10(lambda2);
//   protected Real x1 = log10(64.0 * Re1);
//   protected Real y1 = log10(Re1);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real x2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real y2 = log10(aux5);
//   protected Real y2d = 0.5 + 1.090079149577162 / (aux4 * aux5);
// algorithm
//   (y, dy_dx) := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
//   Re := 10.0 ^ y;
//   dRe_ddp := Re * dy_dx / abs(dp_fric);
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.massFlowRate_dp_staticHead \"Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head\"
//   input Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real g_times_height_ab \"Gravity times (Height(port_b) - Height(port_a))\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = 1.0 \"Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dp_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Upper end of regularization domain of the m_flow(dp) relation\";
//   protected Real dp_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Lower end of regularization domain of the m_flow(dp) relation\";
//   protected Real m_flow_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at upper end of regularization domain\";
//   protected Real m_flow_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at lower end of regularization domain\";
//   protected Real dm_flow_ddp_fric_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at upper end of regularization domain\";
//   protected Real dm_flow_ddp_fric_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at lower end of regularization domain\";
//   protected Real m_flow_zero(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0;
//   protected Real dm_flow_ddp_fric_zero;
//   protected Real dp_grav_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_a \"Static head if mass flows in design direction (a to b)\";
//   protected Real dp_grav_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_b \"Static head if mass flows against design direction (b to a)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Boundary between transition and turbulent regime\";
//   protected Real dp_zero(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 0.5 * (dp_grav_a + dp_grav_b);
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min((745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta)) ^ 0.97, Re_turbulent) \"Boundary between laminar regime and transition\";
// algorithm
//   dp_a := max(dp_grav_a, dp_grav_b) + dp_small;
//   dp_b := min(dp_grav_a, dp_grav_b) - dp_small;
//   if dp >= dp_a then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   elseif dp <= dp_b then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   else
//     (m_flow_a, dm_flow_ddp_fric_a) := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_a - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow_b, dm_flow_ddp_fric_b) := Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_b - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow, dm_flow_ddp_fric_zero) := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
//     if dp > dp_zero then
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a)[1];
//     else
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero)[1];
//     end if;
//   end if;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.massFlowRate_dp_staticHead;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow \"Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction\"
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.01 \"Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Re entering turbulent curve\";
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min(745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta), Re_turbulent) \"Re leaving laminar curve\";
// algorithm
//   rho := if m_flow >= 0.0 then rho_a else rho_b;
//   mu := if m_flow >= 0.0 then mu_a else mu_b;
//   Re := diameter * abs(m_flow) / (mu * crossArea);
//   lambda2 := if Re <= Re1 then 64.0 * Re else if Re >= Re2 then 0.25 * (Re / log10(0.2702702702702702 * Delta + 5.74 / Re ^ 0.9)) ^ 2.0 else Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2(Re, Re1, Re2, Delta);
//   dp := 0.5 * length * mu ^ 2.0 * diameter ^ (-3.0) * (if m_flow >= 0.0 then lambda2 else -lambda2) / rho;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2
//   input Real Re(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Delta;
//   output Real lambda2;
//   protected Real yd1 = 1.0;
//   protected Real aux1 = 1.121782646756099;
//   protected Real dx;
//   protected Real x1 = log10(Re1);
//   protected Real y1 = log10(64.0 * Re1);
//   protected Real x2 = log10(Re2);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real diff_x = x2 - x1;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real yd2 = 2.0 + 4.0 * aux1 / (Re2 ^ 0.9 * aux3 * aux2);
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real y2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real m = (y2 - y1) / diff_x;
//   protected Real c2 = (3.0 * m + (-2.0) * yd1 - yd2) / diff_x;
//   protected Real c3 = (yd1 + yd2 + (-2.0) * m) / diff_x ^ 2.0;
// algorithm
//   dx := log10(Re / Re1);
//   lambda2 := 64.0 * Re1 * (Re / Re1) ^ (1.0 + dx * (c2 + dx * c3));
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.setState_phX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density(Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.setState_pTX(p, T, X));
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.pressure \"Return pressure\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
// algorithm
//   p := state.p;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.pressure;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.setState_pTX \"Return thermodynamic state from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState(p, T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.setState_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric \"Calculate mass flow rate as function of pressure drop due to friction\"
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") \"Inner cross section area\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   output Real dm_flow_ddp_fric \"Derivative of mass flow rate with dp_fric\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dRe_ddp \"dRe/ddp\";
//   protected Real aux1;
//   protected Real aux2;
// algorithm
//   if dp_fric >= 0.0 then
//     rho := rho_a;
//     mu := mu_a;
//   else
//     rho := rho_b;
//     mu := mu_b;
//   end if;
//   lambda2 := 2.0 * abs(dp_fric) * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   aux1 := 2.0 * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   Re := 0.015625 * lambda2;
//   dRe_ddp := 0.015625 * aux1;
//   if Re > Re1 then
//     Re := (-2.0) * sqrt(lambda2) * log10(2.51 / sqrt(lambda2) + 0.27 * Delta);
//     aux2 := sqrt(aux1 * abs(dp_fric));
//     dRe_ddp := 0.4342944819032518 * (2.51 / ((2.51 / aux2 + 0.27 * Delta) * abs(dp_fric)) - log(2.51 / aux2 + 0.27 * Delta) * aux1 / aux2);
//     if Re < Re2 then
//       (Re, dRe_ddp) := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
//     end if;
//   end if;
//   m_flow := crossArea * mu * (if dp_fric >= 0.0 then Re else -Re) / diameter;
//   dm_flow_ddp_fric := crossArea * mu * dRe_ddp / diameter;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative \"Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)\"
//   input Real lambda2 \"Known independent variable\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   output Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Unknown return variable\";
//   output Real dRe_ddp \"Derivative of return value\";
//   protected Real y1d = 1.0;
//   protected Real y;
//   protected Real dy_dx \"Derivative in transformed space\";
//   protected Real x = log10(lambda2);
//   protected Real x1 = log10(64.0 * Re1);
//   protected Real y1 = log10(Re1);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real x2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real y2 = log10(aux5);
//   protected Real y2d = 0.5 + 1.090079149577162 / (aux4 * aux5);
// algorithm
//   (y, dy_dx) := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
//   Re := 10.0 ^ y;
//   dRe_ddp := Re * dy_dx / abs(dp_fric);
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.massFlowRate_dp_staticHead \"Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head\"
//   input Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real g_times_height_ab \"Gravity times (Height(port_b) - Height(port_a))\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = 1.0 \"Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dp_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Upper end of regularization domain of the m_flow(dp) relation\";
//   protected Real dp_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Lower end of regularization domain of the m_flow(dp) relation\";
//   protected Real m_flow_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at upper end of regularization domain\";
//   protected Real m_flow_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at lower end of regularization domain\";
//   protected Real dm_flow_ddp_fric_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at upper end of regularization domain\";
//   protected Real dm_flow_ddp_fric_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at lower end of regularization domain\";
//   protected Real m_flow_zero(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0;
//   protected Real dm_flow_ddp_fric_zero;
//   protected Real dp_grav_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_a \"Static head if mass flows in design direction (a to b)\";
//   protected Real dp_grav_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_b \"Static head if mass flows against design direction (b to a)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Boundary between transition and turbulent regime\";
//   protected Real dp_zero(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 0.5 * (dp_grav_a + dp_grav_b);
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min((745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta)) ^ 0.97, Re_turbulent) \"Boundary between laminar regime and transition\";
// algorithm
//   dp_a := max(dp_grav_a, dp_grav_b) + dp_small;
//   dp_b := min(dp_grav_a, dp_grav_b) - dp_small;
//   if dp >= dp_a then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   elseif dp <= dp_b then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   else
//     (m_flow_a, dm_flow_ddp_fric_a) := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_a - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow_b, dm_flow_ddp_fric_b) := Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_b - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow, dm_flow_ddp_fric_zero) := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
//     if dp > dp_zero then
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a)[1];
//     else
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero)[1];
//     end if;
//   end if;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.massFlowRate_dp_staticHead;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow \"Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction\"
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.01 \"Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Re entering turbulent curve\";
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min(745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta), Re_turbulent) \"Re leaving laminar curve\";
// algorithm
//   rho := if m_flow >= 0.0 then rho_a else rho_b;
//   mu := if m_flow >= 0.0 then mu_a else mu_b;
//   Re := diameter * abs(m_flow) / (mu * crossArea);
//   lambda2 := if Re <= Re1 then 64.0 * Re else if Re >= Re2 then 0.25 * (Re / log10(0.2702702702702702 * Delta + 5.74 / Re ^ 0.9)) ^ 2.0 else Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2(Re, Re1, Re2, Delta);
//   dp := 0.5 * length * mu ^ 2.0 * diameter ^ (-3.0) * (if m_flow >= 0.0 then lambda2 else -lambda2) / rho;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2
//   input Real Re(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Delta;
//   output Real lambda2;
//   protected Real yd1 = 1.0;
//   protected Real aux1 = 1.121782646756099;
//   protected Real dx;
//   protected Real x1 = log10(Re1);
//   protected Real y1 = log10(64.0 * Re1);
//   protected Real x2 = log10(Re2);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real diff_x = x2 - x1;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real yd2 = 2.0 + 4.0 * aux1 / (Re2 ^ 0.9 * aux3 * aux2);
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real y2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real m = (y2 - y1) / diff_x;
//   protected Real c2 = (3.0 * m + (-2.0) * yd1 - yd2) / diff_x;
//   protected Real c3 = (yd1 + yd2 + (-2.0) * m) / diff_x ^ 2.0;
// algorithm
//   dx := log10(Re / Re1);
//   lambda2 := 64.0 * Re1 * (Re / Re1) ^ (1.0 + dx * (c2 + dx * c3));
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.setState_phX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density_pTX \"Return density from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density(Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.setState_pTX(p, T, X));
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.pressure \"Return pressure\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
// algorithm
//   p := state.p;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.pressure;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.setState_pTX \"Return thermodynamic state from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState(p, T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.setState_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric \"Calculate mass flow rate as function of pressure drop due to friction\"
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") \"Inner cross section area\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   output Real dm_flow_ddp_fric \"Derivative of mass flow rate with dp_fric\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dRe_ddp \"dRe/ddp\";
//   protected Real aux1;
//   protected Real aux2;
// algorithm
//   if dp_fric >= 0.0 then
//     rho := rho_a;
//     mu := mu_a;
//   else
//     rho := rho_b;
//     mu := mu_b;
//   end if;
//   lambda2 := 2.0 * abs(dp_fric) * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   aux1 := 2.0 * diameter ^ 3.0 * rho / (mu ^ 2.0 * length);
//   Re := 0.015625 * lambda2;
//   dRe_ddp := 0.015625 * aux1;
//   if Re > Re1 then
//     Re := (-2.0) * sqrt(lambda2) * log10(2.51 / sqrt(lambda2) + 0.27 * Delta);
//     aux2 := sqrt(aux1 * abs(dp_fric));
//     dRe_ddp := 0.4342944819032518 * (2.51 / ((2.51 / aux2 + 0.27 * Delta) * abs(dp_fric)) - log(2.51 / aux2 + 0.27 * Delta) * aux1 / aux2);
//     if Re < Re2 then
//       (Re, dRe_ddp) := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
//     end if;
//   end if;
//   m_flow := crossArea * mu * (if dp_fric >= 0.0 then Re else -Re) / diameter;
//   dm_flow_ddp_fric := crossArea * mu * dRe_ddp / diameter;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative \"Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)\"
//   input Real lambda2 \"Known independent variable\";
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between laminar regime and transition\";
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") \"Boundary between transition and turbulent regime\";
//   input Real Delta \"Relative roughness\";
//   input Real dp_fric(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss due to friction (dp = port_a.p - port_b.p)\";
//   output Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Unknown return variable\";
//   output Real dRe_ddp \"Derivative of return value\";
//   protected Real y1d = 1.0;
//   protected Real y;
//   protected Real dy_dx \"Derivative in transformed space\";
//   protected Real x = log10(lambda2);
//   protected Real x1 = log10(64.0 * Re1);
//   protected Real y1 = log10(Re1);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real x2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real y2 = log10(aux5);
//   protected Real y2d = 0.5 + 1.090079149577162 / (aux4 * aux5);
// algorithm
//   (y, dy_dx) := Modelica.Fluid.Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);
//   Re := 10.0 ^ y;
//   dRe_ddp := Re * dy_dx / abs(dp_fric);
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric.interpolateInRegion2_withDerivative;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.massFlowRate_dp_staticHead \"Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head\"
//   input Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real g_times_height_ab \"Gravity times (Height(port_b) - Height(port_a))\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = 1.0 \"Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real dp_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Upper end of regularization domain of the m_flow(dp) relation\";
//   protected Real dp_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Lower end of regularization domain of the m_flow(dp) relation\";
//   protected Real m_flow_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at upper end of regularization domain\";
//   protected Real m_flow_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Value at lower end of regularization domain\";
//   protected Real dm_flow_ddp_fric_a(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at upper end of regularization domain\";
//   protected Real dm_flow_ddp_fric_b(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Derivative at lower end of regularization domain\";
//   protected Real m_flow_zero(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0;
//   protected Real dm_flow_ddp_fric_zero;
//   protected Real dp_grav_a(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_a \"Static head if mass flows in design direction (a to b)\";
//   protected Real dp_grav_b(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = g_times_height_ab * rho_b \"Static head if mass flows against design direction (b to a)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Boundary between transition and turbulent regime\";
//   protected Real dp_zero(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") = 0.5 * (dp_grav_a + dp_grav_b);
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min((745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta)) ^ 0.97, Re_turbulent) \"Boundary between laminar regime and transition\";
// algorithm
//   dp_a := max(dp_grav_a, dp_grav_b) + dp_small;
//   dp_b := min(dp_grav_a, dp_grav_b) - dp_small;
//   if dp >= dp_a then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   elseif dp <= dp_b then
//     m_flow := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)[1];
//   else
//     (m_flow_a, dm_flow_ddp_fric_a) := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_a - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow_b, dm_flow_ddp_fric_b) := Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.Internal.m_flow_of_dp_fric(dp_b - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
//     (m_flow, dm_flow_ddp_fric_zero) := Modelica.Fluid.Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
//     if dp > dp_zero then
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a)[1];
//     else
//       m_flow := Modelica.Fluid.Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero)[1];
//     end if;
//   end if;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.massFlowRate_dp_staticHead;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow \"Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction\"
//   input Real m_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flow rate from port_a to port_b\";
//   input Real rho_a(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_a\";
//   input Real rho_b(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Density at port_b\";
//   input Real mu_a(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_a (dummy if use_mu = false)\";
//   input Real mu_b(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Dynamic viscosity at port_b (dummy if use_mu = false)\";
//   input Real length(quantity = \"Length\", unit = \"m\") \"Length of pipe\";
//   input Real diameter(quantity = \"Length\", unit = \"m\", min = 0.0) \"Inner (hydraulic) diameter of pipe\";
//   input Real crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * diameter ^ 2.0 \"Inner cross section area\";
//   input Real roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)\";
//   input Real m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.01 \"Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)\";
//   input Real Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)\";
//   output Real dp(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pressure loss (dp = port_a.p - port_b.p)\";
//   protected Real mu(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) \"Upstream viscosity\";
//   protected Real rho(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) \"Upstream density\";
//   protected Real Re(quantity = \"ReynoldsNumber\", unit = \"1\") \"Reynolds number\";
//   protected Real lambda2 \"Modified friction coefficient (= lambda*Re^2)\";
//   protected Real Delta = roughness / diameter \"Relative roughness\";
//   protected Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\") = Re_turbulent \"Re entering turbulent curve\";
//   protected Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\") = min(745.0 * exp(if Delta <= 0.0065 then 1.0 else 0.0065 / Delta), Re_turbulent) \"Re leaving laminar curve\";
// algorithm
//   rho := if m_flow >= 0.0 then rho_a else rho_b;
//   mu := if m_flow >= 0.0 then mu_a else mu_b;
//   Re := diameter * abs(m_flow) / (mu * crossArea);
//   lambda2 := if Re <= Re1 then 64.0 * Re else if Re >= Re2 then 0.25 * (Re / log10(0.2702702702702702 * Delta + 5.74 / Re ^ 0.9)) ^ 2.0 else Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2(Re, Re1, Re2, Delta);
//   dp := 0.5 * length * mu ^ 2.0 * diameter ^ (-3.0) * (if m_flow >= 0.0 then lambda2 else -lambda2) / rho;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2
//   input Real Re(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re1(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Re2(quantity = \"ReynoldsNumber\", unit = \"1\");
//   input Real Delta;
//   output Real lambda2;
//   protected Real yd1 = 1.0;
//   protected Real aux1 = 1.121782646756099;
//   protected Real dx;
//   protected Real x1 = log10(Re1);
//   protected Real y1 = log10(64.0 * Re1);
//   protected Real x2 = log10(Re2);
//   protected Real aux2 = 0.2702702702702702 * Delta + 5.74 / Re2 ^ 0.9;
//   protected Real diff_x = x2 - x1;
//   protected Real aux3 = log10(aux2);
//   protected Real L2 = 0.25 * (Re2 / aux3) ^ 2.0;
//   protected Real yd2 = 2.0 + 4.0 * aux1 / (Re2 ^ 0.9 * aux3 * aux2);
//   protected Real aux4 = 2.51 / sqrt(L2) + 0.27 * Delta;
//   protected Real y2 = log10(L2);
//   protected Real aux5 = (-2.0) * sqrt(L2) * log10(aux4);
//   protected Real m = (y2 - y1) / diff_x;
//   protected Real c2 = (3.0 * m + (-2.0) * yd1 - yd2) / diff_x;
//   protected Real c3 = (yd1 + yd2 + (-2.0) * m) / diff_x ^ 2.0;
// algorithm
//   dx := log10(Re / Re1);
//   lambda2 := 64.0 * Re1 * (Re / Re1) ^ (1.0 + dx * (c2 + dx * c3));
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow.interpolateInRegion2;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.FluidConstants;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.density \"Return density\"
//   input Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.density;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.setState_phX;
//
// function Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Utilities.cubicHermite_withDerivative \"Evaluate a cubic Hermite spline, return value and derivative\"
//   input Real x \"Abscissa value\";
//   input Real x1 \"Lower abscissa value\";
//   input Real x2 \"Upper abscissa value\";
//   input Real y1 \"Lower ordinate value\";
//   input Real y2 \"Upper ordinate value\";
//   input Real y1d \"Lower gradient\";
//   input Real y2d \"Upper gradient\";
//   output Real y \"Interpolated ordinate value\";
//   output Real dy_dx \"Derivative dy/dx at abscissa value x\";
//   protected Real h \"Distance between x1 and x2\";
//   protected Real t \"abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]\";
//   protected Real h00 \"Basis function 00 of cubic Hermite spline\";
//   protected Real h10 \"Basis function 10 of cubic Hermite spline\";
//   protected Real h01 \"Basis function 01 of cubic Hermite spline\";
//   protected Real h11 \"Basis function 11 of cubic Hermite spline\";
//   protected Real h00d \"d/dt h00\";
//   protected Real h10d \"d/dt h10\";
//   protected Real h01d \"d/dt h01\";
//   protected Real h11d \"d/dt h11\";
//   protected Real aux3 \"t cube\";
//   protected Real aux2 \"t square\";
// algorithm
//   h := x2 - x1;
//   if abs(h) > 0.0 then
//     t := (x - x1) / h;
//     aux3 := t ^ 3.0;
//     aux2 := t ^ 2.0;
//     h00 := 1.0 + 2.0 * aux3 + (-3.0) * aux2;
//     h10 := aux3 + (-2.0) * aux2 + t;
//     h01 := 3.0 * aux2 + (-2.0) * aux3;
//     h11 := aux3 - aux2;
//     h00d := 6.0 * (aux2 - t);
//     h10d := 1.0 + 3.0 * aux2 + (-4.0) * t;
//     h01d := 6.0 * (t - aux2);
//     h11d := 3.0 * aux2 + (-2.0) * t;
//     y := y1 * h00 + h * y1d * h10 + y2 * h01 + h * y2d * h11;
//     dy_dx := y1 * h00d / h + y1d * h10d + y2 * h01d / h + y2d * h11d;
//   else
//     y := 0.5 * (y1 + y2);
//     dy_dx := 9.999999999999999e+59 * /*Real*/(sign(y2 - y1));
//   end if;
// end Modelica.Fluid.Utilities.cubicHermite_withDerivative;
//
// function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero \"Evaluate polynomial of order 3 that passes the origin with a predefined derivative\"
//   input Real x \"Value for which polynomial shall be evaluated\";
//   input Real x1 \"Abscissa value\";
//   input Real y1 \"y1=f(x1)\";
//   input Real y1d \"First derivative at y1\";
//   input Real y0d \"First derivative at f(x=0)\";
//   output Real y;
//   protected Real a1;
//   protected Real a2;
//   protected Real a3;
//   protected Real xx;
// algorithm
//   a1 := x1 * y0d;
//   a2 := 3.0 * y1 + (-2.0) * a1 - x1 * y1d;
//   a3 := y1 + (-a2) - a1;
//   xx := x / x1;
//   y := xx * (a1 + xx * (a2 + xx * a3));
// end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
//
// function Modelica.Fluid.Utilities.regFun3 \"Co-monotonic and C1 smooth regularization function\"
//   input Real x \"Abscissa value\";
//   input Real x0 \"Lower abscissa value\";
//   input Real x1 \"Upper abscissa value\";
//   input Real y0 \"Ordinate value at lower abscissa value\";
//   input Real y1 \"Ordinate value at upper abscissa value\";
//   input Real y0d \"Derivative at lower abscissa value\";
//   input Real y1d \"Derivative at upper abscissa value\";
//   output Real y \"Ordinate value\";
//   output Real c \"Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used\";
//   protected Real h0 \"Width of interval i=0\";
//   protected Real Delta0 \"Slope of secant on interval i=0\";
//   protected Real xstar \"Inflection point of cubic polynomial S0\";
//   protected Real mu \"Distance of inflection point and left limit x0\";
//   protected Real eta \"Distance of right limit x1 and inflection point\";
//   protected Real omega \"Slope of cubic polynomial S0 at inflection point\";
//   protected Real rho \"Weighting factor of eta and eta_tilde, mu and mu_tilde\";
//   protected Real theta0 \"Slope metric\";
//   protected Real mu_tilde \"Distance of start of linear section and left limit x0\";
//   protected Real eta_tilde \"Distance of right limit x1 and end of linear section\";
//   protected Real xi1 \"Start of linear section\";
//   protected Real xi2 \"End of linear section\";
//   protected Real a1 \"Leading coefficient of cubic on the left\";
//   protected Real a2 \"Leading coefficient of cubic on the right\";
//   protected Real const12 \"Integration constant of left cubic, linear section\";
//   protected Real const3 \"Integration constant of right cubic\";
//   protected Real aux01;
//   protected Real aux02;
//   protected Boolean useSingleCubicPolynomial = false \"Indicate to override further logic and use single cubic\";
// algorithm
//   assert(x0 < x1, \"regFun3(): Data points not sorted appropriately (x0 = \" + String(x0, 6, 0, true) + \" > x1 = \" + String(x1, 6, 0, true) + \"). Please flip arguments.\");
//   if y0d * y1d >= 0.0 then
//   else
//     assert(abs(y0d) < 1e-15 or abs(y1d) < 1e-15, \"regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = \" + String(y0d, 6, 0, true) + \", y1d = \" + String(y1d, 6, 0, true) + \"). Please correct arguments.\");
//   end if;
//   h0 := x1 - x0;
//   Delta0 := (y1 - y0) / h0;
//   if abs(Delta0) <= 0.0 then
//     y := y0 + Delta0 * (x - x0);
//     c := 0.0;
//   elseif abs(y1d + y0d + (-2.0) * Delta0) < 1e-13 then
//     y := y0 + (x - x0) * (y0d + (x - x0) * ((-2.0) * y0d + 3.0 * Delta0 + (x - x0) * (y0d + y1d + (-2.0) * Delta0) / h0 - y1d) / h0);
//     aux01 := 0.5 * (x0 + x1);
//     c := 3.0 * (y0d + y1d + (-2.0) * Delta0) * ((aux01 - x0) / h0) ^ 2.0 + 2.0 * ((-2.0) * y0d + 3.0 * Delta0 - y1d) * (aux01 - x0) / h0 + y0d;
//   else
//     xstar := 0.3333333333333333 * (x0 * ((-3.0) * (y0d + y1d) + 6.0 * Delta0) + h0 * ((-2.0) * y0d - y1d) + 3.0 * h0 * Delta0) / (2.0 * Delta0 + (-y1d) - y0d);
//     mu := xstar - x0;
//     eta := x1 - xstar;
//     omega := 3.0 * (y0d + y1d + (-2.0) * Delta0) * ((xstar - x0) / h0) ^ 2.0 + 2.0 * ((-2.0) * y0d + 3.0 * Delta0 - y1d) * (xstar - x0) / h0 + y0d;
//     aux01 := 0.25 * /*Real*/(sign(Delta0)) * min(abs(omega), abs(Delta0));
//     if abs(y0d - y1d) <= 1e-13 then
//       aux02 := y0d;
//       if y1 > y0 + y0d * (x1 - x0) then
//         useSingleCubicPolynomial := true;
//       end if;
//     elseif abs(y1d + y0d + (-2.0) * Delta0) < 1e-13 then
//       aux02 := 9.999999999999999e+59 * (6.0 * Delta0 * (y1d + y0d + (-1.5) * Delta0) + (-y1d) * y0d - y1d ^ 2.0 - y0d ^ 2.0) * (if y1d + y0d + (-2.0) * Delta0 >= 0.0 then 1.0 else -1.0);
//     else
//       aux02 := 0.3333333333333333 * (6.0 * Delta0 * (y1d + y0d + (-1.5) * Delta0) + (-y0d ^ 2.0) - y1d * y0d - y1d ^ 2.0) / (y1d + y0d + (-2.0) * Delta0);
//     end if;
//     if (mu > 0.0 and eta < h0 and Delta0 * omega <= 0.0 or abs(aux01) < abs(aux02) and aux02 * Delta0 >= 0.0 or abs(aux01) < abs(0.1 * Delta0)) and not useSingleCubicPolynomial then
//       c := aux01;
//       if abs(c) < abs(aux02) and aux02 * Delta0 >= 0.0 then
//         c := aux02;
//       end if;
//       if abs(c) < abs(0.1 * Delta0) then
//         c := 0.1 * Delta0;
//       end if;
//       theta0 := (y0d * mu + y1d * eta) / h0;
//       if abs(theta0 - c) < 1e-06 then
//         c := 0.999999 * theta0;
//       end if;
//       rho := 3.0 * (Delta0 - c) / (theta0 - c);
//       mu_tilde := rho * mu;
//       eta_tilde := rho * eta;
//       xi1 := x0 + mu_tilde;
//       xi2 := x1 - eta_tilde;
//       a1 := (y0d - c) / max(mu_tilde ^ 2.0, 1e-13);
//       a2 := (y1d - c) / max(eta_tilde ^ 2.0, 1e-13);
//       const12 := y0 + (-0.3333333333333333) * a1 * (x0 - xi1) ^ 3.0 - c * x0;
//       const3 := y1 + (-0.3333333333333333) * a2 * (x1 - xi2) ^ 3.0 - c * x1;
//       if x < xi1 then
//         y := 0.3333333333333333 * a1 * (x - xi1) ^ 3.0 + c * x + const12;
//       elseif x < xi2 then
//         y := c * x + const12;
//       else
//         y := 0.3333333333333333 * a2 * (x - xi2) ^ 3.0 + c * x + const3;
//       end if;
//     else
//       y := y0 + (x - x0) * (y0d + (x - x0) * ((-2.0) * y0d + 3.0 * Delta0 + (x - x0) * (y0d + y1d + (-2.0) * Delta0) / h0 - y1d) / h0);
//       aux01 := 0.5 * (x0 + x1);
//       c := 3.0 * (y0d + y1d + (-2.0) * Delta0) * ((aux01 - x0) / h0) ^ 2.0 + 2.0 * ((-2.0) * y0d + 3.0 * Delta0 - y1d) * (aux01 - x0) / h0 + y0d;
//     end if;
//   end if;
// end Modelica.Fluid.Utilities.regFun3;
//
// function Modelica.Fluid.Utilities.regSquare2 \"Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous\"
//   input Real x \"abscissa value\";
//   input Real x_small(min = 0.0) = 0.01 \"approximation of function for |x| <= x_small\";
//   input Real k1(min = 0.0) = 1.0 \"y = (if x>=0 then k1 else k2)*x*|x|\";
//   input Real k2(min = 0.0) = 1.0 \"y = (if x>=0 then k1 else k2)*x*|x|\";
//   input Boolean use_yd0 = false \"= true, if yd0 shall be used\";
//   input Real yd0(min = 0.0) = 1.0 \"Desired derivative at x=0: dy/dx = yd0\";
//   output Real y \"ordinate value\";
// algorithm
//   y := smooth(2, if x >= x_small then k1 * x ^ 2.0 else if x <= (-x_small) then (-k2) * x ^ 2.0 else if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x, x_small, k1, k2, use_yd0, yd0) else -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(-x, x_small, k2, k1, use_yd0, yd0));
// end Modelica.Fluid.Utilities.regSquare2;
//
// function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility \"Interpolating with two 3-order polynomials with a prescribed derivative at x=0\"
//   input Real x;
//   input Real x1 \"approximation of function abs(x) < x1\";
//   input Real k1 \"y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2\";
//   input Real k2 \"y = (if x>=0 then k1 else -k2)*x*|x|\";
//   input Boolean use_yd0 = false \"= true, if yd0 shall be used\";
//   input Real yd0(min = 0.0) = 1.0 \"Desired derivative at x=0: dy/dx = yd0\";
//   output Real y;
//   protected Real x2;
//   protected Real y1;
//   protected Real y2;
//   protected Real y1d;
//   protected Real y2d;
//   protected Real w;
//   protected Real w1;
//   protected Real w2;
//   protected Real y0d;
//   protected Real ww;
// algorithm
//   x2 := -x1;
//   if x <= x2 then
//     y := (-k2) * x ^ 2.0;
//   else
//     y1 := k1 * x1 ^ 2.0;
//     y2 := (-k2) * x2 ^ 2.0;
//     y1d := 2.0 * k1 * x1;
//     y2d := (-2.0) * k2 * x2;
//     if use_yd0 then
//       y0d := yd0;
//     else
//       w := x2 / x1;
//       y0d := 0.5 * ((3.0 * y2 - x2 * y2d) / w + (x1 * y1d + (-3.0) * y1) * w) / ((1.0 - w) * x1);
//     end if;
//     w1 := 2.23606797749979 * k1 * x1;
//     w2 := 2.23606797749979 * k2 * abs(x2);
//     ww := 0.9 * (if w1 < w2 then w1 else w2);
//     if ww < y0d then
//       y0d := ww;
//     end if;
//     y := if x >= 0.0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x2, y2, y2d, y0d);
//   end if;
// end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;
//
// function Modelica.Fluid.Utilities.regStep \"Approximation of a general step, such that the characteristic is continuous and differentiable\"
//   input Real x \"Abscissa value\";
//   input Real y1 \"Ordinate value for x > 0\";
//   input Real y2 \"Ordinate value for x < 0\";
//   input Real x_small(min = 0.0) = 1e-05 \"Approximation of step for -x_small <= x <= x_small; x_small >= 0 required\";
//   output Real y \"Ordinate value to approximate y = if x > 0 then y1 else y2\";
// algorithm
//   y := smooth(1, if x > x_small then y1 else if x < (-x_small) then y2 else if x_small > 0.0 then 0.25 * x * (-3.0 + (x / x_small) ^ 2.0) * (y2 - y1) / x_small + 0.5 * (y1 + y2) else 0.5 * (y1 + y2));
// end Modelica.Fluid.Utilities.regStep;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank1$ports.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank1$ports.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank1$ports.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank1$ports.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank1$ports.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank2$ports.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank2$ports.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank2$ports.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank2$ports.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank2$ports.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank3$ports.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank3$ports.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank3$ports.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank3$ports.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b$tank3$ports.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.BaseClasses.VesselPortsData \"Automatically generated record constructor for Modelica.Fluid.Vessels.BaseClasses.VesselPortsData\"
//   input Real diameter(min = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real height(min = 0.0, quantity = \"Length\", unit = \"m\") = 0.0;
//   input Real zeta_out(min = 0.0) = 0.5;
//   input Real zeta_in(min = 0.0) = 1.04;
//   output VesselPortsData res;
// end Modelica.Fluid.Vessels.BaseClasses.VesselPortsData;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.temperature;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank1.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density \"Return density\"
//   input Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank$tank1.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank1.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := 273.15 + 0.0002390057361376673 * h;
// end Modelica.Fluid.Vessels.OpenTank$tank1.Medium.temperature_phX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.temperature;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank2.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density \"Return density\"
//   input Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank$tank2.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank2.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := 273.15 + 0.0002390057361376673 * h;
// end Modelica.Fluid.Vessels.OpenTank$tank2.Medium.temperature_phX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.temperature \"Return temperature\"
//   input Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := state.T;
// end Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.temperature;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.FluidConstants \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank3.Medium.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.FluidConstants;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState \"Automatically generated record constructor for Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState\"
//   input Real p(min = 0.0, max = 100000000.0, nominal = 100000.0, start = 100000.0, quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\");
//   input Real T(min = 1.0, max = 10000.0, nominal = 300.0, start = 300.0, quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\");
//   output ThermodynamicState res;
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.density \"Return density\"
//   input Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density\";
// algorithm
//   d := 995.586;
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.density;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.dynamicViscosity \"Return dynamic viscosity\"
//   input Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState state \"Thermodynamic state record\";
//   output Real eta(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Dynamic viscosity\";
// algorithm
//   eta := 0.001;
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.dynamicViscosity;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.setState_phX \"Return thermodynamic state from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[:] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = {1.0} \"Mass fractions\";
//   output Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState state \"Thermodynamic state record\";
// algorithm
//   state := Modelica.Fluid.Vessels.OpenTank$tank3.Medium.ThermodynamicState(p, 273.15 + 0.0002390057361376673 * h);
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.setState_phX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.specificEnthalpy_pTX \"Return specific enthalpy from p, T, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
// algorithm
//   h := 4184.0 * (-273.15 + T);
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.specificEnthalpy_pTX;
//
// function Modelica.Fluid.Vessels.OpenTank$tank3.Medium.temperature_phX \"Return temperature from p, h, and X or Xi\"
//   input Real p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Pressure\";
//   input Real h(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific enthalpy\";
//   input Real[1] X(quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) \"Mass fractions\";
//   output Real T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature\";
// algorithm
//   T := 273.15 + 0.0002390057361376673 * h;
// end Modelica.Fluid.Vessels.OpenTank$tank3.Medium.temperature_phX;
//
// function Modelica.Media.Interfaces.Types.Basic.FluidConstants \"Automatically generated record constructor for Modelica.Media.Interfaces.Types.Basic.FluidConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants res;
// end Modelica.Media.Interfaces.Types.Basic.FluidConstants;
//
// function Modelica.Media.Interfaces.Types.Basic.FluidConstants$simpleWaterConstants \"Automatically generated record constructor for Modelica.Media.Interfaces.Types.Basic.FluidConstants$simpleWaterConstants\"
//   input String iupacName;
//   input String casRegistryNumber;
//   input String chemicalFormula;
//   input String structureFormula;
//   input Real molarMass(min = 0.001, max = 0.25, nominal = 0.032, quantity = \"MolarMass\", unit = \"kg/mol\");
//   output FluidConstants$simpleWaterConstants res;
// end Modelica.Media.Interfaces.Types.Basic.FluidConstants$simpleWaterConstants;
//
// function Modelica.SIunits.Conversions.from_degC \"Inline before index reduction\" \"Convert from degCelsius to Kelvin\"
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Kelvin value\";
// algorithm
//   Kelvin := 273.15 + Celsius;
// end Modelica.SIunits.Conversions.from_degC;
//
// function Modelica.SIunits.Conversions.to_bar \"Inline before index reduction\" \"Convert from Pascal to bar\"
//   input Real Pa(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\") \"Pascal value\";
//   output Real bar(quantity = \"Pressure\", unit = \"bar\") \"bar value\";
// algorithm
//   bar := 1e-05 * Pa;
// end Modelica.SIunits.Conversions.to_bar;
//
// function Modelica.SIunits.Conversions.to_degC \"Inline before index reduction\" \"Convert from Kelvin to degCelsius\"
//   input Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Kelvin value\";
//   output Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
// algorithm
//   Celsius := -273.15 + Kelvin;
// end Modelica.SIunits.Conversions.to_degC;
//
// class Modelica.Fluid.Examples.Tanks.ThreeTanks \"Demonstrating the usage of SimpleTank\"
//   Real tank1.fluidVolume(quantity = \"Volume\", unit = \"m3\") = tank1.V \"Volume\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank1.energyDynamics = system.energyDynamics \"Formulation of energy balance\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank1.massDynamics = system.massDynamics \"Formulation of mass balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank1.substanceDynamics = tank1.massDynamics \"Formulation of substance balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank1.traceDynamics = tank1.massDynamics \"Formulation of trace substance balance\";
//   parameter Real tank1.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank1.p_ambient \"Start value of pressure\";
//   parameter Boolean tank1.use_T_start = true \"= true, use T_start, otherwise h_start\";
//   parameter Real tank1.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if tank1.use_T_start then system.T_start else Modelica.Fluid.Vessels.OpenTank$tank1.Medium.temperature_phX(tank1.p_start, tank1.h_start, {tank1.X_start[1]}) \"Start value of temperature\";
//   parameter Real tank1.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = if tank1.use_T_start then Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX(tank1.p_start, tank1.T_start, {tank1.X_start[1]}) else 83680.0 \"Start value of specific enthalpy\";
//   parameter Real tank1.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   Real tank1.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = tank1.p_start, nominal = 100000.0, stateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   Real tank1.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = tank1.h_start) \"Specific enthalpy of medium\";
//   Real tank1.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density of medium\";
//   Real tank1.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = tank1.T_start, nominal = 300.0, stateSelect = StateSelect.prefer) \"Temperature of medium\";
//   Real tank1.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real tank1.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real tank1.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real tank1.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Real tank1.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real tank1.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   parameter Boolean tank1.medium.preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean tank1.medium.standardOrderComponents = true \"If true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real tank1.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(tank1.medium.T) \"Temperature of medium in [degC]\";
//   Real tank1.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(tank1.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real tank1.U(quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real tank1.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Mass of fluid\";
//   Real tank1.mb_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flows across boundaries\";
//   Real tank1.Hb_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow across boundaries or energy source/sink\";
//   Real tank1.Qb_flow(quantity = \"Power\", unit = \"W\") \"Heat flow across boundaries or energy source/sink\";
//   Real tank1.Wb_flow(quantity = \"Power\", unit = \"W\") \"Work flow across boundaries or source term\";
//   protected parameter Boolean tank1.initialize_p = false \"= true to set up initial equations for pressure\";
//   parameter Integer tank1.nPorts = 1 \"Number of ports\";
//   Real tank1.ports[1].m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real tank1.ports[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real tank1.ports[1].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   parameter Boolean tank1.use_portsData = true \"= false to neglect pressure loss and kinetic energy\";
//   parameter Real tank1.portsData[1].diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Inner (hydraulic) diameter of inlet/outlet port\";
//   parameter Real tank1.portsData[1].height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Height over the bottom of the vessel\";
//   parameter Real tank1.portsData[1].zeta_out(min = 0.0) = 0.5 \"Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall\";
//   parameter Real tank1.portsData[1].zeta_in(min = 0.0) = 1.04 \"Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall\";
//   parameter Real tank1.m_flow_nominal(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = if system.use_eps_Re then system.m_flow_nominal else 100.0 * system.m_flow_small \"Nominal value for mass flow rates in ports\";
//   parameter Real tank1.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = if system.use_eps_Re then system.eps_m_flow * tank1.m_flow_nominal else system.m_flow_small \"Regularization range at zero mass flow rate\";
//   parameter Boolean tank1.use_Re = system.use_eps_Re \"= true, if turbulent region is defined by Re, otherwise by m_flow_small\";
//   Real tank1.ports_H_flow[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0);
//   parameter Boolean tank1.use_HeatTransfer = false \"= true to use the HeatTransfer model\";
//   parameter Integer tank1.heatTransfer.n = 1 \"Number of heat transfer segments\";
//   Real tank1.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank1.medium.state.p \"Absolute pressure of medium\";
//   Real tank1.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = tank1.medium.state.T \"Temperature of medium\";
//   Real tank1.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") \"Heat transfer areas\";
//   Real tank1.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   parameter Boolean tank1.heatTransfer.use_k = tank1.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real tank1.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real tank1.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = system.T_ambient \"Ambient temperature\";
//   Real tank1.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real tank1.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real tank1.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperatures defined by fluid states\";
//   Real tank1.portInDensities[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"densities of the fluid at the device boundary\";
//   Real tank1.portVelocities[1](quantity = \"Velocity\", unit = \"m/s\") \"velocities of fluid flow at device boundary\";
//   Real tank1.ports_E_flow[1](quantity = \"Power\", unit = \"W\") \"flow of kinetic and potential energy at device boundary\";
//   Real tank1.s[1](start = tank1.fluidLevel_max) \"curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices\";
//   Real tank1.ports_penetration[1] \"penetration of port with fluid, depending on fluid level and port diameter\";
//   Real tank1.portAreas[1](quantity = \"Area\", unit = \"m2\");
//   Real tank1.vessel_ps_static[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"static pressures inside the vessel at the height of the corresponding ports, zero flow velocity\";
//   constant Real tank1.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 100.0 \"cf. suddenExpansion\";
//   Real tank1.m_flow_turbulent[1](quantity = \"MassFlowRate\", unit = \"kg/s\");
//   protected Real tank1.fluidLevel(quantity = \"Length\", unit = \"m\", min = 0.0) = tank1.level \"level of fluid in the vessel for treating heights of ports\";
//   protected parameter Real tank1.fluidLevel_max(quantity = \"Length\", unit = \"m\", min = 0.0) = tank1.height \"maximum level of fluid in the vessel\";
//   protected parameter Real tank1.vesselArea(quantity = \"Area\", unit = \"m2\") = tank1.crossArea \"Area of the vessel used to relate to cross flow area of ports\";
//   protected Real tank1.portsData_diameter[1];
//   protected Real tank1.portsData_height[1];
//   protected Real tank1.portsData_zeta_in[1];
//   protected Real tank1.portsData_zeta_out[1];
//   protected Boolean tank1.regularFlow[1](start = true);
//   protected Boolean tank1.inFlow[1](start = false);
//   Real tank1.level(quantity = \"Length\", unit = \"m\", min = 0.0, start = tank1.level_start_eps, stateSelect = StateSelect.prefer) \"Level height of tank\";
//   Real tank1.V(quantity = \"Volume\", unit = \"m3\", stateSelect = StateSelect.never) \"Actual tank volume\";
//   parameter Real tank1.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 12.0 \"Height of tank\";
//   parameter Real tank1.crossArea(quantity = \"Area\", unit = \"m2\") = 1.0 \"Area of tank\";
//   parameter Real tank1.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_ambient \"Tank surface pressure\";
//   parameter Real tank1.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = system.T_ambient \"Tank surface Temperature\";
//   parameter Real tank1.level_start(quantity = \"Length\", unit = \"m\", min = 0.0) = 8.0 \"Start value of tank level\";
//   protected final parameter Real tank1.level_start_eps(quantity = \"Length\", unit = \"m\", min = 0.0) = max(tank1.level_start, 1e-15);
//   protected Real tank1.portsData_diameter_internal[1];
//   protected Real tank1.portsData_height_internal[1];
//   protected Real tank1.portsData_zeta_in_internal[1];
//   protected Real tank1.portsData_zeta_out_internal[1];
//   Real tank2.fluidVolume(quantity = \"Volume\", unit = \"m3\") = tank2.V \"Volume\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank2.energyDynamics = system.energyDynamics \"Formulation of energy balance\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank2.massDynamics = system.massDynamics \"Formulation of mass balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank2.substanceDynamics = tank2.massDynamics \"Formulation of substance balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank2.traceDynamics = tank2.massDynamics \"Formulation of trace substance balance\";
//   parameter Real tank2.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank2.p_ambient \"Start value of pressure\";
//   parameter Boolean tank2.use_T_start = true \"= true, use T_start, otherwise h_start\";
//   parameter Real tank2.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if tank2.use_T_start then system.T_start else Modelica.Fluid.Vessels.OpenTank$tank2.Medium.temperature_phX(tank2.p_start, tank2.h_start, {tank2.X_start[1]}) \"Start value of temperature\";
//   parameter Real tank2.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = if tank2.use_T_start then Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX(tank2.p_start, tank2.T_start, {tank2.X_start[1]}) else 83680.0 \"Start value of specific enthalpy\";
//   parameter Real tank2.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   Real tank2.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = tank2.p_start, nominal = 100000.0, stateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   Real tank2.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = tank2.h_start) \"Specific enthalpy of medium\";
//   Real tank2.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density of medium\";
//   Real tank2.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = tank2.T_start, nominal = 300.0, stateSelect = StateSelect.prefer) \"Temperature of medium\";
//   Real tank2.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real tank2.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real tank2.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real tank2.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Real tank2.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real tank2.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   parameter Boolean tank2.medium.preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean tank2.medium.standardOrderComponents = true \"If true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real tank2.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(tank2.medium.T) \"Temperature of medium in [degC]\";
//   Real tank2.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(tank2.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real tank2.U(quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real tank2.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Mass of fluid\";
//   Real tank2.mb_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flows across boundaries\";
//   Real tank2.Hb_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow across boundaries or energy source/sink\";
//   Real tank2.Qb_flow(quantity = \"Power\", unit = \"W\") \"Heat flow across boundaries or energy source/sink\";
//   Real tank2.Wb_flow(quantity = \"Power\", unit = \"W\") \"Work flow across boundaries or source term\";
//   protected parameter Boolean tank2.initialize_p = false \"= true to set up initial equations for pressure\";
//   parameter Integer tank2.nPorts = 1 \"Number of ports\";
//   Real tank2.ports[1].m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real tank2.ports[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real tank2.ports[1].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   parameter Boolean tank2.use_portsData = true \"= false to neglect pressure loss and kinetic energy\";
//   parameter Real tank2.portsData[1].diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Inner (hydraulic) diameter of inlet/outlet port\";
//   parameter Real tank2.portsData[1].height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Height over the bottom of the vessel\";
//   parameter Real tank2.portsData[1].zeta_out(min = 0.0) = 0.5 \"Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall\";
//   parameter Real tank2.portsData[1].zeta_in(min = 0.0) = 1.04 \"Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall\";
//   parameter Real tank2.m_flow_nominal(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = if system.use_eps_Re then system.m_flow_nominal else 100.0 * system.m_flow_small \"Nominal value for mass flow rates in ports\";
//   parameter Real tank2.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = if system.use_eps_Re then system.eps_m_flow * tank2.m_flow_nominal else system.m_flow_small \"Regularization range at zero mass flow rate\";
//   parameter Boolean tank2.use_Re = system.use_eps_Re \"= true, if turbulent region is defined by Re, otherwise by m_flow_small\";
//   Real tank2.ports_H_flow[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0);
//   parameter Boolean tank2.use_HeatTransfer = false \"= true to use the HeatTransfer model\";
//   parameter Integer tank2.heatTransfer.n = 1 \"Number of heat transfer segments\";
//   Real tank2.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank2.medium.state.p \"Absolute pressure of medium\";
//   Real tank2.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = tank2.medium.state.T \"Temperature of medium\";
//   Real tank2.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") \"Heat transfer areas\";
//   Real tank2.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   parameter Boolean tank2.heatTransfer.use_k = tank2.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real tank2.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real tank2.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = system.T_ambient \"Ambient temperature\";
//   Real tank2.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real tank2.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real tank2.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperatures defined by fluid states\";
//   Real tank2.portInDensities[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"densities of the fluid at the device boundary\";
//   Real tank2.portVelocities[1](quantity = \"Velocity\", unit = \"m/s\") \"velocities of fluid flow at device boundary\";
//   Real tank2.ports_E_flow[1](quantity = \"Power\", unit = \"W\") \"flow of kinetic and potential energy at device boundary\";
//   Real tank2.s[1](start = tank2.fluidLevel_max) \"curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices\";
//   Real tank2.ports_penetration[1] \"penetration of port with fluid, depending on fluid level and port diameter\";
//   Real tank2.portAreas[1](quantity = \"Area\", unit = \"m2\");
//   Real tank2.vessel_ps_static[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"static pressures inside the vessel at the height of the corresponding ports, zero flow velocity\";
//   constant Real tank2.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 100.0 \"cf. suddenExpansion\";
//   Real tank2.m_flow_turbulent[1](quantity = \"MassFlowRate\", unit = \"kg/s\");
//   protected Real tank2.fluidLevel(quantity = \"Length\", unit = \"m\", min = 0.0) = tank2.level \"level of fluid in the vessel for treating heights of ports\";
//   protected parameter Real tank2.fluidLevel_max(quantity = \"Length\", unit = \"m\", min = 0.0) = tank2.height \"maximum level of fluid in the vessel\";
//   protected parameter Real tank2.vesselArea(quantity = \"Area\", unit = \"m2\") = tank2.crossArea \"Area of the vessel used to relate to cross flow area of ports\";
//   protected Real tank2.portsData_diameter[1];
//   protected Real tank2.portsData_height[1];
//   protected Real tank2.portsData_zeta_in[1];
//   protected Real tank2.portsData_zeta_out[1];
//   protected Boolean tank2.regularFlow[1](start = true);
//   protected Boolean tank2.inFlow[1](start = false);
//   Real tank2.level(quantity = \"Length\", unit = \"m\", min = 0.0, start = tank2.level_start_eps, stateSelect = StateSelect.prefer) \"Level height of tank\";
//   Real tank2.V(quantity = \"Volume\", unit = \"m3\", stateSelect = StateSelect.never) \"Actual tank volume\";
//   parameter Real tank2.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 12.0 \"Height of tank\";
//   parameter Real tank2.crossArea(quantity = \"Area\", unit = \"m2\") = 1.0 \"Area of tank\";
//   parameter Real tank2.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_ambient \"Tank surface pressure\";
//   parameter Real tank2.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = system.T_ambient \"Tank surface Temperature\";
//   parameter Real tank2.level_start(quantity = \"Length\", unit = \"m\", min = 0.0) = 3.0 \"Start value of tank level\";
//   protected final parameter Real tank2.level_start_eps(quantity = \"Length\", unit = \"m\", min = 0.0) = max(tank2.level_start, 1e-15);
//   protected Real tank2.portsData_diameter_internal[1];
//   protected Real tank2.portsData_height_internal[1];
//   protected Real tank2.portsData_zeta_in_internal[1];
//   protected Real tank2.portsData_zeta_out_internal[1];
//   parameter Real system.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = 101325.0 \"Default ambient pressure\";
//   parameter Real system.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 293.15 \"Default ambient temperature\";
//   parameter Real system.g(quantity = \"Acceleration\", unit = \"m/s2\") = 9.806649999999999 \"Constant gravity acceleration\";
//   parameter Boolean system.allowFlowReversal = true \"= false to restrict to design flow direction (port_a -> port_b)\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.energyDynamics = Modelica.Fluid.Types.Dynamics.FixedInitial \"Default formulation of energy balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.massDynamics = system.energyDynamics \"Default formulation of mass balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.substanceDynamics = system.massDynamics \"Default formulation of substance balances\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.traceDynamics = system.massDynamics \"Default formulation of trace substance balances\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) system.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Default formulation of momentum balances, if options available\";
//   parameter Real system.m_flow_start(quantity = \"MassFlowRate\", unit = \"kg/s\") = 0.0 \"Default start value for mass flow rates\";
//   parameter Real system.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = system.p_ambient \"Default start value for pressures\";
//   parameter Real system.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = system.T_ambient \"Default start value for temperatures\";
//   parameter Boolean system.use_eps_Re = false \"= true to determine turbulent region automatically using Reynolds number\";
//   parameter Real system.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then 1.0 else 100.0 * system.m_flow_small \"Default nominal mass flow rate\";
//   parameter Real system.eps_m_flow(min = 0.0) = 0.0001 \"Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal\";
//   parameter Real system.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = 1.0 \"Default small pressure drop for regularization of laminar and zero flow\";
//   parameter Real system.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = 0.01 \"Default small mass flow rate for regularization of laminar and zero flow\";
//   Real tank3.fluidVolume(quantity = \"Volume\", unit = \"m3\") = tank3.V \"Volume\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank3.energyDynamics = system.energyDynamics \"Formulation of energy balance\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank3.massDynamics = system.massDynamics \"Formulation of mass balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank3.substanceDynamics = tank3.massDynamics \"Formulation of substance balance\";
//   final parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) tank3.traceDynamics = tank3.massDynamics \"Formulation of trace substance balance\";
//   parameter Real tank3.p_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank3.p_ambient \"Start value of pressure\";
//   parameter Boolean tank3.use_T_start = true \"= true, use T_start, otherwise h_start\";
//   parameter Real tank3.T_start(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = if tank3.use_T_start then system.T_start else Modelica.Fluid.Vessels.OpenTank$tank3.Medium.temperature_phX(tank3.p_start, tank3.h_start, {tank3.X_start[1]}) \"Start value of temperature\";
//   parameter Real tank3.h_start(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) = if tank3.use_T_start then Modelica.Fluid.Vessels.OpenTank$tank3.Medium.specificEnthalpy_pTX(tank3.p_start, tank3.T_start, {tank3.X_start[1]}) else 83680.0 \"Start value of specific enthalpy\";
//   parameter Real tank3.X_start[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, nominal = 0.1) = 1.0 \"Start value of mass fractions m_i/m\";
//   Real tank3.medium.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = tank3.p_start, nominal = 100000.0, stateSelect = StateSelect.prefer) \"Absolute pressure of medium\";
//   Real tank3.medium.h(quantity = \"SpecificEnergy\", unit = \"J/kg\", start = tank3.h_start) \"Specific enthalpy of medium\";
//   Real tank3.medium.d(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Density of medium\";
//   Real tank3.medium.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = tank3.T_start, nominal = 300.0, stateSelect = StateSelect.prefer) \"Temperature of medium\";
//   Real tank3.medium.X[1](quantity = \"MassFraction\", unit = \"kg/kg\", min = 0.0, max = 1.0, start = 1.0, nominal = 0.1) \"Mass fractions (= (component mass)/total mass  m_i/m)\";
//   Real tank3.medium.u(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -100000000.0, max = 100000000.0, nominal = 1000000.0) \"Specific internal energy of medium\";
//   Real tank3.medium.R(quantity = \"SpecificHeatCapacity\", unit = \"J/(kg.K)\", min = 0.0, max = 10000000.0, start = 1000.0, nominal = 1000.0) \"Gas constant (of mixture if applicable)\";
//   Real tank3.medium.MM(quantity = \"MolarMass\", unit = \"kg/mol\", min = 0.001, max = 0.25, nominal = 0.032) \"Molar mass (of mixture or single fluid)\";
//   Real tank3.medium.state.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real tank3.medium.state.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   parameter Boolean tank3.medium.preferredMediumStates = true \"= true if StateSelect.prefer shall be used for the independent property variables of the medium\";
//   parameter Boolean tank3.medium.standardOrderComponents = true \"If true, and reducedX = true, the last element of X will be computed from the other ones\";
//   Real tank3.medium.T_degC(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = Modelica.SIunits.Conversions.to_degC(tank3.medium.T) \"Temperature of medium in [degC]\";
//   Real tank3.medium.p_bar(quantity = \"Pressure\", unit = \"bar\") = Modelica.SIunits.Conversions.to_bar(tank3.medium.p) \"Absolute pressure of medium in [bar]\";
//   Real tank3.U(quantity = \"Energy\", unit = \"J\") \"Internal energy of fluid\";
//   Real tank3.m(quantity = \"Mass\", unit = \"kg\", min = 0.0) \"Mass of fluid\";
//   Real tank3.mb_flow(quantity = \"MassFlowRate\", unit = \"kg/s\") \"Mass flows across boundaries\";
//   Real tank3.Hb_flow(quantity = \"EnthalpyFlowRate\", unit = \"W\") \"Enthalpy flow across boundaries or energy source/sink\";
//   Real tank3.Qb_flow(quantity = \"Power\", unit = \"W\") \"Heat flow across boundaries or energy source/sink\";
//   Real tank3.Wb_flow(quantity = \"Power\", unit = \"W\") \"Work flow across boundaries or source term\";
//   protected parameter Boolean tank3.initialize_p = false \"= true to set up initial equations for pressure\";
//   parameter Integer tank3.nPorts = 1 \"Number of ports\";
//   Real tank3.ports[1].m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real tank3.ports[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real tank3.ports[1].h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   parameter Boolean tank3.use_portsData = true \"= false to neglect pressure loss and kinetic energy\";
//   parameter Real tank3.portsData[1].diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Inner (hydraulic) diameter of inlet/outlet port\";
//   parameter Real tank3.portsData[1].height(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.0 \"Height over the bottom of the vessel\";
//   parameter Real tank3.portsData[1].zeta_out(min = 0.0) = 0.5 \"Hydraulic resistance out of vessel, default 0.5 for small diameter mounted flush with the wall\";
//   parameter Real tank3.portsData[1].zeta_in(min = 0.0) = 1.04 \"Hydraulic resistance into vessel, default 1.04 for small diameter mounted flush with the wall\";
//   parameter Real tank3.m_flow_nominal(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = if system.use_eps_Re then system.m_flow_nominal else 100.0 * system.m_flow_small \"Nominal value for mass flow rates in ports\";
//   parameter Real tank3.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\", min = 0.0) = if system.use_eps_Re then system.eps_m_flow * tank3.m_flow_nominal else system.m_flow_small \"Regularization range at zero mass flow rate\";
//   parameter Boolean tank3.use_Re = system.use_eps_Re \"= true, if turbulent region is defined by Re, otherwise by m_flow_small\";
//   Real tank3.ports_H_flow[1](quantity = \"EnthalpyFlowRate\", unit = \"W\", min = -100000000.0, max = 100000000.0, nominal = 1000.0);
//   parameter Boolean tank3.use_HeatTransfer = false \"= true to use the HeatTransfer model\";
//   parameter Integer tank3.heatTransfer.n = 1 \"Number of heat transfer segments\";
//   Real tank3.heatTransfer.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = tank3.medium.state.p \"Absolute pressure of medium\";
//   Real tank3.heatTransfer.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = tank3.medium.state.T \"Temperature of medium\";
//   Real tank3.heatTransfer.surfaceAreas[1](quantity = \"Area\", unit = \"m2\") \"Heat transfer areas\";
//   Real tank3.heatTransfer.Q_flows[1](quantity = \"Power\", unit = \"W\") \"Heat flow rates\";
//   parameter Boolean tank3.heatTransfer.use_k = tank3.use_HeatTransfer \"= true to use k value for thermal isolation\";
//   parameter Real tank3.heatTransfer.k(quantity = \"CoefficientOfHeatTransfer\", unit = \"W/(m2.K)\") = 0.0 \"Heat transfer coefficient to ambient\";
//   parameter Real tank3.heatTransfer.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = system.T_ambient \"Ambient temperature\";
//   Real tank3.heatTransfer.heatPorts[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real tank3.heatTransfer.heatPorts[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real tank3.heatTransfer.Ts[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperatures defined by fluid states\";
//   Real tank3.portInDensities[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"densities of the fluid at the device boundary\";
//   Real tank3.portVelocities[1](quantity = \"Velocity\", unit = \"m/s\") \"velocities of fluid flow at device boundary\";
//   Real tank3.ports_E_flow[1](quantity = \"Power\", unit = \"W\") \"flow of kinetic and potential energy at device boundary\";
//   Real tank3.s[1](start = tank3.fluidLevel_max) \"curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices\";
//   Real tank3.ports_penetration[1] \"penetration of port with fluid, depending on fluid level and port diameter\";
//   Real tank3.portAreas[1](quantity = \"Area\", unit = \"m2\");
//   Real tank3.vessel_ps_static[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"static pressures inside the vessel at the height of the corresponding ports, zero flow velocity\";
//   constant Real tank3.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 100.0 \"cf. suddenExpansion\";
//   Real tank3.m_flow_turbulent[1](quantity = \"MassFlowRate\", unit = \"kg/s\");
//   protected Real tank3.fluidLevel(quantity = \"Length\", unit = \"m\", min = 0.0) = tank3.level \"level of fluid in the vessel for treating heights of ports\";
//   protected parameter Real tank3.fluidLevel_max(quantity = \"Length\", unit = \"m\", min = 0.0) = tank3.height \"maximum level of fluid in the vessel\";
//   protected parameter Real tank3.vesselArea(quantity = \"Area\", unit = \"m2\") = tank3.crossArea \"Area of the vessel used to relate to cross flow area of ports\";
//   protected Real tank3.portsData_diameter[1];
//   protected Real tank3.portsData_height[1];
//   protected Real tank3.portsData_zeta_in[1];
//   protected Real tank3.portsData_zeta_out[1];
//   protected Boolean tank3.regularFlow[1](start = true);
//   protected Boolean tank3.inFlow[1](start = false);
//   Real tank3.level(quantity = \"Length\", unit = \"m\", min = 0.0, start = tank3.level_start_eps, stateSelect = StateSelect.prefer) \"Level height of tank\";
//   Real tank3.V(quantity = \"Volume\", unit = \"m3\", stateSelect = StateSelect.never) \"Actual tank volume\";
//   parameter Real tank3.height(quantity = \"Length\", unit = \"m\", min = 0.0) = 12.0 \"Height of tank\";
//   parameter Real tank3.crossArea(quantity = \"Area\", unit = \"m2\") = 1.0 \"Area of tank\";
//   parameter Real tank3.p_ambient(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_ambient \"Tank surface pressure\";
//   parameter Real tank3.T_ambient(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) = system.T_ambient \"Tank surface Temperature\";
//   parameter Real tank3.level_start(quantity = \"Length\", unit = \"m\", min = 0.0) = 3.0 \"Start value of tank level\";
//   protected final parameter Real tank3.level_start_eps(quantity = \"Length\", unit = \"m\", min = 0.0) = max(tank3.level_start, 1e-15);
//   protected Real tank3.portsData_diameter_internal[1];
//   protected Real tank3.portsData_height_internal[1];
//   protected Real tank3.portsData_zeta_in_internal[1];
//   protected Real tank3.portsData_zeta_out_internal[1];
//   parameter Boolean pipe1.allowFlowReversal = true \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real pipe1.port_a.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe1.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe1.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe1.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real pipe1.port_b.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = if pipe1.allowFlowReversal then 9.999999999999999e+59 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe1.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe1.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean pipe1.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean pipe1.port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean pipe1.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real pipe1.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real pipe1.length(quantity = \"Length\", unit = \"m\") = 2.0 \"Length\";
//   parameter Boolean pipe1.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real pipe1.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Diameter of circular pipe\";
//   parameter Real pipe1.crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * pipe1.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real pipe1.perimeter(quantity = \"Length\", unit = \"m\") = 3.141592653589793 * pipe1.diameter \"Inner perimeter\";
//   parameter Real pipe1.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Average height of surface asperities (default: smooth steel pipe)\";
//   final parameter Real pipe1.V(quantity = \"Volume\", unit = \"m3\") = pipe1.crossArea * pipe1.length * pipe1.nParallel \"volume size\";
//   parameter Real pipe1.height_ab(quantity = \"Length\", unit = \"m\") = 2.0 \"Height(port_b) - Height(port_a)\";
//   parameter Real pipe1.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Real pipe1.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe1.p_a_start \"Start value of pressure at port b\";
//   parameter Real pipe1.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Boolean pipe1.flowModel.from_dp = pipe1.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \"= true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   parameter Integer pipe1.flowModel.n = 2 \"Number of discrete flow volumes\";
//   Real pipe1.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe1.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe1.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe1.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe1.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   Real pipe1.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   parameter Real pipe1.flowModel.nParallel = pipe1.nParallel \"number of identical parallel flow devices\";
//   Real pipe1.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe1.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe1.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe1.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe1.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe1.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe1.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Real pipe1.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean pipe1.flowModel.allowFlowReversal = pipe1.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe1.flowModel.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Formulation of momentum balance\";
//   parameter Real pipe1.flowModel.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = pipe1.m_flow_start \"Start value of mass flow rates\";
//   parameter Real pipe1.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe1.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real pipe1.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe1.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Integer pipe1.flowModel.m = -1 + pipe1.flowModel.n \"Number of flow segments\";
//   Real pipe1.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   Real pipe1.flowModel.m_flows[1](quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe1.flowModel.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0, start = pipe1.flowModel.m_flow_start, stateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real pipe1.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momenta of flow segments\";
//   Real pipe1.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boundaries\";
//   Real pipe1.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real pipe1.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   parameter Boolean pipe1.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Boolean pipe1.flowModel.use_Ib_flows = pipe1.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   Real pipe1.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe1.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe1.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Actual density per segment\";
//   Real pipe1.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe1.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe1.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Actual viscosity per segment\";
//   Real pipe1.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (pipe1.flowModel.p_a_start - pipe1.flowModel.p_b_start) / /*Real*/(-1 + pipe1.flowModel.n)) \"pressure drop between states\";
//   parameter Real pipe1.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean pipe1.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean pipe1.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe1.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 995.586 \"Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean pipe1.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe1.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.001 \"Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   Real pipe1.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") \"pathLengths used internally; to be defined by extending class\";
//   Real pipe1.flowModel.Res_turbulent_internal[1](quantity = \"ReynoldsNumber\", unit = \"1\") \"Re_turbulent used internally; to be defined by extending class\";
//   parameter Real pipe1.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Nominal pressure loss (only for nominal models)\";
//   parameter Real pipe1.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.m_flow_nominal else 100.0 * pipe1.flowModel.m_flow_small \"Nominal mass flow rate\";
//   parameter Real pipe1.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.eps_m_flow * pipe1.flowModel.m_flow_nominal else system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   protected parameter Real pipe1.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   protected final parameter Boolean pipe1.flowModel.constantPressureLossCoefficient = pipe1.flowModel.use_rho_nominal and pipe1.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   protected final parameter Boolean pipe1.flowModel.continuousFlowReversal = not pipe1.flowModel.useUpstreamScheme or pipe1.flowModel.constantPressureLossCoefficient or not pipe1.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   protected Real pipe1.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") \"mean diameters between segments\";
//   protected Real pipe1.flowModel.dp_fric_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.pressureLoss_m_flow(pipe1.flowModel.m_flow_nominal / pipe1.flowModel.nParallel, pipe1.flowModel.rho_nominal, pipe1.flowModel.rho_nominal, pipe1.flowModel.mu_nominal, pipe1.flowModel.mu_nominal, pipe1.flowModel.pathLengths_internal[1], pipe1.flowModel.diameters[1], 0.5 * (pipe1.flowModel.crossAreas[1] + pipe1.flowModel.crossAreas[2]), 0.5 * (pipe1.flowModel.roughnesses[1] + pipe1.flowModel.roughnesses[2]), pipe1.flowModel.m_flow_small / pipe1.flowModel.nParallel, pipe1.flowModel.Res_turbulent_internal[1]) \"pressure loss for nominal conditions\";
//   parameter Boolean pipe2.allowFlowReversal = true \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real pipe2.port_a.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe2.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe2.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe2.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real pipe2.port_b.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = if pipe2.allowFlowReversal then 9.999999999999999e+59 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe2.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe2.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean pipe2.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean pipe2.port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean pipe2.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real pipe2.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real pipe2.length(quantity = \"Length\", unit = \"m\") = 2.0 \"Length\";
//   parameter Boolean pipe2.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real pipe2.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Diameter of circular pipe\";
//   parameter Real pipe2.crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * pipe2.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real pipe2.perimeter(quantity = \"Length\", unit = \"m\") = 3.141592653589793 * pipe2.diameter \"Inner perimeter\";
//   parameter Real pipe2.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Average height of surface asperities (default: smooth steel pipe)\";
//   final parameter Real pipe2.V(quantity = \"Volume\", unit = \"m3\") = pipe2.crossArea * pipe2.length * pipe2.nParallel \"volume size\";
//   parameter Real pipe2.height_ab(quantity = \"Length\", unit = \"m\") = 2.0 \"Height(port_b) - Height(port_a)\";
//   parameter Real pipe2.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Real pipe2.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe2.p_a_start \"Start value of pressure at port b\";
//   parameter Real pipe2.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Boolean pipe2.flowModel.from_dp = pipe2.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \"= true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   parameter Integer pipe2.flowModel.n = 2 \"Number of discrete flow volumes\";
//   Real pipe2.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe2.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe2.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe2.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe2.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   Real pipe2.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   parameter Real pipe2.flowModel.nParallel = pipe2.nParallel \"number of identical parallel flow devices\";
//   Real pipe2.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe2.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe2.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe2.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe2.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe2.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe2.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Real pipe2.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean pipe2.flowModel.allowFlowReversal = pipe2.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe2.flowModel.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Formulation of momentum balance\";
//   parameter Real pipe2.flowModel.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = pipe2.m_flow_start \"Start value of mass flow rates\";
//   parameter Real pipe2.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe2.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real pipe2.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe2.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Integer pipe2.flowModel.m = -1 + pipe2.flowModel.n \"Number of flow segments\";
//   Real pipe2.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   Real pipe2.flowModel.m_flows[1](quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe2.flowModel.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0, start = pipe2.flowModel.m_flow_start, stateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real pipe2.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momenta of flow segments\";
//   Real pipe2.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boundaries\";
//   Real pipe2.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real pipe2.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   parameter Boolean pipe2.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Boolean pipe2.flowModel.use_Ib_flows = pipe2.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   Real pipe2.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe2.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe2.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Actual density per segment\";
//   Real pipe2.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe2.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe2.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Actual viscosity per segment\";
//   Real pipe2.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (pipe2.flowModel.p_a_start - pipe2.flowModel.p_b_start) / /*Real*/(-1 + pipe2.flowModel.n)) \"pressure drop between states\";
//   parameter Real pipe2.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean pipe2.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean pipe2.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe2.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 995.586 \"Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean pipe2.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe2.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.001 \"Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   Real pipe2.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") \"pathLengths used internally; to be defined by extending class\";
//   Real pipe2.flowModel.Res_turbulent_internal[1](quantity = \"ReynoldsNumber\", unit = \"1\") \"Re_turbulent used internally; to be defined by extending class\";
//   parameter Real pipe2.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Nominal pressure loss (only for nominal models)\";
//   parameter Real pipe2.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.m_flow_nominal else 100.0 * pipe2.flowModel.m_flow_small \"Nominal mass flow rate\";
//   parameter Real pipe2.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.eps_m_flow * pipe2.flowModel.m_flow_nominal else system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   protected parameter Real pipe2.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   protected final parameter Boolean pipe2.flowModel.constantPressureLossCoefficient = pipe2.flowModel.use_rho_nominal and pipe2.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   protected final parameter Boolean pipe2.flowModel.continuousFlowReversal = not pipe2.flowModel.useUpstreamScheme or pipe2.flowModel.constantPressureLossCoefficient or not pipe2.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   protected Real pipe2.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") \"mean diameters between segments\";
//   protected Real pipe2.flowModel.dp_fric_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.pressureLoss_m_flow(pipe2.flowModel.m_flow_nominal / pipe2.flowModel.nParallel, pipe2.flowModel.rho_nominal, pipe2.flowModel.rho_nominal, pipe2.flowModel.mu_nominal, pipe2.flowModel.mu_nominal, pipe2.flowModel.pathLengths_internal[1], pipe2.flowModel.diameters[1], 0.5 * (pipe2.flowModel.crossAreas[1] + pipe2.flowModel.crossAreas[2]), 0.5 * (pipe2.flowModel.roughnesses[1] + pipe2.flowModel.roughnesses[2]), pipe2.flowModel.m_flow_small / pipe2.flowModel.nParallel, pipe2.flowModel.Res_turbulent_internal[1]) \"pressure loss for nominal conditions\";
//   parameter Boolean pipe3.allowFlowReversal = true \"= true to allow flow reversal, false restricts to design direction (port_a -> port_b)\";
//   Real pipe3.port_a.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe3.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe3.port_a.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe3.port_a.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   Real pipe3.port_b.m_flow(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = if pipe3.allowFlowReversal then 9.999999999999999e+59 else 0.0) \"Mass flow rate from the connection point into the component\";
//   Real pipe3.port_b.p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Thermodynamic pressure in the connection point\";
//   Real pipe3.port_b.h_outflow(quantity = \"SpecificEnergy\", unit = \"J/kg\", min = -10000000000.0, max = 10000000000.0, nominal = 1000000.0) \"Specific thermodynamic enthalpy close to the connection point if m_flow < 0\";
//   protected parameter Boolean pipe3.port_a_exposesState = false \"= true if port_a exposes the state of a fluid volume\";
//   protected parameter Boolean pipe3.port_b_exposesState = false \"= true if port_b.p exposes the state of a fluid volume\";
//   protected parameter Boolean pipe3.showDesignFlowDirection = true \"= false to hide the arrow in the model icon\";
//   parameter Real pipe3.nParallel(min = 1.0) = 1.0 \"Number of identical parallel pipes\";
//   parameter Real pipe3.length(quantity = \"Length\", unit = \"m\") = 2.0 \"Length\";
//   parameter Boolean pipe3.isCircular = true \"= true if cross sectional area is circular\";
//   parameter Real pipe3.diameter(quantity = \"Length\", unit = \"m\", min = 0.0) = 0.1 \"Diameter of circular pipe\";
//   parameter Real pipe3.crossArea(quantity = \"Area\", unit = \"m2\") = 0.7853981633974483 * pipe3.diameter ^ 2.0 \"Inner cross section area\";
//   parameter Real pipe3.perimeter(quantity = \"Length\", unit = \"m\") = 3.141592653589793 * pipe3.diameter \"Inner perimeter\";
//   parameter Real pipe3.roughness(quantity = \"Length\", unit = \"m\", min = 0.0) = 2.5e-05 \"Average height of surface asperities (default: smooth steel pipe)\";
//   final parameter Real pipe3.V(quantity = \"Volume\", unit = \"m3\") = pipe3.crossArea * pipe3.length * pipe3.nParallel \"volume size\";
//   parameter Real pipe3.height_ab(quantity = \"Length\", unit = \"m\") = -1.0 \"Height(port_b) - Height(port_a)\";
//   parameter Real pipe3.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = system.p_start \"Start value of pressure at port a\";
//   parameter Real pipe3.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe3.p_a_start \"Start value of pressure at port b\";
//   parameter Real pipe3.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = system.m_flow_start \"Start value for mass flow rate\";
//   parameter Boolean pipe3.flowModel.from_dp = pipe3.flowModel.momentumDynamics >= Modelica.Fluid.Types.Dynamics.SteadyStateInitial \"= true, use m_flow = f(dp), otherwise dp = f(m_flow)\";
//   parameter Integer pipe3.flowModel.n = 2 \"Number of discrete flow volumes\";
//   Real pipe3.flowModel.states[1].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe3.flowModel.states[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe3.flowModel.states[2].p(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) \"Absolute pressure of medium\";
//   Real pipe3.flowModel.states[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 1.0, max = 10000.0, start = 300.0, nominal = 300.0) \"Temperature of medium\";
//   Real pipe3.flowModel.vs[1](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   Real pipe3.flowModel.vs[2](quantity = \"Velocity\", unit = \"m/s\") \"Mean velocities of fluid flow\";
//   parameter Real pipe3.flowModel.nParallel = pipe3.nParallel \"number of identical parallel flow devices\";
//   Real pipe3.flowModel.crossAreas[1](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe3.flowModel.crossAreas[2](quantity = \"Area\", unit = \"m2\") \"Cross flow areas at segment boundaries\";
//   Real pipe3.flowModel.dimensions[1](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe3.flowModel.dimensions[2](quantity = \"Length\", unit = \"m\") \"Characteristic dimensions for fluid flow (diameters for pipe flow)\";
//   Real pipe3.flowModel.roughnesses[1](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe3.flowModel.roughnesses[2](quantity = \"Length\", unit = \"m\", min = 0.0) \"Average height of surface asperities\";
//   Real pipe3.flowModel.dheights[1](quantity = \"Length\", unit = \"m\") \"Height(states[2:n]) - Height(states[1:n-1])\";
//   parameter Real pipe3.flowModel.g(quantity = \"Acceleration\", unit = \"m/s2\") = system.g \"Constant gravity acceleration\";
//   parameter Boolean pipe3.flowModel.allowFlowReversal = pipe3.allowFlowReversal \"= true to allow flow reversal, false restricts to design direction (states[1] -> states[n+1])\";
//   parameter enumeration(DynamicFreeInitial, FixedInitial, SteadyStateInitial, SteadyState) pipe3.flowModel.momentumDynamics = Modelica.Fluid.Types.Dynamics.SteadyState \"Formulation of momentum balance\";
//   parameter Real pipe3.flowModel.m_flow_start(quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = -100000.0, max = 100000.0) = pipe3.m_flow_start \"Start value of mass flow rates\";
//   parameter Real pipe3.flowModel.p_a_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe3.p_a_start \"Start value for p[1] at design inflow\";
//   parameter Real pipe3.flowModel.p_b_start(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, max = 100000000.0, start = 100000.0, nominal = 100000.0) = pipe3.p_b_start \"Start value for p[n+1] at design outflow\";
//   parameter Integer pipe3.flowModel.m = -1 + pipe3.flowModel.n \"Number of flow segments\";
//   Real pipe3.flowModel.pathLengths[1](quantity = \"Length\", unit = \"m\") \"Lengths along flow path\";
//   Real pipe3.flowModel.m_flows[1](quantity = \"MassFlowRate.SimpleLiquidWater\", unit = \"kg/s\", min = if pipe3.flowModel.allowFlowReversal then -9.999999999999999e+59 else 0.0, max = 100000.0, start = pipe3.flowModel.m_flow_start, stateSelect = StateSelect.default) \"mass flow rates between states\";
//   Real pipe3.flowModel.Is[1](quantity = \"Momentum\", unit = \"kg.m/s\") \"Momenta of flow segments\";
//   Real pipe3.flowModel.Ib_flows[1](quantity = \"Force\", unit = \"N\") \"Flow of momentum across boundaries\";
//   Real pipe3.flowModel.Fs_p[1](quantity = \"Force\", unit = \"N\") \"Pressure forces\";
//   Real pipe3.flowModel.Fs_fg[1](quantity = \"Force\", unit = \"N\") \"Friction and gravity forces\";
//   parameter Boolean pipe3.flowModel.useUpstreamScheme = true \"= false to average upstream and downstream properties across flow segments\";
//   parameter Boolean pipe3.flowModel.use_Ib_flows = pipe3.flowModel.momentumDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState \"= true to consider differences in flow of momentum through boundaries\";
//   Real pipe3.flowModel.rhos[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe3.flowModel.rhos[2](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0);
//   Real pipe3.flowModel.rhos_act[1](quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0, max = 100000.0, start = 1.0, nominal = 1.0) \"Actual density per segment\";
//   Real pipe3.flowModel.mus[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe3.flowModel.mus[2](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001);
//   Real pipe3.flowModel.mus_act[1](quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0, max = 100000000.0, start = 0.001, nominal = 0.001) \"Actual viscosity per segment\";
//   Real pipe3.flowModel.dps_fg[1](quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", start = (pipe3.flowModel.p_a_start - pipe3.flowModel.p_b_start) / /*Real*/(-1 + pipe3.flowModel.n)) \"pressure drop between states\";
//   parameter Real pipe3.flowModel.Re_turbulent(quantity = \"ReynoldsNumber\", unit = \"1\") = 4000.0 \"Start of turbulent regime, depending on type of flow device\";
//   parameter Boolean pipe3.flowModel.show_Res = false \"= true, if Reynolds numbers are included for plotting\";
//   protected parameter Boolean pipe3.flowModel.use_rho_nominal = false \"= true, if rho_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe3.flowModel.rho_nominal(quantity = \"Density\", unit = \"kg/m3\", displayUnit = \"g/cm3\", min = 0.0) = 995.586 \"Nominal density (e.g., rho_liquidWater = 995, rho_air = 1.2)\";
//   protected parameter Boolean pipe3.flowModel.use_mu_nominal = false \"= true, if mu_nominal is used, otherwise computed from medium\";
//   protected parameter Real pipe3.flowModel.mu_nominal(quantity = \"DynamicViscosity\", unit = \"Pa.s\", min = 0.0) = 0.001 \"Nominal dynamic viscosity (e.g., mu_liquidWater = 1e-3, mu_air = 1.8e-5)\";
//   Real pipe3.flowModel.pathLengths_internal[1](quantity = \"Length\", unit = \"m\") \"pathLengths used internally; to be defined by extending class\";
//   Real pipe3.flowModel.Res_turbulent_internal[1](quantity = \"ReynoldsNumber\", unit = \"1\") \"Re_turbulent used internally; to be defined by extending class\";
//   parameter Real pipe3.flowModel.dp_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Nominal pressure loss (only for nominal models)\";
//   parameter Real pipe3.flowModel.m_flow_nominal(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.m_flow_nominal else 100.0 * pipe3.flowModel.m_flow_small \"Nominal mass flow rate\";
//   parameter Real pipe3.flowModel.m_flow_small(quantity = \"MassFlowRate\", unit = \"kg/s\") = if system.use_eps_Re then system.eps_m_flow * pipe3.flowModel.m_flow_nominal else system.m_flow_small \"Within regularization if |m_flows| < m_flow_small (may be wider for large discontinuities in static head)\";
//   protected parameter Real pipe3.flowModel.dp_small(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, start = 1.0, fixed = false, nominal = 100000.0) \"Within regularization if |dp| < dp_small (may be wider for large discontinuities in static head)\";
//   protected final parameter Boolean pipe3.flowModel.constantPressureLossCoefficient = pipe3.flowModel.use_rho_nominal and pipe3.flowModel.use_mu_nominal \"= true if the pressure loss does not depend on fluid states\";
//   protected final parameter Boolean pipe3.flowModel.continuousFlowReversal = not pipe3.flowModel.useUpstreamScheme or pipe3.flowModel.constantPressureLossCoefficient or not pipe3.flowModel.allowFlowReversal \"= true if the pressure loss is continuous around zero flow\";
//   protected Real pipe3.flowModel.diameters[1](quantity = \"Length\", unit = \"m\") \"mean diameters between segments\";
//   protected Real pipe3.flowModel.dp_fric_nominal(quantity = \"Pressure\", unit = \"Pa\", displayUnit = \"bar\", min = 0.0, nominal = 100000.0) = Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.pressureLoss_m_flow(pipe3.flowModel.m_flow_nominal / pipe3.flowModel.nParallel, pipe3.flowModel.rho_nominal, pipe3.flowModel.rho_nominal, pipe3.flowModel.mu_nominal, pipe3.flowModel.mu_nominal, pipe3.flowModel.pathLengths_internal[1], pipe3.flowModel.diameters[1], 0.5 * (pipe3.flowModel.crossAreas[1] + pipe3.flowModel.crossAreas[2]), 0.5 * (pipe3.flowModel.roughnesses[1] + pipe3.flowModel.roughnesses[2]), pipe3.flowModel.m_flow_small / pipe3.flowModel.nParallel, pipe3.flowModel.Res_turbulent_internal[1]) \"pressure loss for nominal conditions\";
// initial equation
//   tank1.level = tank1.level_start_eps;
//   tank1.medium.T = tank1.T_start;
//   tank2.level = tank2.level_start_eps;
//   tank2.medium.T = tank2.T_start;
//   tank3.level = tank3.level_start_eps;
//   tank3.medium.T = tank3.T_start;
//   pipe1.flowModel.dp_nominal = 1000.0 * pipe1.flowModel.dp_small;
//   pipe1.flowModel.dp_small = system.dp_small;
//   pipe2.flowModel.dp_nominal = 1000.0 * pipe2.flowModel.dp_small;
//   pipe2.flowModel.dp_small = system.dp_small;
//   pipe3.flowModel.dp_nominal = 1000.0 * pipe3.flowModel.dp_small;
//   pipe3.flowModel.dp_small = system.dp_small;
// equation
//   assert(tank1.medium.T >= 272.15 and tank1.medium.T <= 403.15, \"
//   Temperature T (= \" + String(tank1.medium.T, 6, 0, true) + \" K) is not
//   in the allowed range (\" + String(272.15, 6, 0, true) + \" K <= T <= \" + String(403.15, 6, 0, true) + \" K)
//   required from medium model \\\"\" + \"SimpleLiquidWater\" + \"\\\".
//   \");
//   tank1.medium.h = Modelica.Fluid.Vessels.OpenTank$tank1.Medium.specificEnthalpy_pTX(tank1.medium.p, tank1.medium.T, {tank1.medium.X[1]});
//   tank1.medium.u = 4184.0 * (-273.15 + tank1.medium.T);
//   tank1.medium.d = 995.586;
//   tank1.medium.R = 0.0;
//   tank1.medium.MM = 0.018015268;
//   tank1.medium.state.T = tank1.medium.T;
//   tank1.medium.state.p = tank1.medium.p;
//   tank1.medium.X[1] = 1.0;
//   assert(tank1.medium.X[1] >= -1e-05 and tank1.medium.X[1] <= 1.00001, \"Mass fraction X[1] = \" + String(tank1.medium.X[1], 6, 0, true) + \"of substance \" + \"SimpleLiquidWater\" + \"
//   of medium \" + \"SimpleLiquidWater\" + \" is not in the range 0..1\");
//   assert(tank1.medium.p >= 0.0, \"Pressure (= \" + String(tank1.medium.p, 6, 0, true) + \" Pa) of medium \\\"\" + \"SimpleLiquidWater\" + \"\\\" is negative
//   (Temperature = \" + String(tank1.medium.T, 6, 0, true) + \" K)\");
//   tank1.heatTransfer.surfaceAreas = {tank1.crossArea + 3.544907701811032 * sqrt(tank1.crossArea) * tank1.level};
//   tank1.heatTransfer.Ts = {Modelica.Fluid.Vessels.OpenTank$tank1.HeatTransfer$tank1$heatTransfer.Medium.temperature(tank1.heatTransfer.states[1])};
//   tank1.heatTransfer.Ts[1] = tank1.heatTransfer.heatPorts[1].T;
//   tank1.heatTransfer.Q_flows[1] = tank1.heatTransfer.heatPorts[1].Q_flow;
//   tank1.portAreas = {0.7853981633974483 * tank1.portsData_diameter[1] ^ 2.0};
//   tank1.portsData_diameter_internal = {tank1.portsData[1].diameter};
//   tank1.portsData_height_internal = {tank1.portsData[1].height};
//   tank1.portsData_zeta_in_internal = {tank1.portsData[1].zeta_in};
//   tank1.portsData_zeta_out_internal = {tank1.portsData[1].zeta_out};
//   tank1.V = tank1.crossArea * tank1.level \"Volume of fluid\";
//   tank1.medium.p = tank1.p_ambient;
//   tank1.Wb_flow = 0.0 \"Mechanical work is neglected, since also neglected in medium model (otherwise unphysical small temperature change, if tank level changes)\";
//   tank1.vessel_ps_static[1] = max(0.0, tank1.level - tank1.portsData_height[1]) * system.g * tank1.medium.d + tank1.p_ambient;
//   tank1.mb_flow = tank1.ports[1].m_flow;
//   tank1.Hb_flow = tank1.ports_H_flow[1] + tank1.ports_E_flow[1];
//   tank1.Qb_flow = tank1.heatTransfer.Q_flows[1];
//   assert(tank1.fluidLevel <= tank1.fluidLevel_max, \"Vessel is overflowing (fluidLevel > fluidLevel_max = \" + String(tank1.fluidLevel, 6, 0, true) + \")\");
//   assert(tank1.fluidLevel > (-1e-06) * tank1.fluidLevel_max, \"Fluid level (= \" + String(tank1.fluidLevel, 6, 0, true) + \") is below zero meaning that the solution failed.\");
//   tank1.portInDensities[1] = Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX(tank1.vessel_ps_static[1], pipe1.port_b.h_outflow, {}));
//   tank1.portVelocities[1] = smooth(0, tank1.ports[1].m_flow / (Modelica.Fluid.Vessels.OpenTank$tank1.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX(tank1.vessel_ps_static[1], smooth(0, if tank1.ports[1].m_flow > 0.0 then pipe1.port_b.h_outflow else tank1.ports[1].h_outflow), {})) * tank1.portAreas[1]));
//   tank1.ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank1.fluidLevel + (-0.1) * tank1.portsData_diameter[1] - tank1.portsData_height[1], 1.0, 0.001, 0.1 * tank1.portsData_diameter[1]);
//   tank1.m_flow_turbulent[1] = if not tank1.use_Re then tank1.m_flow_small else max(tank1.m_flow_small, 39.26990816987242 * tank1.portsData_diameter[1] * (Modelica.Fluid.Vessels.OpenTank$tank1.Medium.dynamicViscosity(Modelica.Fluid.Vessels.OpenTank$tank1.Medium.setState_phX(tank1.vessel_ps_static[1], pipe1.port_b.h_outflow, {})) + Modelica.Fluid.Vessels.OpenTank$tank1.Medium.dynamicViscosity(tank1.medium.state)));
//   tank1.regularFlow[1] = tank1.fluidLevel >= tank1.portsData_height[1];
//   tank1.inFlow[1] = not tank1.regularFlow[1] and (tank1.s[1] > 0.0 or tank1.portsData_height[1] >= tank1.fluidLevel_max);
//   if tank1.regularFlow[1] then
//     tank1.ports[1].p = homotopy(tank1.vessel_ps_static[1] + 0.5 * tank1.portAreas[1] ^ (-2.0) * Modelica.Fluid.Utilities.regSquare2(tank1.ports[1].m_flow, tank1.m_flow_turbulent[1], (-1.0 + tank1.portsData_zeta_in[1] + (tank1.portAreas[1] / tank1.vesselArea) ^ 2.0) * tank1.ports_penetration[1] / tank1.portInDensities[1], (1.0 + tank1.portsData_zeta_out[1] - (tank1.portAreas[1] / tank1.vesselArea) ^ 2.0) / (tank1.ports_penetration[1] * tank1.medium.d), false, 1.0), tank1.vessel_ps_static[1]);
//     tank1.s[1] = tank1.fluidLevel - tank1.portsData_height[1];
//   elseif tank1.inFlow[1] then
//     tank1.ports[1].p = tank1.vessel_ps_static[1];
//     tank1.s[1] = tank1.ports[1].m_flow;
//   else
//     tank1.ports[1].m_flow = 0.0;
//     tank1.s[1] = 9.869232667160129e-06 * (tank1.ports[1].p - tank1.vessel_ps_static[1]) * (tank1.portsData_height[1] - tank1.fluidLevel);
//   end if;
//   tank1.ports[1].h_outflow = tank1.medium.h;
//   tank1.ports_H_flow[1] = tank1.ports[1].m_flow * smooth(0, if tank1.ports[1].m_flow > 0.0 then pipe1.port_b.h_outflow else tank1.ports[1].h_outflow) \"Enthalpy flow\";
//   tank1.ports_E_flow[1] = tank1.ports[1].m_flow * (0.5 * tank1.portVelocities[1] ^ 2.0 + system.g * tank1.portsData_height[1]) \"Flow of kinetic and potential energy\";
//   tank1.m = tank1.fluidVolume * tank1.medium.d;
//   tank1.U = tank1.m * tank1.medium.u;
//   der(tank1.U) = tank1.Hb_flow + tank1.Qb_flow + tank1.Wb_flow;
//   der(tank1.m) = tank1.mb_flow;
//   assert(tank2.medium.T >= 272.15 and tank2.medium.T <= 403.15, \"
//   Temperature T (= \" + String(tank2.medium.T, 6, 0, true) + \" K) is not
//   in the allowed range (\" + String(272.15, 6, 0, true) + \" K <= T <= \" + String(403.15, 6, 0, true) + \" K)
//   required from medium model \\\"\" + \"SimpleLiquidWater\" + \"\\\".
//   \");
//   tank2.medium.h = Modelica.Fluid.Vessels.OpenTank$tank2.Medium.specificEnthalpy_pTX(tank2.medium.p, tank2.medium.T, {tank2.medium.X[1]});
//   tank2.medium.u = 4184.0 * (-273.15 + tank2.medium.T);
//   tank2.medium.d = 995.586;
//   tank2.medium.R = 0.0;
//   tank2.medium.MM = 0.018015268;
//   tank2.medium.state.T = tank2.medium.T;
//   tank2.medium.state.p = tank2.medium.p;
//   tank2.medium.X[1] = 1.0;
//   assert(tank2.medium.X[1] >= -1e-05 and tank2.medium.X[1] <= 1.00001, \"Mass fraction X[1] = \" + String(tank2.medium.X[1], 6, 0, true) + \"of substance \" + \"SimpleLiquidWater\" + \"
//   of medium \" + \"SimpleLiquidWater\" + \" is not in the range 0..1\");
//   assert(tank2.medium.p >= 0.0, \"Pressure (= \" + String(tank2.medium.p, 6, 0, true) + \" Pa) of medium \\\"\" + \"SimpleLiquidWater\" + \"\\\" is negative
//   (Temperature = \" + String(tank2.medium.T, 6, 0, true) + \" K)\");
//   tank2.heatTransfer.surfaceAreas = {tank2.crossArea + 3.544907701811032 * sqrt(tank2.crossArea) * tank2.level};
//   tank2.heatTransfer.Ts = {Modelica.Fluid.Vessels.OpenTank$tank2.HeatTransfer$tank2$heatTransfer.Medium.temperature(tank2.heatTransfer.states[1])};
//   tank2.heatTransfer.Ts[1] = tank2.heatTransfer.heatPorts[1].T;
//   tank2.heatTransfer.Q_flows[1] = tank2.heatTransfer.heatPorts[1].Q_flow;
//   tank2.portAreas = {0.7853981633974483 * tank2.portsData_diameter[1] ^ 2.0};
//   tank2.portsData_diameter_internal = {tank2.portsData[1].diameter};
//   tank2.portsData_height_internal = {tank2.portsData[1].height};
//   tank2.portsData_zeta_in_internal = {tank2.portsData[1].zeta_in};
//   tank2.portsData_zeta_out_internal = {tank2.portsData[1].zeta_out};
//   tank2.V = tank2.crossArea * tank2.level \"Volume of fluid\";
//   tank2.medium.p = tank2.p_ambient;
//   tank2.Wb_flow = 0.0 \"Mechanical work is neglected, since also neglected in medium model (otherwise unphysical small temperature change, if tank level changes)\";
//   tank2.vessel_ps_static[1] = max(0.0, tank2.level - tank2.portsData_height[1]) * system.g * tank2.medium.d + tank2.p_ambient;
//   tank2.mb_flow = tank2.ports[1].m_flow;
//   tank2.Hb_flow = tank2.ports_H_flow[1] + tank2.ports_E_flow[1];
//   tank2.Qb_flow = tank2.heatTransfer.Q_flows[1];
//   assert(tank2.fluidLevel <= tank2.fluidLevel_max, \"Vessel is overflowing (fluidLevel > fluidLevel_max = \" + String(tank2.fluidLevel, 6, 0, true) + \")\");
//   assert(tank2.fluidLevel > (-1e-06) * tank2.fluidLevel_max, \"Fluid level (= \" + String(tank2.fluidLevel, 6, 0, true) + \") is below zero meaning that the solution failed.\");
//   tank2.portInDensities[1] = Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX(tank2.vessel_ps_static[1], pipe2.port_b.h_outflow, {}));
//   tank2.portVelocities[1] = smooth(0, tank2.ports[1].m_flow / (Modelica.Fluid.Vessels.OpenTank$tank2.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX(tank2.vessel_ps_static[1], smooth(0, if tank2.ports[1].m_flow > 0.0 then pipe2.port_b.h_outflow else tank2.ports[1].h_outflow), {})) * tank2.portAreas[1]));
//   tank2.ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank2.fluidLevel + (-0.1) * tank2.portsData_diameter[1] - tank2.portsData_height[1], 1.0, 0.001, 0.1 * tank2.portsData_diameter[1]);
//   tank2.m_flow_turbulent[1] = if not tank2.use_Re then tank2.m_flow_small else max(tank2.m_flow_small, 39.26990816987242 * tank2.portsData_diameter[1] * (Modelica.Fluid.Vessels.OpenTank$tank2.Medium.dynamicViscosity(Modelica.Fluid.Vessels.OpenTank$tank2.Medium.setState_phX(tank2.vessel_ps_static[1], pipe2.port_b.h_outflow, {})) + Modelica.Fluid.Vessels.OpenTank$tank2.Medium.dynamicViscosity(tank2.medium.state)));
//   tank2.regularFlow[1] = tank2.fluidLevel >= tank2.portsData_height[1];
//   tank2.inFlow[1] = not tank2.regularFlow[1] and (tank2.s[1] > 0.0 or tank2.portsData_height[1] >= tank2.fluidLevel_max);
//   if tank2.regularFlow[1] then
//     tank2.ports[1].p = homotopy(tank2.vessel_ps_static[1] + 0.5 * tank2.portAreas[1] ^ (-2.0) * Modelica.Fluid.Utilities.regSquare2(tank2.ports[1].m_flow, tank2.m_flow_turbulent[1], (-1.0 + tank2.portsData_zeta_in[1] + (tank2.portAreas[1] / tank2.vesselArea) ^ 2.0) * tank2.ports_penetration[1] / tank2.portInDensities[1], (1.0 + tank2.portsData_zeta_out[1] - (tank2.portAreas[1] / tank2.vesselArea) ^ 2.0) / (tank2.ports_penetration[1] * tank2.medium.d), false, 1.0), tank2.vessel_ps_static[1]);
//     tank2.s[1] = tank2.fluidLevel - tank2.portsData_height[1];
//   elseif tank2.inFlow[1] then
//     tank2.ports[1].p = tank2.vessel_ps_static[1];
//     tank2.s[1] = tank2.ports[1].m_flow;
//   else
//     tank2.ports[1].m_flow = 0.0;
//     tank2.s[1] = 9.869232667160129e-06 * (tank2.ports[1].p - tank2.vessel_ps_static[1]) * (tank2.portsData_height[1] - tank2.fluidLevel);
//   end if;
//   tank2.ports[1].h_outflow = tank2.medium.h;
//   tank2.ports_H_flow[1] = tank2.ports[1].m_flow * smooth(0, if tank2.ports[1].m_flow > 0.0 then pipe2.port_b.h_outflow else tank2.ports[1].h_outflow) \"Enthalpy flow\";
//   tank2.ports_E_flow[1] = tank2.ports[1].m_flow * (0.5 * tank2.portVelocities[1] ^ 2.0 + system.g * tank2.portsData_height[1]) \"Flow of kinetic and potential energy\";
//   tank2.m = tank2.fluidVolume * tank2.medium.d;
//   tank2.U = tank2.m * tank2.medium.u;
//   der(tank2.U) = tank2.Hb_flow + tank2.Qb_flow + tank2.Wb_flow;
//   der(tank2.m) = tank2.mb_flow;
//   assert(tank3.medium.T >= 272.15 and tank3.medium.T <= 403.15, \"
//   Temperature T (= \" + String(tank3.medium.T, 6, 0, true) + \" K) is not
//   in the allowed range (\" + String(272.15, 6, 0, true) + \" K <= T <= \" + String(403.15, 6, 0, true) + \" K)
//   required from medium model \\\"\" + \"SimpleLiquidWater\" + \"\\\".
//   \");
//   tank3.medium.h = Modelica.Fluid.Vessels.OpenTank$tank3.Medium.specificEnthalpy_pTX(tank3.medium.p, tank3.medium.T, {tank3.medium.X[1]});
//   tank3.medium.u = 4184.0 * (-273.15 + tank3.medium.T);
//   tank3.medium.d = 995.586;
//   tank3.medium.R = 0.0;
//   tank3.medium.MM = 0.018015268;
//   tank3.medium.state.T = tank3.medium.T;
//   tank3.medium.state.p = tank3.medium.p;
//   tank3.medium.X[1] = 1.0;
//   assert(tank3.medium.X[1] >= -1e-05 and tank3.medium.X[1] <= 1.00001, \"Mass fraction X[1] = \" + String(tank3.medium.X[1], 6, 0, true) + \"of substance \" + \"SimpleLiquidWater\" + \"
//   of medium \" + \"SimpleLiquidWater\" + \" is not in the range 0..1\");
//   assert(tank3.medium.p >= 0.0, \"Pressure (= \" + String(tank3.medium.p, 6, 0, true) + \" Pa) of medium \\\"\" + \"SimpleLiquidWater\" + \"\\\" is negative
//   (Temperature = \" + String(tank3.medium.T, 6, 0, true) + \" K)\");
//   tank3.heatTransfer.surfaceAreas = {tank3.crossArea + 3.544907701811032 * sqrt(tank3.crossArea) * tank3.level};
//   tank3.heatTransfer.Ts = {Modelica.Fluid.Vessels.OpenTank$tank3.HeatTransfer$tank3$heatTransfer.Medium.temperature(tank3.heatTransfer.states[1])};
//   tank3.heatTransfer.Ts[1] = tank3.heatTransfer.heatPorts[1].T;
//   tank3.heatTransfer.Q_flows[1] = tank3.heatTransfer.heatPorts[1].Q_flow;
//   tank3.portAreas = {0.7853981633974483 * tank3.portsData_diameter[1] ^ 2.0};
//   tank3.portsData_diameter_internal = {tank3.portsData[1].diameter};
//   tank3.portsData_height_internal = {tank3.portsData[1].height};
//   tank3.portsData_zeta_in_internal = {tank3.portsData[1].zeta_in};
//   tank3.portsData_zeta_out_internal = {tank3.portsData[1].zeta_out};
//   tank3.V = tank3.crossArea * tank3.level \"Volume of fluid\";
//   tank3.medium.p = tank3.p_ambient;
//   tank3.Wb_flow = 0.0 \"Mechanical work is neglected, since also neglected in medium model (otherwise unphysical small temperature change, if tank level changes)\";
//   tank3.vessel_ps_static[1] = max(0.0, tank3.level - tank3.portsData_height[1]) * system.g * tank3.medium.d + tank3.p_ambient;
//   tank3.mb_flow = tank3.ports[1].m_flow;
//   tank3.Hb_flow = tank3.ports_H_flow[1] + tank3.ports_E_flow[1];
//   tank3.Qb_flow = tank3.heatTransfer.Q_flows[1];
//   assert(tank3.fluidLevel <= tank3.fluidLevel_max, \"Vessel is overflowing (fluidLevel > fluidLevel_max = \" + String(tank3.fluidLevel, 6, 0, true) + \")\");
//   assert(tank3.fluidLevel > (-1e-06) * tank3.fluidLevel_max, \"Fluid level (= \" + String(tank3.fluidLevel, 6, 0, true) + \") is below zero meaning that the solution failed.\");
//   tank3.portInDensities[1] = Modelica.Fluid.Vessels.OpenTank$tank3.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank3.Medium.setState_phX(tank3.vessel_ps_static[1], pipe3.port_b.h_outflow, {}));
//   tank3.portVelocities[1] = smooth(0, tank3.ports[1].m_flow / (Modelica.Fluid.Vessels.OpenTank$tank3.Medium.density(Modelica.Fluid.Vessels.OpenTank$tank3.Medium.setState_phX(tank3.vessel_ps_static[1], smooth(0, if tank3.ports[1].m_flow > 0.0 then pipe3.port_b.h_outflow else tank3.ports[1].h_outflow), {})) * tank3.portAreas[1]));
//   tank3.ports_penetration[1] = Modelica.Fluid.Utilities.regStep(tank3.fluidLevel + (-0.1) * tank3.portsData_diameter[1] - tank3.portsData_height[1], 1.0, 0.001, 0.1 * tank3.portsData_diameter[1]);
//   tank3.m_flow_turbulent[1] = if not tank3.use_Re then tank3.m_flow_small else max(tank3.m_flow_small, 39.26990816987242 * tank3.portsData_diameter[1] * (Modelica.Fluid.Vessels.OpenTank$tank3.Medium.dynamicViscosity(Modelica.Fluid.Vessels.OpenTank$tank3.Medium.setState_phX(tank3.vessel_ps_static[1], pipe3.port_b.h_outflow, {})) + Modelica.Fluid.Vessels.OpenTank$tank3.Medium.dynamicViscosity(tank3.medium.state)));
//   tank3.regularFlow[1] = tank3.fluidLevel >= tank3.portsData_height[1];
//   tank3.inFlow[1] = not tank3.regularFlow[1] and (tank3.s[1] > 0.0 or tank3.portsData_height[1] >= tank3.fluidLevel_max);
//   if tank3.regularFlow[1] then
//     tank3.ports[1].p = homotopy(tank3.vessel_ps_static[1] + 0.5 * tank3.portAreas[1] ^ (-2.0) * Modelica.Fluid.Utilities.regSquare2(tank3.ports[1].m_flow, tank3.m_flow_turbulent[1], (-1.0 + tank3.portsData_zeta_in[1] + (tank3.portAreas[1] / tank3.vesselArea) ^ 2.0) * tank3.ports_penetration[1] / tank3.portInDensities[1], (1.0 + tank3.portsData_zeta_out[1] - (tank3.portAreas[1] / tank3.vesselArea) ^ 2.0) / (tank3.ports_penetration[1] * tank3.medium.d), false, 1.0), tank3.vessel_ps_static[1]);
//     tank3.s[1] = tank3.fluidLevel - tank3.portsData_height[1];
//   elseif tank3.inFlow[1] then
//     tank3.ports[1].p = tank3.vessel_ps_static[1];
//     tank3.s[1] = tank3.ports[1].m_flow;
//   else
//     tank3.ports[1].m_flow = 0.0;
//     tank3.s[1] = 9.869232667160129e-06 * (tank3.ports[1].p - tank3.vessel_ps_static[1]) * (tank3.portsData_height[1] - tank3.fluidLevel);
//   end if;
//   tank3.ports[1].h_outflow = tank3.medium.h;
//   tank3.ports_H_flow[1] = tank3.ports[1].m_flow * smooth(0, if tank3.ports[1].m_flow > 0.0 then pipe3.port_b.h_outflow else tank3.ports[1].h_outflow) \"Enthalpy flow\";
//   tank3.ports_E_flow[1] = tank3.ports[1].m_flow * (0.5 * tank3.portVelocities[1] ^ 2.0 + system.g * tank3.portsData_height[1]) \"Flow of kinetic and potential energy\";
//   tank3.m = tank3.fluidVolume * tank3.medium.d;
//   tank3.U = tank3.m * tank3.medium.u;
//   der(tank3.U) = tank3.Hb_flow + tank3.Qb_flow + tank3.Wb_flow;
//   der(tank3.m) = tank3.mb_flow;
//   pipe1.flowModel.states[1] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.setState_phX(pipe1.port_a.p, $OMC$inStreamDiv(($OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) * pipe2.port_a.h_outflow + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07) * pipe3.port_a.h_outflow) / ($OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07)), pipe2.port_a.h_outflow), {}));
//   pipe1.flowModel.states[2] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.setState_phX(pipe1.port_b.p, tank1.ports[1].h_outflow, {}));
//   pipe1.flowModel.vs = {pipe1.port_a.m_flow / (pipe1.flowModel.crossAreas[1] * Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState*/(pipe1.flowModel.states[1])) * pipe1.nParallel), (-pipe1.port_b.m_flow) / (pipe1.flowModel.crossAreas[2] * Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe1.Medium.ThermodynamicState*/(pipe1.flowModel.states[2])) * pipe1.nParallel)};
//   pipe1.flowModel.crossAreas = {pipe1.crossArea, pipe1.crossArea};
//   pipe1.flowModel.dimensions = {4.0 * pipe1.crossArea / pipe1.perimeter, 4.0 * pipe1.crossArea / pipe1.perimeter};
//   pipe1.flowModel.roughnesses = {pipe1.roughness, pipe1.roughness};
//   pipe1.flowModel.dheights = {pipe1.height_ab};
//   pipe1.flowModel.pathLengths = {pipe1.length};
//   pipe1.flowModel.rhos = if pipe1.flowModel.use_rho_nominal then {pipe1.flowModel.rho_nominal, pipe1.flowModel.rho_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density(pipe1.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.density(pipe1.flowModel.states[2])};
//   pipe1.flowModel.mus = if pipe1.flowModel.use_mu_nominal then {pipe1.flowModel.mu_nominal, pipe1.flowModel.mu_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.dynamicViscosity(pipe1.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.dynamicViscosity(pipe1.flowModel.states[2])};
//   pipe1.flowModel.pathLengths_internal = {pipe1.flowModel.pathLengths[1]};
//   pipe1.flowModel.Res_turbulent_internal = {pipe1.flowModel.Re_turbulent};
//   pipe1.flowModel.diameters = {(pipe1.flowModel.dimensions[1] + pipe1.flowModel.dimensions[2]) * 0.5};
//   assert(pipe1.flowModel.m_flows[1] > (-pipe1.flowModel.m_flow_small) or pipe1.flowModel.allowFlowReversal, \"Reverting flow occurs even though allowFlowReversal is false\");
//   pipe1.flowModel.m_flows[1] = homotopy(Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.WallFriction.massFlowRate_dp_staticHead(pipe1.flowModel.dps_fg[1], pipe1.flowModel.rhos[1], pipe1.flowModel.rhos[2], pipe1.flowModel.mus[1], pipe1.flowModel.mus[2], pipe1.flowModel.pathLengths_internal[1], pipe1.flowModel.diameters[1], pipe1.flowModel.dheights[1] * pipe1.flowModel.g, 0.5 * (pipe1.flowModel.crossAreas[1] + pipe1.flowModel.crossAreas[2]), 0.5 * (pipe1.flowModel.roughnesses[1] + pipe1.flowModel.roughnesses[2]), pipe1.flowModel.dp_small / /*Real*/(-1 + pipe1.flowModel.n), pipe1.flowModel.Res_turbulent_internal[1]) * pipe1.flowModel.nParallel, (pipe1.flowModel.dps_fg[1] - pipe1.flowModel.dheights[1] * pipe1.flowModel.g * pipe1.flowModel.rho_nominal) * pipe1.flowModel.m_flow_nominal / pipe1.flowModel.dp_nominal);
//   pipe1.flowModel.rhos_act[1] = if noEvent(pipe1.flowModel.m_flows[1] > 0.0) then pipe1.flowModel.rhos[1] else pipe1.flowModel.rhos[2];
//   pipe1.flowModel.mus_act[1] = if noEvent(pipe1.flowModel.m_flows[1] > 0.0) then pipe1.flowModel.mus[1] else pipe1.flowModel.mus[2];
//   pipe1.flowModel.Ib_flows[1] = 0.0;
//   pipe1.flowModel.Fs_p[1] = 0.5 * (pipe1.flowModel.crossAreas[1] + pipe1.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.pressure(pipe1.flowModel.states[2]) - Modelica.Fluid.Pipes.StaticPipe$pipe1.FlowModel$pipe1$flowModel.Medium.pressure(pipe1.flowModel.states[1])) * pipe1.flowModel.nParallel;
//   pipe1.flowModel.dps_fg[1] = 2.0 * pipe1.flowModel.Fs_fg[1] / ((pipe1.flowModel.crossAreas[1] + pipe1.flowModel.crossAreas[2]) * pipe1.flowModel.nParallel);
//   pipe1.flowModel.Is[1] = pipe1.flowModel.m_flows[1] * pipe1.flowModel.pathLengths[1];
//   0.0 = pipe1.flowModel.Ib_flows[1] - pipe1.flowModel.Fs_p[1] - pipe1.flowModel.Fs_fg[1];
//   pipe1.port_a.m_flow = pipe1.flowModel.m_flows[1];
//   0.0 = pipe1.port_a.m_flow + pipe1.port_b.m_flow;
//   pipe1.port_b.h_outflow = $OMC$inStreamDiv(($OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) * pipe2.port_a.h_outflow + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07) * pipe3.port_a.h_outflow) / ($OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07)), pipe2.port_a.h_outflow) - system.g * pipe1.height_ab;
//   pipe1.port_a.h_outflow = tank1.ports[1].h_outflow + system.g * pipe1.height_ab;
//   assert(pipe1.length >= pipe1.height_ab, \"Parameter length must be greater or equal height_ab.\");
//   pipe2.flowModel.states[1] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.setState_phX(pipe2.port_a.p, $OMC$inStreamDiv(($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) * pipe1.port_a.h_outflow + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07) * pipe3.port_a.h_outflow) / ($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07)), pipe1.port_a.h_outflow), {}));
//   pipe2.flowModel.states[2] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.setState_phX(pipe2.port_b.p, tank2.ports[1].h_outflow, {}));
//   pipe2.flowModel.vs = {pipe2.port_a.m_flow / (pipe2.flowModel.crossAreas[1] * Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState*/(pipe2.flowModel.states[1])) * pipe2.nParallel), (-pipe2.port_b.m_flow) / (pipe2.flowModel.crossAreas[2] * Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe2.Medium.ThermodynamicState*/(pipe2.flowModel.states[2])) * pipe2.nParallel)};
//   pipe2.flowModel.crossAreas = {pipe2.crossArea, pipe2.crossArea};
//   pipe2.flowModel.dimensions = {4.0 * pipe2.crossArea / pipe2.perimeter, 4.0 * pipe2.crossArea / pipe2.perimeter};
//   pipe2.flowModel.roughnesses = {pipe2.roughness, pipe2.roughness};
//   pipe2.flowModel.dheights = {pipe2.height_ab};
//   pipe2.flowModel.pathLengths = {pipe2.length};
//   pipe2.flowModel.rhos = if pipe2.flowModel.use_rho_nominal then {pipe2.flowModel.rho_nominal, pipe2.flowModel.rho_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density(pipe2.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.density(pipe2.flowModel.states[2])};
//   pipe2.flowModel.mus = if pipe2.flowModel.use_mu_nominal then {pipe2.flowModel.mu_nominal, pipe2.flowModel.mu_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.dynamicViscosity(pipe2.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.dynamicViscosity(pipe2.flowModel.states[2])};
//   pipe2.flowModel.pathLengths_internal = {pipe2.flowModel.pathLengths[1]};
//   pipe2.flowModel.Res_turbulent_internal = {pipe2.flowModel.Re_turbulent};
//   pipe2.flowModel.diameters = {(pipe2.flowModel.dimensions[1] + pipe2.flowModel.dimensions[2]) * 0.5};
//   assert(pipe2.flowModel.m_flows[1] > (-pipe2.flowModel.m_flow_small) or pipe2.flowModel.allowFlowReversal, \"Reverting flow occurs even though allowFlowReversal is false\");
//   pipe2.flowModel.m_flows[1] = homotopy(Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.WallFriction.massFlowRate_dp_staticHead(pipe2.flowModel.dps_fg[1], pipe2.flowModel.rhos[1], pipe2.flowModel.rhos[2], pipe2.flowModel.mus[1], pipe2.flowModel.mus[2], pipe2.flowModel.pathLengths_internal[1], pipe2.flowModel.diameters[1], pipe2.flowModel.dheights[1] * pipe2.flowModel.g, 0.5 * (pipe2.flowModel.crossAreas[1] + pipe2.flowModel.crossAreas[2]), 0.5 * (pipe2.flowModel.roughnesses[1] + pipe2.flowModel.roughnesses[2]), pipe2.flowModel.dp_small / /*Real*/(-1 + pipe2.flowModel.n), pipe2.flowModel.Res_turbulent_internal[1]) * pipe2.flowModel.nParallel, (pipe2.flowModel.dps_fg[1] - pipe2.flowModel.dheights[1] * pipe2.flowModel.g * pipe2.flowModel.rho_nominal) * pipe2.flowModel.m_flow_nominal / pipe2.flowModel.dp_nominal);
//   pipe2.flowModel.rhos_act[1] = if noEvent(pipe2.flowModel.m_flows[1] > 0.0) then pipe2.flowModel.rhos[1] else pipe2.flowModel.rhos[2];
//   pipe2.flowModel.mus_act[1] = if noEvent(pipe2.flowModel.m_flows[1] > 0.0) then pipe2.flowModel.mus[1] else pipe2.flowModel.mus[2];
//   pipe2.flowModel.Ib_flows[1] = 0.0;
//   pipe2.flowModel.Fs_p[1] = 0.5 * (pipe2.flowModel.crossAreas[1] + pipe2.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.pressure(pipe2.flowModel.states[2]) - Modelica.Fluid.Pipes.StaticPipe$pipe2.FlowModel$pipe2$flowModel.Medium.pressure(pipe2.flowModel.states[1])) * pipe2.flowModel.nParallel;
//   pipe2.flowModel.dps_fg[1] = 2.0 * pipe2.flowModel.Fs_fg[1] / ((pipe2.flowModel.crossAreas[1] + pipe2.flowModel.crossAreas[2]) * pipe2.flowModel.nParallel);
//   pipe2.flowModel.Is[1] = pipe2.flowModel.m_flows[1] * pipe2.flowModel.pathLengths[1];
//   0.0 = pipe2.flowModel.Ib_flows[1] - pipe2.flowModel.Fs_p[1] - pipe2.flowModel.Fs_fg[1];
//   pipe2.port_a.m_flow = pipe2.flowModel.m_flows[1];
//   0.0 = pipe2.port_a.m_flow + pipe2.port_b.m_flow;
//   pipe2.port_b.h_outflow = $OMC$inStreamDiv(($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) * pipe1.port_a.h_outflow + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07) * pipe3.port_a.h_outflow) / ($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe3.port_a.m_flow, 1e-07)), pipe1.port_a.h_outflow) - system.g * pipe2.height_ab;
//   pipe2.port_a.h_outflow = tank2.ports[1].h_outflow + system.g * pipe2.height_ab;
//   assert(pipe2.length >= pipe2.height_ab, \"Parameter length must be greater or equal height_ab.\");
//   pipe3.flowModel.states[1] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.setState_phX(pipe3.port_a.p, $OMC$inStreamDiv(($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) * pipe1.port_a.h_outflow + $OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) * pipe2.port_a.h_outflow) / ($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07)), pipe1.port_a.h_outflow), {}));
//   pipe3.flowModel.states[2] = /*.Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.ThermodynamicState*/(Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.setState_phX(pipe3.port_b.p, tank3.ports[1].h_outflow, {}));
//   pipe3.flowModel.vs = {pipe3.port_a.m_flow / (pipe3.flowModel.crossAreas[1] * Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState*/(pipe3.flowModel.states[1])) * pipe3.nParallel), (-pipe3.port_b.m_flow) / (pipe3.flowModel.crossAreas[2] * Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.density(/*.Modelica.Fluid.Pipes.StaticPipe$pipe3.Medium.ThermodynamicState*/(pipe3.flowModel.states[2])) * pipe3.nParallel)};
//   pipe3.flowModel.crossAreas = {pipe3.crossArea, pipe3.crossArea};
//   pipe3.flowModel.dimensions = {4.0 * pipe3.crossArea / pipe3.perimeter, 4.0 * pipe3.crossArea / pipe3.perimeter};
//   pipe3.flowModel.roughnesses = {pipe3.roughness, pipe3.roughness};
//   pipe3.flowModel.dheights = {pipe3.height_ab};
//   pipe3.flowModel.pathLengths = {pipe3.length};
//   pipe3.flowModel.rhos = if pipe3.flowModel.use_rho_nominal then {pipe3.flowModel.rho_nominal, pipe3.flowModel.rho_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density(pipe3.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.density(pipe3.flowModel.states[2])};
//   pipe3.flowModel.mus = if pipe3.flowModel.use_mu_nominal then {pipe3.flowModel.mu_nominal, pipe3.flowModel.mu_nominal} else {Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.dynamicViscosity(pipe3.flowModel.states[1]), Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.dynamicViscosity(pipe3.flowModel.states[2])};
//   pipe3.flowModel.pathLengths_internal = {pipe3.flowModel.pathLengths[1]};
//   pipe3.flowModel.Res_turbulent_internal = {pipe3.flowModel.Re_turbulent};
//   pipe3.flowModel.diameters = {(pipe3.flowModel.dimensions[1] + pipe3.flowModel.dimensions[2]) * 0.5};
//   assert(pipe3.flowModel.m_flows[1] > (-pipe3.flowModel.m_flow_small) or pipe3.flowModel.allowFlowReversal, \"Reverting flow occurs even though allowFlowReversal is false\");
//   pipe3.flowModel.m_flows[1] = homotopy(Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.WallFriction.massFlowRate_dp_staticHead(pipe3.flowModel.dps_fg[1], pipe3.flowModel.rhos[1], pipe3.flowModel.rhos[2], pipe3.flowModel.mus[1], pipe3.flowModel.mus[2], pipe3.flowModel.pathLengths_internal[1], pipe3.flowModel.diameters[1], pipe3.flowModel.dheights[1] * pipe3.flowModel.g, 0.5 * (pipe3.flowModel.crossAreas[1] + pipe3.flowModel.crossAreas[2]), 0.5 * (pipe3.flowModel.roughnesses[1] + pipe3.flowModel.roughnesses[2]), pipe3.flowModel.dp_small / /*Real*/(-1 + pipe3.flowModel.n), pipe3.flowModel.Res_turbulent_internal[1]) * pipe3.flowModel.nParallel, (pipe3.flowModel.dps_fg[1] - pipe3.flowModel.dheights[1] * pipe3.flowModel.g * pipe3.flowModel.rho_nominal) * pipe3.flowModel.m_flow_nominal / pipe3.flowModel.dp_nominal);
//   pipe3.flowModel.rhos_act[1] = if noEvent(pipe3.flowModel.m_flows[1] > 0.0) then pipe3.flowModel.rhos[1] else pipe3.flowModel.rhos[2];
//   pipe3.flowModel.mus_act[1] = if noEvent(pipe3.flowModel.m_flows[1] > 0.0) then pipe3.flowModel.mus[1] else pipe3.flowModel.mus[2];
//   pipe3.flowModel.Ib_flows[1] = 0.0;
//   pipe3.flowModel.Fs_p[1] = 0.5 * (pipe3.flowModel.crossAreas[1] + pipe3.flowModel.crossAreas[2]) * (Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.pressure(pipe3.flowModel.states[2]) - Modelica.Fluid.Pipes.StaticPipe$pipe3.FlowModel$pipe3$flowModel.Medium.pressure(pipe3.flowModel.states[1])) * pipe3.flowModel.nParallel;
//   pipe3.flowModel.dps_fg[1] = 2.0 * pipe3.flowModel.Fs_fg[1] / ((pipe3.flowModel.crossAreas[1] + pipe3.flowModel.crossAreas[2]) * pipe3.flowModel.nParallel);
//   pipe3.flowModel.Is[1] = pipe3.flowModel.m_flows[1] * pipe3.flowModel.pathLengths[1];
//   0.0 = pipe3.flowModel.Ib_flows[1] - pipe3.flowModel.Fs_p[1] - pipe3.flowModel.Fs_fg[1];
//   pipe3.port_a.m_flow = pipe3.flowModel.m_flows[1];
//   0.0 = pipe3.port_a.m_flow + pipe3.port_b.m_flow;
//   pipe3.port_b.h_outflow = $OMC$inStreamDiv(($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) * pipe1.port_a.h_outflow + $OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07) * pipe2.port_a.h_outflow) / ($OMC$PositiveMax(-pipe1.port_a.m_flow, 1e-07) + $OMC$PositiveMax(-pipe2.port_a.m_flow, 1e-07)), pipe1.port_a.h_outflow) - system.g * pipe3.height_ab;
//   pipe3.port_a.h_outflow = tank3.ports[1].h_outflow + system.g * pipe3.height_ab;
//   assert(pipe3.length >= pipe3.height_ab, \"Parameter length must be greater or equal height_ab.\");
//   tank1.ports[1].m_flow + pipe1.port_b.m_flow = 0.0;
//   tank1.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   tank1.portsData_diameter[1] = tank1.portsData_diameter_internal[1];
//   tank1.portsData_height[1] = tank1.portsData_height_internal[1];
//   tank1.portsData_zeta_in[1] = tank1.portsData_zeta_in_internal[1];
//   tank1.portsData_zeta_out[1] = tank1.portsData_zeta_out_internal[1];
//   tank2.ports[1].m_flow + pipe2.port_b.m_flow = 0.0;
//   tank2.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   tank2.portsData_diameter[1] = tank2.portsData_diameter_internal[1];
//   tank2.portsData_height[1] = tank2.portsData_height_internal[1];
//   tank2.portsData_zeta_in[1] = tank2.portsData_zeta_in_internal[1];
//   tank2.portsData_zeta_out[1] = tank2.portsData_zeta_out_internal[1];
//   tank3.ports[1].m_flow + pipe3.port_b.m_flow = 0.0;
//   tank3.heatTransfer.heatPorts[1].Q_flow = 0.0;
//   tank3.portsData_diameter[1] = tank3.portsData_diameter_internal[1];
//   tank3.portsData_height[1] = tank3.portsData_height_internal[1];
//   tank3.portsData_zeta_in[1] = tank3.portsData_zeta_in_internal[1];
//   tank3.portsData_zeta_out[1] = tank3.portsData_zeta_out_internal[1];
//   pipe1.port_a.m_flow + pipe2.port_a.m_flow + pipe3.port_a.m_flow = 0.0;
//   pipe1.port_a.p = pipe2.port_a.p;
//   pipe1.port_a.p = pipe3.port_a.p;
//   pipe3.port_b.p = tank3.ports[1].p;
//   pipe1.port_b.p = tank1.ports[1].p;
//   pipe2.port_b.p = tank2.ports[1].p;
// end Modelica.Fluid.Examples.Tanks.ThreeTanks;
// "
// ""
// endResult
