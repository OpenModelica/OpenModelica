(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright  
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:        Main.rml
 ** module:      Main
 ** description: Modelica main program
 **
 ** RCS: $Id$
 **
 ** This is the main program in the Modelica specification. 
 ** It either tranlates a file given as a command line argument
 ** or starts a server loop communicating through CORBA or sockets
 ** (The Win32 implementation only implements CORBA)
 **)
module Main:
	relation main: string list => ()
end

with "Absyn.rml"
with "Parser.rml"
with "Dump.rml"
with "DumpGraphviz.rml"
with "SCode.rml"
with "DAE.rml"
with "DAELow.rml"
with "Inst.rml"
with "Interactive.rml"
with "RTOpts.rml"
with "Debug.rml"
with "Socket.rml"
with "Print.rml"
with "Corba.rml"
with "System.rml"
with "Util.rml"
with "TaskGraph.rml"
with "TaskGraphExt.rml" 
with "SimCodegen.rml"
with "ErrorExt.rml"
with "Error.rml"
(* adrpo -- not used
with "ModUtil.rml"
with "Codegen.rml"
*)

(** relation: server_loop
 **
 ** This relation is the main loop of the server listening to a port
 ** which recieves modelica expressions,  
 **)
relation server_loop: (int,Interactive.InteractiveSymbolTable)  => Interactive.InteractiveSymbolTable =

  rule	Socket.handlerequest shandle => str &
	Debug.fprint ("interactivedump" ,"------- Recieved Data from client -----\n") &
	Debug.fprint ("interactivedump" , str ) &
	Debug.fprint ("interactivedump", "------- End recieved Data-----\n") &
	Print.clear_buf & 
	(*Print.clear_error_buf &*)
   	handle_command (str,isymb)  => (true,replystr,newsymb) &
	Socket.sendreply(shandle,replystr) &
	server_loop (shandle,newsymb) => ressymb
	-----------------------------
	server_loop (shandle,isymb) => ressymb

  rule  (* 2004-11-27 - adrpo added this part to make the loop deterministic *)
	Socket.handlerequest shandle => str &
	Debug.fprint ("interactivedump" ,"------- Recieved Data from client -----\n") &
	Debug.fprint ("interactivedump" , str ) &
	Debug.fprint ("interactivedump", "------- End recieved Data-----\n") &
	(*Print.clear_error_buf &*)
	Print.clear_buf & 
	handle_command (str,isymb)  => (false,replystr,newsymb) &
	(* 2004-11-27 - adrpo added part ends here *)
	Print.print_buf "Exiting\n" &
	Socket.sendreply(shandle, "quit requested, shutting server down\n") &
 	Socket.close shandle &
	Socket.cleanup 
	---------------------
	server_loop (shandle,isymb) => isymb
end

relation check_classdef: string => bool =

  rule	Util.strncmp(" ",str,1) => true & 
	string_list(str) => clst &
	list_delete(clst,0) => clst' &
	list_string(clst') => str' &
	check_classdef(str')=> res
	--------------------------
	check_classdef(str) => res
	(* Need to check for a whitespace after as well to get the keyword,
	e.g typeOf function would be taken as a type definition otherwise *)
  rule	Util.strncmp ("end ",str,4) => false &
	Util.strncmp ("type ",str,5) => false &
	Util.strncmp ("class ",str,6) => false &
	Util.strncmp ("model ",str,6) => false &
	Util.strncmp ("block ",str,6) => false &
	Util.strncmp ("within ",str,7) => false &
	Util.strncmp ("record ",str,7) => false &
 	Util.strncmp ("package ",str,8) => false &
	Util.strncmp ("partial ",str,8) => false &
	Util.strncmp ("function ",str,9) => false &
	Util.strncmp ("connector ",str,10) => false &
	Util.strncmp ("encapsulated ",str,12) => false 
	-------------------------------
	check_classdef str => false

  axiom	check_classdef _ => true
end


relation make_debug_result : (string, string) => string =

  rule	Print.get_string () => debugstr &
	Util.string_append_list ([res, 
				  "\n---DEBUG(",flagstr,")---\n", 
				  debugstr,
				  "\n---/DEBUG(",flagstr,")---\n"]) => res_with_debug &
	RTOpts.debug_flag (flagstr) => dumpflag &
	Util.if (dumpflag, res_with_debug, res) => res'
	-----------------------------------------------------
	make_debug_result (flagstr, res) => res'
end

(** relation handle_command
 **
 ** This relation handles the commands in form of strings send to the server
 ** If the command is quit, the relation returns false, otherwise it sends 
 ** the string to the parse relation and returns true.
 **)
relation handle_command: (string,Interactive.InteractiveSymbolTable)  => 
	(bool, string, Interactive.InteractiveSymbolTable) =

  rule	Util.strncmp("quit()",str,6) => true 
	-------------------------------
	handle_command (str, isymb) => (false,"Ok\n",isymb)
	
	(* Add a class or function to the interactive symbol table.
	   If it is a function, type check it. *)
  rule	Debug.fcall0 ("dump", Print.clear_buf) &
	Debug.fcall0 ("dumpgraphviz", Print.clear_buf) &
	Debug.fprint ("dump","\nTrying to parse class definition...\n") &
	Parser.parsestring(str) => (p,msg) & (* Always succeeds, check msg for errors *)
	msg = "Ok" &  (* fails here if the string is not "Ok" *)
	Interactive.type_check_function(p, isymb) &  
	Interactive.add_scope(p,vars) => p' &
	Interactive.update_scope(p,vars) => vars' &
	Interactive.update_program (p',iprog) => newprog &
	Interactive.remove_compiled_functions(p,cf) => cf' &
 	Debug.fprint ("dump", "\n--------------- Parsed program ---------------\n") &
	Debug.fcall ("dumpgraphviz", DumpGraphviz.dump, newprog) &
	Debug.fcall ("dump", Dump.dump, newprog) &
	make_debug_result("dump", "Ok") => res' &
	make_debug_result("dumpgraphviz", res') => res
	----------------------------------------------
	handle_command (str, isymb as Interactive.SYMBOLTABLE(iprog,a,b,vars,cf)) => 
	(true, res, Interactive.SYMBOLTABLE(newprog,a,b,vars',cf'))
	
	(* Interactively evaluate an algorithm statement or expression *)
  rule	Debug.fcall0 ("dump", Print.clear_buf) &
	Debug.fcall0 ("dumpgraphviz", Print.clear_buf) &
	Debug.fprint ("dump","\nNot a class definition, trying expresion parser\n") &
	Parser.parsestringexp str => (exp,msg) & (* always succeeds, check msg for errors *)
	msg = "Ok" &
	Interactive.evaluate(exp,isymb,false) => (evalstr,newisymb) &
	Debug.fprint ("dump", "\n--------------- Parsed expression ---------------\n") &
	Debug.fcall ("dump", Dump.dump_istmt, exp) &
	make_debug_result("dump", evalstr) => res' &
	make_debug_result("dumpgraphviz", res') => res
	--------------------------------------------------
	handle_command (str, isymb) => (true, res, newisymb)

  rule	Debug.fcall0 ("failtrace", Print.clear_buf) &
	Parser.parsestring str => (p,msg) &
	Parser.parsestringexp str => (p,expmsg) &
	not msg = "Ok" &
	not expmsg = "Ok" &
	Debug.fprint ("failtrace", "\nBoth parser and expression parser failed: \n") &
	Debug.fprintl ("failtrace", ["parser: \n", msg, "\n"]) &
	Debug.fprintl ("failtrace", ["expparser: \n", expmsg, "\n"]) &
	make_debug_result("failtrace", msg) => res
	-----------------------------------------------------
	handle_command (str,isymb) => (true, res, isymb)


  rule  Print.print_buf "Error occured building AST\n" &
	Print.get_string () => debugstr &
	string_append (debugstr,"Syntax Error\n") => str
	----------------------------------
	handle_command (_,isymb) => (true,str,isymb)
end

(** relation: is_modelica_file
 **
 ** Succeeds if filename ends with .mo or .mof
 **)
relation is_modelica_file: string => () =

  rule	System.strtok(filename,".") => lst &
	list_reverse(lst) => last::_ &
	last = "mo"
	------------
	is_modelica_file(filename)

  rule	System.strtok(filename,".") => lst &
	list_reverse(lst) => last::_ &
	last = "mof"
	------------
	is_modelica_file(filename)

end

(** relation: is_flat_modelica_file
 **
 ** Succeeds if filename ends with .mof
 **)
relation is_flat_modelica_file: string => () =

  rule	System.strtok(filename,".") => lst &
	list_reverse(lst) => last::_ &
	last = "mof"
	------------
	is_flat_modelica_file(filename)
end

(** relation: is_modelica_script_file
 **
 ** Succeeds if filname end with .mos
 **)
relation is_modelica_script_file: string => () =

  rule	System.strtok(filename,".") => lst &
	list_reverse(lst) => last::_ &
	last = "mos"
	------------
	is_modelica_script_file(filename)
end

(** relation: transform_if_flat
 ** Checks is a modelica file is a flat modelica file
 ** and if so, translates all variables on the form a.b.c to a_b_c
 **)
relation transform_if_flat: (string, DAE.DAElist) => DAE.DAElist =

  rule	is_flat_modelica_file(f) &
	DAE.to_modelica_form(dae) => d 
	---------------------
	transform_if_flat(f,dae) => d

  axiom	transform_if_flat(_,d) => d

end

(** relation: translate_file
 **
 ** This relation invokes the translator on a source file.  The
 ** argument should be a list with a single file name.
 **)
relation translate_file : string list => () =

	(* A Modelica file .mo *)
  rule	is_modelica_file(f) 
	& Parser.parse f => p
	& Debug.fprint ("dump", "\n--------------- Parsed program ---------------\n")
	& Debug.fcall ("dumpgraphviz", DumpGraphviz.dump, p)
	& Debug.fcall ("dump", Dump.dump, p)
	
	& Debug.fprint ("info", "\n------------------------------------------------------------ \n")
	& Debug.fprint ("info", "---elaborating\n")
	& SCode.elaborate(p) => p'

	& Debug.fprint ("info", "\n------------------------------------------------------------ \n")
	& Debug.fprint ("info", "---instantiating\n")
	& Inst.instantiate(p') => d'' 
         & DAE.transform_if_eq_to_expr(d'') => d'
	& Debug.fprint ("beforefixmodout", "Explicit part:\n")
	& Debug.fcall ("beforefixmodout", DAE.dump_debug, d')
(*	& Inst.instantiate_implicit(pfunc') => dimpl'
	& Debug.fprint ("beforefixmodout", "Implicit part:\n")
	& Debug.fcall ("beforefixmodout", DAE.dump_debug, dimpl')
*)	& fix_modelica_output (d') => d
(*	& fix_modelica_output (dimpl') => dimpl
*)
	& Print.clear_buf()
	& Debug.fprint ("info", "---dumping\n")
	& Debug.fcallret ("flatmodelica", DAE.dump_str, d, "") => s
	& Debug.fcall ("flatmodelica", Print.print_buf, s)
(*
	& Debug.fprint ("flatmodelica", "Implicit:\n")
	& Debug.fcall ("flatmodelica", DAE.dump, dimpl)
*)
	& Debug.fcallret ("none", DAE.dump_str, d, "") => s
	& Debug.fcall ("none", Print.print_buf, s)
	& Debug.fcall ("daedump", DAE.dump, d)
	& Debug.fcall ("daedump2", DAE.dump2, d)
	& Debug.fcall ("daedumpdebug", DAE.dump_debug, d)
	& Debug.fcall ("daedumpgraphv", DAE.dump_graphviz, d)
	& Absyn.last_classname(p) => cname

	& Print.get_string () => str
	& RTOpts.silent() => silent 
	& bool_not(silent) => notsilent
	& Debug.bcall(notsilent,print, str)
	& optimize_dae(p',d, d, cname)
	------------------------------
	translate_file [f]

	(* Modelica script file .mos *)
  rule	is_modelica_script_file(f) &
 	Parser.parseexp f => stmts &
	Interactive.evaluate(stmts,Interactive.empty_symboltable,true) => (res,newst) &
	print res
	------------------------------
	translate_file [f]

  rule	ErrorExt.print_messages_str() => str &
	print str 
	---------------------
	translate_file [f] => fail
	
  rule	Print.print_error_buf "# Too many arguments\n"
	----------------------------
	translate_file _::_::_ => fail

  rule	Print.print_buf "Usage: omc <options> filename \n" &
	Print.print_buf "omc accepts .mo (Modelica files) \n" &
	Print.print_buf "            .mof (Flat Modelica files) \n" &
	Print.print_buf "            .mos (Modelica Script files) \n" &
 	Print.print_buf "Options:\n========" &
	Print.print_buf "+s    Generate simulation code\n" &
	Print.print_buf "+q    Run in quiet mode, ouput nothing\n" &
	Print.print_buf "+d=flags, set flags: \n" &
	Print.print_buf "    blt               apply blt transformation\n" &
	Print.print_buf "    interactive       run in interactive mode\n" &
	Print.print_buf "    interactiveCorba  run in interactive mode using Corba\n" &
	Print.print_buf "    ..., see DEBUG.TXT for further flags\n" 
 	----------------------------
 	translate_file [] => fail
end

(** relation: runt_backend_q
 **
 ** Determine if backend, i.e. BLT etc. should be run.
 ** It should be run if either "blt" flag is set or if 
 ** parallelization is enabled by giving flag -n=<no proc.>
 **)
relation run_backend_q: () => bool =

  rule	RTOpts.debug_flag "blt" => bltflag &
	RTOpts.simulation_cg => sim_cg &
	RTOpts.no_proc() => n &
	int_gt (n,0) => par &
	bool_or (bltflag,par) => res &
	bool_or(res,sim_cg) => res'
	----------------------------
	run_backend_q() => res' 
end

(** relation: optimize_dae
 ** 
 ** Run the backend. Used for both parallization and for normal execution.
 **)
relation optimize_dae: (SCode.Program, DAE.DAElist, DAE.DAElist, Absyn.Path) => () =

  rule	run_backend_q() => true
	& DAELow.lower(dae,true(* add dummy state*)) => dlow 
	& Debug.fcall("dumpdaelow", DAELow.dump, dlow) 
	& DAELow.incidence_matrix(dlow) => m 
	& DAELow.transpose_matrix(m) => mT 
	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix_t, mT) 
	& DAELow.matching_algorithm(dlow,m,mT,(DAELow.INDEX_REDUCTION,DAELow.EXACT,DAELow.REMOVE_SIMPLE_EQN)) 
	  => (v1,v2,dlow',m,mT) 
	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
	& Debug.fcall("bltdump", DAELow.dump_incidence_matrix_t, mT) 
	& Debug.fcall("bltdump", DAELow.dump,dlow')
	& Debug.fcall("bltdump", DAELow.dump_matching, v1)
	& DAELow.strong_components(m,mT,v1,v2) => (comps) 
	& Debug.fcall("bltdump",DAELow.dump_components,comps) 
	& modpar(dlow',v1,v2,comps) 
	& simcodegen(classname,p,daeimpl,dlow',v1,v2,m,mT,comps)

	-----------------------
	optimize_dae(p,dae,daeimpl,classname) => ()

  rule	(* so main can print error messages *)
	run_backend_q() => true
	------------------------
	optimize_dae(_,_,_,_) => fail

	(* If not running backend. *)
  rule	run_backend_q() => false
	---------------------
	optimize_dae(_,_,_,_) => ()
end

(** relation: modpar
 **
 ** The automatic paralellzation module.
 **)
relation modpar: (DAELow.DAELow, int vector, int vector, int list list) => () =

  rule	(* If modpar not enabled, nproc = 0, return *) 
	RTOpts.no_proc() => n &
	int_eq(n,0) => true
	----------------
	modpar(_,_,_,_) => ()

  rule	(* Otherwise, build task graph *)
	(*print "old dae:" & DAELow.dump dae &*)
	print "translating dae.\n" &
	DAELow.translate_dae (dae) => indexed_dae &
	DAELow.calculate_values(indexed_dae) => indexed_dae' &
(*	print "new dae:" & DAELow.dump indexed_dae' &*)
	print "building task graph\n" &
	TaskGraph.build_taskgraph(indexed_dae',ass1,ass2,comps) &
	TaskGraphExt.dump_graph("model.viz") &
	RTOpts.latency  => l &
	RTOpts.bandwidth => b &
	clock() => t1 &
	TaskGraphExt.merge_tasks(l,b) &
	clock() => t2 &
	real_sub(t2,t1) => time &
	real_string(time) => timestr &
	print "task merging took " & print timestr & print " seconds\n" &
	TaskGraphExt.dump_merged_graph("merged_model.viz") &
	RTOpts.no_proc => n &
	TaskGraphExt.schedule(n) &
	DAELow.calculate_sizes(indexed_dae') => (nx,ny,np,_)  &
	int_string np => nps &
	print "=======\nnp =" & print nps & print "=======\n" &
	TaskGraphExt.generate_code(nx,ny,np) &
	print "done\n" 
	-----------------
	modpar(dae,ass1,ass2,comps)

  rule	Debug.fprint("failtrace", "-modpar failed\n") 
	---------------
	modpar(_,_,_,_) => fail
	
end

(** relation simcodegen
 **
 ** Genereates simulation code using the SimCodegen module
 **)
relation simcodegen: (Absyn.Path, (* classname *)
		      SCode.Program,
		      DAE.DAElist, 
		      DAELow.DAELow, 
		      int vector, (* ass1 *)
		      int vector, (* ass2 *)
		      DAELow.IncidenceMatrix,
		      DAELow.IncidenceMatrixT,
		      int list list) (* blocks *)
	  => () =

  rule	RTOpts.simulation_cg() => true &
	Print.clear_error_buf() &
	Print.clear_buf() &
	DAELow.translate_dae (dlow) => indexed_dlow &
	DAELow.calculate_values(indexed_dlow) => indexed_dlow' &
	Absyn.path_string(classname) => cname_str &
	Util.string_append_list([cname_str,".cpp"]) => filename &
	Util.string_append_list([cname_str,"_functions.cpp"]) => funcfilename &
	Util.string_append_list([cname_str,"_init.txt"]) => init_filename &
	Util.string_append_list([cname_str,".makefile"]) => makefilename &
	SimCodegen.generate_functions(p,dae,indexed_dlow',classname,funcfilename) => libs &
	SimCodegen.generate_simulation_code(dae,indexed_dlow',ass1,ass2,m,mt,comps,classname,filename,funcfilename) &
	SimCodegen.generate_init_data(indexed_dlow',classname,init_filename,0.0,1.0,500.0) &
	SimCodegen.generate_makefile(makefilename,cname_str,libs)
	----------------------------------------------------------------------------------
	simcodegen(classname,p,dae,dlow,ass1,ass2,m,mt,comps)

	(* If something above failed. fail so Main can print errors *)
  rule	RTOpts.simulation_cg() => true 
	-----------------
	simcodegen(_,_,_,_,_,_,_,_,_) => fail

	(* If not generating simulation code*)
  rule	RTOpts.simulation_cg() => false
	-----------------
	simcodegen(_,_,_,_,_,_,_,_,_) => ()

end

(** relation: run_modpar_q
 **
 ** Returns true if parallelization should be run.
 **)
relation run_modpar_q: () => bool =
	
  rule	RTOpts.no_proc() => n &
	int_gt(n,0) => res
	------------------
	run_modpar_q() => res
end

(** relation: fix_modelica_output
 **
 ** Transform the dae, replacing dots with underscore in variables and 
 ** equations.
 **)
relation fix_modelica_output : DAE.DAElist => DAE.DAElist =

  rule	RTOpts.modelica_output => true &
	Inst.init_vars_modelica_output dae => dae'
	-------------------------------
	fix_modelica_output DAE.DAE(dae) => DAE.DAE(dae')

  rule	RTOpts.modelica_output => false
	-------------------------------
	fix_modelica_output (d as DAE.DAE(dae)) => d

end

(** relation: interactivemode
 **
 ** Initiate the interactive mode using socket communication.
 **)
relation interactivemode: string list => () =

  rule	Socket.waitforconnect 29500  => shandle &
	server_loop (shandle, Interactive.empty_symboltable) => _
	-------------------
	interactivemode _
end

(** relation: interactivemode_corba
 **
 ** Initiate the interactive mode using corba communication.
 **)
relation interactivemode_corba: string list => () =

  rule	Corba.initialize &
	server_loop_corba (Interactive.empty_symboltable) => _
	-------------------
	interactivemode_corba _
end

(** relation: server_loop_corba
 **
 ** This relation is the main loop of the server for a CORBA impl.
 **)
relation server_loop_corba: (Interactive.InteractiveSymbolTable)  => 
	Interactive.InteractiveSymbolTable =

  rule	Corba.wait_for_command() => str &
	Print.clear_buf & 
	handle_command (str,isymb)  => (true,replystr,newsymb) &
	Corba.sendreply(replystr) &
	server_loop_corba (newsymb) => ressymb
	-----------------------------
	server_loop_corba (isymb) => ressymb

  rule (* start - 2005-06-12 - adrpo added this part to make the loop deterministic *)
		Corba.wait_for_command() => str &
		Print.clear_buf & 
		handle_command (str,isymb)  => (false,replystr,newsymb) &
		(* end - 2005-06-12 - *)
	Print.print_buf "Exiting\n" &
	Corba.sendreply("quit requested, shutting server down\n") &
 	Corba.close
	---------------------
	server_loop_corba (isymb) => isymb
end

(** relation: main
 **
 ** This is the main relation that the RML runtime system calls to
 ** start the translation.
 **)
relation main : string list => () =

  rule	RTOpts.args args => args' &
	RTOpts.debug_flag("interactive") => ismode &
	RTOpts.debug_flag("interactiveCorba") => icmode &
	bool_or(ismode,icmode) => imode &
	bool_not(imode) => imode' &
	Debug.bcall (ismode, interactivemode, args' ) &
	Debug.bcall (icmode, interactivemode_corba, args') &
	Debug.bcall (imode', translate_file, args') &
	Print.get_error_string => s &
	Debug.fcall("failtrace",print,s) 
	---------------------------------------
	main args 

  rule	(* If main fails, retrieve error messages and print to std out. *)
	Print.get_error_string => str &
	print str 
	--------------
	main _ => fail
end

