(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(* $Id$ *)

(**
 ** This module contain functionality for model management, expression evaluation, etc. 
 ** in the interactive environment.
 ** The module defines a symboltable used in the interactive environment containing:
 ** - Modelica models (described using Absyn AST)
 ** - Variable bindings
 ** - Compiled functions (so they do not need to be recompiled)
 ** - Instantiated classes (that can be reused, not impl. yet)
 ** - Modelica models in SCode form (to speed up instantiation. not impl. yet)
 **)

module Interactive:
  with "Absyn.rml"
  with "SCode.rml" 
  with "DAE.rml" 							  
  with "Types.rml"
  with "Values.rml"
  with "Env.rml"

(** An Statement given in the interactive environment can either be 
 ** an Algorithm statement or an expression.
 **)

  datatype InteractiveStmt = IALG of Absyn.AlgorithmItem
			   | IEXP of Absyn.Exp
(** Several interactive statements is used in Modelicasc scripts.**)
  datatype InteractiveStmts = ISTMTS of InteractiveStmt list * 
					bool (* true if output result == no semicolon*)
							  
  datatype InstantiatedClass =  INSTCLASS of Absyn.Path * (* The F.Q.name of the inst:ed class*)
					     DAE.Element list (* The list of DAE elements *)
						* Env.Env  (* The env of the inst:ed class*)

  datatype InteractiveVariable = IVAR of Absyn.Ident * (* The variable identifier *)
					 Values.Value *  (* The value *)
					 Types.Type  (* The type of the expression *)

  datatype InteractiveSymbolTable = SYMBOLTABLE of Absyn.Program * (*The ast*)
						   SCode.Program * (* The exploded ast *)
						   InstantiatedClass list * (* List of instantiated classes*)
						   InteractiveVariable list * (*List of variables with values*)  
  						   (Absyn.Path * Types.Type) list (* List of compiled functions, F.Q name + type*)

  relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	  => (string,InteractiveSymbolTable) 
            (* this is exported due to the need of using several interactive modules *)
  relation evaluate2:  (InteractiveStmts, InteractiveSymbolTable) => (string,InteractiveSymbolTable)

  relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program
  relation update_scope: (Absyn.Program, InteractiveVariable list) => InteractiveVariable list
  relation add_component: (string,Absyn.ComponentRef,Absyn.ComponentRef,Absyn.NamedArg list, Absyn.Program) => (Absyn.Program,string)
  relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int
  relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	    => (Absyn.Path * Types.Type) list
  relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env 
  relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) => Absyn.Class 

  relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) => Types.Type 
  relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) => InstantiatedClass list 
  relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) => InstantiatedClass 

  relation get_contained_class_and_file: (Absyn.Path, Absyn.Program) => (Absyn.Program, string)
  

  relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	  => InteractiveSymbolTable
  relation add_scope: (Absyn.Program, InteractiveVariable list) => Absyn.Program 
  relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool  


  relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list 
  relation get_components_in_class: (Absyn.Class) => Absyn.Element list 
  relation get_classnames_in_elts: (Absyn.ElementItem list) => string list
  relation get_components: (Absyn.ComponentRef,Absyn.Program) => string 
  relation is_primitive_class: (Absyn.Class,Absyn.Program) => bool 
  relation get_componentitems_name: Absyn.ComponentItem list => string list 

          (* this is added for optimization of modeleditor*)
           
  relation get_top_classnames: (Absyn.Program) => string
  relation get_component_modification: Absyn.Element => string 

  relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class 

 relation traverse_classes: (Absyn.Program, 
                            Absyn.Path option,
			     ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),  (* rel-ation to apply*)
			     'a, (* extra value passed to re-lation*)
			     bool) (* true = traverse protected elements*)
	  => (Absyn.Program *  Absyn.Path option * 'a) 


  relation is_package: (Absyn.ComponentRef, Absyn.Program) => bool

  relation get_top_classnames_in_program: Absyn.Program => string list
        
  relation build_within: Absyn.Path => Absyn.Within

end


with "Dump.rml"
with "Debug.rml"
with "RTOpts.rml"
with "Util.rml"
with "Parser.rml"
with "Prefix.rml"
with "Mod.rml"
with "Lookup.rml"
with "ClassInf.rml"
with "Exp.rml"
with "Inst.rml"
with "Static.rml"							  
with "ModUtil.rml"
with "Codegen.rml"
with "Print.rml"
with "System.rml"
with "ClassLoader.rml"
with "Ceval.rml"
 
 (** relation: evaluate
  **
  ** This relation evaluates expressions feeded interactively to the compiler.
 **)

 relation evaluate: (InteractiveStmts, InteractiveSymbolTable, bool) 
	   => (string,InteractiveSymbolTable) =

   rule	evaluate2(ISTMTS([x],true),st) => (res,newst)
	 ----------------------------
	 evaluate (ISTMTS([x],true),st,false) => ("",newst)

   rule	(* Verbose, semicolon off *)
	 evaluate2(ISTMTS([x],false),st) => (res,newst)
	 ----------------------------
	 evaluate (ISTMTS([x],true),st,true) => (res,newst)

   rule	evaluate2(ISTMTS([x],false),st) => (res,newst)
	 ----------------------------
	 evaluate (ISTMTS([x],false),st,verbose) => (res,newst)

   rule	evaluate2(ISTMTS([x],sc),st) => (res,newst) &
	 evaluate(ISTMTS(xs,sc),newst,false) => (res,newst') 
	 ------------------------------------------
	 evaluate (ISTMTS(x::xs,sc),st,false) => (res,newst')

   rule	evaluate2(ISTMTS([x],sc),st) => (res,newst) &
	 evaluate(ISTMTS(xs,sc),newst,true) => (res2,newst') &
	 Util.string_append_list([res,res2]) => res'
	 ------------------------------------------
	 evaluate (ISTMTS(x::xs,sc),st,true) => (res',newst')
 end

(** relation: evaluate2
 **
 ** Helper relation to evaluate.
 **)

 relation evaluate2:  (InteractiveStmts, InteractiveSymbolTable) 
	  => (string,InteractiveSymbolTable) =

   rule	get_variable_names(vars) => vars &
	 string_append(vars,"\n") => str
	 --------------------------
	 evaluate2(ISTMTS([IEXP(Absyn.CALL(Absyn.CREF_IDENT("listVariables",_),Absyn.FUNCTIONARGS([],[])))],_),st as SYMBOLTABLE(_,_,_,vars,_))
	   => (str,st)

   rule	evaluate_graphical_api(stmts,st) => (str,newst) &
	 string_append(str,"\n") => str'
	 ----------------------------------------------------
	 evaluate2(stmts as ISTMTS([IEXP(Absyn.CALL(_,_))],_),st) => (str',newst)

   rule	evaluate_expr(exp,st) => (s1,newst) &
	 string_append(s1,"\n") => str
	 ------------------------------------------------------
	 evaluate2(stmts as ISTMTS([exp],_),st) => (str,newst)

   axiom	evaluate2(_,st) => ("Not implemented yet\n",st)
 end


 (** relation: evaluate_expr
  **
  ** This relation takes an 'InteractiveStmt´ and a symboltable and 
  ** evaluates the expression using Staticexp.
  **)

 relation evaluate_expr: (InteractiveStmt, InteractiveSymbolTable) =>
	 (string,InteractiveSymbolTable) =

   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	 Ceval.ceval (env,sexp,true,SOME(st'),NONE,Ceval.MSG) 
	  => (value,SOME(st'')) &
	 Values.val_string value =>  str
	 -------------------------------
	 evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => (str,st'')

   rule	build_env_from_symboltable(st) => env &	
	 not Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) 
	 -------------------------------
	 evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => fail

   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,exp,true,SOME(st)) => (sexp,prop,SOME(st')) &
	 not Ceval.ceval (env,sexp,true,SOME(st'),NONE,Ceval.NO_MSG) => (_,_) 
	 -------------------------------
	 evaluate_expr(IEXP(exp),st as SYMBOLTABLE(p,_,_,_,_)) => fail

   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,cond,true,SOME(st)) 
	   => (econd,prop,SOME(st')) &
	 Ceval.ceval (env,econd,true,SOME(st'),NONE,Ceval.MSG) 
	   => (Values.BOOL(true),SOME(st'')) 
	 -----------------------------------------------
	 evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_)),st as SYMBOLTABLE(p,_,_,_,_))
	     => ("", st'')

   rule	build_env_from_symboltable(st) => env &	
	 Static.elab_exp(env,msg,true,SOME(st)) 
	   => (msg',prop,SOME(st')) &
	 Ceval.ceval (env,msg',true,SOME(st'),NONE,Ceval.MSG) 
	   => (Values.STRING(str),SOME(st'')) 
	 -----------------------------------------------
	 evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),Absyn.FUNCTIONARGS([cond,msg],_)),_)),st as SYMBOLTABLE(p,_,_,_,_))
	     => (str, st'')

   rule	build_env_from_symboltable(st) => env &
	 Static.elab_exp(env,exp,true,SOME(st)) => (sexp,Types.PROP(t,_),SOME(st'))  &
	 Ceval.ceval(env,sexp,true,SOME(st'),NONE,Ceval.MSG) 
	  => (value,SOME(st'')) &
	 Values.val_string value =>  str &
	 add_var_to_symboltable(ident,value,t,st'') => newst	
	 -----------------------------------------------
	 evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(Absyn.CREF_IDENT(ident,[]),exp),_)),st as SYMBOLTABLE(p,_,_,_,_)) 
	     => (str, newst)

	(* Since expressions cannot be tuples an empty string is returned *)
   rule	build_env_from_symboltable(st) => env &
	 Static.elab_exp(env,rexp,true,SOME(st)) => (srexp,rprop,SOME(st'))	&
	 Types.get_prop_type rprop => ((Types.T_TUPLE(types),_)) &
	 Util.list_map(crefexps, get_ident_from_crefexp) => idents &
	 Ceval.ceval(env,srexp,true,SOME(st'),NONE,Ceval.MSG) 
	  => (Values.TUPLE(values), SOME(st'')) &
	 add_vars_to_symboltable(idents,values,types,st'') => newst
	 -----------------------------------------------
	 evaluate_expr(IALG(Absyn.ALGORITHMITEM(Absyn.ALG_TUPLE_ASSIGN(Absyn.TUPLE(crefexps),rexp),_)),st as SYMBOLTABLE(p,_,_,_,_)) 
	     => ("", newst)

   rule	Print.get_error_string() => s1 & Print.clear_error_buf() & string_append("Error evaluating expr.\n",s1) => str &
	 Debug.fprint ("failtrace", "#-- evaluate_expr failed:") &
	 Debug.fcall ("failtrace", Dump.dump_istmt, ISTMTS([stmt], true)) &
	 Debug.fprintln ("failtrace", "\n")
	 -----------------------------
	 evaluate_expr(stmt,st) => (str,st)
 end

(** relation: get_ident_from_crefexp
 **
 ** Return the (first) identifier of a Component Reference in an expression.
 **)

 relation get_ident_from_crefexp : Absyn.Exp => Absyn.Ident =

   axiom	get_ident_from_crefexp Absyn.CREF(Absyn.CREF_IDENT(id, _)) => id

   rule	Print.print_error_buf "# Not a component reference in tuple assignment:\n# " &
	 Dump.print_exp_str exp => str &
	 Print.print_error_buf str &
	 Print.print_error_buf "\n"
	 --------------------
	 get_ident_from_crefexp exp => fail
 end

(** relation: get_variable_names
 **
 ** Return a string containing a comma separated list of variables.
**)

 relation get_variable_names: (InteractiveVariable list) => string =

   rule	get_variable_list_str(vars) => strlst &
	 Util.string_delimit_list(strlst,", ") => str &
	 Util.string_append_list(["{",str,"}"]) => res
	 ---------------------------------------------
	 get_variable_names(vars) => res
 end

(** relation: get_variable_list_str
 **
 ** Helper relation to get_variable_names
 **)

 relation get_variable_list_str: (InteractiveVariable list) => string list =

   axiom	get_variable_list_str([]) => []

   rule	get_variable_list_str(vs)=> res 
	 ----------------------------
	 get_variable_list_str(IVAR(p,_,_)::vs) => p::res
 end

(** relation: get_type_of_variables
**
 ** Return the type of an interactive variable, given a list of variables 
 ** and a variable identifier.
 **)

 relation get_type_of_variable: (Absyn.Ident, InteractiveVariable list) 
	  => Types.Type =
   axiom get_type_of_variable(id,[]) => fail

   rule	varid = id
	 ----------------------------------------------
	 get_type_of_variable (varid,IVAR(id,_,tp)::rest) => tp 

   rule	not varid = id &
	 get_type_of_variable(varid,rest) => tp
	 ----------------------------------------------
	 get_type_of_variable (varid,IVAR(id,_,_)::rest) => tp 
 end

(** relation: add_vars_to_symboltable
 **
 ** Add a list of variables to the interactive symboltable given names, 
 ** values and types.
 **)

 relation add_vars_to_symboltable: (Absyn.Ident list, Values.Value list,
				    Types.Type list, InteractiveSymbolTable) 
	   => InteractiveSymbolTable =

   axiom	add_vars_to_symboltable ([],_,_,st) => st

   rule	add_var_to_symboltable (id, v, t, st) => st' &
	 add_vars_to_symboltable(idrest, vrest, trest, st') => st''
	 -------------------------------------------------------------
	 add_vars_to_symboltable (id::idrest, v::vrest, t::trest, st) => st''
 end


(** relation: add_var_to_symboltable
 **
 ** Helper relation to add_vars_to_symboltable.
 **)

 relation add_var_to_symboltable: (Absyn.Ident, Values.Value, Types.Type,InteractiveSymbolTable) 
	   => InteractiveSymbolTable =

   rule	add_var_to_varlist(ident,v,t,vars) => vars'
	 ----------------------------
	 add_var_to_symboltable(ident,v,t,SYMBOLTABLE(p,sp,id,vars,cf))
	   => SYMBOLTABLE(p,sp,id,vars',cf)
 end

(** relation: add_var_to_varlist
 **
 ** Helper relation to add_var_to_symboltable
 **)

 relation add_var_to_varlist: (Absyn.Ident, Values.Value, Types.Type,
			       InteractiveVariable list) 
	   => InteractiveVariable list =
   rule	ident = id2
	 -----------
	 add_var_to_varlist(ident,v,t,IVAR(id2,_,_)::rest) 
	     => IVAR(ident,v,t)::rest

   rule	not ident = id2 &
	 add_var_to_varlist(ident,v,t,rest) => rest'
	  ------------------------------------
	 add_var_to_varlist(ident,v,t,IVAR(id2,val2,t2)::rest)
	     => IVAR(id2,val2,t2)::rest'

   axiom	add_var_to_varlist(ident,v,t,[]) => [IVAR(ident,v,t)]
 end

 (** relation: build_env_from_symboltable
  ** author: PA
  ** 
  ** Builds an environment from a symboltable by adding all interactive variables
  ** and their bindings to the environment.
  **)

 relation build_env_from_symboltable: (InteractiveSymbolTable) => Env.Env =

   rule	SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 add_vars_to_env(vars,env) => env'
	 ------------------------------------------
	 build_env_from_symboltable(SYMBOLTABLE(p,sp,ic,vars,cf)) => env'
 end

(** relation: add_vars_to_env
 **
 ** Helper relation to build_env_from_symboltable.
 **)

 relation add_vars_to_env: (InteractiveVariable list, Env.Env) => Env.Env =

   rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	 Env.update_frame_v(env,
	     Types.VAR(
		 id,
		 Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		 false,
		 tp,
		 Types.VALBOUND(v)
	     ),false,[]) => env' &
	 add_vars_to_env(rest,env') => env''
	 ---------------------------------------
	 add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

   rule	not Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,_,_) &
	 Env.extend_frame_v(env,
	     Types.VAR(
		 id,
		 Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),
		 false,
		 tp,
		 Types.VALBOUND(v)
	     ),NONE,false,[]) => env' &
	 add_vars_to_env(rest,env') => env''
	 ---------------------------------------
	 add_vars_to_env (IVAR(id,v,tp)::rest,env) => env''

   axiom	 add_vars_to_env([],env) => env

 end

 (** relation: evaluate_graphical_api
  **
  ** This relation evaluates all primitives in the graphical api.
  **)

 relation evaluate_graphical_api: (InteractiveStmts, InteractiveSymbolTable) 
	  =>  (string, InteractiveSymbolTable) = 

   rule	get_source_file(class,p) => resstr
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getSourceFile",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class)],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,st)

   rule	set_source_file(class,filename,p) => (resstr,newp)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setSourceFile",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.STRING(filename)
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))			

   rule	set_extends_modifier_value(class,Absyn.CREF_IDENT(ident,[]),
				    subident,mod,p) 
	   => (newp,resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setExtendsModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod))
				     ],[])))],_
	     ), 
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))			

   rule	get_extends_modifier_names(class,ident,p) => resstr 
	 --------------------------------------------  
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getExtendsModifierNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			

   rule	get_extends_modifier_value(class,Absyn.CREF_IDENT(ident,[]),subident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getExtendsModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			
   rule	get_component_modifier_names(class,ident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)			

   rule	get_component_modifier_value(class,Absyn.CREF_IDENT(ident,[]),subident,p) 
	   => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_parameter_value(class,Absyn.CREF_IDENT(ident,[]),p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(Absyn.CREF_IDENT(ident,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	(* expressions *)
	 set_parameter_value(class,ident,exp,p) => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(ident as Absyn.CREF_IDENT(_,_)),
				     Absyn.CODE(Absyn.C_MODIFICATION(Absyn.CLASSMOD(_,SOME(exp))))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))

   rule	(* special case for clearing modifier *)
	 set_component_modifier(class,ident,Absyn.CREF_IDENT("",[]),mod,p) 
	   => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(ident as Absyn.CREF_IDENT(_,_)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod as Absyn.CLASSMOD([],NONE)))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))


   rule	set_component_modifier(class,Absyn.CREF_IDENT(ident,[]),subident,mod,p) 
	   => (p',resstr)
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setComponentModifierValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),
				     Absyn.CREF(Absyn.CREF_QUAL(ident,_,subident)),
				     Absyn.CODE(Absyn.C_MODIFICATION(mod))
				     ],[])))],_),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))

   rule	get_parameter_value(class,ident,p) => resstr 
	 --------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getParameterValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	set_parameter_value(class,ident,exp,p) => (p',resstr)
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("setParameterValue",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(class),Absyn.CREF(ident),exp],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(p',s,ic,iv,cf))


   rule	get_parameter_names(cr,p) => resstr
	 -----------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getParameterNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule update_program(
       Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),"")],Absyn.TOP),
       p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) 
	 ----------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("createModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	Absyn.cref_to_path(path) => path' &
	 Absyn.path_last_ident(path') => name &
	 Absyn.strip_last(path') => wpath &
	 update_program(
	     Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),"")],Absyn.WITHIN(wpath)),p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf)
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("createModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(path as Absyn.CREF_QUAL(_,_,_))],[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	Absyn.cref_to_path(cr) => path &
	 update_program(
	     Absyn.PROGRAM([Absyn.CLASS(name,false,false,false,Absyn.R_MODEL,Absyn.PARTS([Absyn.PUBLIC([])],NONE),"")],Absyn.WITHIN(path)),
	     p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) &
	 string_append(name,"\n") => resstr
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("newModel",_),
		 Absyn.FUNCTIONARGS( [Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(cr)] , [])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)


   rule  System.regular_file_exist(name) => 0 &
	 Parser.parse(name) => p1 &
	 update_program(p1,p) => newp &
	 get_top_classnames(p1) => top_names_str
	 ---------------------------------------------------
	 evaluate_graphical_api(
	      ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (top_names_str,SYMBOLTABLE(newp,s,ic,iv,cf))



	 (** it the rule above have failed then check if file exists **)
	 (* without this omc crashes *)
   rule  System.regular_file_exist(name) => rest &
	 int_gt(rest,0) => true
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)

	 (*check if the parse went wrong*)

   rule  not Parser.parse(name) => p1
	 ---------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("loadFileInteractive",_),
		 Absyn.FUNCTIONARGS( [Absyn.STRING(name)] ,[])))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("error",st)



	 rule	delete_class(cr,p) => (resstr, newp)
	 ---------------------------------------------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)], [])))],_
		 ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))


   rule	add_component(name,tp,model,nargs,p) => (newp,resstr)
	 & Print.get_string() => str & string_append(resstr,str) => resstr'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	(*delete_component(name,model,p) => (newp,resstr) &
	 add_component(name,tp,model,nargs,newp) => (newp2,resstr)*)
	 update_component(name,tp,model,nargs,p) =>(newp, res)
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("updateComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(tp),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (res, SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_component(name,model,p) => (newp,resstr)
	 & Print.get_string() => str & string_append(resstr,str) => resstr'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(name,_)),Absyn.CREF(model)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	add_class_annotation(cr,nargs,p) => newp &
	 let newst = SYMBOLTABLE(newp,s,ic,iv,cf) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addClassAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => ("true",newst)

   rule	get_component_count(cr,p) => count &
	 int_string count => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponent",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_components(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponents",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_component_annotations(cr,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getComponentAnnotations",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponentAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_component_modification(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthComponentModification",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_inheritance_count(cr,p) => count &
	 int_string count => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getInheritanceCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_inherited_class(cr,n,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthInheritedClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_connection_count(cr,p) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getConnectionCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connection(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	add_connection(cr,c1,c2,nargs,p) => (resstr,newp) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("addConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_connection(cr,c1,c2,p) => (resstr,newp) 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("deleteConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp,s,ic,iv,cf))

   rule	delete_connection(cr,c1,c2,p) => (s1,newp) &
	 add_connection(cr,c1,c2,nargs,newp) => (resstr,newp') 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("updateConnection",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(c1),Absyn.CREF(c2),Absyn.CREF(cr)],nargs)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,SYMBOLTABLE(newp',s,ic,iv,cf))

   rule	get_nth_connection_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnectionAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_connector_count(cr,p) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getConnectorCount",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connector(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnector",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_nth_connector_icon_annotation(cr,p,n) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getNthConnectorIconAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.INTEGER(n)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)


   rule	Absyn.cref_to_path(cr) => path &
	 get_icon_annotation(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getIconAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_diagram_annotation(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getDiagramAnnotation",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_packages_in_path(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getPackages",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_top_packages(p) => s1 &
	 string_append(s1,"\n") => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getPackages",_),
		 Absyn.FUNCTIONARGS([],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	Absyn.cref_to_path(cr) => path &
	 get_classnames_in_path(path,p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNames",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	get_top_classnames(p) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("getClassNames",_),
		 Absyn.FUNCTIONARGS([],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_primitive(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isPrimitive",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_type(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isType",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_connector(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isConnector",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_model(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_record(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isRecord",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_block(cr,p) => b1 &
	 Util.bool_string(b1) => resstr 
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isBlock",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_function(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isFunction",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_package(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isPackage",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_class(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_parameter(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isParameter",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_protected(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isProtected",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	is_constant(cr,class,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("isConstant",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr),Absyn.CREF(class)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 Util.bool_string(b1) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 is_model(cr,p) => b2 &
	 bool_and(b1,b2) => res &
	 Util.bool_string(res) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existModel",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	exist_class(cr,p) => b1 &
	 is_package(cr,p) => b2 &
	 bool_and(b1,b2) => res &
	 Util.bool_string(res) => resstr
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("existPackage",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(cr)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) => (resstr,st)

   rule	(** For now, renaming a class clears all caches... **)
	 (* Substantial analysis required to find out what to keep in cache
	  ** and what must be thrown out *)
	 rename_class(p,old_cname,new_cname) => p'  &
	 SCode.elaborate(p') => s'
	 -----------------------
	 evaluate_graphical_api(
	     ISTMTS([IEXP(Absyn.CALL(
		 Absyn.CREF_IDENT("renameClass",_),
		 Absyn.FUNCTIONARGS([Absyn.CREF(old_cname), Absyn.CREF(new_cname)],_)))],_
	     ),
	     st as SYMBOLTABLE(p,s,ic,iv,cf)) 
	   => ("OK",SYMBOLTABLE(p',s',[],[],[]))

 end

 (** relation: is_parameter_element
  **
  ** Returns true if Element is a component of variability parameter, 
  ** false otherwise.
 **)

 relation is_parameter_element: (Absyn.Element) => bool =

   axiom	is_parameter_element( Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.PARAM,_,_),_,_),_,_,_)) => true

   axiom	is_parameter_element(_) => false
 end

 (** relation: get_parameter_names
  **
  ** Retrieves the names of all parameters in the class 
  **)

 relation get_parameter_names: (Absyn.ComponentRef, (* class *)
				Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_select(comps,is_parameter_element) => comps' &
	 Util.list_map(comps',get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_map(compelts',get_componentitem_name) => names &
	 Util.string_delimit_list(names,", ") => res &
	 Util.string_append_list(["{",res,"}"]) => res'
	 -------------------------------------------
	 get_parameter_names(class,p) => res'

 axiom	get_parameter_names(_,_) => "Error"
 end

 (** relation: get_class_env
  **
  ** Retrieves the environment of the class, including the frame of the class
  ** itself by partially instantiating it.
 **)
 relation get_class_env: (Absyn.Program, Absyn.Path) => Env.Env =


   rule	SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,p_class,false) 
	   => (cl as SCode.CLASS(id,_,encflag,restr,_),env') &
	 Env.open_scope(env',encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,cl,false,[]) 
	   => (env'',_)
	 ---------------------
	 get_class_env(p,p_class) => env''

 end

 (** relation: get_source_file
  ** author: PA
  **
  ** Retrieves the Source file attribute of a Class.
  ** When parsing classes, the source file name is added to the Class 
  ** definition and to all Elements, see Absyn. This relation retrieves the
  ** source file of the Class.
  **)

 relation get_source_file: (Absyn.ComponentRef, (* class *)
			    Absyn.Program) => string =
   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 Absyn.class_filename(cdef) => filename
	 ---------------------------
	 get_source_file(class,p) => filename

 axiom	get_source_file(_,_) => "Error"

 end

 (** relation: set_source_file
  ** author: PA
  **
  ** Sets the source file of a Class. Is for instance used
  ** when adding a new class to an aldready stored package.
  ** The class should then have the same file as the package.
  **)

 relation set_source_file: (Absyn.ComponentRef, (* class *)
			    string, (* filename *)
			    Absyn.Program) 
	   => (string,
	       Absyn.Program) =

   rule	Absyn.cref_to_path(class) => p_class &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 build_within(p_class) => within &
	 Absyn.set_class_filename(cdef,filename) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ----------------------------
	 set_source_file(class,filename,p) => ("Ok",newp)

   axiom	set_source_file(_,_,p) => ("Error" ,p)
 end

 (** relation: set_extends_modifier_value
  **
  ** This relation sets the submodifier value of an extends clause in a Class.
  ** for instance,
  ** model test extends A(p1=3,p2(z=3)); end test;
  ** setExtendsModifierValue(test,A,p1,Code(=4)) => OK
  ** => model test extends A(p1=4,p2(z=3)); end test;
  **)

 relation set_extends_modifier_value: (Absyn.ComponentRef, (* class *)
				       Absyn.ComponentRef, (* inherit class*)
				       Absyn.ComponentRef, (* subident*)
				       Absyn.Modification,
				       Absyn.Program)
	 => (Absyn.Program,string)  =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inheritclass) => inherit_class &
	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_class_env(p,p_class) => env &
	 set_extends_submodifier_in_class(cdef,inherit_class,subident,mod,env)
	   => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ------------------------------
	 set_extends_modifier_value(class,inheritclass,subident,mod,p) 
	   => (newp, "Ok")

   axiom	set_extends_modifier_value(_,_,_,_,p) => (p,"Error")
 end

 (** relation: set_extends_submodifier_in_class
  ** author: PA
  **
  ** Sets a modifier of an extends clause for a given subcomponent.
  ** For instance, 
  ** extends A(b=4); // b is subcomponent
  **)

 relation set_extends_submodifier_in_class:(Absyn.Class, 
					    Absyn.Path, (* inherit_name*)
					    Absyn.ComponentRef, (* submodifier*)
					    Absyn.Modification,
					    Env.Env) => Absyn.Class =
   rule	set_extends_submodifier_in_classparts(parts,inherit_name,submod,mod,env) 
	   => parts'
	   ---------------------------------------------------------
	 set_extends_submodifier_in_class(Absyn.CLASS(id,p,f,e,r,
							Absyn.PARTS(parts,cmt),file),
					    inherit_name, submod,mod,env)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file)
 end

 (** relation: set_extends_submodifier_in_classparts
  **
  ** Helper relation to set_extends_submodifier_in_class
  **)

 relation set_extends_submodifier_in_classparts: (Absyn.ClassPart list, 
						  Absyn.Path, (* inherit_name*)
						  Absyn.ComponentRef, (* submodifier*)
						  Absyn.Modification,
						  Env.Env)
	   => Absyn.ClassPart list =
   axiom	set_extends_submodifier_in_classparts([],_,_,_,_) => []

   rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_elementitems(elts,inherit,submod,mod,env) 
	   => elts'
	 -------------------------------------
	 set_extends_submodifier_in_classparts(Absyn.PUBLIC(elts)::rest,
						 inherit,submod,mod,env)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_elementitems(elts,inherit,submod,mod,env) 
	   => elts'
	 -------------------------------------
	 set_extends_submodifier_in_classparts(Absyn.PROTECTED(elts)::rest,inherit,submod,mod,env)
	   => (Absyn.PROTECTED(elts')::res)

    rule	set_extends_submodifier_in_classparts(rest,inherit,submod,mod,env) => res 
	 -------------------------------------
	 set_extends_submodifier_in_classparts(elt::rest,inherit,submod,mod,env)
	   => (elt::res)
 end

 (** relation: set_extends_submodifier_in_elementitems
  **
  ** Helper relation to set_extends_submodifier_in_classparts
  **)

 relation set_extends_submodifier_in_elementitems:(Absyn.ElementItem list,
						   Absyn.Path,(*inherit_name*)
						   Absyn.ComponentRef, (*submodifier*)
						   Absyn.Modification,
						   Env.Env)
	 => Absyn.ElementItem list =

   axiom	set_extends_submodifier_in_elementitems([],_,_,_,_) => [] 

   rule	set_extends_submodifier_in_elementitems(rest,inherit,submod,mod,env) 
	   => res &
	 set_extends_submodifier_in_element(elt,inherit,submod,mod,env) => elt'
	 -------------------------------------------------
	 set_extends_submodifier_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,inherit,submod,mod,env)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_extends_submodifier_in_elementitems(rest,inherit,submod,mod,env) 
	   => res 
	 -------------------------------------------------
	 set_extends_submodifier_in_elementitems(elt::rest,inherit,submod,mod,env)
	   => elt::res
 end

 (** relation: set_extends_submodifier_in_element
  **
  ** Helper relation to set_extends_submodifier_in_elementitems
  **)

 relation set_extends_submodifier_in_element: (Absyn.Element, 
					       Absyn.Path,(*inherit_name*)
					       Absyn.ComponentRef, (*submodifier*)
					       Absyn.Modification,
					       Env.Env)
	   => Absyn.Element =


   rule	(* special case for clearing modifications*)
	 -----------------------------
	 set_extends_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs),s,l,constr),inherit,submod,Absyn.CLASSMOD([],NONE),env) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,[]),s,l,constr)

   rule	Inst.make_fully_qualified(env,path) => path' &
	 ModUtil.path_equal(inherit,path') => true &
	 set_submodifier_in_elementargs(eargs,submod,mod) => eargs'
	 ----------------------------------------------------
	 set_extends_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs),s,l,constr),inherit,submod,mod,env) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.EXTENDS(path,eargs'),s,l,constr)
   axiom	set_extends_submodifier_in_element(elt,_,_,_,_) => elt
 end

 (** relation: get_extends_modifier_value
  **
  ** Return the submodifier value of an extends clause
  ** for instance,
  ** model test extends A(p1=3,p2(z=3)); end test;
  ** getExtendsModifierValue(test,A,p1) => =3
 **)

 relation get_extends_modifier_value:(Absyn.ComponentRef, (*class *)
				      Absyn.ComponentRef, (* ident*)
				      Absyn.ComponentRef, (* subident*)
				      Absyn.Program) 
	   => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inherit_name) => name &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_class_env(p,p_class) => env &
	 get_extends_elementspec_in_class(cdef) => exts &
	 Util.list_map_1(exts,make_extends_fully_qualified,env) => exts' &
	 Util.list_select_1(exts',name,extends_elementspec_named) 
	   => [ Absyn.EXTENDS(extpath,extmod) ] &	
	 get_modification_value(extmod,subident) => mod  &
	 Dump.unparse_modification_str(mod) => res 
	 -----------------------------------------
	 get_extends_modifier_value(class,inherit_name,subident,p)
	   => res

   axiom	get_extends_modifier_value(_,_,_,_) => "Error"
 end

 (** relation: make_extends_fully_qualified
  **
  ** Makes an EXTENDS ElementSpec having a fully qualified extends path.
  **)

 relation make_extends_fully_qualified: (Absyn.ElementSpec, Env.Env) 
	   => Absyn.ElementSpec =

   rule	Inst.make_fully_qualified(env,path) => path'
	 -------------------------
	 make_extends_fully_qualified(Absyn.EXTENDS(path,earg),env)
	   => Absyn.EXTENDS(path',earg)
 end

 (** relation: get_extends_modifier_names
  **
  ** Return the modifier names of a modification on an extends clause.
  ** For instance,
  ** model test extends A(p1=3,p2(z=3)); end test;
  ** getExtendsModifierNames(test,A) => {p1,p2}
  **)

 relation get_extends_modifier_names: (Absyn.ComponentRef, (* class *)
				       Absyn.ComponentRef, (* inherited class *)
				       Absyn.Program) 
	 => (string) =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(inherit_name) => name &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_extends_elementspec_in_class(cdef) => exts &
	 get_class_env(p,p_class) => env &
	 Util.list_map_1(exts,make_extends_fully_qualified,env) => exts' &
	 Util.list_select_1(exts',name,extends_elementspec_named) => [ Absyn.EXTENDS(extpath,extmod) ] &
	 get_modification_names(extmod) => res &
	 Util.string_delimit_list(res,", ") => res' &
	 Util.string_append_list(["{",res',"}"]) => res''
	 ------------------------------------
	 get_extends_modifier_names(class,inherit_name,p) => res''

   axiom	get_extends_modifier_names(_,_,_) => "Error"

 end

 (** relation extends_elementspec_name
  **
  ** Returns true if elementspec of EXTENDS has the name given as path, 
  ** false otherwise.
  **)

 relation extends_elementspec_named: (Absyn.ElementSpec, 
				      Absyn.Path) 
	   => bool  =

   rule	ModUtil.path_equal(path,extpath) => res
	 --------------------------
	 extends_elementspec_named(Absyn.EXTENDS(extpath,_),path) => res
 end

 (** relation extends_name
  **
  ** Return the class name of an EXTENDS element spec.
  **)

 relation extends_name: (Absyn.ElementSpec) => Absyn.Path =

   axiom  extends_name (Absyn.EXTENDS(path,_)) => path	
 end

 (** relation: get_extends_elementspec_in_class
  **
  ** Retrieve all ElementSpec of a class that are EXTENDS.
  **)

 relation get_extends_elementspec_in_class: (Absyn.Class) 
	   => Absyn.ElementSpec list =

   rule	get_extends_elementspec_in_classparts(parts) => ext
	 -------------------------
	 get_extends_elementspec_in_class( Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => ext

   axiom	get_extends_elementspec_in_class(_) => []
 end

(** relation: get_extends_elementspec_in_classparts
 **
 ** Helper relation to get_extends_elementspec_in_class.
 **)

 relation get_extends_elementspec_in_classparts:(Absyn.ClassPart list) 
	   => Absyn.ElementSpec list = 


   axiom	get_extends_elementspec_in_classparts([]) => []

   rule	get_extends_elementspec_in_classparts(rest) 
	   => lst1 &
	 get_extends_elementspec_in_elementitems(elts) 
	   => lst2 &
	   list_append(lst1,lst2) => res
	 -------------------------------------
	 get_extends_elementspec_in_classparts(Absyn.PUBLIC(elts)::rest)
	   => res

   rule	get_extends_elementspec_in_classparts(rest) 
	   => lst1 &
	 get_extends_elementspec_in_elementitems(elts) 
	   => lst2 &
	   list_append(lst1,lst2) => res
	 -------------------------------------
	 get_extends_elementspec_in_classparts(Absyn.PROTECTED(elts)::rest)
	   => (res)

    rule	get_extends_elementspec_in_classparts(rest) 
	   => res 
	 -------------------------------------
	 get_extends_elementspec_in_classparts(elt::rest)
	   => (res)
 end

(** relation: get_extends_elementspec_in_elementitems
 **
 ** Helper relation to get_extends_elementspec_in_classparts.
 **)

 relation get_extends_elementspec_in_elementitems: (Absyn.ElementItem list) 
	 => Absyn.ElementSpec list =
   axiom	get_extends_elementspec_in_elementitems([]) => [] 

   rule	(* Bug in RML. If the two premisses below are in swapped order
	  * the compiler enters infinite loop (but no stack overflow) *)
	 get_extends_elementspec_in_element(elt) => elt &
	 get_extends_elementspec_in_elementitems(rest) 
	   => res 
	 -------------------------------------------------
	 get_extends_elementspec_in_elementitems(Absyn.ELEMENTITEM(elt)::rest)
	   => elt::res

   rule	get_extends_elementspec_in_elementitems(rest) 
	   => res 
	 -------------------------------------------------
	 get_extends_elementspec_in_elementitems(_::rest)
	   => res
 end

(** relation: get_extends_elementspec_in_element
 **
 ** Helper relation to get_extends_elementspec_in_elementitems.
**)
	    
 relation get_extends_elementspec_in_element:(Absyn.Element) 
	   => Absyn.ElementSpec =

   axiom	get_extends_elementspec_in_element(Absyn.ELEMENT(_,_,_,_,ext as Absyn.EXTENDS(_,_),_,_,_)) => ext
 end

 (** relation: set_component_modifier
  **
  ** Sets a submodifier of a component.
  **)

 relation set_component_modifier: (Absyn.ComponentRef, (* class *)
				   Absyn.ComponentRef, (* variable name *)
				   Absyn.ComponentRef, (* submodifier name*)
				   Absyn.Modification, 
				   Absyn.Program)
	   => (Absyn.Program, string) =

   rule	Absyn.cref_to_path(class) => p_class &

	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 set_component_submodifier_in_class(cdef,varname,subident,mod) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 -----------------------------------
	 set_component_modifier(class,Absyn.CREF_IDENT(varname,_),subident,mod,p) 
	   => (newp,"Ok") 

   axiom	set_component_modifier(_,_,_,_,p) => (p, "Error")
 end


 (** relation: set_component_submodifier_in_class
  **
  ** Sets a sub modifier on a component in a class.
  **)

 relation set_component_submodifier_in_class: (Absyn.Class, 
					       Absyn.Ident, (* component name*)
					       Absyn.ComponentRef,(*subvariable path*)
					       Absyn.Modification)
	   => Absyn.Class =

   rule	set_component_submodifier_in_classparts(parts,varname,submodident,mod) 
	   => parts'
	   ---------------------------------------------------------
	 set_component_submodifier_in_class(Absyn.CLASS(id,p,f,e,r,
							Absyn.PARTS(parts,cmt),file),
					    varname, submodident,mod)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file)
 end

 (** relation: set_component_submodifier_in_classparts
  **
  ** Helper relation to set_component_submodifier_in_class
  **)

 relation set_component_submodifier_in_classparts: (Absyn.ClassPart list, 
						    Absyn.Ident, (* component name*)
						    Absyn.ComponentRef, (* subvariable path*)
						    Absyn.Modification)
	 => Absyn.ClassPart list =

   axiom	set_component_submodifier_in_classparts([],_,_,_) => []

   rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_elementitems(elts,varname,submodident,mod) 
	   => elts'
	 -------------------------------------
	 set_component_submodifier_in_classparts(Absyn.PUBLIC(elts)::rest,
						 varname,submodident,mod)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_elementitems(elts,varname,submodident,mod) 
	   => elts'
	 -------------------------------------
	 set_component_submodifier_in_classparts(Absyn.PROTECTED(elts)::rest,varname,submodident,mod)
	   => (Absyn.PROTECTED(elts')::res)

    rule	set_component_submodifier_in_classparts(rest,varname,submodident,mod) => res 
	 -------------------------------------
	 set_component_submodifier_in_classparts(elt::rest,varname,submodident,mod)
	   => (elt::res)
 end

 (** relation: set_component_submodifier_in_elementitems
  **
  ** Helper relation to set_component_submodifier_in_classparts
  **)

 relation set_component_submodifier_in_elementitems:(Absyn.ElementItem list,
						     Absyn.Ident, (* component name*)
						     Absyn.ComponentRef, (* subvariable path*)
						     Absyn.Modification)
	 => Absyn.ElementItem list =

   axiom	set_component_submodifier_in_elementitems([],_,_,_) => [] 

   rule	set_component_submodifier_in_elementitems(rest,varname,submodident,mod) 
	   => res &
	 set_component_submodifier_in_element(elt,varname,submodident,mod) => elt'
	 -------------------------------------------------
	 set_component_submodifier_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,varname,submodident,mod)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_component_submodifier_in_elementitems(rest,varname,submodident,mod) 
	   => res 
	 -------------------------------------------------
	 set_component_submodifier_in_elementitems(elt::rest,varname,submodident,mod)
	   => elt::res
 end

 (** relation: set_component_submodifier_in_element
  **
  ** Helper relation to set_component_submodifier_in_elementitems
  **)

 relation set_component_submodifier_in_element: (Absyn.Element, 
						 Absyn.Ident, (* component name*)
						 Absyn.ComponentRef, (* submodifier path*)
						 Absyn.Modification)
	 => Absyn.Element =

   rule	set_component_submodifier_in_compitems(compitems,varname,submodident,mod) 
	   => compitems'
	 ----------------------------------------------------
	 set_component_submodifier_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems),s,l,constr),varname,submodident,mod) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems'),s,l,constr)

   axiom	set_component_submodifier_in_element(elt,_,_,_) => elt
 end

 (** relation: set_component_submodifier_in_compitems
  **
  ** Helper relation to set_component_submodifier_in_element
  **)

 relation set_component_submodifier_in_compitems:(Absyn.ComponentItem list,
						  Absyn.Ident, (* component name*)
						  Absyn.ComponentRef, (* submodifier path*)
						  Absyn.Modification)
	 => (Absyn.ComponentItem list) =

   axiom	set_component_submodifier_in_compitems([],_,_,_) => []

   rule	(* for "empty" modifications*)
	 varname = id 
	 ---------------------------------------
	 set_component_submodifier_in_compitems(
			   Absyn.COMPONENTITEM(
			    Absyn.COMPONENT(id,dim,_),cmt)::rest,
						varname,submodpath,Absyn.CLASSMOD([],NONE))
	   => (Absyn.COMPONENTITEM(
				   Absyn.COMPONENT(id,dim,NONE),cmt)::rest)

   rule	varname = id &
	 set_submodifier_in_elementargs(args,submodpath,mod) => args'
	 ---------------------------------------
	 set_component_submodifier_in_compitems(
			   Absyn.COMPONENTITEM(
			    Absyn.COMPONENT(id,dim,
					    SOME(Absyn.CLASSMOD(args,
								expopt))),cmt)::rest,
						varname,submodpath,mod)
	   => (Absyn.COMPONENTITEM(
		 Absyn.COMPONENT(id,dim,
				 SOME(Absyn.CLASSMOD(args',
						     expopt))),cmt)::rest)

   rule	varname = id 
	 ----------------------------
	 set_component_submodifier_in_compitems(
			   Absyn.COMPONENTITEM(
			    Absyn.COMPONENT(id,dim,NONE),cmt)::rest,
						varname,submod,mod)
	   => (Absyn.COMPONENTITEM(
		 Absyn.COMPONENT(id,dim,
				 SOME(Absyn.CLASSMOD([Absyn.MODIFICATION(false,Absyn.NON_EACH,submod,SOME(mod),NONE)],NONE))),cmt)::rest)

   rule	set_component_submodifier_in_compitems(rest,varname,submodident,mod) => res
	 ---------------------------------
	 set_component_submodifier_in_compitems(comp::rest,varname,submodident,mod)
	   => comp::res

   rule	print "-set_component_submodifier_in_compitems failed\n" 
	 -----------------------
	 set_component_submodifier_in_compitems(_,_,_,_) => fail
 end

 (** relation: set_submodifier_in_elementargs
  **
  ** Helper relation to set_component_submodifier_in_compitems
  **)

 relation set_submodifier_in_elementargs: (Absyn.ElementArg list,
					   Absyn.ComponentRef, (* subcomponent name*)
					   Absyn.Modification)
	   => Absyn.ElementArg list =

	 (* empty list, add as new modifier *)
   axiom	set_submodifier_in_elementargs([],cref ,mod) 
	   => [Absyn.MODIFICATION(false,Absyn.NON_EACH,cref,SOME(mod),NONE)]

   rule	name = submodident
	  ----------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,idx),_,cmt)::rest,Absyn.CREF_IDENT(submodident,_),mod) 
	   => Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,idx),SOME(mod),cmt)::rest

   rule	Absyn.cref_equal(cr1,cr2) => true
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,cr1 as Absyn.CREF_QUAL(_,_,_),_,cmt)::rest,cr2,mod) 
	   => Absyn.MODIFICATION(f,each,cr1,SOME(mod),cmt)::rest

   rule	name1 = name2 
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,Absyn.CREF_QUAL(name1,_,_),_,cmt)::rest,Absyn.CREF_IDENT(name2,idx),mod) 
	   => Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name2,idx),SOME(mod),cmt)::rest

   rule	name1 = name2 &
	 set_submodifier_in_elementargs(args,cr1,mod) => args'
	 ---------------------------------
	 set_submodifier_in_elementargs(Absyn.MODIFICATION(f,each,cr as Absyn.CREF_IDENT(name2,_),SOME(Absyn.CLASSMOD(args,exp)),cmt)::rest,Absyn.CREF_QUAL(name1,_,cr1),mod) 
	   => Absyn.MODIFICATION(f,each,cr,SOME(Absyn.CLASSMOD(args',exp)),cmt)::rest

   rule	set_submodifier_in_elementargs(rest,submodident,mod) => res
	 ----------------------
	 set_submodifier_in_elementargs(m::rest,submodident,mod) 
	   => m::res

   rule  print "-set_submodifier_in_elementargs failed\n"
	 -------------------
	 set_submodifier_in_elementargs(_,_,_) => fail
 end

 (** relation: get_component_modifier_value(class,ident,subident,p) => resstr 
  **
  ** Returns the modifier value of component ident for modifier subident.
  ** For instance, 
  ** model A
  **  B b1(a1(p1=0,p2=0));
  ** end A;
  ** getComponentModifierValues(A,b1,a1) => Code((p1=0,p2=0))
 **)

 relation get_component_modifier_value: (Absyn.ComponentRef, (* class *)
					 Absyn.ComponentRef, (* variable name *)
					 Absyn.ComponentRef, (* submodifier name*)
					 Absyn.Program)
	 => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(ident) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_map(comps,get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) 
	   => [Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(mod,_))),_)] &
	 get_modification_value(mod,subident) => mod  &
	 Dump.unparse_modification_str(mod) => res 
	   ---------------------------
	 get_component_modifier_value(class,ident,subident,p) => res

   axiom	get_component_modifier_value(_,_,_,_) => "Error"

 end

 (** relation: get_modification_value
  **
  ** Helper relation to get_component_modifier_value
  ** Investigates modifications to find submodifier.
 **)

 relation get_modification_value:(Absyn.ElementArg list, Absyn.ComponentRef) 
	   => Absyn.Modification =

   rule	Absyn.cref_equal(cr1,cr2) => true
	 ---------------------
	 get_modification_value (Absyn.MODIFICATION(f,each,cr1,SOME(mod),cmt)::rest,
				 cr2) => mod
   rule	name1=name2 &
	 get_modification_value(args,cr2) => res
	 ---------------------
	 get_modification_value (Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name1,_),SOME(Absyn.CLASSMOD(args,exp)),cmt)::rest,Absyn.CREF_QUAL(name2,_,cr2)) 
	   => res


   rule	get_modification_value(rest,name) => mod
	 ---------------------
	 get_modification_value (_::rest,name) => mod
 end

 (** relation: get_component_modifier_names
  **
  ** Return the modifiernames of a component, i.e. Foo f( ) 
 **)

 relation get_component_modifier_names: (Absyn.ComponentRef, (* class *)
					 Absyn.ComponentRef, (* variable name *)
					 Absyn.Program) 
	 => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(ident) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_map(comps,get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) 
	   => [Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(mod,_))),_)] &
	 get_modification_names(mod) => res &
	 Util.string_delimit_list(res,", ") => res' &
	 Util.string_append_list(["{",res',"}"]) => res''
	 ------------------------------------------------
	 get_component_modifier_names(class,ident,p) => res''

   axiom	get_component_modifier_names(_,_,_) => "{}"
 end

(** relation: get_modification_names
 **
 ** Helper relation to get_component_modifier_names
 **)

 relation get_modification_names:(Absyn.ElementArg list) 
	   => string list  =

   axiom	get_modification_names([]) => []

   rule	get_modification_names(rest) => names
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,Absyn.CREF_IDENT(name,_),NONE,cmt)::rest)
	   => name::names

   rule	Dump.print_component_ref_str(cr) => name &
	 get_modification_names(rest) => names 
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,cr ,SOME(Absyn.CLASSMOD([],_)),cmt)::rest)
	   => name::names

   rule	Dump.print_component_ref_str(cr) => name &		       
	 get_modification_names(args) => names2 &
	 Util.list_map_1r(names2,string_append,".") => names2' &
	 Util.list_map_1r(names2',string_append,name) => names2'' &
	 get_modification_names(rest) => names &
	 list_append(names2'',names) => res
	 ---------------
	 get_modification_names(Absyn.MODIFICATION(f,each,cr,SOME(Absyn.CLASSMOD(args,_)),cmt)::rest)
	   => res

   rule	get_modification_names(rest) => names
	 ---------------
	 get_modification_names(_::rest)
	   => names
 end

 (** relation: get_parameter_value
  **
  ** Returns the value of a parameter in a class.
 **)

 relation get_parameter_value: (Absyn.ComponentRef, (* class *)
			       Absyn.ComponentRef, (* variable name *)
				Absyn.Program) => string =

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(name) => Absyn.IDENT(name) &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 Util.list_select(comps,is_parameter_element) => comps' &
	 Util.list_map(comps',get_componentitems_in_element) => compelts &
	 Util.list_flatten(compelts) => compelts' & 
	 Util.list_select_1(compelts',name,componentitem_named) => [compitem] &
	 get_variable_binding_in_componentitem(compitem) => exp &
	 Dump.print_exp_str(exp) => res 
	 ----------------------------------------------------
	 get_parameter_value(class,name,p) => res

   axiom	get_parameter_value(_,_,_) => "Error"
 end

 (** relation: get_variable_binding_in_componenitem
  **
  ** Retrieve the variable binding from an ComponentItem
  **)

 relation get_variable_binding_in_componentitem: (Absyn.ComponentItem) 
	   => Absyn.Exp =

   axiom	get_variable_binding_in_componentitem(Absyn.COMPONENTITEM(
								   Absyn.COMPONENT(_,_,SOME(Absyn.CLASSMOD(_,SOME(e)))),_)) => e
 end

 (** relation: set_parameter_value
  **
  ** Sets the parameter value of a class and returns the updated program.
  **)

 relation set_parameter_value:(Absyn.ComponentRef, (*class*)
			      Absyn.ComponentRef, (*ident*)
			      Absyn.Exp,		 (* exp*)
			      Absyn.Program) 
	   => (Absyn.Program,string)	=

   rule	Absyn.cref_to_path(class) => p_class &
	 Absyn.cref_to_path(name) => Absyn.IDENT(varname) &
	 build_within(p_class) => within &
	 get_pathed_class_in_program(p_class,p) => cdef &
	 set_variable_binding_in_class(cdef,varname,exp) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'],within),p) => newp
	 ------------------------------------------------------
	 set_parameter_value(class,name,exp,p) => (newp,"Ok")

   axiom	set_parameter_value(_,_,_,p) => (p,"Error")
 end

 (** relation: set_variable_binding_in_class
  **
  ** Takes a class and an identifier and value an sets the variable binding to 
  ** the passed expression.
  **)

 relation set_variable_binding_in_class:(Absyn.Class,Absyn.Ident,Absyn.Exp) 
	   => (Absyn.Class) =

   rule	set_variable_binding_in_classparts(parts,id2,exp) => parts'
	 ---------------------------------------------------------
	 set_variable_binding_in_class(Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts,cmt),file),
				       id2,exp)
	   => Absyn.CLASS(id,p,f,e,r,Absyn.PARTS(parts',cmt),file)
 end

 (** relation: set_variable_binding_in_classparts
  **
  ** Sets a binding of a variable in a ClassPart list, named by the passed 
  ** argument.
  **)

 relation set_variable_binding_in_classparts: (Absyn.ClassPart list, Absyn.Ident, 
					       Absyn.Exp)	
	   => Absyn.ClassPart list =

   axiom	set_variable_binding_in_classparts([],_,_) => []

   rule	set_variable_binding_in_classparts(rest,id,exp) => res &
	 set_variable_binding_in_elementitems(elts,id,exp) => elts'
	 -------------------------------------
	 set_variable_binding_in_classparts(Absyn.PUBLIC(elts)::rest,id,exp)
	   => (Absyn.PUBLIC(elts')::res)

   rule	set_variable_binding_in_classparts(rest,id,exp) => res &
	 set_variable_binding_in_elementitems(elts,id,exp) => elts'
	 -------------------------------------
	 set_variable_binding_in_classparts(Absyn.PROTECTED(elts)::rest,id,exp)
	   => (Absyn.PROTECTED(elts')::res)

   rule	set_variable_binding_in_classparts(rest,id,exp) => res 
	 -------------------------------------
	 set_variable_binding_in_classparts(elt::rest,id,exp)
	   => (elt::res)
 end

 (** relation: set_variable_binding_in_elementitems
  **
  ** Sets a variable binding in a list of ElementItems
 **)

 relation set_variable_binding_in_elementitems: (Absyn.ElementItem list, Absyn.Ident,
						 Absyn.Exp) 
	   => Absyn.ElementItem list =

  axiom	set_variable_binding_in_elementitems([],_,_) => [] 

   rule	set_variable_binding_in_elementitems(rest,id,exp) => res &
	 set_variable_binding_in_element(elt,id,exp) => elt'
	 -------------------------------------------------
	 set_variable_binding_in_elementitems(Absyn.ELEMENTITEM(elt)::rest,id,exp)
	   => Absyn.ELEMENTITEM(elt')::res

   rule	set_variable_binding_in_elementitems(rest,id,exp) => res 
	 -------------------------------------------------
	 set_variable_binding_in_elementitems(elt::rest,id,exp)
	   => elt::res
 end

 (** relation: set_variable_binding_in_element
  **
  ** Sets a variable binding in an Element.
  **)

 relation set_variable_binding_in_element: (Absyn.Element, Absyn.Ident, 
					    Absyn.Exp)
	 => Absyn.Element =

   rule	set_variable_binding_in_compitems(compitems,id,exp) => compitems'
	 --------------------------
	 set_variable_binding_in_element(Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems),s,l,constr),id,exp) 
	   => Absyn.ELEMENT(f,r,i,n,Absyn.COMPONENTS(attr,tp,compitems'),s,l,constr)

   axiom	set_variable_binding_in_element(elt,id,exp) => elt
 end

 (** relation: set_variable_binding_in_compitems
  **
  ** Sets a variable binding in a ComponentItem list
  **)

 relation set_variable_binding_in_compitems: (Absyn.ComponentItem list, 
					      Absyn.Ident,
					      Absyn.Exp) 
	   => (Absyn.ComponentItem list) = 

   axiom	set_variable_binding_in_compitems([],_,_) => []

   rule	id = id2
	 -------------------------------
	 set_variable_binding_in_compitems(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
							       SOME(Absyn.CLASSMOD(arg,_))),cmt)::rest,
					   id2,exp)
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,SOME(Absyn.CLASSMOD(arg,SOME(exp)))),cmt)::rest
   rule	id = id2
	 -------------------------------
	 set_variable_binding_in_compitems(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
							       NONE),cmt)::rest,
					   id2,exp)
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(id,dim,
						  SOME(Absyn.CLASSMOD([],SOME(exp)))),cmt)::rest

   rule	set_variable_binding_in_compitems(rest,id,exp) => res
	 -------------------------------
	 set_variable_binding_in_compitems(item::rest,id,exp)
	   => item::res							      
 end

 (** relation: build_within
  **
  ** From a fully qualified model name, build a suitable within clause
 **)

 relation build_within: Absyn.Path => Absyn.Within =

   axiom	build_within(Absyn.IDENT(_)) => Absyn.TOP

   rule	Absyn.strip_last(path) => w_path 	
	 -------------------------------------
	 build_within(path) => Absyn.WITHIN(w_path)
 end

 (** relation: componentitem_named
  **
  ** Returns true if the component item has the name matching the second 
  ** argument.
  **)
 relation componentitem_named: (Absyn.ComponentItem, Absyn.Ident) => bool =

   rule	id = id2 
	 -------------------------
	 componentitem_named(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_),id2) => true

   axiom	componentitem_named(_,_) => false
 end

 (**  relation: get_componentitem_name
  **
  ** Returns the name of a ComponentItem
  **)

 relation get_componentitem_name: Absyn.ComponentItem => Absyn.Ident =

   axiom	get_componentitem_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_)) => id
 end

 (** relation: get_componentitems_in_element
  **
  ** Retrieves the ComponentItems of a component Element.
  ** If Element is not a component, empty list is returned.
  **)

 relation get_componentitems_in_element:(Absyn.Element) => Absyn.ComponentItem list =

   axiom	get_componentitems_in_element(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,l),_,_,_)) 
				       => l 
   axiom	get_componentitems_in_element(_) => []
 end

 (** relation: rename_class
  **
  ** This relation renames a class (given as a qualified path name) to a 
  ** new name -in the same scope-. All references to the class name in the
  ** program is updated to the new name. The relation does not allow a 
  ** renaming that will move the class to antoher package. To do this, the 
  ** class must be copied.
  **)

 relation rename_class: (Absyn.Program, 
			 Absyn.ComponentRef, (* old class as qualified name*)
			 Absyn.ComponentRef) (* new class, as identifier *)
	   => Absyn.Program =

   rule	(* class in package *)
	 Absyn.cref_to_path(old_class) => old_path &
	 traverse_classes(p,NONE,rename_class_visitor,(old_path,new_name),
			  true (* traverse protected*)) => ((p',_,_))
	 ------------------------
	 rename_class(p,old_class as Absyn.CREF_QUAL(_,_,_),Absyn.CREF_IDENT(new_name,_))
	   => p'
 end

 (** relation: rename_class_visitor
  **
  ** This visitor renames a class given a new name
  **)

 relation rename_class_visitor: ((Absyn.Class* Absyn.Path option *(Absyn.Path*string)))
	   => ((Absyn.Class*Absyn.Path option *(Absyn.Path*string))) =

   rule	Absyn.path_last_ident(old_class) => id2 &
	 id = id2 
	 ----------------
	 rename_class_visitor((Absyn.CLASS(id,a,b,c,d,e,f),pa,(old_class,new_name)))
	   => ((Absyn.CLASS(new_name,a,b,c,d,e,f),pa,(old_class,new_name)))

   axiom	rename_class_visitor((class,pa,args)) => ((class,pa,args))

 end


 (** relation: traverse_classes
  ** 
  ** This relation traverses all classes of a program and applies a relation 
  ** to each class. The relation takes the Absyn.Class, Absyn.Path option 
  ** and an additional argument and returns an updated class and the 
  ** additional values. The Absyn.Path option contains the path to the class
  ** that is traversed
  **)

  relation traverse_classes: (Absyn.Program, 
			     Absyn.Path option,
			      ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)),  (* rel-ation to apply*)
			      'a, (* extra value passed to re-lation*)
			      bool) (* true = traverse protected elements*)
	   => (Absyn.Program *  Absyn.Path option * 'a) =

   rule	traverse_classes2(lst,pa,visitor,args,traverse_prot) => ((lst',pa',args'))
	 -------------------------------------------------------------------------
	  traverse_classes(Absyn.PROGRAM(lst,within),pa,visitor,args,traverse_prot) 
	   => ((Absyn.PROGRAM(lst',within),pa',args'))
 end

 (** relation: traverse_classes2
  **
  ** Helper relation to traverse_classes.
  **)

 relation traverse_classes2:(Absyn.Class list,
			     Absyn.Path option,
  ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)),  (* rel-ation to apply*)
			      'a, (* extra value passed to re-lation*)
			      bool) (* true = traverse protected elements*)
	   => (Absyn.Class list * Absyn.Path option * 'a) =

   axiom	traverse_classes2([],pa,visitor,args,_) => (([],pa,args))

   rule	visitor((class,pa,args)) => ((class',pa',args')) &
	 traverse_inner_class(class,pa,visitor,args',traverse_prot) => ((class'',pa'',args'')) &
	 traverse_classes2(classes,pa,visitor,args'',traverse_prot) => ((classes',pa''',args'''))
	 ------------------------
	 traverse_classes2(class::classes,pa,visitor,args,traverse_prot)
	 => ((class''::classes',pa''',args'''))

   rule	print "-traverse_classes2 failed\n" 
	 ---------------------
	 traverse_classes2(_,_,_,_,_) => fail
 end

 (** relation: traverse_inner_class
  **
  ** Helper relation to traverse_classes2. This relation traverses all 
  ** inner classes of a class.
  **)

  relation traverse_inner_class:(Absyn.Class, (* class to traverse inner classes in *)
				 Absyn.Path option,
				 ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)), (* visitor rlation*)
				  'a (* extra argument *),
				 bool ) (* true = traverse protected elts *)
	   => (Absyn.Class * Absyn.Path option * 'a) =


   rule  Absyn.join_paths(pa,Absyn.IDENT(name))  => tmp_pa &
	  traverse_inner_class_parts(parts,SOME(tmp_pa),visitor,args,visit_prot) => ((parts',pa',args'))
	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file),SOME(pa),visitor,args,visit_prot)  
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file),pa',args'))

   rule  traverse_inner_class_parts(parts,SOME(Absyn.IDENT(name)),visitor,args,visit_prot) => ((parts',pa',args'))
	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file),NONE,visitor,args,visit_prot) 
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file),pa',args'))

   rule  traverse_inner_class_parts(parts,pa,visitor,args,visit_prot) => ((parts',pa',args'))

	  --------------------------------------------------------------
	  traverse_inner_class(Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts,str_opt),file),pa,visitor,args,visit_prot) 
	   => ((Absyn.CLASS(name,p,f,e,r,Absyn.PARTS(parts',str_opt),file),pa',args'))

   axiom	traverse_inner_class(cl,pa,_,args,_) => ((cl,pa,args))

 end

 (** relation: traverse_inner_class_parts
  **
  ** Helper relation to traverse_inner_class
  **)

 relation traverse_inner_class_parts: (Absyn.ClassPart list,
				       Absyn.Path option,
				       ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class *  Absyn.Path option *'a)), (* visitor*)
				       'a,
				       bool) (* true = visit protected elements*)
	 => (Absyn.ClassPart list * Absyn.Path option * 'a) =

   axiom	traverse_inner_class_parts([],pa,_,args,_) => (([],pa,args))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,visit_prot) => ((elts',pa',args')) &
	 traverse_inner_class_parts(parts,pa,visitor,args',visit_prot) => ((parts',pa'',args''))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(Absyn.PUBLIC(elts)::parts,pa,visitor,args,visit_prot)
	   => ((Absyn.PUBLIC(elts')::parts',pa'',args''))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,true) => ((elts',pa',args')) &
	 traverse_inner_class_parts(parts,pa,visitor,args',true) => ((parts',pa'',args''))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(Absyn.PROTECTED(elts)::parts,pa,visitor,args,true)
	   => ((Absyn.PROTECTED(elts')::parts',pa'',args''))

   rule	traverse_inner_class_parts(parts,pa,visitor,args,true) => ((parts',pa',args'))
	 ------------------------------------------------------------------
	 traverse_inner_class_parts(part::parts,pa,visitor,args,true)
	   => ((part::parts',pa',args'))
 end

 (** relation traverse_inner_class_elements
  **
  ** Helper relation to traverse_inner_class_parts.
  **)

 relation traverse_inner_class_elements:(Absyn.ElementItem list,
				       Absyn.Path option,
				       ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option * 'a)), (* visitor*)
				       'a,
					 bool)  (* visit protected elts *)
	   => (Absyn.ElementItem list * Absyn.Path option * 'a) =

   axiom	traverse_inner_class_elements([],pa,_,args,_) => (([],pa,args))

   rule	traverse_inner_class_elementspec(elt_spec,pa,visitor,args,visit_prot) 
	   => ((elt_spec',pa',args')) &
	 traverse_inner_class_elements(elts,pa,visitor,args',visit_prot) 
	   => ((elts',pa'',args''))
	 -------------------------------------------------------------
	 traverse_inner_class_elements(Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,io,n,elt_spec,file,line,constr))::elts,pa,visitor,args,visit_prot)
	   => ((Absyn.ELEMENTITEM(Absyn.ELEMENT(f,r,io,n,elt_spec',file,line,constr))::elts',
		pa'',
	       args''))

   rule	traverse_inner_class_elements(elts,pa,visitor,args,visit_prot) 
	   => ((elts',pa',args'))
	 ----------------------------------------------------------------
	 traverse_inner_class_elements(elt::elts,pa,visitor,args,visit_prot) 
	   => ((elt::elts',pa',args'))
 end

 (** relation: traverse_inner_class_elementspec
  **
  ** Helper relation to traverse_inner_class_elements
  **)

 relation traverse_inner_class_elementspec: ( Absyn.ElementSpec,
				       Absyn.Path option,
					     ((Absyn.Class * Absyn.Path option * 'a) => (Absyn.Class * Absyn.Path option *  'a)), (* visitor*)
					     'a,
					     bool) (* visit protected elts *)
	   => (Absyn.ElementSpec * Absyn.Path option * 'a) =

   rule	visitor((class,pa,args)) => ((class',pa',args')) &
	 traverse_inner_class(class',pa,visitor,args',visit_prot) => ((class'',pa'',args'')) 
	 -------------------------------------
	 traverse_inner_class_elementspec(Absyn.CLASSDEF(repl,class),pa,visitor,args,visit_prot)
	 => ((Absyn.CLASSDEF(repl,class''),pa'',args''))

   axiom	traverse_inner_class_elementspec(elt_spec,pa,_,args,_) => ((elt_spec,pa,args))

 end

 (** relation: is_primitive 
  **
  ** This relation takes a component reference and a program. 
  ** It returns the true if the refrenced type is a primitive type, otherwise 
  ** it returns false.
 **)

 relation is_primitive: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => class &
	 is_primitive_class(class,p) => res
	 ----------------------------
	 is_primitive(cr,p) => res

 (* Instead of elaborating and lookup these in env, we optimize a bit and just return true for these *)
   axiom	is_primitive(Absyn.CREF_IDENT("Real",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("Integer",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("String",_),_) => true
   axiom	is_primitive(Absyn.CREF_IDENT("Boolean",_),_) => true
   axiom	is_primitive(_,_) => false
 end



 (** relation: delete_class
  **
  ** This relation takes a component reference and a program. 
  ** It deletes the class specified by the component reference from the 
  ** given program.
  **)
 relation delete_class: (Absyn.ComponentRef, Absyn.Program) 
	  => (string, Absyn.Program) =

   rule	(* Class inside another class, inside another class *)
	 Absyn.cref_to_path(class) => cpath &
	 Absyn.strip_last(cpath) => parentcpath &
	 Absyn.strip_last(parentcpath) => parentparentcpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 get_pathed_class_in_program(parentcpath, p) => parentcdef &
	 remove_inner_class(cdef, parentcdef) => parentcdef' &
	 update_program(Absyn.PROGRAM([parentcdef'], Absyn.WITHIN(parentparentcpath)), p) => newp
	 ----------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

   rule	(* Class inside other class *)
	 Absyn.cref_to_path(class) => cpath &
	 Absyn.strip_last(cpath) => parentcpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 get_pathed_class_in_program(parentcpath, p) => parentcdef &
	 remove_inner_class(cdef, parentcdef) => parentcdef' &
	 update_program(Absyn.PROGRAM([parentcdef'], Absyn.TOP), p) => newp
	 ----------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", newp)

   rule	(* Top level class *)
	 Absyn.cref_to_path(class) => cpath &
	 get_pathed_class_in_program(cpath, p) => cdef &
	 delete_class_from_list(cdef, clist) => clist'
	 ---------------------------------------------------------------------------------------
	 delete_class(class, p as Absyn.PROGRAM(clist, w)) => ("true", Absyn.PROGRAM(clist', w))

   axiom	delete_class(_, p) => ("false",p)	
 end

(** relation: delete_class_from_list
 **
 ** Helper relation to delete_class.
 **)

 relation delete_class_from_list: (Absyn.Class, Absyn.Class list)
	  => Absyn.Class list =

	 (* Empty list *)
   axiom	 delete_class_from_list(_,[]) => []

   rule name = name2
	 -------------------------------------------------------------------------------------------
   delete_class_from_list(Absyn.CLASS(name,_,_,_,_,_,_), Absyn.CLASS(name2,_,_,_,_,_,_)::xs) => xs

   rule not name = name2 &
   delete_class_from_list(cdef, xs) => res
	 --------------------------------------
   delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_,_), (x as Absyn.CLASS(name2,_,_,_,_,_,_))::xs) => x::res

   rule delete_class_from_list(cdef, xs) => res
	 --------------------------------------
   delete_class_from_list(cdef as Absyn.CLASS(name,_,_,_,_,_,_), x::xs) => x::res
 end

(** relation: is_type 
 **
 ** This relation takes a component reference and a program. 
 ** It returns true if the refrenced class has the restriction "type", 
 ** otherwise it returns false.
 **)

 relation is_type: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_,_) 
	 ----------------------------
	 is_type(cr,p) => true

   axiom	is_type(cr,p) => false
 end

 (** relation: is_connector
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "connector", 
  ** otherwise it returns false.
 **)

 relation is_connector: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_) 
	 ----------------------------
	 is_connector(cr,p) => true

   axiom	is_connector(cr,p) => false
 end

 (** relation: is_model
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "model", 
  ** otherwise it returns false.
 **)

 relation is_model: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_MODEL,_,_) 
	 ----------------------------
	 is_model(cr,p) => true

   axiom	is_model(cr,p) => false
 end

 (** relation: is_record
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "record", 
  ** otherwise it returns false.
 **)

 relation is_record: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_RECORD,_,_) 
	 ----------------------------
	 is_record(cr,p) => true

   axiom	is_record(cr,p) => false
 end

 (** relation: is_block
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "block", 
  ** otherwise it returns false.
 **)

 relation is_block: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_BLOCK,_,_) 
	 ----------------------------
	 is_block(cr,p) => true

   axiom	is_block(cr,p) => false
 end

 (** relation: is_function
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "function", 
  ** otherwise it returns false.
 **)

 relation is_function: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_FUNCTION,_,_) 
	 ----------------------------
	 is_function(cr,p) => true

   axiom	is_function(cr,p) => false
 end

 (** relation: is_package
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "package", otherwise it returns 
  ** false.
 **)

 relation is_package: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_PACKAGE,_,_) 
	 ----------------------------
	 is_package(cr,p) => true

   axiom	is_package(cr,p) => false
 end

 (** relation: is_class
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class has the restriction "class", 
  ** otherwise it returns  false.
 **)

 relation is_class: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(_,_,_,_,Absyn.R_CLASS,_,_) 
	 ----------------------------
	 is_class(cr,p) => true

   axiom	is_class(cr,p) => false
 end


 (** relation: is_parameter
  **
  ** This relation takes a class and a component reference and a program
  ** and returns true if the component referenced is a parameter.
 **)

 relation is_parameter: (Absyn.ComponentRef, Absyn.ComponentRef, 
			 Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.PARAM,_,_),_,_) 
	 ------------------------
	 is_parameter (cr,classname,p) => true

   axiom	is_parameter (_,_,_) => false
 end

 (** relation: is_protected
  **
  ** This relation takes a class and a component reference and a program
  ** and returns true if the component referenced is in a protected section.
 **)

 relation is_protected: (Absyn.ComponentRef, Absyn.ComponentRef, 
			 Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => _
	 ------------------------
	 is_protected (cr,classname,p) => false

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_protected_list(parts) => protlst &
	 get_components_contains_name(cr,protlst) => _
	 ---------------------------------------------
	 is_protected (cr,classname,p) => true

   axiom	is_protected (_,_,_) => false
 end

 (** relation: is_constant
  **
  ** This relation takes a class and a component reference and a program
  ** and returns true if the component referenced is a constant.
 **)

 relation is_constant: (Absyn.ComponentRef, Absyn.ComponentRef, 
			Absyn.Program) 
	  => bool =

   rule	Absyn.cref_to_path(classname) => path &
	 get_pathed_class_in_program(path,p) => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(cr,publst) => Absyn.COMPONENTS(Absyn.ATTR(_,Absyn.CONST,_,_),_,_) 
	 ------------------------
	 is_constant (cr,classname,p) => true

  axiom	is_constant (_,_,_) => false
 end

(** relation: get_component_contains_name
 **
 ** Return the ElementSpec containing the name given as argument from a list
 ** of ElementItems
 **)

 relation get_components_contains_name: (Absyn.ComponentRef, Absyn.ElementItem list) 
	   => Absyn.ElementSpec =

   rule	get_compitem_named(cr,ellst) => _
	 -------------------
	 get_components_contains_name (cr,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,res as Absyn.COMPONENTS(_,_,ellst),_,_,_))::xs) => res

   rule	get_components_contains_name(cr,xs) => res
	 -----------------------------------------
	 get_components_contains_name (cr,x::xs) => res
 end

(** relation: get_compitem_named
 **
 ** Helper relation to get_components_contains_name.
 **)

 relation get_compitem_named: (Absyn.ComponentRef, Absyn.ComponentItem list)
	   => Absyn.ComponentItem =

   rule	id1 = id2 
	 ---------
	 get_compitem_named(Absyn.CREF_IDENT(id1,_), (x as Absyn.COMPONENTITEM(Absyn.COMPONENT(id2,_,_),_))::xs) => x

   rule	get_compitem_named(cr,xs) => res
	 --------------------------------
	 get_compitem_named(cr, x::xs) => res
 end

 (** relation: exist_class
  **
  ** This relation takes a component reference and a program. 
  ** It returns true if the refrenced class exists in the symbol table, 
  ** otherwise it returns false.
 **)

 relation exist_class: (Absyn.ComponentRef, Absyn.Program) => bool =

   rule	Absyn.cref_to_path(cr) => path &
	 get_pathed_class_in_program(path,p) => _
	 ----------------------------
	 exist_class(cr,p) => true

   axiom	exist_class(cr,p) => false
 end

(** relation: is_primitive_class
 **
 ** Return true of a class is a primitive class, i.e. one of the builtin 
** classes or the 'type' restricted class. It also checks derived classes
** using short class definition.
**)

 relation is_primitive_class: (Absyn.Class,Absyn.Program) => bool =

   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_INT,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_REAL,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_STRING,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_PREDEFINED_BOOL,_,_),_) => true
   axiom	is_primitive_class(Absyn.CLASS(_,_,_,_,Absyn.R_TYPE,_,_),_) => true

   rule	Absyn.cref_to_path(Absyn.CREF_IDENT(cname,[])) => inmodel &
	 lookup_classdef(path,inmodel,p)=> (cdef,_) &
	 is_primitive_class(cdef,p) => res
	 -------------------------------
	 is_primitive_class(Absyn.CLASS(cname,_,_,_,Absyn.R_CLASS,Absyn.DERIVED(path,_,_,_,_),_),p) => res

 end

 (** relation: remove_compiled_functions
 **
  ** A Compiled function should be removed if its definition is updated.
 **)

 relation remove_compiled_functions: (Absyn.Program, (Absyn.Path * Types.Type) list)
	     => (Absyn.Path * Types.Type) list =
   rule	remove_cf(id,cfs) => cfs'
	 -----------------
	 remove_compiled_functions(Absyn.PROGRAM([Absyn.CLASS(id,_,_,_,Absyn.R_FUNCTION,_,_)],_),cfs) => cfs'
   axiom	remove_compiled_functions(_,cfs) => cfs
 end

(** relation: remove_cf
 **
 ** Helper relation to remove_compiled_functions.
 **)

 relation remove_cf: (Absyn.Ident, (Absyn.Path * Types.Type) list)
	     => (Absyn.Path * Types.Type) list =

   axiom	remove_cf(_,[]) => []

   rule	id1 = id2 &
	 remove_cf(id1,rest) => res
	 --------------------------
	 remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => res 
   rule	not id1 = id2 &
	 remove_cf(id1,rest) => res
	 --------------------------
	 remove_cf(id1,(Absyn.IDENT(id2),t)::rest) => ((Absyn.IDENT(id2),t)::res)
 end

 (** relation: update_program
  **
  ** This relation takes an old program (second argument), i.e. the old 
  ** symboltable, and a new program (first argument), i.e. a new set of
  ** classes and updates the old program with the definitions in the new one.
  **)     

 relation update_program: (Absyn.Program,Absyn.Program) => Absyn.Program =

  axiom	update_program (Absyn.PROGRAM([],_),prg) => prg

   rule	(* For split definitions at top, when introducing new model, eg. "package A" *)
	 let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE),"") &
	 update_program(Absyn.PROGRAM([newclass],Absyn.TOP),oldp) => newp
	 -------------------------------------------------------
	 update_program(Absyn.BEGIN_DEFINITION(Absyn.IDENT(name),restr,p,e),oldp) => newp

   rule	(* For split definitions not at top,  eg. "package A.B" *)
	 Absyn.strip_last(path) => w &
	 Absyn.path_last_ident(path) => name &
	 let newclass = Absyn.CLASS(name,p,false,e,restr,Absyn.PARTS([Absyn.PUBLIC([])],NONE),"") &
	 update_program(Absyn.PROGRAM([newclass],Absyn.WITHIN(w)),oldp) => newp
	 -------------------------------------------------------
	 update_program(Absyn.BEGIN_DEFINITION(path as Absyn.QUALIFIED(_,_),
					       restr,p,e),oldp) 
	   => newp

   rule	class_in_program(name,p2) => false &
	 update_program(Absyn.PROGRAM(c2,w),Absyn.PROGRAM((c1::c3),w2)) => pnew
	 ---------------------------------------------------------
	 update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_,_))::c2,w as Absyn.TOP),p2 as Absyn.PROGRAM(c3,w2)) => pnew

   rule	class_in_program(name,p2) => true &
	 update_program(Absyn.PROGRAM(c2,w),p2) => pnew &
	 replace_class_in_program(c1,pnew) => pnew' 
	 ------------------------------------------
	 update_program (Absyn.PROGRAM((c1 as Absyn.CLASS(name,_,_,_,_,_,_))::c2,w as Absyn.TOP),p2) => pnew'

   rule	insert_class_in_program(c1,w,p2) => pnew &
	 update_program(Absyn.PROGRAM(c2,w),pnew) => pnew' 
	 ---------------------------------------------
	 update_program(Absyn.PROGRAM(c1::c2,w as Absyn.WITHIN(path)),p2) => pnew'

   rule	(* nested packages (of form A.B) *)
	 get_pathed_class_in_program(path,p) => cdef &
	 Absyn.strip_last(path) => modelwithin &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       false, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,"",0,NONE)))
	   => newcdef &	
	  update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
	   => newp

   rule	(* top package *)
	  get_pathed_class_in_program(path,p) => cdef &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       false, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,"",0,NONE)))
	   => newcdef &	
	  update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.COMP_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
	   => newp

   rule	(* nested packages ( e.g. A.B ) *)
	 get_pathed_class_in_program(path,p) => cdef &
	 Absyn.strip_last(path) => modelwithin &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       false, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,"",0,NONE)))
	   => newcdef &	
	   update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.QUALIFIED(_,_))),p) 
	   => newp
   rule	(* top level package e.g. A *)
	 get_pathed_class_in_program(path,p) => cdef &
	 add_to_public(cdef,
		       Absyn.ELEMENTITEM(
					 Absyn.ELEMENT(
						       false, 
						       false, 
						       Absyn.UNSPECIFIED,
						       "",
						       elt,"",0,NONE)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)
	   => newp
	 --------------------------------
	 update_program(Absyn.IMPORT_DEFINITION(elt,SOME(path as Absyn.IDENT(_))),p) 
	   => newp	

   rule	Print.print_buf "Further program merging not implemented yet\n"
	 ------------------------
	 update_program (a,b) => b
 end


 (** relation: add_scope
  **
  **  This relation adds the scope of the scope variable to the program,
  ** so it can be inserted at the correct place.
  ** It also adds the scope to BEGIN_DEFINITION, COMP_DEFINITION and 
  ** IMPORT_DEFINITION so an empty class definition
  ** can be inserted at the correct place.
  *)
 relation add_scope: (Absyn.Program, InteractiveVariable list) 
	   => Absyn.Program =

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path))
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,Absyn.TOP),vars) 
	   => Absyn.PROGRAM(cls,Absyn.WITHIN(path))

   rule	not get_variable_value("scope",vars) => _
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,w),vars) 
	   => Absyn.PROGRAM(cls,w)

   rule	(* This should probably be forbidden. *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	   Absyn.join_paths(path,path2) => newpath 
	 --------------------------------------
	 add_scope(Absyn.PROGRAM(cls,Absyn.WITHIN(path2)),vars)
	   => Absyn.PROGRAM(cls,Absyn.WITHIN(newpath))

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.join_paths(path,path2) => newpath  
	 --------------------
	 add_scope(Absyn.BEGIN_DEFINITION(path2,restr,p,e),vars)
	 => Absyn.BEGIN_DEFINITION(newpath,restr,p,e)

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) 
	   --------------------
	 add_scope(Absyn.COMP_DEFINITION(elt,NONE),vars)
	   => Absyn.COMP_DEFINITION(elt,SOME(path))

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) 
	   --------------------
	 add_scope(Absyn.IMPORT_DEFINITION(elt,NONE),vars)
	   => Absyn.IMPORT_DEFINITION(elt,SOME(path))

   axiom	add_scope(p,_) => p
 end

 (** relation: update_scope
  ** This relation takes a PROGRAM and updates the variable scope to according
  ** to the value of program:
  ** 1. BEGIN_DEFINITION ident appends ident to scope
  ** 2. END_DEFINITION ident removes ident from scope
 **)

 relation update_scope: (Absyn.Program, InteractiveVariable list) 
	   => InteractiveVariable list =

   rule	(* If not top scope *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.join_paths(path,Absyn.IDENT(id)) => newscope &
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			    vars)
	   => vars'
	 -------------------------------------------------------------
	 update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'

   rule	(* If top scope *)
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id))) &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			    vars)
	   => vars'
	 -----------
	 update_scope(Absyn.BEGIN_DEFINITION(Absyn.IDENT(id),_,_,_),vars) => vars'

   rule	(* If not top scope *)
	 get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(path)) &
	 Absyn.path_last_ident(path) => id2 &
	 id1 = id2 &
	 Absyn.strip_last(path) => newscope &
	 let newscope' = Values.CODE(Absyn.C_TYPENAME(newscope)) &
	 Absyn.strip_last(path) => path' &
	 add_var_to_varlist(
			    "scope",
			    newscope',
			    ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE)),
			    vars)
	   => vars'
	 ----------------------
	 update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

   rule	get_variable_value("scope",vars) 
	   => Values.CODE(Absyn.C_TYPENAME(Absyn.IDENT(id2))) &
	 id1 = id2 &  
	 remove_var_from_varlist("scope",vars) => vars' 
	 ------------------------
	 update_scope(Absyn.END_DEFINITION(id1),vars) => vars'

  axiom update_scope(_,vars) => vars
 end

(** relation: remove_var_from_varlist
 **
 ** Helper relation to update_scope.
**)

 relation remove_var_from_varlist: (Absyn.Ident,InteractiveVariable list) 
	 => InteractiveVariable list =

   axiom	remove_var_from_varlist(_,[]) => []

   rule	id1 = id2 
	 ---------
	 remove_var_from_varlist(id1, IVAR(id2,_,_)::rest) => rest

   rule	not id1 = id2 &
	 remove_var_from_varlist(id1,rest) => rest'
	 -----------------------------------------
	 remove_var_from_varlist(id1,(v as IVAR(id2,_,_))::rest)
	   => v::rest'
 end

(** relation: get_variable_value
 **
 ** Return the value of an interactive variable from a list of 
 ** InteractiveVariable.
 **)

 relation get_variable_value: (Absyn.Ident, InteractiveVariable list) => 
	 (Values.Value) =

   rule	id1 = id2
	 -------
	 get_variable_value(id1,IVAR(id2,v,_)::_) => v

   rule	not id1 = id2 &
	 get_variable_value(id1,rest) => v
	 ---------------------------------
	 get_variable_value(id1,IVAR(id2,v,_)::rest) => v
 end


 (** relation: lookup_classdef
  **
  ** This relation takes a Path of a class to lookup and a Path as a 
  ** starting point for the lookup rules and a Program.
  ** It returns the Class definition and the complete Path to the class.
 **)

 relation lookup_classdef: (Absyn.Path, Absyn.Path, Absyn.Program) 
	  => (Absyn.Class, Absyn.Path) =

   rule	(* Look first inside 'inmodel' *)
	 get_pathed_class_in_program(inmodel,p) => inmodeldef &
	 get_pathed_class_in_program(path,Absyn.PROGRAM([inmodeldef],Absyn.TOP)) => cdef &
	 Absyn.join_paths(inmodel,path) => newpath
	 --------------------------------
	 lookup_classdef(path, inmodel,p) => (cdef,newpath)

	 (* Then look inside next level *)
   rule	Absyn.strip_last(inmodel) => innewpath &
	 lookup_classdef(path,innewpath,p) => (cdef,respath)
	 ------------------------------
	 lookup_classdef(path,inmodel,p) => (cdef,respath)

   rule	(* Finally look in top level *)
	 get_pathed_class_in_program(path,p) => cdef
	 ------------------------------------------
	 lookup_classdef(path,_,p) => (cdef,path)

   axiom	lookup_classdef(Absyn.IDENT("Real"),_,_) => 
	 (Absyn.CLASS("Real",false,false,false,Absyn.R_PREDEFINED_REAL,Absyn.PARTS([],NONE),""), 
	  Absyn.IDENT("Real"))

   axiom	lookup_classdef(Absyn.IDENT("Integer"),_,_) => 
	 (Absyn.CLASS("Integer",false,false,false,Absyn.R_PREDEFINED_INT,Absyn.PARTS([],NONE),""), 
	  Absyn.IDENT("Integer"))

   axiom	lookup_classdef(Absyn.IDENT("String"),_,_) => 
	 (Absyn.CLASS("String",false,false,false,Absyn.R_PREDEFINED_STRING,Absyn.PARTS([],NONE),""), 
	  Absyn.IDENT("String"))

   axiom	lookup_classdef(Absyn.IDENT("Boolean"),_,_) => 
	 (Absyn.CLASS("Boolean",false,false,false,Absyn.R_PREDEFINED_BOOL,Absyn.PARTS([],NONE),""), 
	  Absyn.IDENT("Boolean"))

   rule	Print.print_error_buf "#Error, lookup_classdef failed\n" &
	 Absyn.path_string path => s1 &
	 Absyn.path_string inpath => s2 &
	 Print.print_error_buf s1 & Print.print_error_buf " in " & 
	 Print.print_error_buf s2 &
	 Print.print_error_buf "\n" 
	 ---------------------
	 lookup_classdef(path,inpath,_) => fail
 end

 (** relation: delete_component
  **
  ** This relation deletes a component from a class given the name of the 
  ** component instance, the model in which the component is instantiated in, 
  ** and the Program.
  **
  ** Both public and protected lists are searched.
  **)

 relation delete_component: (string, Absyn.ComponentRef, Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 not get_pathed_class_in_program(modelpath,p) => _
	 ---------------------------------
	 delete_component (name,model,p) => (p,"false\n") 

   rule	Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_component_from_class(name, cdef) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ------------------------------------------------
	 delete_component(name, model as Absyn.CREF_QUAL(_,_,_),p as Absyn.PROGRAM(_,w)) => (newp,"true\n")

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_component_from_class(name, cdef) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 delete_component( name, model as Absyn.CREF_IDENT(_,_), p as Absyn.PROGRAM(_,w)) => (newp,"true\n")

   axiom	delete_component(_,_,p) => (p,"false\n") 
 end

 (** relation: delete_component_from_class
  **
  ** This relation deletes a component from a class given the name of the component instance, and a 'Class'.
  ** 
  ** Both public and protected lists are searched.
  **)
 relation delete_component_from_class: (string, Absyn.Class)
	  => Absyn.Class =

	 (* Search in public list *)
   rule	get_public_list(parts) => publst &
	 delete_component_from_elementitems(name,publst) => publst2 &
	 list_length(publst2) => l2 &
	 list_length(publst) => l1 &
	 int_sub(l1,1) => l1' &
	 l1' = l2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------------------
	 delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file)) 
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)

	 (* Search in protected list *)
   rule	get_protected_list(parts) => protlst &
	 delete_component_from_elementitems(name,protlst) => protlst2 &
	 list_length(protlst2) => l2 &
	 list_length(protlst) => l1 &
	 int_sub(l1,1) => l1' &
	 l1' = l2 &
	 replace_protected_list(parts,protlst2) => parts2 
	 --------------------------------------------
	 delete_component_from_class(name, Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file)) 
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)
 end	

(** relation: delete_component_from_elementitems
 **
 ** Helper relation to delete_component_from_class.
**)

 relation delete_component_from_elementitems: (string, Absyn.ElementItem list) 
	   => Absyn.ElementItem list =
   axiom	 delete_component_from_elementitems (_,[]) => []

   rule	name = name2 
	 -------------
	 delete_component_from_elementitems(name,Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_)]),_,_,_))::xs) => xs

   rule	not name = name2 &
	 delete_component_from_elementitems(name, xs) => res
	 -------------------------
	 delete_component_from_elementitems(name, (x as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,[Absyn.COMPONENTITEM(Absyn.COMPONENT(name2,_,_),_)]),_,_,_)))::xs) => x::res

   rule	delete_component_from_elementitems(name, xs) => res
	 ---------------------------------------------------
	 delete_component_from_elementitems(name,x::xs) => x::res 
 end

 (** relation add_component
  **
  ** This relation takes:  arg1 - string giving the instancename, 
  ** arg2 - `ComponentRef' giving the component type
  ** arg3 - ComponentRef giving the model to instantiate the component within,
  ** arg4 - `NamedArg' list of annotations 
  ** arg5 - a Program. 
  *** The result is an updated program with the component and its annotations 
  ** inserted, and a string "OK" for success. If the insertion fails, a
  ** suitable error string is given along with the input Program.
  **)

 relation add_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,
			  Absyn.NamedArg list, Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 not get_pathed_class_in_program(modelpath,p) => _
	 ---------------------------------
	 add_component (name,tp,model,nargs,p) => (p,"false\n") 


	 (* Adding component to model that resides inside package *)
   rule	Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	 modification_to_absyn(nargs,NONE) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ------------------------------------------------
	 add_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

	 (* Adding component to model that resides on top level *)
   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 annotation_list_to_absyn_comment(nargs,NONE) => annotation &
	 modification_to_absyn(nargs,NONE) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(Absyn.ATTR(false,Absyn.VAR,Absyn.BIDIR,[]),tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p)=> newp
	 ------------------------------------------------
	 add_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) => (newp,"Ok\n")

   axiom	add_component (_,_,_,_,p) => (p,"Error")

 end

 (** relation: update_component
  **
  ** This relation updates a component in a class. The reason for having 
  ** this relation is that a deletion followed by an addition would mean that 
  ** all optional arguments must be present to the add_component relation 
  ** in order to get the same component attributes,etc. as previous. 
  **) 

 relation update_component: (string, Absyn.ComponentRef,Absyn.ComponentRef,
			     Absyn.NamedArg list,
			     Absyn.Program) 
	  => (Absyn.Program ,string) =

   rule	(* Updating a public component to model that resides inside package *)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_public_list(parts) => publst &
	 get_components_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	   => Absyn.COMPONENTS(attr,tp,items) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(attr,tp,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	 --------------------------
	 update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp, "true")

   rule	(* Updating a protected component to model that resides inside package*)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_protected_list(parts) => protlst &
	 get_components_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	   => Absyn.COMPONENTS(attr,tp,items) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(attr,tp,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE)))
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p) => newp
	 --------------------------
	 update_component( name,tp,model as Absyn.CREF_QUAL(_,_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp, "true\n")

   rule	(* Updating a public component to model that resides on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_public_list(parts) => publst &
	 get_components_contains_name(Absyn.CREF_IDENT(name,[]),publst) 
	   =>Absyn.COMPONENTS(attr,tp,items) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_public(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(attr,tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) 
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp,"true\n")

   rule	(* Updating a protected component to model that resides on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.cref_to_path(tp) => tppath &
	 delete_component(name,model,p) => (p',_) &
	 get_pathed_class_in_program(modelpath,p') => cdef &
	 get_pathed_class_in_program(modelpath,p) => Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) &
	 get_protected_list(parts) => protlst &
	 get_components_contains_name(Absyn.CREF_IDENT(name,[]),protlst) 
	   =>Absyn.COMPONENTS(attr,tp,items) &
	 get_compitem_named(Absyn.CREF_IDENT(name,[]),items) 
	   => Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,mod),ann) &
	 annotation_list_to_absyn_comment(nargs,ann) => annotation &
	 modification_to_absyn(nargs,mod) => modification &
	 add_to_protected(cdef,Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",
	     Absyn.COMPONENTS(attr,tppath,
		 [Absyn.COMPONENTITEM(Absyn.COMPONENT(name,[],modification),annotation)]),"",0,NONE))) 
	   => newcdef &	
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ------------------------------------------------
	 update_component( name,tp,model as Absyn.CREF_IDENT(_,_),nargs,p as Absyn.PROGRAM(_,w)) 
	   => (newp,"true\n")

 end

 (** relation:add_class_annotation 
  **
  ** This relation takes a `ComponentRef' and an `Exp' expression and a 
  ** `Program' and adds the expression as a annotation to the specified 
  ** model in the program, returning the updated program.
 **)

 relation add_class_annotation:(Absyn.ComponentRef,Absyn.NamedArg list,
				Absyn.Program) 
	  => Absyn.Program =

   rule	(* Class inside other class *)
	 Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_class_annotation_to_class(cdef,nargs) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'], Absyn.WITHIN(modelwithin)),p) => newp
	 -----------------------------
	 add_class_annotation(model as Absyn.CREF_QUAL(_,_,_),nargs,p) => newp

   rule	(* Class on top level *)
	 Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_class_annotation_to_class(cdef,nargs) => cdef' &
	 update_program(Absyn.PROGRAM([cdef'], Absyn.TOP),p) => newp
	 -----------------------------
	 add_class_annotation(model as Absyn.CREF_IDENT(_,_),nargs,p) => newp
 end

 (** relation: add_class_annotation_to_class
  *
  * This relation adds an annotation on element level to a `Class´.
  **)

 relation add_class_annotation_to_class: ( Absyn.Class, Absyn.NamedArg list) 
	   => Absyn.Class =

   rule	(* No annotation element found in class *)
	 get_public_list(parts) => publst &
	 not get_element_annotation_in_elements(publst) => _ &
	 annotation_list_to_absyn(nargs) => annotation &
	 add_to_public(cdef,Absyn.ANNOTATIONITEM(annotation)) => cdef' 
	 ------------------------------------------------------------
	 add_class_annotation_to_class(cdef as Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),nargs) => cdef'

   rule	get_public_list(parts) => publst &
	 get_element_annotation_in_elements(publst) => Absyn.ANNOTATIONITEM(oldann) &
	 annotation_list_to_absyn(nargs) => newann &
	 merge_annotations(oldann,newann) => newann' &
	 replace_element_annotation_in_elements(publst,newann') => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------
	 add_class_annotation_to_class(cdef as Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file),nargs)
	 => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)
 end

 (** relation: replace_element_annotation_in_elements
  *
  * This relation takes an element list and replaces the first annotation 
  ** with the one given as argument.
  **)

 relation replace_element_annotation_in_elements: (Absyn.ElementItem list,
						   Absyn.Annotation)
	   => Absyn.ElementItem list =

  axiom	replace_element_annotation_in_elements(Absyn.ANNOTATIONITEM(_)::xs,a) 
	   => Absyn.ANNOTATIONITEM(a)::xs

   rule	replace_element_annotation_in_elements(xs,a2) => res
	 -----------------------
	 replace_element_annotation_in_elements(a::xs,a2) 
	   => a::res

   axiom	replace_element_annotation_in_elements([],_) => []
 end

 (** relation: get_element_annotation_in_elements
  **
  ** This relation retrieves the forst Annotation among the elements 
  ** taken as argument
  **)

 relation get_element_annotation_in_elements: (Absyn.ElementItem list) 
	   => Absyn.ElementItem =

  axiom	get_element_annotation_in_elements((a as Absyn.ANNOTATIONITEM(_))::xs) => a

   rule	get_element_annotation_in_elements(xs) => a
	 -------------------------------------------
	 get_element_annotation_in_elements(_::xs) => a
 end

 (** relation: merge_annotations
  **
  ** This relation takes an old annotation as first argument and a new 
  ** annotation as  second argument and merges the two.
  ** Annotation "parts" that exist in both the old and the new annotation 
  ** will be changed according to the new definition. For instance,
  ** merge_annotations(annotation(x=1,y=2),annotation(x=3)) 
  ** => annotation(x=3,y=2)
  **)

 relation merge_annotations:(Absyn.Annotation, Absyn.Annotation) 
	  => Absyn.Annotation =

   rule	not remove_modification_in_elementargs(eltargs,cr) => _ &
	 merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs) 
	   ----------------------------
	 merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			   Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(mod::neweltargs)

   rule	remove_modification_in_elementargs(eltargs,cr) => eltargs' &
	 merge_annotations(Absyn.ANNOTATION(oldrest),Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs) 
	 -----------------------------------------------------------------------
	 merge_annotations(Absyn.ANNOTATION((mod as Absyn.MODIFICATION(_,_,cr,_,_))::oldrest),
			   Absyn.ANNOTATION(eltargs))
	   => Absyn.ANNOTATION(neweltargs)

   axiom	merge_annotations(Absyn.ANNOTATION([]),a) => a
 end

 (** relation: remove_modification_in_elementargs
  **
  ** This relation removes the class modification named by the second argument.
  ** If no such class modification is found the relation fails.
  ** Currently, only identifiers are allowed as class modifiers, 
  ** i.e. a(...) and not a.b(...)
 **)

 relation remove_modification_in_elementargs:(Absyn.ElementArg list, 
					      Absyn.ComponentRef )
	 => Absyn.ElementArg list = 

   rule	id = id2 
	 ---------------------------------------------
	 remove_modification_in_elementargs([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)],cr as Absyn.CREF_IDENT(id2,_))
	   => []
   rule	not id = id2 
	 ---------------------------------------------
	 remove_modification_in_elementargs([(m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))],cr as Absyn.CREF_IDENT(id2,_))
	   => fail

   rule	id = id2 &
	 remove_modification_in_elementargs(xs,cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_)::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => res
   rule	not id = id2 &
	 remove_modification_in_elementargs(xs, cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => m::res

   rule	remove_modification_in_elementargs(xs, cr) => res 
	 ---------------------------------------------
	 remove_modification_in_elementargs((m as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),_,_))::xs,cr as Absyn.CREF_IDENT(id2,_))
	   => m::res 
 end

(** relation: get_inheritance_count
 **
 ** This relation takes a `ComponentRef' and a `Program' and returns the 
 ** number of inherited classes in the class referenced by the 
  ** `ComponentRef'.
 **)
relation get_inheritance_count: (Absyn.ComponentRef,Absyn.Program) => int = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &

	 count_base_classes(cdef) => count
	 -------------------------------------------------
	 get_inheritance_count( model,p) => count

  axiom	get_inheritance_count (_,_) => 0
end

(** relation: get_inheritance_count
 ** This relation takes a `ComponentRef' and a `Program' and returns the 
 ** number of inherited classes in the class referenced by the `ComponentRef'.
 **)
relation get_nth_inherited_class: (Absyn.ComponentRef,int,Absyn.Program) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	   get_nth_inherited_class2(c,cdef,n,env') => str 
	 -------------------------------------------------
	 get_nth_inherited_class( model,n,p) => str
	
  axiom	get_nth_inherited_class (_,_,_) => "Error"
 end

(** relation: get_nth_inherited_class2
 **
 ** Helper relation to get_nth_inherited_class.
 **)

 relation get_nth_inherited_class2: (SCode.Class, Absyn.Class,int, Env.Env) 
	   => string =

   rule	(* First try without instantiating, if class is in parents*)
	 get_base_classes(cdef,env) => lst &  
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => cref &
	 Absyn.cref_to_path(cref) => path &
	 Absyn.path_string(path) => str
	 -----------------------
	 get_nth_inherited_class2(c as SCode.CLASS(_,_,_,_,_),cdef,n,env)
	   => str

   rule	(* If that fails, instantiate, which takes more time*)
	 Env.open_scope(env,encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	   => (env'',_) &
	 get_base_classes(cdef,env'') => lst &  
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => cref &
	 Absyn.cref_to_path(cref) => path &
	 Absyn.path_string(path) => str
	 --------------------------
	 get_nth_inherited_class2(c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	   => str
 end

 (** relation: get_component_count
  **
  ** This relation takes a `ComponentRef' and a `Program' and returns the 
  ** number of public components in the class referenced by the `ComponentRef'.
  **)
relation get_component_count: (Absyn.ComponentRef,Absyn.Program) => int = 

   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_components(cdef) => count
	-------------------------------------------------
	get_component_count( model,p) => count
 end

 (** relation: count_components
  **
  ** This relation takes a `Class' and returns the number of components 
  ** in that class
 **)

 relation count_components: Absyn.Class => int =

   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file) => c1 &
	 count_components_in_elts(elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file) 
	     => res

   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file) => c1 &
	 count_components_in_elts(elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt),file) 
	     => res
   rule	count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file) => res
	 -----------------------------------------------------
	 count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file) => res

   axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],_),_) => 0
   axiom count_components Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_),_) => -1
 end

(** relation: count_components_in_elts
 **
 ** Helper relation to count_components
 **)
 
 relation count_components_in_elts: Absyn.ElementItem list => int =

   rule	count_components_in_elts(lst) => c1 &
	 list_length(complst) => ncomps &
	 int_add(c1,ncomps) => res
	 --------------------------
	 count_components_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,complst),_,_,NONE))::lst) => res

   rule	count_components_in_elts(lst) => res
	 ----------------------------
	 count_components_in_elts(_::lst) => res

   axiom	count_components_in_elts([]) => 0
 end

 (** relation: get_nth_component
  **
  ** This relation takes a `ComponentRef', a `Program' and an int and 
  ** returns a comma separated string of names containing the name, type 
  ** and comment of that component.
  **)

 relation get_nth_component: (Absyn.ComponentRef,Absyn.Program, int) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component2(c,cdef,n,env') => str 
	 -------------------------------------------------
	 get_nth_component( model,p,n) => str

	 axiom get_nth_component(_,_,_) => "Error"
 end

(** relation: get_nth_component2
 **
 ** Helper relation to get_nth_component.
 **)

 relation get_nth_component2: (SCode.Class,Absyn.Class, int, Env.Env) 
	   => string =


  rule	Env.open_scope(env,encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	   => (env'',_) &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_info_old (comp,env'') => [s1] &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 --------------------------
	 get_nth_component2 (c as SCode.CLASS(id,_,encflag,restr,_),cdef,n,env)
	   => str
   rule	print "get_nth_component2 failed\n" 
	 -----------------------
	 get_nth_component2(_,_,_,_) => fail

 end

 (** relation: get_components
  **
  ** This relation takes a `ComponentRef', a `Program' and an int and  returns 
  ** a list of all components, as returned by get_nth_component.
  **)

 relation get_components: (Absyn.ComponentRef,Absyn.Program) => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Lookup.lookup_class(env,modelpath,false) 
	   => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	 Env.open_scope(env',encflag,SOME(id)) => env2 &
	 ClassInf.start(restr,id) => ci_state &
	 Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	   => (env'',_) &
	 get_public_components_in_class(cdef) => comps1 &
	 get_components_info (comps1,"\"public\"",env'') => s1 &
	 get_protected_components_in_class(cdef) => comps2 &
	 get_components_info(comps2,"\"protected\"",env'') => s2 &
	 Util.string_delimit_list_no_empty([s1,s2],",") => str &
	 Util.string_append_list(["{",str,"}"]) => res
	 -------------------------------------------------
	 get_components(model,p) => res

	 axiom get_components(_,_) => "Error"
 end


 (** relation: get_component_annotations
  **
  ** This relation takes a `ComponentRef', a `Program' and
  ** returns a list of all component annotations, as returned by 
  ** get_nth_component_annotation.
  **)

 relation get_component_annotations: (Absyn.ComponentRef,
				       Absyn.Program) 
	   => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_components_in_class(cdef) => comps &
	 get_component_annotations_from_elts(comps) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 -------------------------------------------------
	 get_component_annotations( model,p) => str

	 axiom get_component_annotations(_,_) => "Error"
 end

 (** relation: get_nth_component_annotation
  **
  ** This relation takes a `ComponentRef', a `Program' and an int and  
  ** returns a comma separated string of values corresponding to the flat 
  ** record for component annotations.
  **)

 relation get_nth_component_annotation: (Absyn.ComponentRef,Absyn.Program,int) 
	  => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_annotation(comp) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str
	 ---------------------------------------------- 
	 get_nth_component_annotation( model,p,n) => str

	 axiom get_nth_component_annotation(_,_,_) => "Error"
 end

(** relation: get_nth_component_modification
 **
 ** This relation takes a `ComponentRef', a `Program' and an int and 
  ** returns a comma separated string of values corresponding to the 
 ** flat record for component annotations.
 **)
relation get_nth_component_modification: (Absyn.ComponentRef,Absyn.Program, int) 
	   => string = 

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_component_in_class(cdef,n) => comp &
	 get_component_modification(comp) => str &
	 Util.string_append_list(["{",str,"}"]) => str'
	 ---------------------------------------------- 
	 get_nth_component_modification( model,p,n) => str'

	 axiom get_nth_component_modification(_,_,_) => "Error"
end

(** relation: get_connection_count
 **
 ** This relation takes a `ComponentRef' and a `Program' and returns a 
 ** string containing the number of connections in the model identified by 
 ** the `ComponentRef'.
 **)

relation get_connection_count: (Absyn.ComponentRef, Absyn.Program) => string =
	
  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_connections cdef => numconn &
	int_string numconn => res
	-------------------------
	get_connection_count (model,p) => res
	
  axiom get_connection_count(_,_) => "Error"
end

(** relation: get_nth_connection
 **
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
 ** returns a comma separated string for the nth connection, e.g. "R1.n,C.p".
 **)
		 
relation get_nth_connection: (Absyn.ComponentRef, Absyn.Program, int) 
	  => string =

   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => Absyn.EQUATIONITEM(eq,_) &
	get_connection_str eq => str
	----------------------------
	get_nth_connection (model,p,n) => str
	
  axiom get_nth_connection(_,_,_) => "Error"
end

(** relation: add_connection
 **
 ** Adds a connect equation to the model, i..e connect(c1,c2)
 **)

 relation add_connection: (Absyn.ComponentRef, (* model name *)
			   Absyn.ComponentRef, (* c1 *)
			   Absyn.ComponentRef, (* c2 *)
			   Absyn.NamedArg list, (* annotations *)
			   Absyn.Program) => 
	 (string, Absyn.Program) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.strip_last(modelpath) => package &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),NONE)) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,[],p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 annotation_list_to_absyn(nargs) => annotation &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),SOME(Absyn.COMMENT(SOME(annotation),NONE)))) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],w),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_IDENT(_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 Absyn.strip_last(modelpath) => package &
	 annotation_list_to_absyn(nargs) => annotation &
	 add_to_equation(cdef,Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(c1,c2),SOME(Absyn.COMMENT(SOME(annotation),NONE)))) 
	   => newcdef &
	 update_program(Absyn.PROGRAM([newcdef],Absyn.WITHIN(package)),p)=> newp
	 ---------------------------------------------------
	 add_connection(model as Absyn.CREF_QUAL(_,_,_),c1,c2,nargs,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)	
 end

(** relation: delete_connection
 **
 ** Deleted the connection connect(c1,c2) from a model.
 **)

 relation delete_connection: (Absyn.ComponentRef, (* model name*)
			      Absyn.ComponentRef, (* c1 *)
			      Absyn.ComponentRef, (* c2 *)
			      Absyn.Program)
	   => (string,Absyn.Program) =

   rule	Absyn.cref_to_path(model) => modelpath &
	 Absyn.strip_last(modelpath) => modelwithin &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_equation_in_class(cdef,c1,c2) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.WITHIN(modelwithin)),p)=> newp
	 ---------------------------------------------------
	 delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 delete_equation_in_class(cdef,c1,c2) => newcdef &
	 update_program(Absyn.PROGRAM([newcdef], Absyn.TOP),p) => newp
	 ---------------------------------------------------
	 delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Ok",newp)

   axiom	delete_connection(model,c1,c2,p as Absyn.PROGRAM(_,w)) => ("Error",p)	
 end

(** relation: delete_equation_in_class
 **
 ** Helper relation to delete_connection.
 **)

 relation delete_equation_in_class: (Absyn.Class, 
				     Absyn.ComponentRef, 
				     Absyn.ComponentRef)
	   => Absyn.Class =  

   rule	get_equation_list(parts) => eqlst &
	 delete_equation_in_eqlist(eqlst,c1,c2) => eqlst' &
	 replace_equation_list(parts,eqlst') => parts2 
	 ----------------------------
	 delete_equation_in_class(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file),c1,c2)
	   => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)
 end

 relation delete_equation_in_eqlist: (Absyn.EquationItem list, Absyn.ComponentRef,Absyn.ComponentRef) => Absyn.EquationItem list =

   axiom	delete_equation_in_eqlist([],_,_) => []

   rule	Absyn.cref_to_path(c1) => p1 & Absyn.path_string(p1) => s1 &
	 Absyn.cref_to_path(c2) => p2 & Absyn.path_string(p2) => s2 &
	 Absyn.cref_to_path(cn1) => pn1 & Absyn.path_string(pn1) => sn1 &
	 Absyn.cref_to_path(cn2) => pn2 & Absyn.path_string(pn2) => sn2 &
	 s1 = sn1 & s2 = sn2 &
	 delete_equation_in_eqlist(xs,c1,c2) => res
	 ---------------------
	 delete_equation_in_eqlist(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(cn1,cn2),_)::xs,c1,c2) => res

   rule	delete_equation_in_eqlist(xs,c1,c2) => res
	 ------------------------------------
	 delete_equation_in_eqlist(x::xs,c1,c2) => x::res
 end

(** relation: get_nth_connection_annotation
 **
 ** This relation takes a `ComponentRef' and a `Program' and an int and 
 ** returns a comma separated string  of values for the annotation of the 
 ** nth connection.
 **)

relation get_nth_connection_annotation: (Absyn.ComponentRef,Absyn.Program,int) 
	  => string =
	
   rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	get_nth_connectionitem_in_class(cdef,n) => citem &
	get_connection_annotation_str (citem) => s1 &
	string_append("{",s1) => s2 &
	string_append(s2,"}") => str
	--------------
	get_nth_connection_annotation(model,p,n) => str
	
  axiom	get_nth_connection_annotation(_,_,_) => "{}"
end

(** relation: get_connector_count
 **
 ** This relation takes a ComponentRef and a Program and returns the number
 ** of connector components in the class given by the classname in the 
 ** ComponentRef. A partial instantiation of the inheritance structure is 
 ** performed in order to find all connectors of the class.
 **)

relation get_connector_count: ((* Env.Env, *) Absyn.ComponentRef, 
			       Absyn.Program) 
	  => string =
	 (** A complete instantiation is far too expensive. Instead we only 
	  ** look through the components of the class for types declared using 
	  ** the "connector" restricted class keyword. We also look in
	  ** base classes  (recursively)  
	  **)

  rule	Absyn.cref_to_path(model) => modelpath &
	get_pathed_class_in_program(modelpath,p) => cdef &
	count_public_connectors(modelpath,p,cdef) => count &
	int_string(count) => countstr
	-------------------
	get_connector_count (model,p) => countstr
	
  axiom get_connector_count(_,_) => "Error"
end

(** relation: get_nth_connector
 ** This relation takes a ComponentRef and a Program and an int and returns 
 ** a string with the name of the nth
 ** connector component in the class given by ComponentRef in the Program.
 **)
		 
 relation get_nth_connector: (Absyn.ComponentRef, Absyn.Program, int) 
	  => string =

  rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_public_connector_str(modelpath,cdef,p,n) => (str,tp) &
	 Absyn.path_string tp => tpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,tpstr) => resstr
	 -----------------
	 get_nth_connector(model,p,n)=> resstr

   axiom get_nth_connector(_,_,_) => "Error"
 end

 (** relation: get_nth_connector
  **
  ** This relation takes a ComponentRef and a Program and an int and returns 
  ** a string with the name of the nth connectors icon annotation in the 
  ** class given by ComponentRef in the Program.
  **)

relation get_nth_connector_icon_annotation: (Absyn.ComponentRef, 
					     Absyn.Program, int) 
	  => string =

   rule	Absyn.cref_to_path(model) => modelpath &
	 get_pathed_class_in_program(modelpath,p) => cdef &
	 get_nth_public_connector_str(modelpath,cdef,p,n) => (resstr,tp) &
	 get_icon_annotation(tp,p) => resstr
	 --------------------------
	 get_nth_connector_icon_annotation(model,p,n)=> resstr

   axiom get_nth_connector_icon_annotation(_,_,_) => "Error"	
 end

(** relation: get_diagram_annotation
 **
 ** This relation takes a Path and a Program and returns a comma separated 
 **  string of values for the diagram annotation for the class named by the 
 ** first argument.
 **)
relation get_diagram_annotation: (Absyn.Path, Absyn.Program) => string =
	 
   rule	get_pathed_class_in_program (modelpath,p) => cdef &
	 get_diagram_annotation_in_class(cdef) => str
	 ---------------------------
	 get_diagram_annotation(modelpath,p) => str
	 
  axiom	get_diagram_annotation(_,_) => "get_diagram_annotation failed!"
end

(** relation: get_icon_annotation
 ** This relation takes a Path and a Program and returns a comma separated
 ** string of values for the icon annotation for the class named by the 
 ** first argument. 	
 **)

 relation get_icon_annotation: (Absyn.Path, Absyn.Program) => string =

    rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_icon_annotation_in_class(cdef) => str
	 -----------------------------------------
	 get_icon_annotation(modelpath,p) => str
   axiom get_icon_annotation(_,_) => ""
 end

 (** relation: get_packages_in_path
  **
  ** This relation takes a Path and a Program and returns a list of the 
  ** names of the packages found in the Path.
 **)

 relation get_packages_in_path: (Absyn.Path,Absyn.Program) => string =

   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_packages_in_class(modelpath,p,cdef) => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 ----------------------
	 get_packages_in_path (modelpath,p) => res
   axiom	 get_packages_in_path(_,_) => "Error"
 end

 (** relation: get_top_packages 
  **
  ** This relation takes a Path and a Program and returns a list of the 
  ** names of the packages found in the Path.
  **)

 relation get_top_packages: (Absyn.Program) => string =

   rule	get_top_packages_in_program(p) => strlist &
	 Util.string_delimit_list(strlist,",") => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 -------------------------
	 get_top_packages(p) => res

   axiom	get_top_packages(_) => "Error"
 end

(** relation: get_top_packages_in_program
 **
 ** Helper relation to get_top_packages.
 **)

 relation get_top_packages_in_program: Absyn.Program => string list =

   axiom	get_top_packages_in_program Absyn.PROGRAM([],_) => []

   rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	 -----------------------------------------
	 get_top_packages_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_,_)::rest,w)) => id::res

   rule	get_top_packages_in_program (Absyn.PROGRAM(rest,w)) => res
	 ------------------------------------------
	 get_top_packages_in_program (Absyn.PROGRAM(_::rest,w)) => res
 end

 (** relation: get_packages_in_class
  **
  ** This relation takes a `Class' definition and a Path identifying 
  ** the class. It returns a string containing comma separated package
  ** names found in the class definition.
  **)
 relation get_packages_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) 
	  => string =

   rule	get_packages_in_parts(parts) => strlist &
	 Util.string_delimit_list(strlist,",") => res
	 -------------------------------------
	 get_packages_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,cmt),_)) => res

   rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	 get_packages_in_class(newpath,p,cdef) => res 
	 --------------------------------------------
	 get_packages_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
 end

(** relation: get_packages_in_parts
 **
 ** Helper relation to get_packages_in_class.
 **)

 relation get_packages_in_parts:(Absyn.ClassPart list ) => string list =

  axiom	get_packages_in_parts [] => []
	 
  rule	get_packages_in_elts(elts) => l1 &
	 get_packages_in_parts(rest) => l2 &
	 list_append(l1,l2) => res
	 -------------------------
	 get_packages_in_parts(Absyn.PUBLIC(elts)::rest) => res	
	 
  rule	get_packages_in_parts(rest) => res
	 -----------------------------------
	 get_packages_in_parts(_::rest) => res
 end

(** relation: get_packages_in_elts
 **
 ** Helper relation to get_packages_in_parts.
**)

relation get_packages_in_elts: (Absyn.ElementItem list) => string list =
   axiom	 get_packages_in_elts [] => []

   rule	get_packages_in_elts(rest) => res
	 --------------------------------
	 get_packages_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,Absyn.R_PACKAGE,_,_)),_,_,NONE))::rest) => id::res

   rule	get_packages_in_elts(rest) => res
	 --------------------------------
	 get_packages_in_elts (_::rest) => res
end

(** relation: get_classnames_in_path
 **
 ** Return a comma separated list of classes in a given Path.
 **)

relation get_classnames_in_path: (Absyn.Path,Absyn.Program) 
	  => string =

   rule	get_pathed_class_in_program(modelpath,p) => cdef &
	 get_classnames_in_class(modelpath,p,cdef) => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 ----------------------
	 get_classnames_in_path (modelpath,p) => res

  axiom	get_classnames_in_path(_,_) => "Error"
 end

 (** relation: get_top_classnames
  **
  ** This relation takes a Path and a Program and returns a list of
  ** the names of the packages found at the top scope.
  **)

 relation get_top_classnames: (Absyn.Program) => string =

  rule	get_top_classnames_in_program(p) => strlist &
	 Util.string_delimit_list(strlist,",") => str &
	 string_append("{",str) => s1 &
	 string_append(s1,"}") => res
	 -------------------------
	 get_top_classnames(p) => res

  axiom	get_top_classnames(_) => "Error"
 end

(** relation: get_top_classnames_in_program
 **
 ** Helper relation to get_top_classnames.
 **)

relation get_top_classnames_in_program: Absyn.Program => string list =

  axiom	get_top_classnames_in_program Absyn.PROGRAM([],_) => []

  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res 
	-----------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(Absyn.CLASS(id,_,_,_,_,_,_)::rest,w)) => id::res
	
  rule	get_top_classnames_in_program (Absyn.PROGRAM(rest,w)) => res
	------------------------------------------
	get_top_classnames_in_program (Absyn.PROGRAM(_::rest,w)) => res
end

 (** relation: get_classnames_in_class
  **
  ** This relation takes a `Class' definition and a Path identifying the
  ** class. 
  ** It returns a string containing comma separated package names found 
  ** in the class definition.
  **)

 relation get_classnames_in_class:(Absyn.Path, Absyn.Program, Absyn.Class) 
	  => string =

   rule	get_classnames_in_parts(parts) => strlist &
	 Util.string_delimit_list(strlist,",") => res
	 -------------------------------------
	 get_classnames_in_class(_,_,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => res
	 
   rule	lookup_classdef(path,inmodel,p) => (cdef,newpath) &
	 get_classnames_in_class(newpath,p,cdef) => res 
	 --------------------------------------------
	 get_classnames_in_class(inmodel,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
 end

(** relation: get_classnames_in_parts
 ** 
 ** Helper relation to get_classnames_in_class.
 **)

relation get_classnames_in_parts:(Absyn.ClassPart list ) => string list =

   axiom	get_classnames_in_parts [] => []

   rule	get_classnames_in_elts(elts) => l1 &
	 get_classnames_in_parts(rest) => l2 &
	 list_append(l1,l2) => res
	 -------------------------
	 get_classnames_in_parts(Absyn.PUBLIC(elts)::rest) => res	

   rule	get_classnames_in_parts(rest) => res
	 -----------------------------------
	 get_classnames_in_parts(_::rest) => res
 end

(** relation: get_classnames_in_elts
 **
 ** Helper relation to get_classnames_in_parts.
 **)

 relation get_classnames_in_elts: (Absyn.ElementItem list) 
	  => string list =
  
  axiom	 get_classnames_in_elts [] => []

  rule	get_classnames_in_elts(rest) => res
	 --------------------------------
	 get_classnames_in_elts ( Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(id,_,_,_,_,_,_)),_,_,NONE))::rest) => id::res

   rule	get_classnames_in_elts(rest) => res
 	 --------------------------------
	 get_classnames_in_elts (_::rest) => res
 end


 (** relation: get_base_classes
  **
  ** This relation gets all base classes of a class, NOT Recursive.
  ** It uses the environment to get the fully qualified names of the classes.
  **)

 relation get_base_classes : (Absyn.Class, Env.Env) 
	   => Absyn.ComponentRef list =

   rule	get_base_classes_from_parts(parts, env) => res 
	 -----------------------------------------
	 get_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),env) 
	   => res

  axiom	get_base_classes (_,_) => []
 end

(** relation: get_base_classes_from_parts
 **
 ** Helper relation to get_base_classes.
**)

 relation get_base_classes_from_parts: (Absyn.ClassPart list, Env.Env) 
	   => Absyn.ComponentRef list =

   rule	get_base_classes_from_elts(elts, env) => c1 &
	 get_base_classes_from_parts(rest, env) => c2 &
	 list_append(c1,c2) => res 
	 ----------------------------
	 get_base_classes_from_parts(Absyn.PUBLIC(elts)::rest, env) => res

   rule	get_base_classes_from_parts(rest, env) => res
	 ----------------------------------------
	 get_base_classes_from_parts(_::rest, env) => res

   axiom	get_base_classes_from_parts([], env) => []
 end

(** relation: get_base_classes_from_elts
 **
 ** Helper relation to get_base_classes_from_parts.
 **)

 relation get_base_classes_from_elts : (Absyn.ElementItem list, Env.Env) 
	   => Absyn.ComponentRef list =

   axiom	get_base_classes_from_elts([], env) => []

   rule	(* Inherited class is defined inside package *)
	 get_base_classes_from_elts(rest,env) => cl &
	 Lookup.lookup_class(env,path,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(path) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_to_cref(p') => cref
	 ------------------------
	 get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest, env )
	     => cref::cl

   rule	(* Inherited class defined on top level scope*)
	 get_base_classes_from_elts(rest,env) => cl &
	 Lookup.lookup_class(env,path,true) => (c,env') &
	 Env.get_env_path(env') => NONE &
	 Absyn.path_to_cref(path) => cref
	 --------------------------------
	 get_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest, env )
	     => cref::cl

   rule	get_base_classes_from_elts(rest, env) => cl
	 --------------------------------------
	 get_base_classes_from_elts (_::rest, env) => cl
 end

 (** relation: count_base_classes
  **
  ** This relation counts the number of base classes of a class
  **)

 relation count_base_classes : (Absyn.Class) 
	   => int =

   rule	count_base_classes_from_parts(parts) => res 
	 -----------------------------------------
	 count_base_classes (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) 
	   => res

   axiom	count_base_classes (_) => 0
 end

(** relation: count_base_classes_from_parts
 **
 ** Helper relation to count_base_classes.
 **)

 relation count_base_classes_from_parts: (Absyn.ClassPart list) 
	   => int =

   rule	count_base_classes_from_elts(elts) => c1 &
	 count_base_classes_from_parts(rest) => c2 &
	 int_add(c1,c2) => res
	 ----------------------------
	 count_base_classes_from_parts(Absyn.PUBLIC(elts)::rest) => res

   rule	count_base_classes_from_parts(rest) => res
	 ----------------------------------------
	 count_base_classes_from_parts(_::rest) => res

   axiom	count_base_classes_from_parts([]) => 0
 end

(** relation: count_base_classes_from_elts
 **
 ** Helper relation to count_base_classes_from_parts.
 **)

 relation count_base_classes_from_elts : (Absyn.ElementItem list) 
	   => int =

   axiom	count_base_classes_from_elts([]) => 0

   rule	(* Inherited class *)
	 count_base_classes_from_elts(rest) => cl &
	 int_add(cl,1) => res
	 ------------------------
	 count_base_classes_from_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(path,_),_,_,_))::rest )
	     => res

   rule	count_base_classes_from_elts(rest) => cl
	 --------------------------------------
	 count_base_classes_from_elts (_::rest) => cl
 end

(** relation: get_icon_annotation_in_class
 **
 ** Helper relation to get_icon_annotation.
**)

 relation get_icon_annotation_in_class : (Absyn.Class) => string =

   rule	get_icon_annotation_from_parts(parts) => annlst &
	 get_icon_annotation_str(annlst) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str 
	 ------------------------
	 get_icon_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) 
	   => str	
 end

(** relation: get_icon_annotation_from_parts
 **
 ** Helper relation to get_icon_annotation_in_class.
**)

 relation get_icon_annotation_from_parts: Absyn.ClassPart list 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_parts [] => []

   rule	get_icon_annotation_from_elts(elts) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.PUBLIC(elts)::rest) => res

   rule	get_icon_annotation_from_elts(elts) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.PROTECTED(elts)::rest) => res

   rule	get_icon_annotation_from_eqns(eqns) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.EQUATIONS(eqns)::rest) => res

   rule	get_icon_annotation_from_eqns(eqns) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.INITIALEQUATIONS(eqns)::rest) => 
	 res

   rule	get_icon_annotation_from_algs(algs) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.ALGORITHMS(algs)::rest) => res

   rule	get_icon_annotation_from_algs(algs) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(Absyn.INITIALALGORITHMS(algs)::rest) => res
   rule	get_icon_annotation_from_parts(rest) => res
	 -----------------------------------------
	 get_icon_annotation_from_parts(_::rest) => res
 end

(** relation: get_icon_annotation_from_elts
 **
 ** Helper relation to get_icon_annotation_from_parts.
 **)

 relation get_icon_annotation_from_elts: (Absyn.ElementItem list) 
	   => Absyn.ElementArg list =

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 get_icon_annotation_from_elts(Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(lst))::rest)
	   => lst
   rule	get_icon_annotation_from_elts(rest) => res
	 -----------------------------
	 get_icon_annotation_from_elts(_::rest)
	   => res
 end

(** relation: contain_icon_annotation
 ** 
 ** Helper relation to get_icon_annotation_from_elts.
 **)

 relation contain_icon_annotation: Absyn.ElementArg list => () =

   axiom	contain_icon_annotation(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),_,_)::_) => ()

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 contain_icon_annotation(_::lst) 
 end

(** relation: get_icon_annotation_from_eqns
 **
 ** Helper relation to get_icon_annotation_from_parts.
 **)

 relation get_icon_annotation_from_eqns: (Absyn.EquationItem list) 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_eqns [] => []

   rule	contain_icon_annotation(lst)
	 --------------------------------------
	 get_icon_annotation_from_eqns(Absyn.EQUATIONITEMANN(Absyn.ANNOTATION(lst))::rest)
	   => lst

   rule	get_icon_annotation_from_eqns(rest) => res
	 --------------------------------------
	 get_icon_annotation_from_eqns(_::rest) => res
 end

(** relation: get_icon_annotation_from_algs
 **
 ** Helper relation to get_icon_annotation_from_parts
 **)

 relation get_icon_annotation_from_algs: Absyn.AlgorithmItem list 
	   => Absyn.ElementArg list =

   axiom	get_icon_annotation_from_algs [] => []

   rule	contain_icon_annotation(lst)
	 -----------------------------
	 get_icon_annotation_from_algs(Absyn.ALGORITHMITEMANN(Absyn.ANNOTATION(lst))::rest) 
	 => lst
   rule	get_icon_annotation_from_algs(rest) => res
	 -----------------------------
	 get_icon_annotation_from_algs(_::rest) => res
 end

(** relation: get_icon_annotation_str
 **
 ** Helper relation to get_icon_annotation_in_class.
 **)

 relation get_icon_annotation_str: (Absyn.ElementArg list) => string =

  rule	get_annotation_string (Icon_program,Absyn.ANNOTATION([ann])) => str 
	 -----------------------------------------------
	 get_icon_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),mod,_))::_) => str

   rule	get_icon_annotation_str (xs) => str
	 -------------------------------
	 get_icon_annotation_str( _::xs) => str
 end

(** relation: get_diagram_annotation_in_class
 **
 ** Retrieve the diagram annotation as a string from the class passed as 
 ** argument.
 **)

 relation get_diagram_annotation_in_class : (Absyn.Class) => string =

   rule	get_public_list(parts) => publst &
	 get_protected_list(parts) => protlst &
	 list_append(publst,protlst) => lst &
	 get_diagram_annotation_in_elementitemlist(lst) => str
	 ----------------------------
	 get_diagram_annotation_in_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => str	
 end

 relation get_diagram_annotation_in_elementitemlist: (Absyn.ElementItem list) => string =
   axiom	get_diagram_annotation_in_elementitemlist [] => ""

   rule	get_diagram_annotation_str(annlst) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => str	
	 ----------------------------
	 get_diagram_annotation_in_elementitemlist (Absyn.ANNOTATIONITEM(Absyn.ANNOTATION(annlst))::_) => str

   rule	get_diagram_annotation_in_elementitemlist(xs) => str
	 ------------------------------------------------
	 get_diagram_annotation_in_elementitemlist(_::xs) => str
 end

(** relation: get_diagram_annotation_str
 **
 ** Helper relation to get_diagram_anonotation_in_elementitemlist.
 **)

 relation get_diagram_annotation_str: (Absyn.ElementArg list) => string =

  rule	get_annotation_string (Diagram_program,Absyn.ANNOTATION([ann])) => str 
	 -----------------------------------------------
	 get_diagram_annotation_str ( (ann as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),mod,_))::_) => str

   rule	get_diagram_annotation_str (xs) => str
	 -------------------------------
	 get_diagram_annotation_str( _::xs) => str
 end

(** relation: get_nth_public_connector_str
 **
 ** Helper relation to get_nth_connector.
 **)

 relation get_nth_public_connector_str: (Absyn.Path, Absyn.Class, Absyn.Program,  int) => (string,Absyn.Path) =

   rule	get_nth_connector_str (p, modelpath, elt, n) => (str,tp)
	 ------------------------------------------
	 get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,_),_), p, n)  
	   => (str,tp)

	 (** The rule above failed, count the number of connectors in the first public list, subtract the number 
	  ** and try the rest of the list **)
   rule	count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([Absyn.PUBLIC(elt)],cmt),file)) => c1 &
	 int_sub(n,c1) => c2 &
	 get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file),p,c2) => (str,tp)
	 --------------------------------------------------
	 get_nth_public_connector_str(modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file), p, n) => (str,tp)

   rule	get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file), p, n) => (str,tp)
	 -----------------------------------------------------
	 get_nth_public_connector_str (modelpath, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file), p, n) => (str,tp)

 end

 (** relation: get_nth_connector_str
  **
  ** This relation takes an ElementItem list and an int and  returns the name of the nth connector component
  ** in that list. 
  **)

 relation get_nth_connector_str: (Absyn.Program, Absyn.Path, Absyn.ElementItem list
				  ,int)
	   => (string, Absyn.Path) =

   rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	 get_nth_public_connector_str(newmodelpath,cdef,p,n) => (str,tp)
	 -----------------
	 get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst,n) => (str,tp)

   rule	lookup_classdef(tp,modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors(newmodelpath,p,cdef) => c1 &
	 int_sub(n,c1) => c2 &
	 get_nth_connector_str(p,modelpath,lst,c2) => (str,tp)
	 -----------------
	 get_nth_connector_str(p,modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst,n) => (str,tp) 

   rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 get_nth_compname(complst,n) => str 
	 ----------------------------------
	 get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst, n) 
	   => (str,tp)

   rule	(** Not so fast, since we lookup and instantiate two times just because this was not 
	  ** the connector we were looking for. **)
	 lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 list_length(complst) => c1 &
	 int_sub(n,c1) => newn &
	 get_nth_connector_str(p,modelpath,lst,newn) => (str,tp)
	 ---------------------------------------
	 get_nth_connector_str(p, modelpath, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst, n)
	   => (str,tp)

   rule	get_nth_connector_str(p,modelpath,lst,n) => (str,tp)
	 ---------------------------------------
	 get_nth_connector_str(p,modelpath,_::lst,n) => (str,tp)

   axiom	get_nth_connector_str(p,modelpath,[],n) => fail
 end

(** relation: get_nth_compname
 ** 
 ** Returns the nth component name from a list of ComponentItem's.
 ** Index is from 1..n.
 **)

 relation get_nth_compname: (Absyn.ComponentItem list, int) => string =

   axiom	get_nth_compname (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,_,_),_)::lst,1) => id

   rule	int_sub(n,1) => n1 &
	 get_nth_compname (xs, n1) => res
	 --------------------------------
	 get_nth_compname (_::xs,n ) => res
   axiom	get_nth_compname ([],_) => fail
 end

(** relation: count_public_connectors
 **  This relation takes a Class and counts the number of connector 
  ** components in the class. This also includes counting in inherited classes.
 **)
 relation count_public_connectors: (Absyn.Path, Absyn.Program, Absyn.Class) 
	  => int =

   rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => c1 &
	 count_connectors(modelpath,p,elt) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_public_connectors (modelpath, p,  Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file)) 
	     => res

   rule	count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => res
	 -----------------------------------------------------
	 count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file)) => res

   axiom count_public_connectors (modelpath, p, Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),file)) => 0

   rule	lookup_classdef(cname,modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors (newmodelpath,p,cdef) => res
	 --------------------------------------------------
	 count_public_connectors (modelpath,p,Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(cname,_,_,_,_),_)) => res
 end

(** relation: count_connectors
 **
 ** This relation takes a Path to the current model and a ElementItem list 
 ** and returns the number of connector components in that list.
 **)

 relation count_connectors: (Absyn.Path,Absyn.Program,Absyn.ElementItem list) 
	  => int =

   rule	lookup_classdef(tp, modelpath,p) => (cdef,newmodelpath) &
	 count_public_connectors(newmodelpath,p,cdef) => c1 &
	 count_connectors(modelpath,p,lst) => c2 &
	 int_add(c1,c2) => res
	 ---------------------
	 count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.EXTENDS(tp,_),_,_,NONE))::lst) => res

   rule	lookup_classdef(tp,modelpath,p) => (Absyn.CLASS(_,_,_,_,Absyn.R_CONNECTOR,_,_), newmodelpath) &
	 list_length(complst) => c1 &
	 count_connectors(modelpath,p,lst) => c2 &
	 int_add(c1,c2) => res
	 --------------------
	 count_connectors(modelpath, p, Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,tp,complst),_,_,NONE))::lst) => res


	 (* Rule above didn't match => element not connector components, try rest of list*)
   rule	count_connectors(modelpath, p, lst) => res 
	 ---------------------
	 count_connectors(modelpath, p, _::lst) => res

   axiom	count_connectors(_, _, []) => 0
 end

 (** relation: get_connection_annotation_str
  **
  ** This relation takes an `EquationItem' and returns a comma separated 
  ** string of values  from the flat record of a connection annotation that 
  ** is found in the `EquationItem'.
  **)

relation get_connection_annotation_str: Absyn.EquationItem => string =

   rule	create_funcargs_from_elementargs(elts) => fargs &
	 SCode.elaborate(Line_program) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
	 Static.elab_graphics_exp(env,Absyn.CALL(Absyn.CREF_IDENT("Line",[]),fargs), false (*impl*)) => (newexp,_) &	
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &
	 Exp.print_exp_str(newexp) => gexpstr 
	 -------------------------------------------------
	 get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_), SOME(Absyn.COMMENT(SOME(Absyn.ANNOTATION([Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Line",_),SOME(Absyn.CLASSMOD(elts,NONE)),_)])),_))))
	   => gexpstr

   axiom	get_connection_annotation_str(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),NONE)) => fail

end
(** relation: create_functionargs_from_elementargs
 **
 **  Trasform an ElementArg list to function argments. This is used when
 ** translating a graphical annotation to a record constructor.
 **)

relation create_funcargs_from_elementargs: Absyn.ElementArg list 
	  => Absyn.FunctionArgs =

   axiom	create_funcargs_from_elementargs([]) => Absyn.FUNCTIONARGS([],[])

   rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	 ----------------
	 create_funcargs_from_elementargs(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(id,_),SOME(Absyn.CLASSMOD(_,SOME(exp))),_)::xs)
	   => Absyn.FUNCTIONARGS(expl,Absyn.NAMEDARG(id,exp)::narg)

   rule	create_funcargs_from_elementargs(xs) => Absyn.FUNCTIONARGS(expl,narg)
	 ----------------
	 create_funcargs_from_elementargs(_::xs)
	   => Absyn.FUNCTIONARGS(expl,narg)
 end


 (**relation: get_nth_connectionitem_in_class
  **
  ** This relation takes a `Class' and  an int ane returns the nth 
  ** `EquationItem' containing a connect statement in that class.
 **)
 relation get_nth_connectionitem_in_class: (Absyn.Class, int) => Absyn.EquationItem =

   rule	get_nth_connectionitem_in_classparts(parts,n) => eq
	 -------------------------
	 get_nth_connectionitem_in_class ( Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_),n) => eq
 end

(**relation: get_nth_connectionitem_in_classparts
 **
 ** This relation takes a `ClassPart' list and an int and returns 
 ** the nth connections as an `EquationItem'.
 **)

 relation get_nth_connectionitem_in_classparts: (Absyn.ClassPart list, int) => Absyn.EquationItem =

   rule	get_nth_connectionitem_in_equations(e,n) => eq
	 -------------------------------------
	 get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

	 (* The rule above failed, subtract the number of connections in the first equation section *)
	 (* and try with the rest of the classparts*)
   rule	count_connections_in_equations(e) => c1 &
	 int_sub(n,c1)=> newn &
	 get_nth_connectionitem_in_classparts(xs,newn) => eq
	 -----------------------------------------------
	 get_nth_connectionitem_in_classparts (Absyn.EQUATIONS(e)::xs,n) => eq

   rule	get_nth_connectionitem_in_classparts(xs,n) => eq
	 --------------------------------------------
	 get_nth_connectionitem_in_classparts(_::xs,n) => eq

 end

 (** relation: get_nth_connection_in_equations
  **
  ** This relation takes  an `Equation' list and an int and 
  ** returns the nth connection as an `Equation'. If the number is 
  ** larger than the number of connections in the list, the relation fails.
 **)

 relation get_nth_connectionitem_in_equations: (Absyn.EquationItem list, int) => Absyn.EquationItem =

 axiom	get_nth_connectionitem_in_equations ((eq as Absyn.EQUATIONITEM((Absyn.EQ_CONNECT(_,_)),_))::xs,1) => eq

   rule	int_sub (n,1) => newn &
	 get_nth_connectionitem_in_equations (xs,newn) => eq
	 -----------------------------------------------
	 get_nth_connectionitem_in_equations (Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs,n) => eq

   rule	get_nth_connectionitem_in_equations (xs,n) => eq
	 --------------------------------------------
	 get_nth_connectionitem_in_equations (_::xs,n) => eq

   axiom get_nth_connectionitem_in_equations([],_) => fail
 end

 (** relation: get_connection_str
  **
  ** This relation takes an `Equation' assumed to contain a connection and 
  ** returns a comma separated string of componentreferences, e.g "R1.n,C.p" 
  ** for  connect(R1.n,C.p).
  **)

 relation get_connection_str:  Absyn.Equation => string =

  rule	Absyn.cref_to_path cr1 => p1 &
	 Absyn.cref_to_path cr2 => p2 &
	 Absyn.path_string p1 => s1 &
	 Absyn.path_string p2 => s2 &
	 string_append(s1,",") => s3 &
	 string_append(s3,s2) => str
	 ---------------------------
	 get_connection_str Absyn.EQ_CONNECT(cr1,cr2) => str
 end 

(** relation: count_connections
 **
 ** This relation takes a `Class' and returns an int with the number of 
 ** connections in the `Class'.
 **)
		 
 relation count_connections: Absyn.Class => int =

  rule	count_connections_in_classparts(parts) => count
	 -----------------------------------------------
	 count_connections Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_) 
	  => count
 end

 (** relation: count_connections_in_classparts
  **
  ** This relation takes a `ClassPart' list and returns an int with the 
  ** number of connections in that list.
  **)

 relation count_connections_in_classparts: Absyn.ClassPart list => int =

   rule	count_connections_in_equations(eqlist) => r1 &
	 count_connections_in_classparts(xs) => r2 &
	 int_add (r1,r2) => res
	 ----------------------
	 count_connections_in_classparts( Absyn.EQUATIONS(eqlist)::xs) => res

   rule	count_connections_in_classparts(xs) => res
	 ------------------------------------------
	 count_connections_in_classparts( _::xs) => res

	 axiom count_connections_in_classparts([]) => 0
 end

 (** relation: count_connections_in_equations
  **
  ** This relation takes an `Equation' list and returns  an int 
  ** with the number of connect statements in that list.
 **)

 relation count_connections_in_equations: Absyn.EquationItem list => int =

   rule	count_connections_in_equations(xs) => r1 &
	 int_add(r1,1)  => res 
	 ---------------------
	 count_connections_in_equations(Absyn.EQUATIONITEM(Absyn.EQ_CONNECT(_,_),_)::xs) => res

   rule	count_connections_in_equations(xs) => res
	 -----------------------------------------
	 count_connections_in_equations(_::xs) => res

   axiom	count_connections_in_equations([]) => 0
 end

(** relation: get_component_annotations_from_elts
 **
 ** Helper relation to get_component_annotations.
 **)

 relation get_component_annotations_from_elts: (Absyn.Element list) 
	  => string =

  rule	SCode.elaborate(Placement_program) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 get_componentitems_annotations(comps,env) => res &
	 Util.string_delimit_list(res,",") => res'
	 ------------------------------------------------
	 get_component_annotations_from_elts(comps) => res'
 end

(** relation: get_componentitems_annotations
 **
 ** Helper relation to get_component_annotations_from_elts
 **)
		   
 relation get_componentitems_annotations: (Absyn.Element list, Env.Env) 
	   => string list =

  axiom	get_componentitems_annotations([],_) => []

  rule	get_componentitems_annotations_from_items(items,env)
	  => res1 &
	   get_componentitems_annotations(rest,env) => res2 &
	 list_append(res1,res2) => res
	 ------------------------
	 get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,items),_,_,_)::rest,env) 
	  => res
  rule	get_componentitems_annotations(rest,env) => res2 &
	 list_append(["{}"],res2) => res
	 ------------------------
	 get_componentitems_annotations(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,_),_,_,_)::rest,env) 
	  => res
	   
  rule	get_componentitems_annotations(rest,env) => res 
	 ------------------------
	 get_componentitems_annotations(_::rest,env) => res
 end

(** relation: get_componentitems_annotations_from_items
 **
 ** Helper relation to get_componentitems_annotations.
 **)

 relation get_componentitems_annotations_from_items: (Absyn.ComponentItem list,
					   Env.Env) 
	   => string list =

   axiom	get_componentitems_annotations_from_items ([],env) => []

  rule	Lookup.lookup_class(env,Absyn.IDENT("Placement"),false) => (c,env') &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false) => mod' &
	 Mod.elab_mod(env',Prefix.NOPRE,mod',false) => mod'' &
	 Inst.inst_class(env', mod'', Prefix.NOPRE, [], c,
		 	 [], false,Inst.TOP_CALL) 
 	  => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => gexpstr &
	 Util.string_append_list(["{",gexpstr,"}"]) => gexpstr' &

	 get_componentitems_annotations_from_items(rest,env) => res
	 -----------------------------------------------
	 get_componentitems_annotations_from_items(Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
		 Absyn.ANNOTATION(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),SOME(Absyn.CLASSMOD(mod,NONE)),_)::_)
	 ),_)))::rest,env)
	   => gexpstr'::res

   rule	get_componentitems_annotations_from_items(rest,env) => res 
	 -----------------------
	 get_componentitems_annotations_from_items (Absyn.COMPONENTITEM(_,NONE)::(rest as _::_),env) => "{},"::res

   axiom	get_componentitems_annotations_from_items ([Absyn.COMPONENTITEM(_,NONE)],env) => ["{}"]

 end

(** relation: get_component_annotation
 **
 ** This relation takes an `Element' and returns a comma separated string 
 ** of values corresponding to the flat record for a component annotation. 
 ** If several components are declared within the eleement, a list of values
 ** is given for each of them.
 **)
 
relation get_component_annotation: Absyn.Element => string =

   rule	get_componentitems_annotation(lst) => str
	 -----------------------------------------
	 get_component_annotation(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,NONE)) => str
	 axiom get_component_annotation _ => ""
 end 

(** relation: get_componentitems_annotation
 **
 ** Helper relation to get_component_annotation.
**)

 relation get_componentitems_annotation: Absyn.ComponentItem list => string =

   rule	get_annotation_string(Placement_program, Absyn.ANNOTATION(mod)) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"},") => s3 &
	 get_componentitems_annotation(rest) => str &
	 string_append(s3,str) => res
	 ----------------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
		 Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Placement",_),_,_)::_)
	 ),_)))::(rest as (_::_))) => res

   rule	get_annotation_string(Placement_program, Absyn.ANNOTATION(mod)) => s1 &
	 string_append("{",s1) => s2 &
	 string_append(s2,"}") => res 
	 ----------------------------
	 get_componentitems_annotation ([Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(SOME(
	 Absyn.ANNOTATION(mod as Absyn.MODIFICATION(_,_, Absyn.CREF_IDENT("Placement",_),_,_)::_)
	 ),_)))]) => res

   rule	get_componentitems_annotation(rest) => str &
	 string_append("{nada},",str) => res
	 -----------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,SOME(Absyn.COMMENT(NONE,_)))::(rest as (_::_))) => res

   rule	get_componentitems_annotation(rest) => str &
	 string_append("{},",str) => res
	 -----------------------
	 get_componentitems_annotation (Absyn.COMPONENTITEM(_,NONE)::(rest as (_::_))) => res

   rule	let res = "{}"
	 -----------------------
	 get_componentitems_annotation ([Absyn.COMPONENTITEM(_,NONE)]) => res
 end

 (** relation: get_component_modification
  **
  ** This relation takes an `Element' and returns a comma separated list of 
  ** Code expression for the modification of the component.
 **)
 relation get_component_modification: Absyn.Element => string =

   rule	get_componentitems_modification(lst) => str
	 -----------------------------------------
	 get_component_modification(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,NONE)) => str
	 axiom get_component_modification _ => ""
 end

(** relation: get_componentitems_modification
 **
 ** Helper relation to get_component_modification.
 **)

 relation get_componentitems_modification: Absyn.ComponentItem list => string =

   rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => s1 &
	 get_componentitems_modification(rest) => s2 &
	 Util.string_append_list([s1,",",s2]) => res
	 -------------------------------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_)::(rest as (_::_))) => res

   rule	Dump.print_exp_str Absyn.CODE(Absyn.C_MODIFICATION(mod)) => res
	 -------------------------------------------------------------
	 get_componentitems_modification ([Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,SOME(mod)),_)]) => res

   rule	get_componentitems_modification(rest) => str &
	 string_append("Code(),",str) => res
	 -----------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_)::(rest as (_::_))) => res

   rule	get_componentitems_modification(rest) => str &
	 string_append("Code(),",str) => res
	 -----------------------
	 get_componentitems_modification (Absyn.COMPONENTITEM(Absyn.COMPONENT(_,_,NONE),_)::(rest as (_::_))) => res

   rule	let res = "Code()"
	 -----------------------
	 get_componentitems_modification ([Absyn.COMPONENTITEM(_,NONE)]) => res
 end


 (** relation_ get_annotation_string
  **
  ** This relation takes an annotation and returns a comma separates string 
  ** of values representing the flat record of the specific annotation.
  ** The relation as two special rules for handling of Icon and Diagram 
  ** annotations since these two contain graphic primitives, which must be
  ** handled specially because Modelica does not have the possibility to store 
  ** polymorphic values (e.g. different record classes with the same baseclass)
  ** in for instance an array.
 **)

 relation get_annotation_string: (Absyn.Program,Absyn.Annotation) => string =

   rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &

	 SCode.elaborate(p) => p' &
	 Inst.make_simple_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	 get_class_in_program("Icon",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &	
	 Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &

	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str  &
	 Static.elab_graphics_exp(env,graphicexp,false (*impl*) ) => (graphicexp2,prop) &
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &

	 Exp.print_exp_str(graphicexp2) => gexpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,gexpstr) => totstr
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

	 (* First line in the first rule above fails if return value from strip_graphics_modification doesn't match the rhs of => *)
   rule	strip_graphics_modification(mod) => (stripmod, gxmods) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	 SCode.elaborate(p) => p' &
	 Inst.make_simple_env_from_program(p',Absyn.IDENT("Icon")) => env  & 
	 get_class_in_program("Icon",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',true) => mod'' &	
	 Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str 
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Icon",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => str


   rule	strip_graphics_modification(mod) => (stripmod,[Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(_,SOME(graphicexp))),_)]) &
	 SCode.build_mod(SOME(Absyn.CLASSMOD(stripmod,NONE)),false) => mod' &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("Diagram")) => env  & 
	 get_class_in_program("Diagram",p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &
	 Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _,cs, t, state) &

	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str  &

	 Static.elab_graphics_exp(env,graphicexp,false (*impl*)) => (graphicexp2,prop) &
	 (* this is to clear the error-msg generated by the annotations. *)
	 Print.clear_error_buf() &
	 Exp.print_exp_str(graphicexp2) => gexpstr &
	 string_append(str,",") => s1 &
	 string_append(s1,gexpstr) => totstr
	 -----------------------------------
	 get_annotation_string(p,Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("Diagram",_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => totstr

   rule	SCode.build_mod(SOME(Absyn.CLASSMOD(mod,NONE)),false) => mod' & 
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT(anncname)) => env  & 
	 get_class_in_program(anncname,p) => placementc &
	 SCode.elab_class(placementc) => placementclass &
	 Mod.elab_mod (env,Prefix.NOPRE,mod',false) => mod'' &
	 Inst.inst_class(env, mod'', Prefix.NOPRE, [], placementclass,
			 [], false,Inst.TOP_CALL) 
	   => (dae, _, cs, t, state) &
	 (* Put bindings of variables as expressions inside variable elements of the dae instead of equations *)
	 Inst.init_vars_modelica_output dae => dae' &
	 DAE.get_variable_bindings_str dae' => str 
	 -----------------------------------------
	 get_annotation_string(p, Absyn.ANNOTATION([(Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT(anncname,_),SOME(Absyn.CLASSMOD(mod,_)),_))])) => str

   rule	Print.print_buf "get_annotation_string failed!\n"
	 ---------------------------------------
	 get_annotation_string(_,_) => fail
 end

 (** relation: strip_graphics_modification
  ** 
  ** This relation strips out the `graphics' modification from an ElementArg 
  ** list and return two lists, one with the other modifications and the 
  ** second with the `graphics' modification
 **)

 relation strip_graphics_modification: (Absyn.ElementArg list) => (Absyn.ElementArg list, Absyn.ElementArg list) =

   axiom	strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,Absyn.CREF_IDENT("graphics",_),_,_))::rest) => (rest, [mod])

   rule	strip_graphics_modification(rest) => (l1,l2) 
	 ------------------------------------------
	 strip_graphics_modification((mod as Absyn.MODIFICATION(_,_,_,_,_))::rest) => (mod::l1,l2)

   axiom	strip_graphics_modification([]) => ([],[])
 end


 (** relation: get_components_in_class
  ** 
  ** Both public and protected lists are searched.
 **)
relation get_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in public list *)
   rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	 get_components_in_elementitems(elts) => lst2 &
	 list_append(lst2,lst1) => res
	 ------------------------------
	 get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file)) => res

   (* Search in protected list *)
   rule	get_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	get_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file)) => res

  axiom	get_components_in_class(_) => []
 end

 (** relation: get_public_components_in_class
  ** 
  ** Public lists are searched.
 **)
relation get_public_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in public list *)
   rule	get_public_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	 get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file)) => res

   rule	get_public_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) 
	  => res
	------------------------------
	get_public_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file)) => res

  axiom	get_public_components_in_class(_) => []
 end

 (** relation: get_protected_components_in_class
  ** 
  ** Protected lists are searched.
 **)
relation get_protected_components_in_class: (Absyn.Class) => Absyn.Element list =

  axiom	 get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

   (* Search in protected list *)
   rule	get_protected_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	get_components_in_elementitems(elts) => lst2 &
	list_append(lst2,lst1) => res
	------------------------------
	 get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file)) => res

   rule	get_protected_components_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) 
	  => res
	------------------------------
	get_protected_components_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file)) => res

  axiom	get_protected_components_in_class(_) => []
 end

(** relation: get_components_in_elementitems
 **
 ** Helper relation to get_components_in_class.
 **)
		   
 relation get_components_in_elementitems: (Absyn.ElementItem list) 
	   => Absyn.Element list =

   axiom	get_components_in_elementitems([]) => []

   rule	get_components_in_elementitems(rest) => res
	 -------------------------------------------
	 get_components_in_elementitems(Absyn.ELEMENTITEM(elt)::rest) 
	   => elt::res

   rule	get_components_in_elementitems(rest) => res
	 -------------------------------------------
	 get_components_in_elementitems(_::rest) => res
end

(** relation: get_nth_component_in_class
 **
 ** Returns the nth Component of a class. Indexed from 1..n.
 **)

relation get_nth_component_in_class:  (Absyn.Class,int) => Absyn.Element =

   rule	count_components_in_elts(elt) => count &
	 int_le(n,count) => true &
	 get_nth_component_in_elementitems(elt,n) => res
	 -----------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt),file),n) 
	     => res

	     (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	     (* subtract and try next public list *)
   rule	count_components_in_elts(elt) => c1 &
	 int_sub(n,c1) => newn &
	 int_string(newn) => newnstr &
	 int_gt(newn,0) =>  true &
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt),file),newn) => res
	 ------------------------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elt)::rest,cmt),file),n) => res

   rule	get_nth_component_in_elementitems(elt,n) => res
	 -----------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt),file),n) 
	     => res

	     (* The rule above failed, i.e the nth number is larger than # elements in first public list *)
	     (* subtract and try next public list *)
   rule	count_components_in_elts(elt) => c1 &
	 int_sub(n,c1) => newn &
	 int_gt(newn,0) => true &
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt),file),newn) => res
	 ------------------------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elt)::rest,cmt),file),n) => res

   rule	get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file),n) => res
	 -----------------------------------------------------------------------
	 get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::lst,cmt),file),n) => res

   axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),file),_) => fail
   axiom get_nth_component_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.DERIVED(_,_,_,_,_),file),_) => fail

 end

 (** relation: get_elementitems_in_class
  ** 
  ** Both public and protected lists are searched.
 **)

 relation get_elementitems_in_class: (Absyn.Class) => Absyn.ElementItem list =

   axiom	 get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS([],cmt),_)) => []

	 (* Search in public list *)
   rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	 list_append(elts,lst1) => lst 
		 ------------------------------
	     get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PUBLIC(elts)::lst,cmt),file)) => lst

	 (* Search in protected list *)
   rule	get_elementitems_in_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(lst,cmt),file)) => lst1 &
	 list_append(elts,lst1) => lst 
	     ------------------------------
	     get_elementitems_in_class (Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(Absyn.PROTECTED(elts)::lst,cmt),file)) => lst

   axiom get_elementitems_in_class(_) => []
 end

 (** relation: get_nth_component_in_elementintems 
  **
  ** This relation takes an `ElementItem' list and and integer and returns 
  ** the nth component in the list, indexed from 1..n.
 **)

 relation get_nth_component_in_elementitems: (Absyn.ElementItem list, int) 
	   => Absyn.Element =

   axiom	get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,elt::_),g,h,i))::_,1) 
	   => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),g,h,i)

   rule	list_length(lst) => numcomps &
	 int_gt(n,numcomps) => true &
	 int_sub(n,numcomps) => newn &
	 get_nth_component_in_elementitems(rest,newn) => res
	 ---------------------------------------------------
	 get_nth_component_in_elementitems(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,_,lst),_,_,_))::rest,n) => res

   rule	list_length(lst) => numcomps &
	 int_le(n,numcomps) => true &
	 int_sub(n,1) => n' &
	 list_nth(lst,n') => elt
	 -----------------------------
	 get_nth_component_in_elementitems(Absyn.ELEMENTITEM(elt as Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,lst),g,h,i))::rest,n) 
	   => Absyn.ELEMENT(a,b,c,d,Absyn.COMPONENTS(e,f,[elt]),g,h,i)

   rule	get_nth_component_in_elementitems(rest,n) => res
	 ------------------------------------------------
	 get_nth_component_in_elementitems(_::rest,n) => res

  axiom	get_nth_component_in_elementitems([],_) => fail
 end

(** relation: get_components_info
 **
 ** Helper relation to get_components.
 ** Return all the info as a comma separated list of values.

 ** get_component_info => {{name, type, comment, access, final, flow, 
 ** replaceable, variability,innerouter,vardirection},..}
 ** where access is one of: "public", "protected"
 ** where final is one of: true, false
 ** where flow is one of: true, false
 ** where replaceable is one of: true, false
 ** where variability is one of: "constant", "parameter", "discrete" 
 **  or "unspecified"
 ** where innerouter is one of: "inner", "outer", ("innerouter") or "none"
 ** where vardirection is one of: "input", "output" or "unspecified".
 **)

 relation get_components_info: (Absyn.Element list,
				string, (* "public" or "protected" *)
				Env.Env)
	  => string =

 rule	get_components_info2(elts,access,env) => (lst as _::_) &
	 Util.string_delimit_list(lst,"},{") => lst' &
	 Util.string_append_list(["{",lst',"}"]) => res
	 -----------------------------------------------
	 get_components_info(elts,access,env) => res
  axiom	get_components_info(_,_,_) => ""
 end

(** relation: get_components_info2
 **
 ** Helper relation to get_components_info
 **)

 relation get_components_info2: (Absyn.Element list, 
				 string, (* "public" or "protected" *)
				 Env.Env) => string list =
   axiom	get_components_info2([],_,_) => []

   rule	get_component_info(elt,access,env) => lst1 &
	 get_components_info2(rest,access,env) => lst2 &
	 list_append(lst1,lst2) => res
	 ----------------------------------------------------------
	 get_components_info2(elt::rest,access,env) => res
 end

 (** relation: get_component_info
  **
  ** This relation takes an `Element' and returns a list of strings 
  ** of comma separated values of the 
  **  type and name and comment, and attributes of  of the component, 
  ** If Element is not a component, the empty string is returned
 **)
 relation get_component_info: (Absyn.Element,
			       string, (* "public" or "protected" *)
			       Env.Env) 
	   => string list =

   rule	Lookup.lookup_class(env,p,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(p) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_string(p') => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst &
	 Util.bool_string(f) => final &
	 Util.bool_string(r) => repl &
	 inner_outer_str(inout) => inout_str &
	 attr_flow_str(attr) => flow_str &
	 attr_variability_str(attr) => variability_str &
	 attr_direction_str(attr) => dir_str &
	 Util.string_delimit_list([access,final,flow_str,repl,variability_str,
				   inout_str,dir_str],", ") => str &
	 suffix_infos(lst,str) => lst' 
	 --------------------------------------
	 get_component_info(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_,_),access,env) => lst'

	 rule	Absyn.path_string(p) => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst &
	 Util.bool_string(f) => final &
	 Util.bool_string(r) => repl &
	 inner_outer_str(inout) => inout_str &
	 attr_flow_str(attr) => flow_str &
	 attr_variability_str(attr) => variability_str &
	 attr_direction_str(attr) => dir_str &
	 Util.string_delimit_list([access,final,flow_str,repl,variability_str,
				   inout_str,dir_str],", ") => str &
	 suffix_infos(lst,str) => lst' 
	 -------------------------------------------
	 get_component_info(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_,_),access,env) => lst'

	 axiom	get_component_info(_,_,env) => []

   rule	print "get_component_info failed\n"
	 -------------------------------------------
	 get_component_info(_,_,_) => fail
 end

 (** relation: get_component_info_old
  **
  ** This relation takes an `Element' and returns a list of strings 
  ** of comma separated values of the 
  **  type and name and comment of the component, e.g. 'Resistor,R1, "comment"' 
  ** or 'Resistor,R1,"comment1",R2,"comment2"'
  ** If Element is not a component, the empty string is returned
 **)
 relation get_component_info_old: (Absyn.Element,
			       Env.Env) 
	   => string list =

   rule	Lookup.lookup_class(env,p,true) => (c,env') &
	 Env.get_env_path(env') => SOME(envpath) &
	 Absyn.path_last_ident(p) => tpname &
	 Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	 Absyn.path_string(p') => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst 
	 --------------------------------------
	 get_component_info_old(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_,_),env) => lst

	 rule	Absyn.path_string(p) => typename &
	 get_componentitems_name(lst) => names &
	 prefix_typename(typename,names) => lst 
	 -------------------------------------------
	 get_component_info_old(Absyn.ELEMENT(f,r,inout,_,Absyn.COMPONENTS(attr,p,lst),_,_,_),env) => lst

	 axiom	get_component_info_old(_,env) => []

   rule	print "get_component_info_old failed\n"
	 -------------------------------------------
	 get_component_info_old(_,_) => fail
 end

(** relation: inner_outer_str
 **
 ** Helper relation to get_component_info, retrieve the inner outer string.
 **)
 relation inner_outer_str: Absyn.InnerOuter => string =

  axiom	inner_outer_str (Absyn.INNER) =>  "\"inner\""
  axiom	inner_outer_str (Absyn.OUTER) => "\"outer\""
  axiom	inner_outer_str (Absyn.UNSPECIFIED) => "\"none\""
end
	
(** relation: attr_flow_str
 **
 ** Helper relation to get_component_info, retrieve flow attribite as bool 
 ** string.
 **)

 relation attr_flow_str: (Absyn.ElementAttributes) => string =
	 
  rule	Util.bool_string(f) => res
	----------------------
	 attr_flow_str(Absyn.ATTR(f,_,_,_)) => res
 end

(** relation: attr_variability_str
 **
 ** Helper relation to get_component_info, retrieve variability as a 
 ** string.
 **)
		   
 relation attr_variability_str: (Absyn.ElementAttributes) => string =

  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.VAR,_,_)) => "\"unspecified\""
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.DISCRETE,_,_)) 
	  => "\"discrete\""  
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.PARAM,_,_)) 
	  => "\"parameter\"" 
  axiom	attr_variability_str(Absyn.ATTR(_,Absyn.CONST,_,_)) 
	  => "\"constant\""
 end
	
(** relation: attr_direction_str
 **
 ** Helper relation to get_component_info, retrieve direction as a 
 ** string.
 **)
		   
 relation attr_direction_str: (Absyn.ElementAttributes) => string =

  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.INPUT,_)) => "\"input\""
  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.OUTPUT,_)) => "\"output\""
  axiom	attr_direction_str(Absyn.ATTR(_,_,Absyn.BIDIR,_)) => "\"unspecified\""

 end


(** relation: suffix_infos
**
 ** Helper relation to get_component_info. Add suffix info to 
 ** element names, etc.
 **)
		   
		   
 relation suffix_infos: (string list ,string) => string list =

  axiom	suffix_infos ([],_) => []
	 
  rule	suffix_infos(rest,suffix) => res &
	 Util.string_append_list([str,", ",suffix]) => str'
	 ---------------------
	 suffix_infos(str::rest,suffix) => str'::res 
 end

(** relation: prefix_typename 
 **
 ** Helper relation to get_component_info. Add a prefix typename to each
 ** string in the list.
 **)

 relation prefix_typename: (string, string list) => string list =
   axiom	prefix_typename (_,[]) => []

   rule	prefix_typename(tp,rest) => res &
	 Util.string_append_list([tp,",",str]) => str'
	 ---------------------
	 prefix_typename(tp,str::rest) => str'::res
 end


 (** relation_get_componentitems_name
  **
  ** This relation takes a `ComponentItems' list and returns a 
  ** comma separated list of all
  ** component names and comments (if any).
 **)

 relation get_componentitems_name: Absyn.ComponentItem list => string list =

   rule	string_append(c1,",") => s1 &
	 get_componentitems_name(c2::rest) => lst &
	 Util.string_append_list([s1,"\"",s2,"\""]) => str
	 ----------------------------
	 get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),SOME(Absyn.COMMENT(_,SOME(s2))))::(c2::rest)) => str::lst

   rule	string_append(c1,",") => s1 &
	 get_componentitems_name(c2::rest) => lst &
	 Util.string_append_list([s1,"\"\""]) => str
	 ----------------------------
	 get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),NONE)::(c2::rest)) => str::lst

   rule	get_componentitems_name(rest) => res
	 ------------------------------------
	 get_componentitems_name(_::rest) => res

   rule	Util.string_append_list([c1,",\"",s2,"\""]) => res
	 ----------------------
	 get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),SOME(Absyn.COMMENT(_,SOME(s2))))]) => [res]

   rule  Util.string_append_list([c1,",\"\""]) => res
	 ---------------------------------------
	 get_componentitems_name([Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),_)]) => [res]

  axiom	get_componentitems_name([_]) => []
 end

 (** relation: add_to_public
  **
  ** This relation takes a 'Class' definition and adds an `ElementItem' to the first public list in the class.
  ** If no public list is available in the class one is created.
  **)

 relation add_to_public: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

   rule	get_public_list(parts) => publst &
	 list_append(publst,[eitem]) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 --------------------------------------------
	 add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)

   axiom	add_to_public ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file),eitem) => fail

   axiom	add_to_public(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PUBLIC([eitem])::parts,cmt),file)

 end

 (** relation: add_to_protected
  **
  ** This relation takes a 'Class' definition and adds an `ElementItem' to 
  ** the first protected list in the class.
  ** If no protected list is available in the class one is created.
  **)

 relation add_to_protected: (Absyn.Class, Absyn.ElementItem) => Absyn.Class = 

   rule	get_protected_list(parts) => protlst &
	 list_append(protlst,[eitem]) => protlst2 &
	 replace_protected_list(parts,protlst2) => parts2 
	 --------------------------------------------
	 add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)

   axiom	add_to_protected ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file),eitem) => fail

   axiom	add_to_protected(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(Absyn.PROTECTED([eitem])::parts,cmt),file)

 end

 (** relation: add_to_equation
  ** This relation takes a 'Class' definition and adds an `EquationItem' to 
  ** the first equation list in the class.
  ** If no public list is available in the class one is created.
  **)

 relation add_to_equation: (Absyn.Class, Absyn.EquationItem) => Absyn.Class = 

   rule	get_equation_list(parts) => eqlst &
	 let eqlst2 = eitem::eqlst &
	 replace_equation_list(parts,eqlst2) => parts2 
	 --------------------------------------------
	 add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file), eitem) 
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts2,cmt),file)

   axiom	add_to_equation ( Absyn.CLASS(i,p,f,e,r,Absyn.DERIVED(_,_,_,_,_),file),eitem) => fail

   rule	(* Add the equations last, to make nicer output if public section present *)
	 list_append(parts,[Absyn.EQUATIONS([eitem])]) => newparts
	 ------------------
	 add_to_equation(Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(parts,cmt),file),eitem)
	     => Absyn.CLASS(i,p,f,e,r,Absyn.PARTS(newparts,cmt),file)
 end


 (** relation: replace_class_in_program
  **
  ** This relation takes a `Class' and a `Program' and replaces the class 
  ** definition at the top level in the program by the class definition of 
  ** the `Class'.
  **)

 relation replace_class_in_program: (Absyn.Class, Absyn.Program) => Absyn.Program =
   axiom replace_class_in_program(c, Absyn.PROGRAM([],w)) => Absyn.PROGRAM([c],w)
   rule	name1 = name2
	 -------------
	 replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_,_),Absyn.PROGRAM(Absyn.CLASS(name2,_,_,_,_,_,_)::clst,w))
	     => Absyn.PROGRAM(c::clst,w)

   rule	not name1 = name2 &
	 replace_class_in_program(c, Absyn.PROGRAM(clst,w)) => Absyn.PROGRAM(newclst,w)
	 -------------------------------------------------------
	 replace_class_in_program(c as Absyn.CLASS(name1,_,_,_,_,_,_),
	     Absyn.PROGRAM((c1 as Absyn.CLASS(name2,_,_,_,_,_,_))::clst,w)) 
	     => Absyn.PROGRAM(c1::newclst,w)

   rule	Print.print_buf "replace_class_in_program failed \n class:" &
	 Debug.fcall ("dump", Dump.dump, Absyn.PROGRAM([c],Absyn.TOP)) &
	 Print.print_buf "\nprogram: \n" &
	 Debug.fcall ("dump", Dump.dump, p)
	 ----------------------------
	 replace_class_in_program(c,p) => fail
 end

 (** relation: insert_class_in_program 
  **
  ** This relation inserts the class into the Program at the scope given by the
  ** within argument. If the class referenced by the within argument is not 
  ** defined, the relation prints an error message and fails.
  **)

 relation insert_class_in_program: (Absyn.Class, Absyn.Within, Absyn.Program) => Absyn.Program =

   rule	get_class_in_program(n1,p) => c2 &
	 insert_class_in_class(c1,w,c2) => c3 &
	 update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	 -------------------------------------------------
	 insert_class_in_program(c1,w as Absyn.WITHIN(Absyn.QUALIFIED(n1,_)),p) => pnew

   rule	get_class_in_program(n1,p) => c2 &
	 insert_class_in_class(c1,w,c2) => c3 &
	 update_program(Absyn.PROGRAM([c3],Absyn.TOP),p) => pnew
	 -------------------------------------------------
	 insert_class_in_program(c1, w as Absyn.WITHIN(Absyn.IDENT(n1)),p) => pnew

   rule	print "Error inserting in class. (" & Dump.unparse_within(0, w) => s1 & print s1 
	 & print ") program = \n" (*& Dump.unparse_str p => pstr & print pstr & print "\n"  *)
	 -------------------
	 insert_class_in_program(c1 as Absyn.CLASS(name,_,_,_,_,_,_),w,p) => fail	
 end

 (** relation: insert_class_in_class
  ** 
  ** This relation takes a class to update (the first argument)  and an inner 
  ** class (which is either replacing
  ** an earlier class or is a new inner definition) and a within statement
  ** pointing inside the class (including the class itself in the reference), 
  ** and updates the class with the inner class.
  **)

 relation insert_class_in_class: (Absyn.Class, Absyn.Within, Absyn.Class) 
	  => Absyn.Class =

   rule	replace_inner_class(c1,c2) => cnew  
	 ----------------------------------
	 insert_class_in_class(c1,Absyn.WITHIN(Absyn.IDENT(name)),c2) => cnew

   rule  get_first_ident_from_path(path) => name2 &
	 get_inner_class(c2,name2) => cinner &
	 insert_class_in_class(c1,Absyn.WITHIN(path),cinner) => cnew &
	 replace_inner_class(cnew,c2) => cnew' 
	 ---------------------------------------------
	 insert_class_in_class(c1,Absyn.WITHIN(Absyn.QUALIFIED(name,path)),c2) => cnew'

   rule	Print.print_buf "insert_class_in_class failed\n" 
	 -------------------------------------
	 insert_class_in_class(_,_,_) => fail
 end

 (** relation: get_first_ident_from_path
  **
  ** This relation takes a `Path` as argument and returns the first `Ident' 
  ** of the path.
  **)

 relation get_first_ident_from_path: Absyn.Path => Absyn.Ident =
      axiom get_first_ident_from_path (Absyn.IDENT(name)) => name
      axiom get_first_ident_from_path (Absyn.QUALIFIED(name,path)) => name
 end

 (** relation: remove_inner_class 
  **
  ** This relation takes two class definitions. The first one is the local 
  ** class that should be removed from the second one.
  **)

 relation remove_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

   rule	get_public_list(parts) => publst &
	 remove_class_in_elementitemlist(publst,c1) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 -----------------------------------------------
	 remove_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file)) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file)

   rule	Print.print_buf "Failed in remove_inner_class\n"
	 ---------------------------------------
	 remove_inner_class (_,_) => fail
 end

 (** relation: remove_class_in_elementitemlist
  **
  ** This relation takes an Element list and a Class and returns a modified 
  ** element list where the class definition of the class is removed.
  **)

 relation remove_class_in_elementitemlist: (Absyn.ElementItem list, Absyn.Class) => Absyn.ElementItem list =

   rule	remove_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not name1 = name &
	 remove_class_in_elementitemlist(xs,c) => res
	 ------------------------------------------
	 remove_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_,_)) => e1::res

   rule name1 = name 
	 -----------------------------
	 remove_class_in_elementitemlist(
	     (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_,_)),f,g,h)))::xs,
	     c2 as Absyn.CLASS(name,_,_,_,_,_,_))
	     => xs

   rule	remove_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_in_elementitemlist(c1::xs,c) => c1::res

   axiom	 remove_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),"",0,NONE))]
 end

(** relation: replace_inner_class 
 **
 ** This relation takes two class definitions. The first one is 
 ** inserted/replaced as a local class inside the second one.
 **)

 relation replace_inner_class: (Absyn.Class, Absyn.Class) => Absyn.Class =

   rule	get_public_list(parts) => publst &
	 replace_class_in_elementitemlist(publst,c1) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 -----------------------------------------------
	 replace_inner_class (c1,Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file)) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file)
   rule	Print.print_buf "Failed in replace_inner_class\n"
	 ---------------------------------------
	 replace_inner_class (_,_) => fail
 end

(** relation: replace_class_in_elementitemlist
 **
 ** This relation takes an Element list and a Class and returns a modified 
 ** element list where the class definition of the class is updated or added.
 **)

 relation replace_class_in_elementitemlist: (Absyn.ElementItem list, 
					     Absyn.Class) 
	  => Absyn.ElementItem list =

   rule	replace_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 replace_class_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not name1 = name &
	 replace_class_in_elementitemlist(xs,c) => res
	 ------------------------------------------
	 replace_class_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,_,NONE)))::xs,c as Absyn.CLASS(name,_,_,_,_,_,_)) => e1::res

   rule name1 = name 
	 -----------------------------
	 replace_class_in_elementitemlist(
	     (e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e, Absyn.CLASS(name1,_,_,_,_,_,_)),f,g,h)))::xs,
	     c2 as Absyn.CLASS(name,_,_,_,_,_,_))
	     => Absyn.ELEMENTITEM(Absyn.ELEMENT(a,b,c,d,Absyn.CLASSDEF(e,c2),f,g,h))::xs

   rule	replace_class_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 replace_class_in_elementitemlist(c1::xs,c) => c1::res

   axiom	 replace_class_in_elementitemlist([],c) => [Absyn.ELEMENTITEM(Absyn.ELEMENT(false,false,Absyn.UNSPECIFIED,"",Absyn.CLASSDEF(false,c),"",0,NONE))]
 end

(** relation: get_inner_class
 **
 ** This relation takes a class name and a class and return the inner class 
 ** definition having that name.
 **)

 relation get_inner_class: (Absyn.Class, Absyn.Ident) => Absyn.Class =
   rule	get_public_list(parts) => publst &
	 get_class_from_elementitemlist(publst,name) => c1
	 -----------------------------------------------
	 get_inner_class (Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_), name) => c1

   rule	Print.get_string => str &
	 Print.clear_buf &
	 Print.print_buf "get_inner_class failed, c:" &
	 Dump.dump Absyn.PROGRAM([c],Absyn.TOP) &
	 Print.print_buf "name :" & Print.print_buf name & 
	 Print.get_string => s1 & (*print s1 &*) Print.clear_buf & Print.print_buf str 
	 --------------
	 get_inner_class (c,name) => fail
 end

 (** relation: replace_public_list
  **
  ** This relation replaces the `ElementItem' list in the `ClassPart' list, 
  ** and returns the updated list.
 **)

 relation replace_public_list: (Absyn.ClassPart list,Absyn.ElementItem list) 
	  => Absyn.ClassPart list =

   rule	delete_public_list(rest) => rest'
	 ---------------------------------
	 replace_public_list ((lst as Absyn.PUBLIC(_))::rest,newpublst) 
	   => Absyn.PUBLIC(newpublst)::rest'

   rule	replace_public_list(xs,new) => ys
	 ---------------------------------
	 replace_public_list(x::xs,new) => x::ys

   axiom replace_public_list([],_) => []
 end

(** relation: replace_public_list
 **
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, 
 ** and returns the updated list.
 **)
		 
 relation replace_protected_list: (Absyn.ClassPart list,
				   Absyn.ElementItem list) 
	  => Absyn.ClassPart list =
	 
   rule	delete_protected_list(rest) => rest'
	 ---------------------------------
	 replace_protected_list ((lst as Absyn.PROTECTED(_))::rest,newprotlist) 
	   => Absyn.PROTECTED(newprotlist)::rest'

   rule	replace_protected_list(xs,new) => ys
	 ---------------------------------
	 replace_protected_list(x::xs,new) => x::ys

   axiom replace_protected_list([],_) => []
 end

(** relation: delete_public_list
 **
 ** Deletes all PULIC classparts from the list.
 **)

 relation delete_public_list:(Absyn.ClassPart list) 
	   => Absyn.ClassPart list =
   axiom	delete_public_list([]) => []

   rule	delete_public_list(xs) => res
	 -----------------------------
	 delete_public_list(Absyn.PUBLIC(_)::xs) => res

   rule	delete_public_list(xs) => res
	 -----------------------------
	 delete_public_list(x::xs) => x::res
 end

(** relation: delete_protected_list
**
 ** Deletes all PROTECTED classparts from the list.
 **)

 relation delete_protected_list:(Absyn.ClassPart list) 
	   => Absyn.ClassPart list =
   axiom	delete_protected_list([]) => []

   rule	delete_protected_list(xs) => res
	 -----------------------------
	 delete_protected_list(Absyn.PROTECTED(_)::xs) => res

   rule	delete_protected_list(xs) => res
	 -----------------------------
	 delete_protected_list(x::xs) => x::res
 end

 (** relation: replace_equation_list
  **
  ** This relation replaces the `EquationItem' list in the `ClassPart' list, 
  ** and returns the updated list.
 *)

 relation replace_equation_list: (Absyn.ClassPart list,
				  Absyn.EquationItem list) 
	  => Absyn.ClassPart list =

   axiom replace_equation_list ((lst as Absyn.EQUATIONS(_))::rest,newpublst) 
	   => Absyn.EQUATIONS(newpublst)::rest

   rule	replace_equation_list(xs,new) => ys
	 ---------------------------------
	 replace_equation_list(x::xs,new) => x::ys

   axiom replace_equation_list([],_) => []
 end

(** relation: get_public_list
 **
 ** This relation takes a ClassPart List and returns an appended list of 
 ** all public lists.
 **)
		 
 relation get_public_list: Absyn.ClassPart list => Absyn.ElementItem list =

  axiom	get_public_list([]) => []

   rule	get_public_list(rest) => res2 &
	 list_append(res1,res2) => res
	 -----------------------------
	 get_public_list Absyn.PUBLIC(res1)::rest => res

   rule	get_public_list(xs) => ys
	 ---------------------------
	 get_public_list(x::xs) => ys

 end

 (** relation: get_protected_list
  ** This relation takes a ClassPart List and returns an appended list of 
  ** all protected lists.
 **)

 relation get_protected_list: Absyn.ClassPart list => Absyn.ElementItem list =

   axiom	get_protected_list([]) => []

   rule	get_protected_list(rest) => res2 &
	 list_append(res1,res2) => res
	 -----------------------------
	 get_protected_list Absyn.PROTECTED(res1)::rest => res

   rule	get_protected_list(xs) => ys
	 ---------------------------
	 get_protected_list(x::xs) => ys
 end

(** relation: get_equation_list
 **
 ** This relation takes a ClassPart List and returns the first EquationItem 
 ** list of the class.
 **)
		 
 relation get_equation_list: Absyn.ClassPart list => Absyn.EquationItem list =

   axiom get_equation_list Absyn.EQUATIONS(lst)::rest => lst

   rule	get_equation_list(xs) => ys
	 ---------------------------
	 get_equation_list(x::xs) => ys

   axiom get_equation_list(_) => fail
 end


(** relation: get_class_from_elementitemlist
 **
 ** This relation takes an ElementItem list and an Ident and returns the 
 ** class definition among the element list having that identifier.
 **)

 relation get_class_from_elementitemlist: (Absyn.ElementItem list, 
					   Absyn.Ident) 
	  => Absyn.Class =

   rule	get_class_from_elementitemlist(xs,name) => res
	 ----------------------------------------------
	 get_class_from_elementitemlist(Absyn.ANNOTATIONITEM(_)::xs,name) => res

   rule	name1 = name2
	 ------------------------------
	 get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,_,NONE))::xs,name2) => c1

   rule	not name1 = name &
	 get_class_from_elementitemlist(xs,name) => res
	 ------------------------------------------
	 get_class_from_elementitemlist(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,c1 as Absyn.CLASS(name1,_,_,_,_,_,_)),_,_,NONE))::xs,name) => res

   rule	get_class_from_elementitemlist(xs,name) => res
	 ----------------------------------------------
	 get_class_from_elementitemlist(_::xs,name) => res

   axiom	 get_class_from_elementitemlist([],_) => fail
 end

(** relation: class_in_program
 **
 ** This relation takes a name and a Program and returns true if the name 
 ** exists as a top class in the program.
 **)

 relation class_in_program:(string,Absyn.Program) => bool = 

   axiom class_in_program (str,Absyn.PROGRAM([],_)) => false

   rule	not str = c1 &
	 class_in_program(str,Absyn.PROGRAM(p,w)) => res
	 -----------------------
	 class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_,_)::p,w)) => res

   axiom class_in_program (_,_) => true
 end



(** relation: get_pathed_class_in_program
 **
 ** This relation takes a `Path' and a `Program` and retrieves the class 
 ** definition referenced by the `Path' from the `Program'.
 **)

 relation get_pathed_class_in_program: (Absyn.Path, Absyn.Program) 
	  => Absyn.Class =

   rule	get_class_in_program(str,p) => c1 
	 ---------------------------------
	 get_pathed_class_in_program (Absyn.IDENT(str),p) => c1

   rule	get_class_in_program(c1,p) => c1def &
	 get_classes_in_class(Absyn.IDENT(c1),p,c1def) => classes &
	 get_pathed_class_in_program(prest,Absyn.PROGRAM(classes,w)) => res
	 ------------------------------------------------------------
	 get_pathed_class_in_program (path as Absyn.QUALIFIED(c1,prest),p as Absyn.PROGRAM(_,w)) => res
 end

(** relation: get_classes_in_class
 ** This relation takes a `Class' definition and returns a list of local 
 ** `Class' definitions of that class.
 **)
		 
 relation get_classes_in_class: (Absyn.Path, Absyn.Program,Absyn.Class) 
	  => Absyn.Class list =

   rule	get_classes_in_parts(parts)  => res
	 --------------------------
	 get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(parts,_),_)) => res

   rule	lookup_classdef(path, modelpath,p) => (cdef,newpath) &
	 get_classes_in_class(newpath,p,cdef) => res
	 --------------------------------------------
	 get_classes_in_class(modelpath,p,Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(path,_,_,_,_),_)) => res
 end

(** relation: get_classes_in_parts
 **
 ** Helper relation to get_classes_in_class.
 **)

 relation get_classes_in_parts: Absyn.ClassPart list => Absyn.Class list =

   axiom	 get_classes_in_parts [] => []	

   rule	get_classes_in_parts(rest) => l1 &
	 get_classes_in_elts(elts) => l2 &
	 list_append(l1,l2) => res
	 ------------------------
	 get_classes_in_parts (Absyn.PUBLIC(elts)::rest) => res

   rule	get_classes_in_parts(rest) => l1 &
	 get_classes_in_elts(elts) => l2 &
	 list_append(l1,l2) => res
	 ------------------------
	 get_classes_in_parts (Absyn.PROTECTED(elts)::rest) => res

   rule	get_classes_in_parts(rest) => res
	 ---------------------------------
	 get_classes_in_parts(_::rest) => res
 end

(** relation: get_classes_in_elts
 **
 ** Helper relation to get_classes_in_parts.
 **)

 relation get_classes_in_elts: Absyn.ElementItem list => Absyn.Class list =

   axiom	get_classes_in_elts [] => []

   rule	get_classes_in_elts (rest) => res
	 ---------------------------------
	 get_classes_in_elts (Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,class),_,_,NONE))::rest)
	     => class::res
   rule	get_classes_in_elts (rest) => res
	 ---------------------------------
	 get_classes_in_elts (_::rest)
	     => res
 end

 (** relation: get_class_in_program
  **
  ** This relation takes a Path and a Program and returns the class with 
  ** the name `Path'.
  ** If that class does not exist, the relation fail
 **)

 relation get_class_in_program:(string, Absyn.Program) => Absyn.Class = 

   axiom get_class_in_program (str,Absyn.PROGRAM([],_)) => fail

   rule	not str = c1 &
	 get_class_in_program(str,Absyn.PROGRAM(p,w)) => res
	 -----------------------------------------
	 get_class_in_program (str, Absyn.PROGRAM(Absyn.CLASS(c1,_,_,_,_,_,_)::p,w)) => res

   rule  str = c1name
	 ------------
	 get_class_in_program (str, Absyn.PROGRAM((c1 as Absyn.CLASS(c1name,_,_,_,_,_,_))::p,w)) => c1
 end

 (** relation: modification_to_absyn
  **
  ** This relation takes a list of `NamedArg' and returns an absyn 
  ** `Modification option'. It collects binding equation from the named 
  ** argument binding=<expr> and creates
  ** corresponding Modification option Absyn node.
  ** Future extension: add general modifiers. Problem: how to express this using named 
  ** arguments. This is not possible. Instead we need a new data type for storing AST, 
  ** and a constructor function for AST, 
  ** e.g. AST x = ASTModification(redeclare R2 r, x=4.2); // new datatype AST
  **					 // new constructor operator ASTModification
  **)

 relation modification_to_absyn: (Absyn.NamedArg list,
				  Absyn.Modification option) 
	   => Absyn.Modification option =

   rule	modification_to_absyn2(nargs) => SOME(mod)
	 --------------------------------
	 modification_to_absyn(nargs,oldmod) => SOME(mod)

   axiom	modification_to_absyn(nargs,oldmod) => oldmod
 end

(** relation: modification_to_absyn2
 **
 ** Helper relation to modification_to_absyn.
 **)

 relation modification_to_absyn2: (Absyn.NamedArg list ) 
	   => Absyn.Modification option =

   axiom	modification_to_absyn2([]) => NONE

   axiom	modification_to_absyn2(Absyn.NAMEDARG("binding",exp)::xs) 
	   => SOME(Absyn.CLASSMOD([],SOME(exp)))

   axiom	modification_to_absyn2(Absyn.NAMEDARG("modification",
					      Absyn.CODE(Absyn.C_MODIFICATION(mod)))::xs)
	   => SOME(mod)

   rule	modification_to_absyn2(xs) => res
	 --------------------------------
	 modification_to_absyn2(x::xs) => res
 end

 (** relation: annotation_list_to_absyn_comment
  **
  ** This relation takes a list of `NamedArg' and returns an absyn Comment.
  ** for instance [annotation = Placement( ...), comment="stringcomment" ] 
  ** is converted to SOME(COMMENT(ANNOTATION(Placement(...),
  **					      SOME("stringcomment")))) 
  **)

 relation annotation_list_to_absyn_comment: (Absyn.NamedArg list,
					      Absyn.Comment option) 
	   => Absyn.Comment option =

   rule	annotation_list_to_absyn_comment2(nargs) => SOME(ann)
	 ----------------
	 annotation_list_to_absyn_comment(nargs,oldann) => SOME(ann)

   axiom	annotation_list_to_absyn_comment(nargs,oldann) => oldann
 end

(** relation: annotation_list_to_absyn_comment2
 **
 ** Helper relation to annotation_list_to_absyn_comment2.
 **)

 relation annotation_list_to_absyn_comment2: (Absyn.NamedArg list) 
	  => Absyn.Comment option =

   rule	annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	 comment_to_absyn(nargs) => SOME(strcmt)
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(NONE,SOME(strcmt)))

   rule	annotation_list_to_absyn(nargs) => Absyn.ANNOTATION([]) &
	 comment_to_absyn(nargs) => NONE
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => NONE

   rule	annotation_list_to_absyn(nargs) => annotation &
	 comment_to_absyn(nargs) => strcmt
	 ----------------------------------
	 annotation_list_to_absyn_comment2(nargs) => SOME(Absyn.COMMENT(SOME(annotation),strcmt))

   axiom	annotation_list_to_absyn_comment2(_) => NONE
 end

(** relation: comment_to_absyn
 **
 ** Helper relation to annotation_list_to_absyn_comment2.
 **)

 relation comment_to_absyn: (Absyn.NamedArg list) => string option =

   axiom	comment_to_absyn(Absyn.NAMEDARG("comment",Absyn.STRING(str))::_) 
	   => SOME(str)

   rule	comment_to_absyn(rest) => res
	 --------------------
	 comment_to_absyn(_::rest) => res

   axiom	comment_to_absyn(_) => NONE
 end

(** relation: annotation_list_to_absyn
 **
 ** This relation takes a list of `NamedArg' and returns an absyn `Annotation'.
 ** for instance [annotation = Placement( ...) ] is converted to 
 ** ANNOTATION(Placement(...)) 
 **)

 relation annotation_list_to_absyn: (Absyn.NamedArg list) => Absyn.Annotation =
  axiom annotation_list_to_absyn( [] ) => Absyn.ANNOTATION([])

   rule	record_constructor_to_modification(e) => eltarg
	 ------------------------------------
	 annotation_list_to_absyn(Absyn.NAMEDARG("annotate",e)::_) => Absyn.ANNOTATION([eltarg])

   rule	annotation_list_to_absyn(al) => annres
	 --------------------------------------
	 annotation_list_to_absyn(a::al) => annres
 end

 (** relation:record_constructor_to_modification
  **
  ** This relation takes a record constructor expression and translates it 
  ** into a `ElementArg'. Since modifications must be named, only named 
  ** arguments are treated in the record constructor.
  **)

 relation record_constructor_to_modification: (Absyn.Exp ) 
	  => Absyn.ElementArg =

   rule	(* Covers the case annotate=Diagram(x=1,y=2) *)
	 Util.list_map(nargs,namedarg_to_modification) => eltarglst &
	 let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr,SOME(Absyn.CLASSMOD(eltarglst,NONE)),NONE)
	 -----------------------------------
	 record_constructor_to_modification(Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs))) => res	

   rule	(* Covers the case annotate=Diagram(SOMETHING(x=1,y=2)) *)
	 Util.list_map(nargs,namedarg_to_modification) => eltarglst &
	 record_constructor_to_modification(e) => emod &
	 let res = Absyn.MODIFICATION(false, Absyn.NON_EACH,
				      cr, SOME(Absyn.CLASSMOD(emod::eltarglst, NONE)), NONE)
	 -----------------------------------
	 record_constructor_to_modification(Absyn.CALL(cr,
						       Absyn.FUNCTIONARGS([e as Absyn.CALL(_,_)],nargs))) => res	


   rule	Print.print_buf "record_constructor_to_modification failed, exp=" & 
	 Absyn.print_absyn_exp e & Print.print_buf "\n" 
	 -------------------------
	 record_constructor_to_modification(e) => fail
 end

(** relation: namedarg_to_modification
 **
 ** This relation takes a `NamedArg' and translates it into a `ElementArg'.
 **)
		 
 relation namedarg_to_modification: (Absyn.NamedArg) => Absyn.ElementArg = 
	 
  rule	record_constructor_to_modification(c) => Absyn.MODIFICATION(_,_,_,SOME(Absyn.CLASSMOD(elts,_)),NONE) &
	 let cr' = Absyn.CREF_IDENT(id,[]) &
	 let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,cr',SOME(Absyn.CLASSMOD(elts,NONE)),NONE)
	 ----------------------------
	 namedarg_to_modification( Absyn.NAMEDARG(id,c as Absyn.CALL(cr,Absyn.FUNCTIONARGS([],nargs)))) => res

   rule	let res = Absyn.MODIFICATION(false,Absyn.NON_EACH,Absyn.CREF_IDENT(id,[]),SOME(Absyn.CLASSMOD([],SOME(e))),NONE)
	 ----------------------------------------------------------------
	 namedarg_to_modification( Absyn.NAMEDARG(id,e)) => res

   rule	Print.print_buf "- namedarg_to_modification failed\n" 
	 ----------------
	 namedarg_to_modification(_) => fail
 end

 (** relation: add_instantiated_class
  **
  ** This relation adds an instantiated class to the list of instantiated 
  ** classes. If the class path already exists, the class is replaced. 
  **)

  relation add_instantiated_class: (InstantiatedClass list, InstantiatedClass) 
	  => InstantiatedClass list =

   axiom	add_instantiated_class ([],cl) => [cl]

   rule	ModUtil.path_equal(path,path2) => true
	 ---------------------------
	 add_instantiated_class(INSTCLASS(path,dae,env)::xs, newc as INSTCLASS(path2,dae',env')) 
	   => newc::xs

   rule	ModUtil.path_equal(path,path2) => false &
	 add_instantiated_class(xs, newc) => res 
	 ---------------------------
	 add_instantiated_class((x as INSTCLASS(path,_,_))::xs, newc as INSTCLASS(path2,_,_)) 
	   => x::res
 end

(** relation: get_instantiated_class
 **
 ** This relation get an instantiated class from the list of instantiated 
 ** classes.
 **)
		 
 relation get_instantiated_class: (InstantiatedClass list, Absyn.Path) 
	  => InstantiatedClass =

   rule	ModUtil.path_equal(path,path2) => true
	 ---------------------------
	 get_instantiated_class((x as INSTCLASS(path,dae,env))::xs, path2) 
	   => x

   rule	ModUtil.path_equal(path,path2) => false &
	 get_instantiated_class(xs, path2) => res 
	 ---------------------------
	 get_instantiated_class((x as INSTCLASS(path,_,_))::xs, path2) 
	   => res
 end

 (** relation: get_contained_class_and_file
  ** author: PA
  ** 
  ** Returns the package or class in which the model is saved and the file 
  **  name it is saved in. This is used to save a model in a package when the 
  ** whole package is saved in a file.
  **)

 relation get_contained_class_and_file: (Absyn.Path, (* class name*)
					 Absyn.Program) (* program*)
	   => (Absyn.Program, (* package as a program*)
	       string) = (* filename *)

   rule	get_pathed_class_in_program(classname,p) => cdef &
	 Absyn.class_filename(cdef) => filename &
	 get_surrounding_package(classname,p) => p' &
	 remove_inner_diff_filed_classes(p') => p''
	 ---------------------------------------------------
	 get_contained_class_and_file(classname,p) => (p'',filename)
 end

 (** relation remove_inner_diff_filed_classes
  ** author: PA
  **
  ** Removes all inner classes that have different file name than the class 
  ** itself. The filename of the class is passed as argument.
  **)

 relation remove_inner_diff_filed_classes: (Absyn.Program) (* package as program. *)
	   => Absyn.Program =

   rule	Util.list_map(classlst,remove_inner_diff_filed_class) => classlst'
	 ------------------------
	 remove_inner_diff_filed_classes(Absyn.PROGRAM(classlst,within)) 
	   =>  Absyn.PROGRAM(classlst',within)
 end

 (** relation: remove_inner_diff_filed_class
  ** author: PA
  ** 
  ** Helper relation to remove_inner_diff_filed_classes, removes all local classes in class
  ** that does not have the same filename as the class iteself.
 **)

 relation remove_inner_diff_filed_class: (Absyn.Class) => Absyn.Class =


   rule	get_public_list(parts) => publst &
	 remove_class_diff_filed_in_elementitemlist(publst,file) => publst2 &
	 replace_public_list(parts,publst2) => parts2 
	 ----------------------------
	 remove_inner_diff_filed_class(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts,cmt),file)) 
	     => Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(parts2,cmt),file)
 end

(** relation: remove_class_diff_filed_in_elementitemlist
 ** author: PA 
 **
 ** This relation takes an Element list and a filename and returns a 
 ** modified element list where the elements not stored in filename is 
 ** removed.
 **)
		 
 relation remove_class_diff_filed_in_elementitemlist: (Absyn.ElementItem list, 
					    string)  (* filename *)
	   => Absyn.ElementItem list =

   rule	(* annotations are kept *)
	 remove_class_diff_filed_in_elementitemlist(xs,c) => res
	 -----------------------------------------
	 remove_class_diff_filed_in_elementitemlist((a1 as Absyn.ANNOTATIONITEM(_))::xs,c) => a1::res

   rule	not filename1 = filename2 &
	 remove_class_diff_filed_in_elementitemlist(xs,filename1) => res
	 ------------------------------------------
	 remove_class_diff_filed_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(_,_,_,_,_,_,filename2)),_,_,_)))::xs,filename1) => res

   rule  filename1 = filename2 &
	 remove_class_diff_filed_in_elementitemlist(xs,filename1) => res
	 -----------------------------
	 remove_class_diff_filed_in_elementitemlist((e1 as Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,Absyn.CLASSDEF(_,Absyn.CLASS(_,_,_,_,_,_,filename2)),_,_,_)))::xs,filename1)
	   => e1::res

   rule	remove_class_diff_filed_in_elementitemlist(xs,filename) => res
	 -----------------------------------------
	 remove_class_diff_filed_in_elementitemlist(c1::xs,filename) => c1::res

   axiom	 remove_class_diff_filed_in_elementitemlist([],filename) => []
 end


 (** relation: get_surrounding_package
  ** author: PA
  **
  ** This relation investigates the surrounding packages and returns the outermost package
  ** that has the same filename as the class
  **)

 relation get_surrounding_package: (Absyn.Path, Absyn.Program) => Absyn.Program =

   rule	get_pathed_class_in_program(classpath,p) => cdef &
	 Absyn.class_filename(cdef) => filename1 &
	 Absyn.strip_last(classpath) => ppath &
	 get_pathed_class_in_program(ppath,p) => pdef &
	 Absyn.class_filename(pdef) => filename2 &
	 filename1 = filename2  &
	 get_surrounding_package(ppath,p) => res
	 -----------------------------------------
	 get_surrounding_package(classpath,p) => res

   rule	(* No package with same filename *)
	 get_pathed_class_in_program(classpath,p) => cdef &
	 build_within(classpath) => within 
	 ----------------------------------	
	 get_surrounding_package(classpath,p) 
	   => Absyn.PROGRAM([cdef],within)
 end


(* AST for the builtin graphical classes *)

 val Graphics_program = Absyn.PROGRAM([
 Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)], NONE),"graphics.mo")
 , Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)], NONE),"graphics.mo")
 , Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)], NONE),"graphics.mo")
 , Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)], NONE),"graphics.mo")
 , Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)], NONE),"graphics.mo")
 , Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE)]), "graphics.mo", 6,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "graphics.mo", 6,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 7,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "graphics.mo", 7,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "graphics.mo", 8,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "graphics.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 9,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "graphics.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE), NONE)]), "graphics.mo", 10,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "graphics.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "graphics.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "graphics.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "graphics.mo", 11,NONE))])], NONE),"graphics.mo")
 , Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"graphics.mo")
 ],Absyn.TOP)


 val Icon_program = 

Absyn.PROGRAM([
Absyn.CLASS("GraphicItem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 1,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("CoordinateSystem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 1,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Icon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("CoordinateSystem"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("coordinateSystem",[], SOME(Absyn.CLASSMOD([(Absyn.MODIFICATION(false, Absyn.NON_EACH, Absyn.CREF_IDENT("extent", []), SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.ARRAY([Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(10.0)),Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(10.0))]),Absyn.ARRAY([Absyn.REAL(10.0),Absyn.REAL(10.0)])])))), NONE))], NONE))), NONE)]), "icon.mo", 1,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)], NONE),"icon.mo")
, Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)], NONE),"icon.mo")
, Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)], NONE),"icon.mo")
, Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)], NONE),"icon.mo")
, Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)], NONE),"icon.mo")
, Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE)]), "icon.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "icon.mo", 8,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "icon.mo", 9,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "icon.mo", 10,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "icon.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 11,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "icon.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE), NONE)]), "icon.mo", 12,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "icon.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "icon.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "icon.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "icon.mo", 13,NONE))])], NONE),"icon.mo")
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"icon.mo")
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"icon.mo")
],Absyn.TOP)

 val Diagram_program = Absyn.PROGRAM([
Absyn.CLASS("GraphicItem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 1,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("CoordinateSystem", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 1,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Diagram", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("CoordinateSystem"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("coordinateSystem",[], SOME(Absyn.CLASSMOD([(Absyn.MODIFICATION(false, Absyn.NON_EACH, Absyn.CREF_IDENT("extent", []), SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.ARRAY([Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(100.0)),Absyn.UNARY(Absyn.UMINUS, Absyn.REAL(100.0))]),Absyn.ARRAY([Absyn.REAL(100.0),Absyn.REAL(100.0)])])))), NONE))], NONE))), NONE)]), "diagram.mo", 1,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)], NONE),"diagram.mo")
, Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)], NONE),"diagram.mo")
, Absyn.CLASS("FillPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Horizontal",NONE), Absyn.ENUMLITERAL("Vertical",NONE), Absyn.ENUMLITERAL("Cross",NONE), Absyn.ENUMLITERAL("Forward",NONE), Absyn.ENUMLITERAL("Backward",NONE), Absyn.ENUMLITERAL("CrossDiag",NONE), Absyn.ENUMLITERAL("HorizontalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("VerticalCylinder",NONE), Absyn.ENUMLITERAL("Sphere",NONE)], NONE),"diagram.mo")
, Absyn.CLASS("BorderPattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Raised",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Sunken",NONE), Absyn.ENUMLITERAL("Engraved",NONE)], NONE),"diagram.mo")
, Absyn.CLASS("TextStyle", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("Bold",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Italic",NONE), Absyn.ENUMLITERAL("Underline",NONE)], NONE),"diagram.mo")
, Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE)]), "diagram.mo", 8,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "diagram.mo", 8,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Polygon", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 9,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "diagram.mo", 9,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Rectangle", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("BorderPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("borderPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("BorderPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 10,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("radius",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "diagram.mo", 10,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Ellipse", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "diagram.mo", 11,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 11,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Text", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillColor",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("FillPattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fillPattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("FillPattern", [],Absyn.CREF_IDENT("None", []))))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("lineThickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textString",[], NONE), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fontName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "diagram.mo", 12,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("TextStyle"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("textStyle",[Absyn.NOSUB], NONE), NONE)]), "diagram.mo", 12,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("Bitmap", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "diagram.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("extent",[Absyn.SUBSCRIPT(Absyn.INTEGER(2)),Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "diagram.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("fileName",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "diagram.mo", 13,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("String"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("imageSource",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.STRING(""))))), NONE)]), "diagram.mo", 13,NONE))])], NONE),"diagram.mo")
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"diagram.mo")
, Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"diagram.mo")
],Absyn.TOP)

 val Line_program = Absyn.PROGRAM([
 Absyn.CLASS("LinePattern", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Solid",NONE), Absyn.ENUMLITERAL("Dash",NONE), Absyn.ENUMLITERAL("Dot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDot",NONE), Absyn.ENUMLITERAL("DashDotDot",NONE)], NONE),"line.mo")
 , Absyn.CLASS("Arrow", false, false, false, Absyn.R_TYPE, Absyn.ENUMERATION([Absyn.ENUMLITERAL("None",NONE), Absyn.ENUMLITERAL("Open",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Filled",NONE), Absyn.ENUMLITERAL("Half",NONE)], NONE),"line.mo")
 , Absyn.CLASS("Line", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("points",[Absyn.NOSUB,Absyn.SUBSCRIPT(Absyn.INTEGER(2))], NONE), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Integer"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("color",[Absyn.SUBSCRIPT(Absyn.INTEGER(3))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.INTEGER(0),Absyn.INTEGER(0),Absyn.INTEGER(0)]))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("LinePattern"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("pattern",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.CREF(Absyn.CREF_QUAL("LinePattern", [],Absyn.CREF_IDENT("Solid", []))))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("thickness",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.25))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Arrow"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrow",[Absyn.SUBSCRIPT(Absyn.INTEGER(2))], SOME(Absyn.CLASSMOD([], SOME(Absyn.ARRAY([Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", []))),Absyn.CREF(Absyn.CREF_QUAL("Arrow", [],Absyn.CREF_IDENT("None", [])))]))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("arrowSize",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(3.0))))), NONE)]), "line.mo", 1,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("smooth",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "line.mo", 1,NONE))])], NONE),"line.mo")
 , Absyn.CLASS("test", false, false, false, Absyn.R_MODEL, Absyn.PARTS([Absyn.PUBLIC([])], NONE),"line.mo")
 ],Absyn.TOP)

 val Placement_program = Absyn.PROGRAM([
Absyn.CLASS("Transformation", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("x",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("y",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("scale",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(1.0))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("aspectRatio",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(1.0))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("flipHorizontal",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("flipVertical",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(false))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Real"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("rotation",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(0.0))))), NONE)]), "placement.mo", 2,NONE))])], NONE),"placement.mo")
, Absyn.CLASS("Placement", false, false, false, Absyn.R_RECORD, Absyn.PARTS([Absyn.PUBLIC([Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Boolean"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("visible",[], SOME(Absyn.CLASSMOD([], SOME(Absyn.BOOL(true))))), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Transformation"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("transformation",[], NONE), NONE)]), "placement.mo", 2,NONE)), Absyn.ELEMENTITEM(Absyn.ELEMENT(false, false, Absyn.UNSPECIFIED , "component", Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.BIDIR, []),Absyn.IDENT("Transformation"),[Absyn.COMPONENTITEM(Absyn.COMPONENT("iconTransformation",[], NONE), NONE)]), "placement.mo", 2,NONE))])], NONE),"placement.mo")
],Absyn.TOP)
