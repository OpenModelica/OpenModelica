(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module does static analysis on expressions.
 ** The analyzed expressions are built using the
 ** constructors in the `Exp' module from expressions defined in 'Absyn'.  
 ** Also, a set of properties of the expressions is calculated during analysis.
 ** Properties of expressions include type information and a boolean indicating if the
 ** expression is constant or not.
 ** If the expression is constant, the 'Ceval' module is used to evaluate the expression
 ** value. A value of an expression is described using the 'Values' module.

 ** The main relation in this module is 'eval_exp' which takes an Absyn.Exp and transform it 
 ** into an Exp.Exp, while performing type checking and automatic type conversions, etc.
 ** To determine types of builtin functions and operators, the module also contain an elaboration
 ** handler for functions and operators. This relation is called 'elab_builtin_handler'. 
 ** NOTE: These relations should only determine the type and properties of the builtin functions and
 ** operators and not evaluate them. Constant evaluation is performed by the 'Ceval' module.
 ** The module also contain a relation for deoverloading of operators, in the 'deoverload' relation.
 ** It transforms operators like '+' to its specific form, ADD, ADD_ARR, etc.
 **
 ** Interactive function calls are also given their types by 'elab_exp', which calls 
 ** 'elab_call_interactive'.
 **
 ** Elaboration for functions involve checking the types of the arguments by filling slots of the
 ** argument list with first positional and then named arguments to find a matching function. The 
 ** details of this mechanism can be found in the Modelica specification.
 ** The elaboration also contain function deoverloading which will be added to Modelica in the future.
 **)

module Static :

  with "Absyn.rml"
  with "Exp.rml"
  with "SCode.rml"
  with "Types.rml"
  with "Env.rml"
  with "Values.rml"
  with "Interactive.rml"

  type Ident = string


  datatype Slot = SLOT of Types.FuncArg *  (* An argument to a function *)
			  bool *	   (* True if the slot has been filled, *)
					   (* i.e. argument has been given a value*)
			  Exp.Exp option * (* Contain the elaborated expression *)
                                           (* for the actual argument *)

			  Types.ArrayDim list  (* dim_size - if argument is a 
					    * 'foreach' argument this list is 
					    * non-empty with the dimension 
					    * sizes of the argument. 
					    * See vectorized calls.
					    *)


  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp,bool,Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option)
  relation elab_graphics_exp : (Env.Env, Absyn.Exp, bool (*impl*) ) => (Exp.Exp,
							Types.Properties) 
	  (* Special relation for graphics annotations, because of inhomogenous *)
	  (* array of graphics primitives *) 
  relation elab_exp_list : (Env.Env, Absyn.Exp list,bool (* Implicit inst *)
			    , Interactive.InteractiveSymbolTable option) 
	    => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option)

  relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool (* Implicit inst *)
				 , Interactive.InteractiveSymbolTable option) 
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option)

  relation elab_cref : (Env.Env, Absyn.ComponentRef, bool (*impl*) )
	  => (Exp.Exp, Types.Properties, SCode.Accessibility)

  relation elab_subscripts : (Env.Env, Absyn.Subscript list, bool (*impl*) )
	  => (Exp.Subscript list, Types.Const)
	  
  relation canon_cref : (Env.Env, Exp.ComponentRef, bool (*impl*) ) => Exp.ComponentRef

  relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list, bool (*impl*) ) 
					  => (Exp.Exp, Types.Properties)) 
  relation elab_builtin_handler_generic : Ident => ((Env.Env, Absyn.Exp list, bool (*impl*) ) 
					  => (Exp.Exp, Types.Properties)) 

  (* Property matching (type conversions etc.) *)

  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list
	    
  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp
  relation component_ref_to_path: Exp.ComponentRef => Absyn.Path 
  relation is_function_in_cflist : ((Absyn.Path * Types.Type) list, Absyn.Path) 
	  => bool
end

with "ClassInf.rml"
with "Dump.rml"
with "Print.rml"
with "System.rml"
with "Lookup.rml"
with "Debug.rml"
with "Inst.rml"
with "Codegen.rml"
with "ModUtil.rml"
with "DAE.rml"
with "Util.rml"
with "RTOpts.rml"
with "Parser.rml"
with "ClassLoader.rml"
with "Mod.rml"
with "Prefix.rml"
with "Ceval.rml"
with "Connect.rml"

(** relation: elab_exp_list
 **
 ** Expression elaboration of Absyn.Exp list, i.e. lists of expressions.
 **)

relation elab_exp_list : (Env.Env, Absyn.Exp list, bool, Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end

(** relation: elab_exp_list_list
 **
 ** Expression elaboration of lists of lists of expressions. Used in for 
 ** instance matrices, etc.
 **)

relation elab_exp_list_list : (Env.Env, Absyn.Exp list list, bool
			       , Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list list, Types.Properties list list, Interactive.InteractiveSymbolTable option ) =

  axiom	elab_exp_list_list (_,[],impl,st) => ([],[],st)

  rule	elab_exp_list (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_list (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_list (env, e::rest,impl,st) => (exp::exps, p::props,st'') 
end


(** relation: ceval_if_constant
 **
 ** This relation calls Ceval.ceval if the Constant parameter indicates
 ** C_CONST.
 **)

relation ceval_if_constant: (Exp.Exp, Types.Properties, Types.Const, bool (* impl *), Env.Env) 
	  => (Exp.Exp, Types.Properties) =

  axiom	ceval_if_constant(e,prop,Types.C_VAR,_,_) => (e, prop)
  axiom	ceval_if_constant(e,prop,Types.C_PARAM,_,_) => (e, prop)

  axiom	ceval_if_constant(e,prop,Types.C_CONST ,impl as true,_) => (e, prop)	

  rule	Ceval.ceval(env,e,impl,NONE,NONE,Ceval.MSG) => (v,_) &
	value_exp(v) => e' &
	value_type(v) => vt
	---------------------------------
	ceval_if_constant(e,prop as Types.PROP(_,c),Types.C_CONST,impl (*as false*),env) => (e',Types.PROP(vt,c))

  rule	Ceval.ceval(env,e,impl,NONE,NONE,Ceval.MSG) => (v,_) &
	value_exp(v) => e' &
	value_type(v) => vt
	---------------------------------
	ceval_if_constant(e,prop as Types.PROP_TUPLE(_,c),Types.C_CONST,impl (*as false*),env) => (e',Types.PROP_TUPLE(vt,c))

  axiom	ceval_if_constant(e,prop,const,impl,env) => (e,prop)

end

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Types.Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

(* The types below should contain the default values of the attributes of the builtin
 * types. But since they are default, we can leave them out for now, unit="" is not 
* that interesting to find out.
*)
  axiom	elab_exp(_, Absyn.INTEGER(x),impl,st)
	  => (Exp.ICONST(x), Types.PROP((Types.T_INTEGER([]),NONE),Types.C_CONST),st)
  axiom	elab_exp(_, Absyn.REAL(x),impl,st)
	  => (Exp.RCONST(x), Types.PROP((Types.T_REAL([]),NONE), Types.C_CONST),st)
  axiom	elab_exp(_, Absyn.STRING(x),impl,st)
	  => (Exp.SCONST(x), Types.PROP((Types.T_STRING([]),NONE), Types.C_CONST),st)
  axiom	elab_exp(_, Absyn.BOOL(x),impl,st)
	  => (Exp.BCONST(x), Types.PROP((Types.T_BOOL([]),NONE), Types.C_CONST),st)

  axiom elab_exp(_,Absyn.END,impl,st)
	  => (Exp.END, Types.PROP((Types.T_INTEGER([]),NONE), Types.C_CONST),st)


  rule	elab_cref(env, cr,impl) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr),impl,st) => (exp,prop,st) 

	(**  Binary and unary operations *)

  rule	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.BINARY(e1'',op',e2''),c) => exp' &
	let prop = Types.PROP(rtype,c) &
	ceval_if_constant(exp',prop,c,impl,env) => (exp'',prop')
	---------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2),impl,st)
	  => (exp'',prop',st'')

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.UNARY(op',e''),c) => exp' &
	let prop = Types.PROP(rtype,c) &
	ceval_if_constant(exp',prop,c,impl,env) => (exp'',prop')
	---------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e),impl, st)
	  => (exp'',prop',st')
	
  rule	(* Logical binary expressions *)
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') &
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.LBINARY(e1'',op',e2''),c) => exp' &
	let prop =  Types.PROP(rtype,c) &
	ceval_if_constant(exp',prop,c,impl,env) => (exp'',prop')
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2),impl,st)
	  => (exp'',prop',st'')

  rule	(* Logical unary expressions *)
	elab_exp (env,e,impl,st) => (e',Types.PROP(t,c),st') &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype) &
	replace_operator_with_fcall(Exp.LUNARY(op',e''),c) => exp' &
	let prop = Types.PROP(rtype,c) &
	ceval_if_constant(exp',prop,c,impl,env) => (exp'',prop')
	----------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e),impl,st)
	  => (exp'',prop',st')

  rule	(* Relations, e.g. a < b *)
	elab_exp (env,e1,impl,st) => (e1', Types.PROP(t1, c1),st') &
	elab_exp (env,e2,impl,st') => (e2', Types.PROP(t2, c2),st'') & 
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype) &
	replace_operator_with_fcall(Exp.RELATION(e1'',op',e2''),c) => exp' &
	let prop = Types.PROP(rtype,c) &
	ceval_if_constant(exp',prop,c,impl,env) => (exp'',prop')
	-----------------------------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2),impl,st)
	  => (exp'',prop',st'')

	(**  Conditional expressions *)

  rule	(* if expressions *)
	elab_exp (env,e1,impl,st) => (e1', prop1,st') &
	elab_exp (env,e2,impl,st') => (e2', prop2,st'') &
	elab_exp (env,e3,impl,st'') => (e3', prop3,st''') &
	elab_ifexp(env,e1',prop1,e2',prop2,e3',prop3,impl,st) => (e,prop)
	(*TODO elseif part *)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3,_),impl,st) => (e,prop,st''')

  rule	(**  Function calls *)
	(** PA. Only positional arguments are elaborated for now.*)
	(** TODO: Implement elaboration of named arguments. *)
	Debug.fprintln("sei", "elab_exp CALL...") &
	elab_call(env,fn,args,nargs,impl,st) => (e,prop,st') &
	Types.prop_all_const prop => c &
	ceval_if_constant(e,prop,c,impl,env) => (e',prop') &
	 Debug.fprintln("sei", "elab_exp CALL done")
	--------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs)),impl,st) 
		=> (e',prop',st')


	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	(* Tuple function calls *)
	elab_tuple(env,e,impl) => (e', props) &
	split_props(props) => (types, consts) 
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e as e1::rest),impl,st) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE((Types.T_TUPLE(types),NONE), Types.TUPLE_CONST(consts)),st)

	(**  Array-related expressions *)

	(** Elab reduction expressions, including array() constructor **)

  rule	elab_call_reduction(env,fn,exp,id,iterexp,impl,st) => (e,prop,st') 
	-------------------------------------------------------------------
	elab_exp (env,Absyn.CALL(fn,Absyn.FOR_ITER_FARG(exp,id,iterexp)),impl,st) 
	  => (e,prop,st')


  rule	(* Range expressions without step value, e.g. 1:5 *)
	elab_exp (env, start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env, stop,impl,st') => (stop', Types.PROP(stop_t, c_stop),st'') &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	Types.const_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt,impl) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop),impl,st)
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const),st'')

  rule	(* Range expressions with step value, e.g. 1:0.5:4 *)
	elab_exp (env,start,impl,st) => (start', Types.PROP(start_t, c_start),st') &
	elab_exp (env,step,impl,st') => (step', Types.PROP(step_t, c_step),st'') &
	elab_exp (env,stop,impl,st'') => (stop', Types.PROP(stop_t, c_stop),st''') &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	Types.const_and (c_start, c_step) => c1 &
	Types.const_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt,impl) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop),impl,st)
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const),st''')

  rule	(* array expressions, e.g. {1,2,3} *)
	elab_array (env, es,impl,st) => (es', Types.PROP(t, const)) & list_length es' => l&
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es),impl,st)
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(l)), t),NONE),
		   const),st)
	
  rule	(* matrix expressions, e.g. [1,0;0,1] with elements of simple type.*)
	elab_exp_list_list(env,es,impl,st) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	elab_matrix_semi (env,es,impl,st,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.simple_type(t) &
	Types.elab_type t => at
	------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es),impl,st)
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 (Types.T_ARRAY(Types.DIM(SOME(dim2)), t),NONE)),NONE),
		   c),st)

  rule	(* matrix expressions, e.g. [1,0;0,1] with array elements. *)
	elab_exp_list_list(env,es,impl,st) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	elab_matrix_semi (env,es,impl,st,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	not Types.simple_type(t) &
	add_onesized_dimensions(es', tps,nmax) => es'' &
	Types.elab_type t => at
	------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es),impl,st)
	  => (Exp.MATRIX(at,nmax,es''),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 (Types.T_ARRAY(Types.DIM(SOME(dim2)), t),NONE)),NONE),
		   c),st)

  rule	(* Code expressions *)
	elab_code_type(env,c) => tp &
	Types.elab_type tp => tp'
	-------------------
	elab_exp (env, Absyn.CODE(c),impl,st) =>  (Exp.CODE(c,tp'),Types.PROP(tp,Types.C_CONST),st)

  rule	Debug.fprint("failtrace", "- elab_exp failed: ") & 
	Debug.fcallret("failtrace", Dump.print_exp_str, e, "") => expstr & 
	Debug.fprintln("failtrace", expstr) 
	-----------------------------------------------------------
	elab_exp(_,e,_,_) => fail
end 

(** relation: add_for_loop_scope_const 
 **
 ** Creates a new scope on the environment used for loops and adds a loop 
 ** variable which is named by the second argument. The variable is given 
 ** the value 1 (one) such that elaboration of expressions of containing the 
 ** loop variable become constant.
 **)
relation add_for_loop_scope_const : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope (env,false (*encapsulated?*),SOME("$for loop scope$")) => env' &
	Env.extend_frame_v(env',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						SCode.PARAM,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.VALBOUND(Values.INTEGER(1))),NONE,
			   false,
			   []) => env''
	--------------------------------------------------------------------------
	add_for_loop_scope_const(env,i,typ) => env''

end


(** relation: elab_call_reduction
 ** 
 ** This relation elaborates reduction expressions, that look like function
 ** calls. For example an array constructor.
 **)
relation elab_call_reduction : (Env.Env, Absyn.ComponentRef, Absyn.Exp,
				Ident, Absyn.Exp, bool,
				Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =


  rule	elab_exp (env,iterexp,impl,st)
	  => (iterexp', 
	      Types.PROP((Types.T_ARRAY(arraydim as Types.DIM(_), iterty),_),
			 iterconst),
	      _) &
	add_for_loop_scope_const(env,iter,iterty) => env' &
	(** const so that expr is elaborated to const **)
	elab_exp (env', exp, impl, st) => (exp', Types.PROP(expty, expconst), st) &
	Types.const_and (expconst, iterconst) => const &
	let prop = Types.PROP((Types.T_ARRAY(arraydim, expty),NONE), const) &
	Absyn.cref_to_path fn => fn'
	---------------------------------------------------
	elab_call_reduction (env,fn,exp,iter,iterexp,impl,st) 
	  => (Exp.REDUCTION (fn',exp',iter,iterexp'), prop, st)

end

(** relation: replace_operator_with_fcall
 **
 ** Replaces a userdefined operator expression with a corresponding function 
 ** call expression. Other expressions just passes through.
**)
relation replace_operator_with_fcall: (Exp.Exp,Types.Const ) => Exp.Exp =

  axiom	replace_operator_with_fcall(Exp.BINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,false))
	  
  axiom	replace_operator_with_fcall(Exp.UNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,false))

  axiom	replace_operator_with_fcall(Exp.LBINARY(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,false))

  axiom	replace_operator_with_fcall(Exp.LUNARY(Exp.USERDEFINED(funcname),e1),c) 
	  => (Exp.CALL(funcname,[e1],false,false))

  axiom	replace_operator_with_fcall(Exp.RELATION(e1,Exp.USERDEFINED(funcname),e2),c) 
	  => (Exp.CALL(funcname,[e1,e2],false,false))
	  
  axiom	replace_operator_with_fcall(e,_) => e
end

(** relation: elab_code_type
 **
 ** This relation will construct the correct type for the given Code 
 ** expression. The types are built-in classes of different types. E.g. 
 ** the class TypeName is the type
 ** of Code expressions corresponding to a type name Code expression. 
**)

relation elab_code_type: (Env.Env, Absyn.Code) => Types.Type =

  axiom	elab_code_type(env, Absyn.C_TYPENAME(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("TypeName"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_VARIABLENAME(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("VariableName"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_EQUATIONSECTION(_,_))
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("EquationSection"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_ALGORITHMSECTION(_,_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("AlgorithmSection"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_ELEMENT(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Element"),[]),NONE))
	  
  axiom	elab_code_type(env, Absyn.C_EXPRESSION(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Expression"),[]),NONE))

  axiom	elab_code_type(env, Absyn.C_MODIFICATION(_)) 
	  => ((Types.T_COMPLEX(ClassInf.UNKNOWN("Modification"),[]),NONE))

end

(** relation elab_graphics_exp
 **
 ** This relation is specially designed for elaboration of expressions when
 ** investigating Modelica 2.0 graphical annotations.
 ** These have an array of records representing graphical objects. These 
 ** elements can have different types, therefore elab_graphic_exp will allow
 ** arrays with elements of varying types. 
 **)

relation elab_graphics_exp : (Env.Env, Absyn.Exp, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_graphics_exp(_, Absyn.INTEGER(x),impl)
	  => (Exp.ICONST(x), Types.PROP((Types.T_INTEGER([]),NONE),Types.C_CONST))
  axiom	elab_graphics_exp(_, Absyn.REAL(x),impl)
	  => (Exp.RCONST(x), Types.PROP((Types.T_REAL([]),NONE),   Types.C_CONST))
  axiom	elab_graphics_exp(_, Absyn.STRING(x),impl)
	  => (Exp.SCONST(x), Types.PROP((Types.T_STRING([]),NONE), Types.C_CONST))
  axiom	elab_graphics_exp(_, Absyn.BOOL(x),impl)
	  => (Exp.BCONST(x), Types.PROP((Types.T_BOOL([]),NONE),   Types.C_CONST))

  rule	elab_cref(env, cr, impl) => (exp,prop,_)
	---------------------------------------
	elab_graphics_exp(env, Absyn.CREF(cr), impl) => (exp,prop) 

	(**  Binary and unary operations *)

  rule	elab_graphics_exp (env,e1,impl) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2,impl) => (e2', Types.PROP(t2, c2)) &
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.BINARY(e1,op,e2),impl)
	  => (Exp.BINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	elab_graphics_exp (env,e,impl) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.UNARY(op,e),impl)
	  => (Exp.UNARY(op',e''),Types.PROP(rtype,c))
	
  rule	(* Logical binary expressions *)
	elab_graphics_exp (env,e1,impl) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2,impl) => (e2', Types.PROP(t2, c2)) &
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LBINARY(e1,op,e2),impl)
	  => (Exp.LBINARY(e1'',op',e2''),Types.PROP(rtype,c))

  rule	(* Logical unary expressions *)
	elab_graphics_exp (env,e,impl) => (e',Types.PROP(t,c)) &
 	operators(op, env, t, (Types.T_NOTYPE,NONE)) => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_graphics_exp (env,exp as Absyn.LUNARY(op,e),impl)
	  => (Exp.LUNARY(op',e''),Types.PROP(rtype,c))

  rule	(* Relation expressions *)
	elab_graphics_exp (env,e1,impl) => (e1', Types.PROP(t1, c1)) &
	elab_graphics_exp (env,e2,impl) => (e2', Types.PROP(t2, c2)) &
	Types.const_and (c1,c2) => c &
	operators(op, env, t1, t2) => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_graphics_exp (env,exp as Absyn.RELATION(e1,op,e2),impl)
	  => (Exp.RELATION(e1'',op',e2''),Types.PROP(rtype,c))

	(**  Conditional expressions *)

  rule	elab_graphics_exp (env,e1,impl) => (e1', prop1) &
	elab_graphics_exp (env,e2,impl) => (e2', prop2) &
	elab_graphics_exp (env,e3,impl) => (e3', prop3) &
	elab_ifexp(env,e1',prop1,e2',prop2,e3',prop3,impl,NONE) => (e,prop)
	(* TODO elseif part*)
	------------------------------------------------------
	elab_graphics_exp (env,Absyn.IFEXP(e1,e2,e3,_),impl) => (e,prop)

	(**  Function calls *)
  rule	Dump.print_component_ref_str fn => fnstr &
	elab_call(env,fn,args,nargs,true,NONE) => (e,prop,_) 
	--------------------------------------
	elab_graphics_exp (env,Absyn.CALL(fn,Absyn.FUNCTIONARGS(args,nargs)),impl) 
		=> (e,prop)

	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	
	elab_tuple(env,e,impl) => (e', props) &
	split_props(props) => (types, consts) 
	-------------------------------------
	elab_graphics_exp (env,Absyn.TUPLE(e as e1::rest),impl) 
	  => (Exp.TUPLE(e'),Types.PROP_TUPLE((Types.T_TUPLE(types),NONE), Types.TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	elab_graphics_exp (env, start,impl) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, stop,impl) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 NONE,
			 (stop',stop_t)) => (start'',NONE,stop'',rt) &
	Types.const_and (c_start, c_stop) => const &
	elab_range_type (env,start'',NONE,stop'',const,rt,impl) => t
	--------------------------------------------------
	elab_graphics_exp (env, Absyn.RANGE(start, NONE, stop),impl)
	  => (Exp.RANGE(rt,start',NONE,stop'), Types.PROP(t, const))

  rule	(*Debug.fprintln("setr", "elab_graphics_exp_range2") &*)
	elab_graphics_exp (env, start,impl) => (start', Types.PROP(start_t, c_start)) &
	elab_graphics_exp (env, step,impl) => (step', Types.PROP(step_t, c_step)) &
	elab_graphics_exp (env, stop,impl) => (stop', Types.PROP(stop_t, c_stop)) &
	deoverload_range((start',start_t),
			 SOME((step',step_t)),
			 (stop',stop_t)) => (start'',SOME(step''),stop'',rt) &
	Types.const_and (c_start, c_step) => c1 &
	Types.const_and (c1, c_stop) => const &
	elab_range_type (env,start'',SOME(step''),stop'',const,rt,impl) => t
	---------------------
	elab_graphics_exp (env, Absyn.RANGE(start, SOME(step), stop),impl)
	  => (Exp.RANGE(rt,start'',SOME(step''),stop''), Types.PROP(t, const))



  rule	elab_graphics_array (env, es,impl) 
	  => (es', Types.PROP(t, const)) & list_length es' => l&
	Types.elab_type t => at &
	Types.is_array t => a
	--------------------------------------------------------------
	elab_graphics_exp (env, Absyn.ARRAY(es),impl)
	  => (Exp.ARRAY(at,a,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(l)), t),NONE),
		   const))
	
  rule	elab_exp_list_list(env,es,impl,NONE) => (_, tps, _) &
	Util.list_list_map(tps,Types.get_prop_type) => tps' &
	Util.list_flatten(tps') => tps'' &
	Types.contain_real(tps'') => havereal &
	elab_matrix_semi (env,es,impl,NONE,havereal) => (es', Types.PROP(t,c), dim1,dim2,nmax) & 
	Types.elab_type t => at
	------------------------------------------------------------
	elab_graphics_exp (env, Absyn.MATRIX(es),impl)
	  => (Exp.MATRIX(at,nmax,es'),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(dim1)),
				 (Types.T_ARRAY(Types.DIM(SOME(dim2)), t),NONE)),NONE),
		   c))

  rule	Print.print_error_buf "- elab_graphics_exp failed: " &
	Dump.print_exp_str e => es & 
	Print.print_error_buf es &
	Print.print_error_buf "\n"
	-----------------------------------------------------------
	elab_graphics_exp(_,e,impl) => fail

end

(** relation: deoverload_range
 **
 ** Does deoverloading of range expressions. They can be both Integer ranges 
 ** and Real ranges. This relation determines which one to use.
**)

relation deoverload_range : ((Exp.Exp*Types.Type), 
			     (Exp.Exp*Types.Type) option,
			     (Exp.Exp*Types.Type)) 
	  => (Exp.Exp, Exp.Exp option, Exp.Exp, Exp.Type) =
	  
  axiom	deoverload_range((e1,(Types.T_INTEGER(_),_)),
			 NONE,
			 (e3,(Types.T_INTEGER(_),_))) => (e1,NONE,e3,Exp.INT)
  axiom	deoverload_range((e1,(Types.T_INTEGER(_),_)),
			 SOME((e2,(Types.T_INTEGER(_),_))),
			 (e3,(Types.T_INTEGER(_),_)))  => (e1,SOME(e2),e3,Exp.INT)

  rule	elab_arglist([(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE)],
		     [(e1,t1),(e3,t3)]) => ([e1',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),NONE,(e3,t3)) => (e1',NONE,e3',Exp.REAL)

  rule	elab_arglist([(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE),(Types.T_REAL([]),NONE)],
		     [(e1,t1),(e2,t2),(e3,t3)]) => ([e1',e2',e3'],_)
	---------------------------------------------------
	deoverload_range((e1,t1),SOME((e2,t2)),(e3,t3)) 
	  => (e1',SOME(e2'),e3',Exp.REAL)

end


(** relation: elab_range_type 
 **
 ** Helper relation to elab_range. Calculates the dimension of the 
 ** range expression.
 **)

relation elab_range_type : (Env.Env, Exp.Exp, Exp.Exp option, 
			    Exp.Exp, Types.Const,
			    Exp.Type, bool (*impl*) ) 
	  => Types.Type =

  rule	Ceval.ceval (env,start,impl,NONE,NONE,Ceval.MSG) => (Values.INTEGER(startv),_) &
	Ceval.ceval (env,stop,impl,NONE,NONE,Ceval.MSG) => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,const ,_,impl (*as false*))
	  => ((Types.T_ARRAY(Types.DIM(SOME(n')), (Types.T_INTEGER([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.INTEGER(startv),_) &
	Ceval.ceval (env,step,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.INTEGER(stepv),_) &
	Ceval.ceval (env,stop,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.INTEGER(stopv),_) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,const,_,impl (*as false*))
	  => ((Types.T_ARRAY(Types.DIM(SOME(n'')), (Types.T_INTEGER([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.REAL(startv),_) &
	Ceval.ceval (env,stop,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_floor n => n'' &
	real_int n'' => n''' &
	int_add (n''',1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,const,_,impl (*as false*))
	  => ((Types.T_ARRAY(Types.DIM(SOME(n')), (Types.T_REAL([]),NONE)),NONE))

  rule	Ceval.ceval (env,start,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.REAL(startv),_) &
	Ceval.ceval (env,step,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.REAL(stepv),_) &
	Ceval.ceval (env,stop,impl,NONE,NONE,Ceval.MSG) 
	  => (Values.REAL(stopv),_) &
	real_sub (stopv,startv) => n &
	real_div (n,stepv) => n' &
	real_floor n' => n''' &
	real_int n''' => n'''' &
 	int_add (n'''',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,const,_,impl (*as false*))
	  => ((Types.T_ARRAY(Types.DIM(SOME(n'')), (Types.T_REAL([]),NONE)),NONE))


  axiom	elab_range_type (_,_,_,_,const,Exp.INT,impl as true)
	  => ((Types.T_ARRAY(Types.DIM(NONE), (Types.T_INTEGER([]),NONE)),NONE))

  axiom	elab_range_type (_,_,_,_,const,Exp.REAL,impl as true)
	  => ((Types.T_ARRAY(Types.DIM(NONE), (Types.T_REAL([]),NONE)),NONE))


  rule	Debug.fprint("failtrace", "- elab_range_type failed: ") &
	Exp.print_exp_str  start => s1 &
	Util.apply_option(step, Exp.print_exp_str) => s2opt &
	Util.flatten_option (s2opt,"none") => s2 &
	Exp.print_exp_str stop => s3 &
	Types.unparse_const const => s4 &
	Util.if(impl, "impl", "expl") => s5 &
	Exp.type_string expty => s6 &
	Util.string_append_list(["(",s1,":",s2,":",s3,") ",s4," ",s5," ",s6]) => str &
	Debug.fprintln("failtrace", str)	
	-------------------------------------------------------
	elab_range_type (env,start,step,stop,const,expty,impl) => fail

end

(** relation: elab_tuple
 **
 ** This relation does elaboration of tuples, i.e. function calls returning 
 ** several values.
 **)

relation elab_tuple : (Env.Env, Absyn.Exp list, bool (*impl*) )
	  => (Exp.Exp list, Types.Properties list) =

  rule	(*Debug.print "\nEntered elab_tuple." &*)
	elab_exp (env,e,impl,NONE) => (e',p,_) &
(*	Debug.print "\nElaborated expression." &*)
	elab_tuple(env,exps,impl) => (exps',props) 
(*	Debug.print "\nThe last element was just elaborated."*)
	-----------------------------
	elab_tuple(env,e::exps,impl) => (e'::exps', p::props) 

  rule 	(*Debug.print "elaborating last element."*)
	----------------
	elab_tuple(env,[],impl) => ([], []) 

end


(** relation: elab_array 
 **
 ** This relation elaborates on array expressions.
 ** 
 ** All types of an array should be equivalent. However, mixed Integer and Real
 ** elements are allowed in an array and in that case the Integer elements
 ** are converted to Real elements.
 
 **)

relation elab_array : (Env.Env, Absyn.Exp list,
		       bool (*impl*), 
		       Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties) =

	  (* array contains mixed Integer and Real types *)
  rule	elab_array_has_mixed_int_reals(env,expl,impl,st) &       
	elab_array_real(env,expl,impl,st) => (expl',prop)
	-------------
	elab_array(env,expl,impl,st) => (expl',prop)

  rule	elab_array2(env,expl,impl,st) => (expl',prop)
	----------------------
	elab_array(env,expl,impl,st) => (expl',prop)
end

(** relation: elab_array_has_mixed_int_reals
 **
 ** Helper relation to elab_array, checks if expression list contains both
 ** Integer and Real types.
 **)
relation elab_array_has_mixed_int_reals: (Env.Env, Absyn.Exp list,
					  bool (*impl*), 
					  Interactive.InteractiveSymbolTable option) => () =

  rule	elab_array_has_int(env,expl,impl,st) & 
	elab_array_has_real(env,expl,impl,st)
	---------------------------------------------------
	elab_array_has_mixed_int_reals(env,expl,impl,st)
end

(** relation: elab_array_has_int
 ** author :PA
 **
 ** Helper relation to elab_array.
 **)

relation elab_array_has_int: (Env.Env, Absyn.Exp list,
			      bool (* impl *),
			      Interactive.InteractiveSymbolTable  option)
	  => () =

  rule	elab_exp(env,e,impl,st) => (e',Types.PROP((Types.T_INTEGER([]),_),_),_)
	-----------------------------
	elab_array_has_int(env,e::expl,impl,st)

  rule	elab_array_has_int(env,expl,impl,st)
	-----------------------------
	elab_array_has_int(env,e::expl,impl,st)
end

(** relation: elab_array_has_real
 ** author :PA
 **
 ** Helper relation to elab_array. 
 **)

relation elab_array_has_real: (Env.Env, Absyn.Exp list,
			      bool (* impl *),
			      Interactive.InteractiveSymbolTable  option)
	  => () =

  rule	elab_exp(env,e,impl,st) => (e',Types.PROP((Types.T_REAL([]),_),_),_)
	-----------------------------
	elab_array_has_real(env,e::expl,impl,st)

  rule	elab_array_has_real(env,expl,impl,st)
	-----------------------------
	elab_array_has_real(env,e::expl,impl,st)
end

(** relation: elab_array_real
 ** 
 ** Helper relation to elab_array, converts all elements to Real
 **)

relation elab_array_real : (Env.Env, Absyn.Exp list,
		       bool (*impl*), 
		       Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties) =

	  (* elaborate each expression, pick first realtype
	   ** and type_convert all expressions to that type *)
  rule	elab_exp_list(env,expl,impl,st) => (expl',props,_) &
	elab_array_first_props_real(props) => real_tp &
	elab_array_const(props) => const &
	Util.list_map(props,Types.get_prop_type) => types &
	elab_array_real2(expl',types,real_tp) => (expl'',real_tp')
	-----------------------
	elab_array_real(env,expl,impl,st) 
	  => (expl'',Types.PROP(real_tp',const))
end

(** relation: elab_array_first_props_real
 ** author: PA
 **
 ** Pick the first type among the list of properties which has elementype
 ** Real.
 **)

relation elab_array_first_props_real: Types.Properties list => Types.Type =

  rule	Types.array_element_type(tp) => (tp' as (Types.T_REAL(_),_))
	-----------------------------------
	elab_array_first_props_real(Types.PROP(tp,_)::_) => tp'

  rule	elab_array_first_props_real(rest) => tp 
	-----------------------------------
	elab_array_first_props_real(_::rest) => tp
end

(** relation: elab_array_const
 **
 ** Constructs a const value from a list of properties, using const_and.
 **)

relation elab_array_const: (Types.Properties list) => Types.Const  =

  axiom	elab_array_const([Types.PROP(tp,c)]) => c

  rule	elab_array_const(rest) => c2 &
	Types.const_and(c2,c1) => c
	--------------------------
	elab_array_const(Types.PROP(_,c1)::rest) => c
end

(** relation: elab_array_real2
 ** author: PA
 ** 
 ** Applies type_convert to all expressions in a list to the type given
 ** as argument.
 **)

relation elab_array_real2: (Exp.Exp list, (* expl *)
			    Types.Type list,
			    Types.Type) (* to_type*) 
	  => (Exp.Exp list, (* new_expl*)
	      Types.Type) (* res_type *) =

  axiom	elab_array_real2([],[],tp) => ([],tp)

	(* No need for type conversion. *)
  rule	Types.equivtypes(t,to_type) => true &
	elab_array_real2(es,ts,to_type) => (res,res_type)
	------------------------------------
	elab_array_real2(e::es,t::ts,to_type) 
	  => (e::res,res_type)

	  (* type conversion *)
  rule	Types.type_convert(e,t,to_type) => (e',res_type) &
	elab_array_real2(es,ts,to_type) => (res,_)
	------------------------------------
	elab_array_real2(e::es,t::ts,to_type) 
	  => (e'::res,res_type)
end


(** relation: elab_array2
 ** 
 ** Helper relation to elab_array, checks that all elements are equivalent.
 **)

relation elab_array2 : (Env.Env, Absyn.Exp list,
		       bool (*impl*), 
		       Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_exp (env,e,impl,st) => (e',prop,_)
	-----------------------------
	elab_array2 (env,[e],impl,st) => ([e'],prop)

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array2 (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	Types.equivtypes(t1,t2) => true &
	Types.const_and (c1,c2) => c
	---------------------------------
	elab_array2 (env,e::es,impl,st) => (e'::es',Types.PROP(t1,c))

  rule	elab_exp (env,e,impl,st) => (e',Types.PROP(t1,c1),_) &
	elab_array2 (env,es,impl,st) => (es',Types.PROP(t2,c2)) &
	Types.equivtypes(t1,t2) => false &
	Print.print_error_buf "# Incompatible types in array expression\n" &
	Print.print_error_buf "  " & Dump.print_exp_str e => str  & 
	Print.print_error_buf str &
	Print.print_error_buf " is of type " &
 	Types.unparse_type t1 => str  & 
	Print.print_error_buf str &
	Print.print_error_buf "\n  while the elements [" &
        Util.list_map(es, Dump.print_exp_str)  => strs &
	Util.string_delimit_list(strs,",") => str &	
	Print.print_error_buf str &
	Print.print_error_buf "] are of type " & Types.unparse_type t2 => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n"
	---------------------------------------------------------
	elab_array2 (env,e::es,impl,st) => fail

  rule	Debug.fprint("failtrace","elab_array failed\n") 
	-----------------------------
	elab_array2 (_,expl,_,_) => fail

end

(** relation: elab_graphics_array
 **
 ** This relation elaborates array expressions for graphics elaboration.
 **)

relation elab_graphics_array : (Env.Env, Absyn.Exp list, bool (*impl*) )
	  => (Exp.Exp list, Types.Properties) =

  rule	elab_graphics_exp (env,e,impl) => (e',prop)
	-----------------------------
	elab_graphics_array (env,[e],impl) => ([e'],prop)

  rule	elab_graphics_exp (env,e,impl) => (e',Types.PROP(t1,c1)) &
	elab_graphics_array (env,es,impl) => (es',Types.PROP(t2,c2)) &
	Types.const_and (c1,c2) => c
	---------------------------------
	elab_graphics_array (env,e::es,impl) => (e'::es',Types.PROP(t1,c))

  rule	Print.print_error_buf "- elab_graphics_array failed\n"
	-----------------------------
	elab_graphics_array (_,_,impl) => fail

end

(** relation elab_matrix_comma
 **
 ** This relation is a helper relation for elab_matrix_semi.
 ** It elaborates one matrix row of a matrix.
 **)

relation elab_matrix_comma : (Env.Env, Absyn.Exp list, bool(*implicit inst.*)
			      , Interactive.InteractiveSymbolTable option, bool (*have real*))
	=> ((Exp.Exp*bool) list, Types.Properties, int, int) =


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t,c),_) &
	Types.ndims t => ndims &
	int_max(2,ndims) => maxn &
	int_gt(ndims,0) => array
	----------------------------------------
	elab_matrix_comma (env,[el],impl,st,havereal) => ([(el',array)],Types.PROP(t,c),1,maxn)


  rule	elab_exp (env,el,impl,st) => (el', Types.PROP(t1,c1),_) &
	elab_matrix_comma(env,els,impl,st,havereal) => (els', Types.PROP(t2,c2), _,maxn2) &

	Types.match_with_promote(Types.PROP(t1,c1),Types.PROP(t2,c2),havereal) => props &

	list_length el::els => dim &

	Types.ndims t1 => maxn1 &
	int_max (maxn1,maxn2) => maxn &
	int_gt(maxn1,0) => array
	-------------------------------------
	elab_matrix_comma (env,el::els,impl,st,havereal) 
	  => ((el',array)::els',props,dim,maxn)
	  
  rule	(*Debug.fprint("failtrace","- elab_matrix_comma failed\n")*)
	-------------------------------------
	elab_matrix_comma (_,_,_,_,_) => fail
end

(** relation: add_onesized_dimensions
 ** author: PA
 **
 ** Array concatenation along first and second dimension using matrix 
 ** constructor will if necessary add 1-sized dimensions until each
 ** element of the constructor have the same dimension maxn >= 2.
 ** This relation adds array constructors to achieve this.
 **)

relation add_onesized_dimensions: ((Exp.Exp*bool) list list, 
				   Types.Properties list list,
				   int ) (* maxn*)
	=> ((Exp.Exp*bool) list list) =

  axiom	add_onesized_dimensions([],_,_) => []

  rule	add_onesized_dimensions_row(e,t,maxn) => e' &
	add_onesized_dimensions(es,ts,maxn) => es'
	-------------------------------------
	add_onesized_dimensions(e::es,t::ts,maxn) => e'::es'
end

(** relation: add_onesized_dimensions_row
 ** author: PA
 ** 
 ** Helper relation to add_onesized_dimensions
 **)
relation add_onesized_dimensions_row:( (Exp.Exp*bool) list, 
				      Types.Properties list,
				      int) (* maxn *)
	=> ((Exp.Exp*bool) list) =
  axiom	add_onesized_dimensions_row([],_,_) => []

  rule	add_onesized_dimensions_row(es,tps,maxn) => es' &
	Types.ndims(tp) => cur_ndims &
	int_sub(maxn,cur_ndims) => add_dims &
	int_sub(add_dims,1) => add_dims' &
	add_onesized_dimensions_exp(e,tp,add_dims') => e'
	------------------------------------
	add_onesized_dimensions_row((e,b)::es,Types.PROP(tp,c)::tps,maxn)
	  => ((e',b)::es')
end

(** relation: add_onesized_dimensions_exp
 ** author: PA
 ** 
 ** Adds onesized array dimensions to an expressions n times.
**)
relation add_onesized_dimensions_exp:(Exp.Exp,
				      Types.Type,
				      int)  (* n *)
	  => Exp.Exp =

  axiom	add_onesized_dimensions_exp(e,tp,-1) => e
  axiom	add_onesized_dimensions_exp(e,tp,0) => e

  rule	int_sub(n,1) => n' & 
	Types.elab_type(tp) => e_tp &
	Types.lift_array(tp,SOME(1)) => tp' &
	Types.elab_type(tp') => e_tp' &
	Exp.type_builtin(e_tp) => array &
	add_onesized_dimensions_exp(e,tp',n') => e' 
	---------------------------
	add_onesized_dimensions_exp(e,tp,n) 
	  => Exp.ARRAY(e_tp',array,[e'])
end

(** relation: elab_matrix_semi
 **
 ** This relation elaborates Matrix expressions, e.g. [1,0;2,1] 
 ** A row is elaborated with elab_matrix_comma.
 *)

relation elab_matrix_semi : (Env.Env, Absyn.Exp list list, bool(*implicit inst.*), Interactive.InteractiveSymbolTable option, bool(*contain real*))
	=> ((Exp.Exp*bool) list list, Types.Properties, int, int, int) =
	  

  rule	elab_matrix_comma(env,el,impl,st,havereal) => (el', props, dim, maxn)
	---------------------------------
	elab_matrix_semi(env,[el],impl,st,havereal) => ([el'], props, 1, dim, maxn)

  rule	list_length(el::els) => dim &
	elab_matrix_comma(env,el,impl,st,havereal) => (el',props1,dim1,maxn1) &
	elab_matrix_semi(env,els,impl,st,havereal) => (els',props2,_,dim2,maxn2) &

	dim1 = dim2 &
			
	Types.match_with_promote(props1,props2,havereal) => props &

	int_max(maxn1,maxn2) => maxn
	--------------------
	elab_matrix_semi(env,el::els,impl,st,havereal) => (el'::els',props,dim,dim1,maxn)

  rule	(*Debug.fprint("failtrace", "- elab_matrix_semi failed\n" )*)
	-------------------
	elab_matrix_semi(_,_,_,_,_) => fail

	(**  Error messages *)
(*
  rule	Print.print_buf "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix_semi(_,[]) => fail

  rule	elab_array(env,el) => (el',Types.PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	Print.print_buf "# Incompatible types in matrix rows\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix is of " &
	Types.print_type t2 & Print.print_buf "\n"
	--------------------------------
	elab_matrix_semi(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	Print.print_buf "# Incompatible row length in matrix expression\n" &
	Print.print_buf "    [" & Dump.print_list(el,Dump.print_exp,",") &
	Print.print_buf "] is a row of size " &
	int_string dim1 => s & Print.print_buf s & Print.print_buf "\n" &
	Print.print_buf "    the rest of the matrix rows are of size " &
	int_string dim2 => s & Print.print_buf s & Print.print_buf "\n"
	--------------------------------------------
	elab_matrix_semi(env,el::els) => fail
*)
end

(** relation: elab_builtin_cardinality
 ** author: PA
 ** 
 ** This relation elaborates the cardinality operator.
 **)

relation elab_builtin_cardinality : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,_),_) 
	  ----------------------------
	elab_builtin_cardinality(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("cardinality"),[exp'],false,true),
	      Types.PROP((Types.T_INTEGER([]),NONE),Types.C_CONST))
end

(** relation: elab_builtin_size
 ** 
 ** This relation elaborates the size operator.
 ** Input is the list of arguments to size as Absyn.Exp expressions and the 
 ** environment, Env.Env.
 **)

relation elab_builtin_size : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  rule	(** size(A,x) that returns size of x:th dimension *)
  	elab_exp(env,dim,impl,NONE) => (dimp,Types.PROP(_,c1),_) &
	elab_exp(env,arraycr,impl,NONE) => (arraycrefe,Types.PROP(arrtp,_),_) &
	Types.dimensions_known(arrtp) => c2 &
	Types.bool_const(c2) => c2' &
	Types.const_and(c1,c2') => c &
	let exp = Exp.SIZE(arraycrefe,SOME(dimp))
	---------------------------------------------------------------
	elab_builtin_size (env, [arraycr,dim], impl) => (exp,Types.PROP((Types.T_INTEGER([]),NONE),c))

  rule	(* size(A) *)
	elab_exp(env,arraycr,impl,NONE) => (arraycrefe,Types.PROP(arrtp,_),_) &
	Types.dimensions_known(arrtp) => c &
	Types.bool_const(c) => c' &
	let exp = Exp.SIZE(arraycrefe,NONE)
	---------------------------------------------------------------
	elab_builtin_size (env, [arraycr], impl) 
	  => (exp,Types.PROP((Types.T_ARRAY(Types.DIM(SOME(1)),(Types.T_INTEGER([]),NONE)),NONE),c'))

  rule	Debug.fprint("failtrace", "- elab_builtin_size failed\n")
	----------------------------------------------------------
	elab_builtin_size (env,expl,impl) => fail
end


(** relation: elab_builtin_fill
 **
 ** This relation elaborates the builtin operator fill.
 ** The input is the arguments to fill as Absyn.Exp expressions and the environment Env.Env
 **)

relation elab_builtin_fill : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp (env,s,impl,NONE) => (s', prop,_) &
	elab_exp_list (env,dims,impl,NONE) => (dims', dimprops,_) &
	Types.get_prop_type prop => sty &
	Ceval.ceval_list (env, dims',impl,NONE,Ceval.MSG) => dimvals &
	elab_builtin_fill_2 (env, s', sty, dimvals) => (exp, prop) 
	--------------------------------------------------
	elab_builtin_fill (env, s::dims, impl) => (exp, prop)

  rule	Debug.fprint("failtrace", "- elab_builtin_fill: Couldn't elaborate fill(): ") &
	Util.bool_string impl => implstr &
	Util.list_map(dims, Dump.print_exp_str) => expstrs &
	Util.string_delimit_list(expstrs, ", ") => expstr &
	Util.string_append_list([expstr, " impl=", implstr]) => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------
	elab_builtin_fill (env,dims,impl) => fail

end

(** relation: elab_builtin_fill_2
 **
 ** Helper relation to elab_builtin_fill
 **)

relation elab_builtin_fill_2 : (Env.Env, Exp.Exp, Types.Type, Values.Value list) 
	  => (Exp.Exp, Types.Properties) =

  rule	build_exp_list (s, v) => arraylist &
	int_string v => dimension & 
	Types.elab_type sty => at &
	Types.is_array sty => a
	----------------------------------
	elab_builtin_fill_2 (env, s, sty, [Values.INTEGER(v)])
	  => (Exp.ARRAY(at,a,arraylist), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(v)), sty),NONE), Types.C_CONST))
			     
  rule	elab_builtin_fill_2 (env, s, sty, rest) 
	  => (exp, Types.PROP(ty,con)) &
        build_exp_list (exp, v) => arraylist &
	int_string v => dimension &
	Types.elab_type ty => at &
	Types.is_array ty => a
	----------------------------------------------------------
	elab_builtin_fill_2 (env, s, sty, Values.INTEGER(v)::rest) 
	  => (Exp.ARRAY(at,a,arraylist), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(v)), ty),NONE), Types.C_CONST))
	
  rule	Print.print_error_buf "#-- elab_builtin_fill_2: Failed to elaborate fill()\n"
	-------------------------------------------------------------
	elab_builtin_fill_2 (_,_,_,_) => fail

end

(** relation: elab_builtin_transpose
 **
 ** This relation elaborates the builtin operator transpose
 ** The input is the arguments to fill as Absyn.Exp expressions and the environment Env.Env
 **)

relation elab_builtin_transpose : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,matexp,impl,NONE) 
	  => (exp', Types.PROP((Types.T_ARRAY(d1,(Types.T_ARRAY(d2,eltp),_)),_),_),_) &
	let newtp = ((Types.T_ARRAY(d2,(Types.T_ARRAY(d1,eltp),NONE)),NONE)) &
	let exp = Exp.CALL(Absyn.IDENT("transpose"),
			   [exp'],false,true) &
	let prop = Types.PROP(newtp,Types.C_VAR)
	------------------------------------
	elab_builtin_transpose (env, [matexp], impl) => (exp, prop)
end

(** relation: build_exp_list
 **
 ** Helper relation to e.g. elab_builtin_fill_2. Creates n copies of the same 
 ** expression given as input.
 **)

relation build_exp_list : (Exp.Exp, int (* n *)) => Exp.Exp list =

  axiom	build_exp_list(e,0) => []
  axiom	build_exp_list (e,1) => [e]

  rule	int_sub (c,1) => c' &
	build_exp_list (e, c') => rest
	------------------------------
	build_exp_list (e, c) => e::rest

end

(** relation: elab_builtin_sum
 **
 ** This relation elaborates the builtin operator sum.
 ** The input is the arguments to fill as Absyn.Exp expressions and the environment Env.Env
 **)

relation elab_builtin_sum : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp(env,arrexp,impl,NONE) 
	      => (exp',Types.PROP((Types.T_ARRAY(dim,tp),_),c),_) &
	let exp'' = Exp.CALL(Absyn.IDENT("sum"),
			   [exp'],false,true)
	---------------------------------------
	elab_builtin_sum(env,[arrexp],impl) => (exp'', Types.PROP(tp,c))
end

(** relation: elab_builtin_pre
 **
 ** This relation elaborates the builtin operator pre.
 ** Input is the arguments to the pre operator and the environment, Env.Env.
 **)

relation elab_builtin_pre : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP(tp,c),_) &
	Types.basic_type(tp) => true &
	let exp'' = Exp.CALL(Absyn.IDENT("pre"),
			   [exp'],false,true)
	------------------------------------
	elab_builtin_pre(env,[exp],impl) => (exp'', Types.PROP(tp,c))

  rule	elab_exp(env,exp,impl,NONE) => (exp,Types.PROP(tp,c),_) &
	Types.basic_type(tp) => false &
	Print.print_error_buf "#Error, operand of pre must be of built-in type.\n"
	------------------------------------
	elab_builtin_pre(env,[exp],impl) => fail

  rule	Print.print_error_buf "#Error, wrong type or wrong number of arguments to pre operator.\n"
	------------------------------------
	elab_builtin_pre(env,_,_) => fail
end

(** relation: elab_builtin_initial
 **
 ** This relation elaborates the builtin operator 'initial()'
 ** Input is the arguments to the operator, which should be an empty list.
 **)

relation elab_builtin_initial : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_initial(env,[],impl) 
	  => (Exp.CALL(Absyn.IDENT("initial"),
			   [],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

  rule	Print.print_error_buf "#Error, initial takes no arguments.\n"
	------------------
	elab_builtin_initial(env,_,_) => fail
end

(** relation: elab_builtin_terminal
 **
 ** This relation elaborates the builtin operator 'terminal()'
 ** Input is the arguments to the operator, which should be an empty list.
 **)

relation elab_builtin_terminal : (Env.Env, Absyn.Exp list, bool (*impl*) ) 
	  => (Exp.Exp, Types.Properties) =

  axiom	elab_builtin_terminal(env,[],impl) 
	  => (Exp.CALL(Absyn.IDENT("terminal"),
			   [],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

  rule	Print.print_error_buf "#Error, terminal takes no arguments.\n"
	------------------
	elab_builtin_terminal(env,_,impl) 
	  => (Exp.CALL(Absyn.IDENT("terminal"),
			   [],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

  rule	Print.print_error_buf "#Error, terminal takes no arguments.\n"
	------------------
	elab_builtin_terminal(env,_,impl) => fail

end

(** relation: elab_builtin_array
 **
 ** This relation elaborates the builtin operator 'array'. For instance, 
 ** array(1,4,6) which is the same as {1,4,6}.
 ** Input is the list of arguments to the operator, as Absyn.Exp list.
 **)

relation elab_builtin_array : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =
  rule	elab_exp_list(env, expl, impl, NONE) 
	  => (exp', typel, _) &
	elab_builtin_array2 (exp', typel) => (exp'', Types.PROP(tp,c)) &  
	list_length(expl) => len &
	let newtp = ((Types.T_ARRAY(Types.DIM(SOME(len)),tp),NONE)) &
	Types.elab_type(newtp) => newtp' &
	Types.is_array(tp) => scalar &
	let exp = Exp.ARRAY(newtp',scalar,exp') 
	---------------------------------
	elab_builtin_array(env,expl,impl) => (exp, Types.PROP(newtp,c))
end

(** relation elab_builtin_array2.
 **
 ** Helper relation to elab_builtin_array.
 ** Asserts that all types are of same dimensionality and of same 
 ** builtin types.
 **)

relation elab_builtin_array2: (Exp.Exp list, Types.Properties list)
	=> (Exp.Exp list, Types.Properties) =

  rule	same_dimensions(tpl) => false &
	Print.print_error_buf "#Error, different dimension sizes in arguments to array.\n"
	------------------------
	elab_builtin_array2(expl,tpl) => fail

  rule	(* If first elt is Integer but arguments contain Real, convert all to Real *)
	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Types.contain_real(tpl') => true &
	elab_builtin_array3(expl,tpl,Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR)) 
	      => (expl', tp)
	-------------------------------------------
	elab_builtin_array2(expl,tpl) => (expl', tp)
	
  rule	elab_builtin_array3(expl,tpl,tp) => (expl',tp)
	---------------------------
	elab_builtin_array2(expl,tpl as (tp::_)) => (expl', tp)
end

(** relation: elab_bultin_array3
 **
 ** Helper relation to elab_builtin_array.
 **)

relation elab_builtin_array3: (Exp.Exp list, Types.Properties list, 
			       Types.Properties)
	=> (Exp.Exp list, Types.Properties) =
  axiom	elab_builtin_array3([],[],tp) => ([],tp)

  rule	Types.match_prop(e1,t1,tp) => e1' &
	elab_builtin_array3(expl,tpl,tp) => (expl',_)
	----------------------------------------
	elab_builtin_array3(e1::expl,t1::tpl,tp) => (e1'::expl', t1)
end

(** relation: elab_builtin_zeros
 **
 ** This relation elaborates the builtin operator 'zeros(n)'.
 **)

relation elab_builtin_zeros : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(0)::args,impl) => (e,p)
	--------------------------------------------------------
	elab_builtin_zeros (env, args,impl) => (e,p)
end

(** relation: same_dimensions
 **
 ** This relation returns true of all the properties, containing types, 
 ** have the same dimensions, otherwise false. 
 **)

relation same_dimensions: (Types.Properties list ) => bool =

  rule	Util.list_map(tpl,Types.get_prop_type) => tpl' &
	Util.list_map(tpl',Types.get_dimension_sizes) => dimsizes &
	same_dimensions2(dimsizes) => res
	--------------------------------
	same_dimensions(tpl) => res
end

relation same_dimensions2:( int list list) => bool =

  rule	Util.list_flatten(l) => []
	------------------
	same_dimensions2(l) => true
	
  rule	Util.list_map(l,Util.list_first) => elts &
	Util.list_map(l,Util.list_rest) => restelts &
	same_dimensions3(elts) => true &
	same_dimensions2(restelts) => true
	----------------------------------
	same_dimensions2(l) => true
  axiom	same_dimensions2(_) => false
end

(** relation: same_dimensions3
 **
 ** Helper relation to same_dimensions2
 **)
			
relation same_dimensions3: (int list) => bool =

  axiom same_dimensions3([]) => true
  axiom	same_dimensions3([_]) => true

  rule	int_eq(i1,i2) => res 
	--------------------
	same_dimensions3([i1,i2]) => res

  rule	same_dimensions3(i2::rest) => res &
	int_eq(i1,i2) => res2 &
	bool_and(res,res2) => res'
	--------------------------
	same_dimensions3(i1::i2::rest) => res'

  axiom	same_dimensions3(_) => false
end

(** relation: elab_builtin_ones
 **
 ** This relation elaborates on the builtin opeator 'ones(n)'.
 **)

relation elab_builtin_ones : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(1)::args,impl) => (e,p)
	--------------------------------------------------------
	elab_builtin_ones (env, args,impl) => (e,p)
end

(** relation: elab_builtin_max
 **
 **  This relation elaborates on the builtin operator 'max(v1,v2)'
 **)

relation elab_builtin_max : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

	(* max(vector) *)
  rule	elab_exp (env,arrexp,impl,NONE) 
	  => (arrexp', Types.PROP(ty, c),_) &
	  Types.array_element_type(ty) => elt_ty
	-------------------------------------------------------
	elab_builtin_max(env, [arrexp],impl) => (Exp.CALL(Absyn.IDENT("max"),[arrexp'],false,true),Types.PROP(elt_ty,c))
	
  rule	(* max(x,y) where x & y are scalars *)
	elab_exp (env,s1,impl,NONE) 
	  => (s1', Types.PROP(ty, c1),_) &
	elab_exp (env,s2,impl,NONE) 
	  => (s2', Types.PROP(_, c2),_) &
	  Types.const_and(c1,c2) => c
	-------------------------------------------------------
	elab_builtin_max(env, [s1, s2],impl) 
	  => (Exp.CALL(Absyn.IDENT("max"),[s1',s2'],false,true),Types.PROP(ty,c))
end

(** relation: elab_builtin_min
 **
 ** This relation elaborates the builtin operator 'min(a,b)'
 **)

relation elab_builtin_min : (Env.Env, Absyn.Exp list, bool (*impl*)) => (Exp.Exp, Types.Properties) =

	(* min(vector) *)
  rule	elab_exp (env,arrexp,impl,NONE) 
	  => (arrexp', Types.PROP(ty, c),_) &
	  Types.array_element_type(ty) => elt_ty
	-------------------------------------------------------
	elab_builtin_min(env, [arrexp],impl) => (Exp.CALL(Absyn.IDENT("min"),[arrexp'],false,true),Types.PROP(elt_ty,c))
	
  rule	(* min(x,y) where x & y are scalars *)
	elab_exp (env,s1,impl,NONE) 
	  => (s1', Types.PROP(ty, c1),_) &
	elab_exp (env,s2,impl,NONE) 
	  => (s2', Types.PROP(_, c2),_) &
	  Types.const_and(c1,c2) => c
	-------------------------------------------------------
	elab_builtin_min(env, [s1, s2],impl) 
	  => (Exp.CALL(Absyn.IDENT("min"),[s1',s2'],false,true),Types.PROP(ty,c))
end


(** relation: elab_builtin_floor
 **
 ** This relation elaborates on the builtin operator floor.
 **)
		 
relation elab_builtin_floor : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule (*print "# floor function not implemented yet\n" &*)
      elab_exp (env,s1,impl,NONE) 
	   => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
     --------------------------------------
     elab_builtin_floor(env,[s1],impl) 
        => (Exp.CALL(Absyn.IDENT("floor"),[s1'],false,true),
            Types.PROP((Types.T_REAL([]),NONE),c))
end

(** relation: elab_builtin_ceil
 **
 ** This relation elaborates on the builtin operator ceil.
 **)
relation elab_builtin_ceil : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =
        
  rule (**print "# ceil function not implemented yet\n" &**)
        elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_ceil(env,[s1],impl) 
          => (Exp.CALL(Absyn.IDENT("ceil"),[s1'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))
end

(** relation: elab_builtin_abs
 **
 ** This relation elaborates on the builtin operator abs
 **)
relation elab_builtin_abs : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,s1,impl,NONE) 
	  => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
	  --------------------------------------
	elab_builtin_abs(env,[s1],impl) 
          => (Exp.CALL(Absyn.IDENT("abs"),[s1'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))
	
  rule	elab_exp (env,s1,impl,NONE) 
	  => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          --------------------------------------
        elab_builtin_abs(env,[s1],impl) 
          => (Exp.CALL(Absyn.IDENT("abs"),[s1'],false,true),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
	
end

(** relation: elab_builtin_sqrt
 **
 ** This relation elaborates on the builtin operator sqrt.
 **)
relation elab_builtin_sqrt : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          (**print "# sqrt function not implemented yet REAL\n" **)
     --------------------------------------
     elab_builtin_sqrt(env,[s1],impl) 
        => (Exp.CALL(Absyn.IDENT("sqrt"),[s1'],false,true),
            Types.PROP((Types.T_REAL([]),NONE),c))

end

(** relation: elab_builtin_div
 **
 ** This relation elaborates on the builtin operator div.
 **)

relation elab_builtin_div : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
        --------------------------------------
        elab_builtin_div(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_div(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_div(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c  
        --------------------------------------
        elab_builtin_div(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("div"),[s1',s2'],false,true),
              Types.PROP((Types.T_INTEGER([]),NONE),c))        
end

(** relation: elab_builtin_mod
 ** This relation elaborates on the builtin operator mod.
 **)
relation elab_builtin_mod : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
        --------------------------------------
        elab_builtin_mod(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_mod(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_mod(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
        --------------------------------------
        elab_builtin_mod(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("mod"),[s1',s2'],false,true),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
        
end

(** relation: elab_builtin_sqrt
 **
 ** This relation elaborates on the builtin operator rem.
 **)

relation elab_builtin_rem : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
        --------------------------------------
        elab_builtin_rem(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_REAL([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_rem(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))
        
  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
          --------------------------------------
        elab_builtin_rem(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),c))

  rule  elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_INTEGER([]),NONE),c1),_) &
          elab_exp (env,s2,impl,NONE) 
	      => (s2', Types.PROP((Types.T_INTEGER([]),NONE),c2),_) &
	  Types.const_and(c1,c2) => c 
        --------------------------------------
        elab_builtin_rem(env,[s1,s2],impl) 
          => (Exp.CALL(Absyn.IDENT("rem"),[s1',s2'],false,true),
              Types.PROP((Types.T_INTEGER([]),NONE),c))
        
end

(** relation: elab_builtin_integer
 **
 ** This relation elaborates on the builtin operator integer, which extracts 
 ** the Integer value of a Real value.
 **)

relation elab_builtin_integer : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =

  rule	elab_exp (env,s1,impl,NONE) 
	      => (s1', Types.PROP((Types.T_REAL([]),NONE),c),_) 
          (**print "# integer function not implemented yet REAL\n" **)
     --------------------------------------
     elab_builtin_integer(env,[s1],impl) 
        => (Exp.CALL(Absyn.IDENT("integer"),[s1'],false,true),
            Types.PROP((Types.T_INTEGER([]),NONE),c))
end

(** relation: elab_builtin_diagonal
 **
 ** This relation elaborates on the builtin operator diagonal, creating a
 ** matrix with a value of the diagonal. The other elements are zero.
 **)

relation elab_builtin_diagonal : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp (env,s1,impl,NONE) 
	  => (s1', Types.PROP((Types.T_ARRAY(dim as Types.DIM(SOME(dimension)),
                                             arrType),NONE),c),_)
        (**print "# integer function not implemented yet REAL\n" **)
        --------------------------------------
        elab_builtin_diagonal(env,[s1],impl) 
          => (
              Exp.CALL(Absyn.IDENT("diagonal"),[s1'],false,true),
              Types.PROP((Types.T_ARRAY(dim,(Types.T_ARRAY(dim,arrType),NONE)),NONE),c))
	
  rule	print"#-- elab_builtin_diagonal: Couldn't elaborate diagonal()\n"
	---------------------------------------------------------
	elab_builtin_diagonal (_,_,_) => fail
	
end

(** relation: elab_builtin_differentiate
 **
 ** This relation elaborates on the builtin operator differentiate, 
 ** by deriving the Exp
 **)

relation elab_builtin_differentiate : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=
        
  rule  Absyn.get_cref_from_exp(s1) => cref_list1 &
        Absyn.get_cref_from_exp(s2) => cref_list2 &
        list_append(cref_list1,cref_list2) => cref_list &
        absyn_cref_list_to_interactive_var_list(cref_list,
                                                Interactive.empty_symboltable,
                                                (Types.T_REAL([]),NONE)) => symbol_table &
        Interactive.build_env_from_symboltable(symbol_table) => gen_env &
        elab_exp (gen_env,s1,impl,NONE) => (s1', st,_) &
        elab_exp(gen_env,s2,impl,NONE) => (s2', st,_)
        --------------------------------------
        elab_builtin_differentiate(env,[s1,s2],impl)
          => (Exp.CALL(Absyn.IDENT("differentiate"),[s1',s2'],false,true),
              st)
        
  rule  print"#-- elab_builtin_differentiate: Couldn't elaborate differentiate()\n"
	---------------------------------------------------------
	elab_builtin_differentiate (_,_,_) => fail
	
end

(** relation: elab_builtin_simplify
 **
 ** This relation elaborates the simplify function.
 ** The call in mosh is: simplify(x+y*x-x,"Real") if the variable should be 
 ** Real or simplify(x+y*x-x,"Integer") if the variable should be Integer
 ** This relation is only for testing Exp.simplify
 **)

relation elab_builtin_simplify : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=
        
  rule  Absyn.get_cref_from_exp(s1) => cref_list &
        absyn_cref_list_to_interactive_var_list(cref_list,
                                                Interactive.empty_symboltable,
                                                (Types.T_REAL([]),NONE)) => symbol_table &
        Interactive.build_env_from_symboltable(symbol_table) => gen_env &
        elab_exp (gen_env,s1,impl,NONE) => (s1', st,_)
        --------------------------------------
        elab_builtin_simplify(env,[s1,Absyn.STRING("Real")],impl)
          => (Exp.CALL(Absyn.IDENT("simplify"),[s1'],false,true),
              st)
        
  rule  Absyn.get_cref_from_exp(s1) => cref_list &
        absyn_cref_list_to_interactive_var_list(cref_list,
                                                Interactive.empty_symboltable,
                                                (Types.T_INTEGER([]),NONE)) => symbol_table &
        Interactive.build_env_from_symboltable(symbol_table) => gen_env &
        elab_exp (gen_env,s1,impl,NONE) => (s1', st,_)
        --------------------------------------
        elab_builtin_simplify(env,[s1,Absyn.STRING("Integer")],impl)
          => (Exp.CALL(Absyn.IDENT("simplify"),[s1'],false,true),
              st)
        

  rule	print"#-- elab_builtin_simplify: Couldn't elaborate simplify()\n"
	---------------------------------------------------------
	elab_builtin_simplify (_,_,_) => fail
	
end

(** relation: absyn_cref_list_to_interactive_var_list
 **
 ** Creates Interactive variables from the list of component references. Each
 ** variable will get a value that is the AST code for the variable itself.
 ** This is used when calling differentiate, etc., to be able to evaluate
 ** a variable and still get the variable name.
 **)

relation absyn_cref_list_to_interactive_var_list: ( Absyn.ComponentRef list, Interactive.InteractiveSymbolTable,Types.Type)
          => Interactive.InteractiveSymbolTable =


  axiom absyn_cref_list_to_interactive_var_list([],symbol_table,_) => symbol_table
  
  rule  Absyn.cref_to_path(cr) => path &
        Absyn.path_string(path) => path_str &
        Interactive.add_var_to_symboltable(path_str,
                                       Values.CODE(Absyn.C_VARIABLENAME(cr)),
                                       tp,
                                       symbol_table) => symbol_table' &
        absyn_cref_list_to_interactive_var_list(rest,symbol_table',tp) => symbol_table''
        -------------------------------------------
        absyn_cref_list_to_interactive_var_list(cr::rest,symbol_table,tp) 
          => symbol_table''
        

  rule  Print.print_error_buf("error in absyn_cref_list_to_interactive_var_list") 
        --------------------------------------------
        absyn_cref_list_to_interactive_var_list(_,_,_) => fail
end


(** relation: elab_builtin_dymtabletimeini
 **
 ** This relation elaborates on the function dymtabletimeini, which is a Dymola
 ** builtin function for table initialization. Should probably be removed in the future.
 **)
relation elab_builtin_dymtabletimeini : (Env.Env, Absyn.Exp list, bool (*impl*) )
	  => (Exp.Exp, Types.Properties)	=
	
  rule	elab_exp (env,e1,impl,NONE) 
	      => (e1', Types.PROP((Types.T_REAL([]),NONE),c),_) &
	elab_exp (env,e2,impl,NONE) 
	      => (e2', Types.PROP((Types.T_INTEGER([]),NONE),c),_) &
	elab_exp (env,e3,impl,NONE) 
	      => (e3', Types.PROP((Types.T_STRING([]),NONE),c),_) &
	elab_exp (env,e4,impl,NONE) 
	      => (e4', Types.PROP((Types.T_STRING([]),NONE),c),_) &
	elab_exp (env,e5,impl,NONE) 
	      => (e5', Types.PROP((Types.T_ARRAY(dim,arrType),NONE),c),_) &
	elab_exp (env,e6,impl,NONE) 
	      => (e6', Types.PROP((Types.T_INTEGER([]),NONE),c),_) 
          (**print "# integer function not implemented yet REAL\n" **)
        --------------------------------------
        elab_builtin_dymtabletimeini(env,[e1,e2,e3,e4,e5,e6],impl) 
          => (
              Exp.CALL(Absyn.IDENT("dymTableTimeIni"),
		       [e1',e2',e3',e4',e5',e6'],false,true),
              Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR))

      
  rule  print"#-- elab_builtin_dymtabletimeini: Couldn't elaborate diagonal()\n"
	    ---------------------------------------------------------
	    elab_builtin_dymtabletimeini (_,_,_) => fail
end
     
(** relation: elab_builtin_noevent
 **
 ** The builtin operator noevent makes sure that events are not generated
 ** for the expression.
 **)

relation elab_builtin_noevent : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp(env,exp,impl,NONE) => (exp',prop,_)
	----------------------------------
	elab_builtin_noevent(env,[exp],impl) 
	  => (Exp.CALL(Absyn.IDENT("noEvent"),[exp'],false,true), prop)
	
end

(** relation: elab_builtin_edge
 **
 ** This relation handles the built in edge operator. If the operand is 
 ** constant edge is always false.
 **)

relation elab_builtin_edge : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

	  (* Constness: C_VAR *)
  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_BOOL([]),_),Types.C_VAR),_)  
	----------------------------------
	elab_builtin_edge(env,[exp],impl) 
	  => (Exp.CALL(Absyn.IDENT("edge"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))
	  (* constness: C_PARAM & C_CONST *)
  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_BOOL([]),_),c),_) &
	value_exp Values.BOOL(false) => exp''
	----------------------------------
	elab_builtin_edge(env,[exp],impl) 
	  => (exp'', Types.PROP((Types.T_BOOL([]),NONE),c))

  rule	Print.print_error_buf "#Error, wrong type or wrong number of arguments to edge operator.\n"
	------------------------------------
	elab_builtin_edge(env,_,_) => fail

	
end

(** relation: elab_builtin_sign
 **
 ** This relation handles the built in sign operator. 
 ** sign(v) is expanded into (if v>0 then 1 else if v < 0 then -1 else 0)
 **)

relation elab_builtin_sign : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

	  (* Constness: C_VAR *)
  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_BOOL([]),_),Types.C_VAR),_)  
	----------------------------------
	elab_builtin_sign(env,[exp],impl) 
	  => (Exp.CALL(Absyn.IDENT("sign"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))
	  (* constness: C_PARAM & C_CONST *)
  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_BOOL([]),_),c),_) &
	value_exp Values.BOOL(false) => exp''
	----------------------------------
	elab_builtin_sign(env,[exp],impl) 
	  => (exp'', Types.PROP((Types.T_BOOL([]),NONE),c))

  rule	Print.print_error_buf "#Error, wrong type or wrong number of arguments to sign operator.\n"
	------------------------------------
	elab_builtin_sign(env,_,_) => fail
end

(** relation: elab_builtin_der
 **
 ** This relation handles the built in der operator.
 **)

relation elab_builtin_der : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_REAL([]),_),Types.C_VAR),_)  
	----------------------------------
	elab_builtin_der(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("der"),[exp'],false,true), Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR))

	  (* Constant expressions should fail *)
  rule	elab_exp(env,exp,impl,NONE) => (exp',Types.PROP((Types.T_REAL([]),_),c),_)  &
	Print.print_error_buf "# Error, der operator applied to constant expression\n" 
	----------------------------------
	elab_builtin_der(env,[exp as Absyn.CREF(cr)],impl) 
	  => fail
  rule	Print.print_error_buf "#Error, wrong type or wrong number of arguments to der operator in '\n" &
	Util.list_map(expl,Dump.print_exp_str) => lst &
	Util.string_delimit_list(lst,", ") => s &
	Util.string_append_list(["der(",s,")'.\n"]) => s &
	Print.print_error_buf s
	------------------------------------
	elab_builtin_der(env,expl,_) => fail	
end

(** relation: elab_builtin_sample
 ** author: PA
 **
 ** This relation handles the built in sample operator.
 **)
		 
 relation elab_builtin_sample : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties) =
	   
  rule	elab_exp(env,start,impl,NONE) 
	  => (start',Types.PROP(tp1,_),_)  &
	   elab_exp(env,interval,impl,NONE) 
	  => (interval',Types.PROP(tp2,_),_)  &
	   Types.integer_or_real(tp1) &
	 Types.integer_or_real(tp2) 
	 ----------------------------------
	 elab_builtin_sample(env,[start,interval],impl) 
	  => (Exp.CALL(Absyn.IDENT("sample"),[start',interval'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))
	   
  rule	elab_exp(env,start,impl,NONE) 
	  => (start',Types.PROP(tp1,_),_)  &
	  not Types.integer_or_real(tp1) &
	Print.print_error_buf "#First argument to sample must be Integer or Real expression.\n"
	----------------------------------
	elab_builtin_sample(env,[start,interval],impl) 
	  => fail

  rule	elab_exp(env,interval,impl,NONE) 
	  => (start',Types.PROP(tp1,_),_)  &
	  not Types.integer_or_real(tp1) &
	Print.print_error_buf "#Second argument to sample must be Integer or Real expression.\n"
	----------------------------------
	elab_builtin_sample(env,[start,interval],impl) 
	  => fail
end

(** relation: elab_builtin_change
 ** author: PA
 **
 ** This relation handles the built in change operator.
 **)
		 
relation elab_builtin_change : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

	  (* simple type, 'discrete' variable *)
  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,_),_) &
	  Types.simple_type(tp1) &
	Lookup.lookup_var(env,cr') => (Types.ATTR(_,_,SCode.DISCRETE,_),_,_)
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("change"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

	  (* simple type, boolean or integer => discrete variable *)
  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,_),_) &
	  Types.simple_type(tp1) &
	Types.discrete_type(tp1) 
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("change"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

	  (* simple type, constant variability *)
  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,Types.C_CONST),_) &
	  Types.simple_type(tp1) 
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("change"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))

	  (* simple type, param variability *)
  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,Types.C_PARAM),_) &
	  Types.simple_type(tp1) 
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => (Exp.CALL(Absyn.IDENT("change"),[exp'],false,true), Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR))


  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp' as Exp.CREF(cr',_),Types.PROP(tp1,_),_) &
	  Types.simple_type(tp1) &
	Lookup.lookup_var(env,cr') => (Types.ATTR(_,_,_,_),_,_) &
	Print.print_error_buf "#Error, operand to change is not a discrete variable\n" 
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => fail

  rule	elab_exp(env,exp,impl,NONE) 
	  => (exp',Types.PROP(tp1,_),_) &
	  not Types.simple_type(tp1) &
	Print.print_error_buf "#Error, operand to change is not a simple type\n" 
	----------------------------------
	elab_builtin_change(env,[exp as Absyn.CREF(cr)],impl) 
	  => fail

  rule	Print.print_error_buf "#Error, operand to change is not a variable\n" 
	----------------------------------
	elab_builtin_change(env,[exp],impl) 
	  => fail
end

(** relation: elab_builtin_cat
 ** author: PA
 **
 ** This relation handles the built in cat operator.
 **)
		 
relation elab_builtin_cat : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,Types.PROP((Types.T_INTEGER(_),_),const1),_) &
	elab_exp_list(env,matrices,impl,NONE) => (matrices',props,_) &
	same_dimensions(props) => true &
	elab_array_const(props) => const2 &
	Types.const_and(const1,const2) => const &
	let Types.PROP(result_type,_)::_ = props
	----------------------------------
	elab_builtin_cat(env,dim::matrices,impl) 
	  => (Exp.CALL(Absyn.IDENT("cat"),dim_exp::matrices',false,true), 
	      Types.PROP(result_type,const))

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,tp,_) &
	  not let Types.PROP((Types.T_INTEGER(_),_),const1) = tp &
	  Print.print_error_buf "# Error, first argument to cat must be an Integer.\n"
	----------------------------------
	elab_builtin_cat(env,dim::matrices,impl) 
	  => fail

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,Types.PROP((Types.T_INTEGER(_),_),const1),_) &
	elab_exp_list(env,matrices,impl,NONE) => (matrices',props,_) &
	same_dimensions(props) => false &
	Print.print_error_buf "# Error, all array arguments to cat operator must be of same dimension.\n"
	----------------------------------
	elab_builtin_cat(env,dim::matrices,impl) 
	  => fail
end

(** relation: elab_builtin_identity
 ** author: PA
 **
 ** This relation handles the built in identity operator.
 **)
		 
relation elab_builtin_identity : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,Types.PROP((Types.T_INTEGER(_),_),Types.C_CONST),_) &
	Ceval.ceval(env,dim_exp,false,NONE,NONE,Ceval.MSG) 
	  => (Values.INTEGER(size),_) 
	----------------------------------
	elab_builtin_identity(env,[dim],impl) 
	  => (Exp.CALL(Absyn.IDENT("identity"),[dim_exp],false,true), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(size)),(Types.T_ARRAY(Types.DIM(SOME(size)),(Types.T_INTEGER([]),NONE)),NONE)),NONE),Types.C_CONST))

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,Types.PROP((Types.T_INTEGER(_),_),Types.C_PARAM),_) &
	Ceval.ceval(env,dim_exp,false,NONE,NONE,Ceval.MSG) 
	  => (Values.INTEGER(size),_)   
	----------------------------------
	elab_builtin_identity(env,[dim],impl) 
	  => (Exp.CALL(Absyn.IDENT("identity"),[dim_exp],false,true), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(size)),(Types.T_ARRAY(Types.DIM(SOME(size)),(Types.T_INTEGER([]),NONE)),NONE)),NONE),Types.C_PARAM))

  rule	elab_exp(env,dim,impl,NONE) 
	  => (dim_exp,Types.PROP((Types.T_INTEGER(_),_),Types.C_VAR),_) 
	----------------------------------
	elab_builtin_identity(env,[dim],impl) 
	  => (Exp.CALL(Absyn.IDENT("identity"),[dim_exp],false,true), 
	      Types.PROP((Types.T_ARRAY(Types.DIM(NONE),(Types.T_ARRAY(Types.DIM(NONE),(Types.T_INTEGER([]),NONE)),NONE)),NONE),Types.C_VAR))

  rule	print "-elab_builtin_identity failed\n" 
	------------------------
	elab_builtin_identity(env,[dim],impl) => fail
end

(** relation: elab_builtin_vector
 ** author: PA
 **
 ** This relation handles the built in vector operator.
 **)
		 
relation elab_builtin_vector : (Env.Env, Absyn.Exp list, bool (*impl*)) 
	  => (Exp.Exp, Types.Properties)	=

	  (* vector(scalar) = {scalar} *)
  rule	elab_exp(env,e,impl,NONE) 
	  => (exp,Types.PROP(tp,c),_) &
	Types.simple_type(tp) &
	Types.elab_type(tp) => tp' &
	Types.lift_array(tp,SOME(1)) => arr_tp
	----------------------------------
	elab_builtin_vector(env,[e],impl) 
	  => (Exp.ARRAY(tp',true,[exp]),Types.PROP(arr_tp,c))

	  (* vector(array of scalars) = array of scalars *)
  rule	elab_exp(env,e,impl,NONE) 
	  => (Exp.ARRAY(etp,scalar,expl),Types.PROP(tp,c),_) &
	Types.ndims(tp) => 1 
	-------------------------------------
	elab_builtin_vector(env,[e],impl)
	  => (Exp.ARRAY(etp,scalar,expl),Types.PROP(tp,c))
	  (* vector of multi dimensional array, at most one dim > 1 *)
  rule	elab_exp(env,e,impl,NONE) 
	  => (Exp.ARRAY(_,_,expl),Types.PROP(tp,c),_) &
	  Types.array_element_type(tp) => tp' &
	Types.elab_type(tp') => etp &
	Types.get_dimension_sizes(tp) => dims &
	  elab_builtin_vector_2(expl,dims) => expl'
	-------------------------------------
	elab_builtin_vector(env,[e],impl)
	  => (Exp.ARRAY(etp,true,expl'),Types.PROP(tp,c))
end

(** relation: elab_builtin_vector_2
 **
 ** Helper relation to elab_builtin_vector.
 **)

relation elab_builtin_vector_2: (Exp.Exp list,int list) => Exp.Exp list =


  rule	int_gt(dim,1) => true &
	(*Util.list_map_1(dims,int_gt,1) => b_lst &
	Util.bool_or_list(b_lst) => false &*)
	elab_builtin_vector_3(expl) => expl' 
	----------------------------------
	elab_builtin_vector_2(expl,dim::dims) => expl'

  rule	elab_builtin_vector_2(expl,dims) => expl'
	----------------------------
	elab_builtin_vector_2([Exp.ARRAY(_,_,expl)],dim::dims) => expl'
end

relation elab_builtin_vector_3: Exp.Exp list => Exp.Exp list =

  axiom	elab_builtin_vector_3 ([]) => []

  rule	elab_builtin_vector_3([expl]) => [e] &
	elab_builtin_vector_3(es) => es
	-------------------------------
	elab_builtin_vector_3(Exp.ARRAY(_,_,[expl])::es) => e::es

  rule	elab_builtin_vector_3(es) => es'
	----------------------
	elab_builtin_vector_3(e::es) => e::es' 
end


(** relation: elab_builtin_handler_generic
 **
 ** This relation dispatches the elaboration of special builtin operators by 
 ** returning the appropriate relation, see also elab_builtin_handler.
 ** These special builtin operators can not be represented in the 
 ** environment since they must be generated on the fly, given a generated 
 ** type.
**)
		 
relation elab_builtin_handler_generic : Ident => ((Env.Env, Absyn.Exp list, bool (*impl*) ) 
					  => (Exp.Exp, Types.Properties)) =

  axiom	elab_builtin_handler_generic "cardinality" => elab_builtin_cardinality

end


(** relation: elab_builtin_handler
 **
 ** This relation dispatches the elaboration of builtin operators by 
 ** returning the appropriate relation. When a new builtin operator is 
 ** added, a new rule has to be added to this relation.
**)
		 
relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list, bool (*impl*) ) 
					  => (Exp.Exp, Types.Properties)) =

  axiom	elab_builtin_handler "size" => elab_builtin_size
  axiom	elab_builtin_handler "zeros" => elab_builtin_zeros
  axiom	elab_builtin_handler "ones" => elab_builtin_ones
  axiom	elab_builtin_handler "fill" => elab_builtin_fill
  axiom	elab_builtin_handler "max" => elab_builtin_max
  axiom	elab_builtin_handler "min" => elab_builtin_min
  axiom elab_builtin_handler "transpose" => elab_builtin_transpose
  axiom	elab_builtin_handler "array" => elab_builtin_array
  axiom	elab_builtin_handler "sum" => elab_builtin_sum
  axiom	elab_builtin_handler "pre" => elab_builtin_pre
  axiom	elab_builtin_handler "initial" => elab_builtin_initial
  axiom	elab_builtin_handler "terminal" => elab_builtin_terminal
  axiom elab_builtin_handler "floor" => elab_builtin_floor
  axiom elab_builtin_handler "ceil" => elab_builtin_ceil
  axiom elab_builtin_handler "abs" => elab_builtin_abs
  axiom elab_builtin_handler "sqrt" => elab_builtin_sqrt
  axiom elab_builtin_handler "div" => elab_builtin_div
  axiom elab_builtin_handler "integer" => elab_builtin_integer
  axiom elab_builtin_handler "mod" => elab_builtin_mod
  axiom elab_builtin_handler "rem" => elab_builtin_rem
  axiom	elab_builtin_handler "diagonal" => elab_builtin_diagonal
  axiom	elab_builtin_handler "differentiate" => elab_builtin_differentiate
  axiom	elab_builtin_handler "simplify" => elab_builtin_simplify
  axiom	elab_builtin_handler "noEvent" => elab_builtin_noevent
  axiom	elab_builtin_handler "edge" => elab_builtin_edge
  axiom	elab_builtin_handler "sign" => elab_builtin_sign 
  axiom	elab_builtin_handler "der" => elab_builtin_der
  axiom	elab_builtin_handler "sample" => elab_builtin_sample
  axiom	elab_builtin_handler "change" => elab_builtin_change
  axiom	elab_builtin_handler "cat" => elab_builtin_cat
  axiom	elab_builtin_handler "identity" => elab_builtin_identity
  axiom	elab_builtin_handler "vector" => elab_builtin_vector

  axiom	elab_builtin_handler "dymTableTimeIni" => elab_builtin_dymtabletimeini

end

(** relation: is_builtin_func
 **
 ** Returns true if the function name given as argument
 ** is a builtin function, which either has a elab_builtin_handler relation
 ** or can be found in the builtin environment.
 **)

relation is_builtin_func : Absyn.Path => bool =

  rule	elab_builtin_handler id => _
	----------------------------
	is_builtin_func Absyn.IDENT(id) => true

  rule	Lookup.is_in_builtin_env path => true
	-------------------------------------
	is_builtin_func path => true

  axiom	is_builtin_func _ => false

end


(** relation: elab_call_builtin
 **
 ** This relation elaborates on builtin operators, by calling the builtin 
 ** handler to retrieve the correct relation to call.
 **)

relation elab_call_builtin : (Env.Env, Absyn.ComponentRef, Absyn.Exp list, bool (*impl*) )
	=> (Exp.Exp, Types.Properties) =

	  (* for normal builtin operators and functions *)
  rule	elab_builtin_handler name => handler &
	handler (env, args, impl) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args, impl) => (exp, prop)

	(* For generic types, like e.g. cardinality *)
  rule	elab_builtin_handler_generic name => handler &
	handler (env, args, impl) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args, impl) => (exp, prop)

end


(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg
		      list, bool (*impl*), Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

	  (** LS: Check if a builtin function call, e.g. size()
	      and calculate if so **)

  rule	(* Elaborate interactive function calls *)
	elab_call_interactive(env,fn,args,nargs,impl,st) => (e,prop,st)
	-------------------------------------------------------
	elab_call(env,fn,args,nargs,impl,st) => (e,prop,st)

  rule	(* PA. Built in functions have only possitional arguments *)
	elab_call_builtin (env, fn, args, impl) => (e,prop)
	---------------------------------------------
	elab_call (env,fn,args,nargs,impl,st) => (e,prop,st)


	(* Interactive mode *)
  rule	Debug.fprintln ("sei", "elab_call 3") &
	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args,nargs,impl,st) => (e,prop) &
	generate_compiled_function(env,fn,e,prop,st) => st' 
	& Debug.fprint ("sei", "elab_call 3 succeeded: ")
	& Dump.print_component_ref_str fn => fnstr
	& Debug.fprintln("sei", fnstr)
	------------------------------------
	elab_call (env,fn,args,nargs,impl as true,st) => (e,prop,st')

	(* Non-interactive mode *)
  rule	Debug.fprint ("sei", "elab_call 4: ") &
	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintln("sei", fnstr) &
	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args,nargs,impl, st) => (e,prop) &
	generate_compiled_function(env,fn,e,prop,st) => st' 
	& Debug.fprint ("sei", "elab_call 4 succeeded: ")
	& Debug.fprintln ("sei", fnstr)
	------------------------------------
	elab_call (env,fn,args,nargs,impl as false,st) => (e,prop,st')

  rule	Debug.fprint("failtrace", "- elab_call failed\n") &
	Debug.fprint("failtrace", " function: ") &
	Dump.print_component_ref_str fn => fnstr &
	Debug.fprint("failtrace", fnstr) &
	Debug.fprint("failtrace", "   posargs: ") &
	Util.list_map(args, Dump.print_exp_str) => argstrs &
	Util.string_delimit_list(argstrs, ", ") => argstr &
	Debug.fprintln("failtrace", argstr)
	-----------------------------------
	elab_call (env,fn,args,nargs,impl,st) => fail

end

(** relation: elab_call_interactive
 *
 * This relation elaborates the functions defined in the interactive environment.
 * Since some of these functions are meta-functions, they can not be described in the type 
 * system, and is thus given the the type T_NOTYPE
 *)
relation elab_call_interactive : (Env.Env, Absyn.ComponentRef, Absyn.Exp list,Absyn.NamedArg list, bool, Interactive.InteractiveSymbolTable option)
 	  => (Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =

  rule	Absyn.cref_to_path(cr) => path & path_to_component_ref(path) => cr'
	-------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("lookupClass",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("lookupClass"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("typeOf",_),
			      [ Absyn.CREF(Absyn.CREF_IDENT(varid,[]))],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("typeOf"),
		       [Exp.CREF(Exp.CREF_IDENT(varid,[]),Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clear",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clear"), [], false, true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("clearVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("clearVariables"), [], false, true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("list",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("list"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
        (* this extracts the fileNamePrefix which is used when generating code and init-file*)
        component_ref_to_path(cr') => classname &
	Absyn.path_string(classname) => cname_str &
    	get_optional_named_arg(env,SOME(st),impl,"fileNamePrefix",
			       (Types.T_STRING([]),NONE),args,Exp.SCONST(cname_str))
	  => filenameprefix &
	let recordtype = 
	((Types.T_COMPLEX(ClassInf.RECORD("SimulationObject")
			,[Types.VAR("flatClass",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
,Types.VAR("exeFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
			  ]
			),NONE))
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("translateModel",_),
			      [ Absyn.CREF(cr)],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("translateModel"),
		       [Exp.CREF(cr',Exp.OTHER),filenameprefix],
		       false,
		       true),
	      Types.PROP(recordtype,Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("instantiateModel",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("instantiateModel"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))


  rule	elab_untyped_cref(env,cr,impl) => cr' &
	get_optional_named_arg(env,SOME(st),impl,"startTime",
			       (Types.T_REAL([]),NONE),args,Exp.RCONST(0.0)) 
	  => startTime &
	get_optional_named_arg(env,SOME(st),impl,"stopTime",
			       (Types.T_REAL([]),NONE),args,Exp.RCONST(1.0))
	  => stopTime &
	get_optional_named_arg(env,SOME(st),impl,"numberOfIntervals",
			       (Types.T_INTEGER([]),NONE),args,Exp.ICONST(500))
	  => numberOfIntervals &
	get_optional_named_arg(env,SOME(st),impl,"method",
			       (Types.T_STRING([]),NONE),args,Exp.SCONST("dassl"))
	  => method &
          (* this extracts the fileNamePrefix which is used when generating code and init-file*)
        component_ref_to_path(cr') => classname &
	Absyn.path_string(classname) => cname_str &
    	get_optional_named_arg(env,SOME(st),impl,"fileNamePrefix",
			       (Types.T_STRING([]),NONE),args,Exp.SCONST(cname_str))
	  => filenameprefix
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("buildModel",_),
			      [ Absyn.CREF(cr)],args,impl,
			      SOME(st))  
	  => (Exp.CALL(Absyn.IDENT("buildModel"),
		       [Exp.CREF(cr',Exp.OTHER),startTime,
			stopTime,numberOfIntervals,method,filenameprefix], (* Fill in rest of defaults here*)
		       false,
		       true),
              Types.PROP((Types.T_ARRAY(Types.DIM(SOME(2)), (Types.T_STRING([]),NONE)),NONE),
		         Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	get_optional_named_arg(env,SOME(st),impl,"startTime",
			       (Types.T_REAL([]),NONE),args,Exp.RCONST(0.0)) 
	  => startTime &
	get_optional_named_arg(env,SOME(st),impl,"stopTime",
			       (Types.T_REAL([]),NONE),args,Exp.RCONST(1.0))
	  => stopTime &
	get_optional_named_arg(env,SOME(st),impl,"numberOfIntervals",
			       (Types.T_INTEGER([]),NONE),args,Exp.ICONST(500))
	  => numberOfIntervals &
	get_optional_named_arg(env,SOME(st),impl,"method",
			       (Types.T_STRING([]),NONE),args,Exp.SCONST("dassl"))
	  => method &
          (* this extracts the fileNamePrefix which is used when generating code and init-file*)
        component_ref_to_path(cr') => classname &
	Absyn.path_string(classname) => cname_str &
	get_optional_named_arg(env,SOME(st),impl,"fileNamePrefix",
			       (Types.T_STRING([]),NONE),args,Exp.SCONST(cname_str))
	  => filenameprefix &
	let recordtype = 
	((Types.T_COMPLEX(ClassInf.RECORD("SimulationResult")
			,[Types.VAR("resultFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
			  ]
			),NONE)) 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("simulate",_),
			      [ Absyn.CREF(cr)],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("simulate"),
		       [Exp.CREF(cr',Exp.OTHER),startTime,
			stopTime,numberOfIntervals,method, filenameprefix],(* Fill in rest of defaults here*)
		       false,
		       true),
	      Types.PROP(recordtype,Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("jacobian",_),
			      [ Absyn.CREF(cr)],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("jacobian"),
		       [Exp.CREF(cr',Exp.OTHER)], 
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_variablenames(vars) => vars' &
	elab_exp(env,size_absyn,false,SOME(st)) => (size_exp,ptop, st') &
        Ceval.ceval(env,size_exp,false,st',NONE,Ceval.MSG) => (Values.INTEGER(size),_) &
	list_length(vars) => var_len 
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("readSimulationResult",_),
			      [ Absyn.STRING(filename),
			       Absyn.ARRAY(vars),
			       size_absyn
			       ],args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readSimulationResult"),
		       [Exp.SCONST(filename),
			Exp.ARRAY(Exp.OTHER,false,vars'),
			size_exp], 
		       false,
		       true),
	      Types.PROP((Types.T_ARRAY(Types.DIM(SOME(var_len)),
					(Types.T_ARRAY(Types.DIM(SOME(size)), (Types.T_REAL([]),NONE)),NONE)),NONE),Types.C_VAR),
	      SOME(st))

  rule	(*elab_variablenames(vars) => vars' &
	list_length(vars) => var_len *)
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("readSimulationResultSize",_),
			      [ Absyn.STRING(filename)],
			      args,impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readSimulationResultSize"),
		       [Exp.SCONST(filename)], 
		       false,
		       true),
	      Types.PROP((Types.T_INTEGER([]),NONE),Types.C_VAR),
	      SOME(st))

	
  rule	elab_variablenames([cr]) => vars'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("plot",_),
			      [cr as Absyn.CREF(_)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("plot"),
		       [Exp.ARRAY(Exp.OTHER,false,vars')],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_variablenames(vars) => vars'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("plot",_),
			      [Absyn.ARRAY(vars)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("plot"),
		       [Exp.ARRAY(Exp.OTHER,false,vars')],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))


  rule	elab_exp(env,exp,impl,SOME(st)) => (exp',prop,st')
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("timing",_),
			      [exp],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("timing"),
		       [exp'],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR),
	      st')


  rule	elab_untyped_cref(env,cr,impl) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("generateCode",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("generateCode"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompiler",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompiler"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompileCommand",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompileCommand"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setCompilerFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setCompilerFlags"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("setDebugFlags",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("setDebugFlags"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("cd",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("cd"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("system",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("system"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_INTEGER([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("readFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("readFile"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

	(* Returns an array of "component references" *)
axiom	elab_call_interactive(env, Absyn.CREF_IDENT("listVariables",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("listVariables"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_ARRAY(Types.DIM(NONE),(Types.T_NOTYPE,NONE)),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("getErrorString",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getErrorString"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("runScript",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("runScript"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("loadModel",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadModel"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("deleteFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("deleteFile"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("loadFile",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("loadFile"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("saveModel",_),
			      [ Absyn.STRING(str),Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("saveModel"),
		       [Exp.SCONST(str),Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("save",_),
			      [ Absyn.CREF(cr)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("save"),
		       [Exp.CREF(cr',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("saveAll",_),
			      [ Absyn.STRING(str)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("saveAll"),
		       [Exp.SCONST(str)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  axiom	elab_call_interactive(env, Absyn.CREF_IDENT("help",_),
			      [],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("help"),
		       [],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getQuantity",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getQuantity"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getDisplayUnit",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getDisplayUnit"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_STRING([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMin",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMin"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getMax",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getMax"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStart",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStart"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getFixed",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getFixed"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getNominal",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getNominal"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_REAL([]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_untyped_cref(env,cr,impl) => cr' &
	elab_untyped_cref(env,cr2,impl) => cr2'
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("getStateSelect",_),
			      [ Absyn.CREF(cr),Absyn.CREF(cr2)],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("getStateSelect"),
		       [Exp.CREF(cr',Exp.OTHER),Exp.CREF(cr2',Exp.OTHER)],
		       false,
		       true),
	      Types.PROP((Types.T_ENUMERATION(["never", "avoid", "default", "prefer", "always"],[]),NONE),Types.C_VAR),
	      SOME(st))

  rule	elab_exp(env,bool_exp,impl,SOME(st)) => (bool_exp',prop,st')
	------------------------------------------------------------------
	elab_call_interactive(env, Absyn.CREF_IDENT("echo",_),
			      [ bool_exp],[],impl,
			      SOME(st)) 
	  => (Exp.CALL(Absyn.IDENT("echo"),
		       [bool_exp'],
		       false,
		       true),
	      Types.PROP((Types.T_BOOL([]),NONE),Types.C_CONST),
	      SOME(st))

end
(** relation: elab_variablenames
 ** This relation elaborates variablenames to Exp.Exp. A variablename can
 ** be used in e.g. plot(model,{v1[3],v2.t}) It should only be used in interactive 
 ** functions that uses variablenames as componentreferences.
**)
relation elab_variablenames: Absyn.Exp list => Exp.Exp list =

  axiom	elab_variablenames [] => []

  rule	(* Use simplified conversion, all indexes integer constants *)
	Exp.to_exp_cref(cr) => cr' &
	elab_variablenames(xs) => xs' 
	-----------------------------
	elab_variablenames(Absyn.CREF(cr)::xs) 
	  => Exp.CREF(cr',Exp.OTHER)::xs'
end


(** relation: get_optional_named_arg
 **  This relation is used to "elaborate" interactive functions optional parameters, 
 ** e.g. simulate(A.b, startTime=1), startTime is an optional parameter 
 **)
relation get_optional_named_arg: (Env.Env, 
				  Interactive.InteractiveSymbolTable option,
				  bool,
				  Ident,
				  Types.Type, (* The expected type *)
				  Absyn.NamedArg list,
				  Exp.Exp) 
	=> Exp.Exp =

  axiom	get_optional_named_arg(_,_,_,_,_,[],exp) => exp

  rule	id = id2 &
	elab_exp(env,exp,impl,st) => (exp',Types.PROP(t,c1),_) &
	Types.match_type(exp',t,tp) => (exp'',_) 
	--------------------------------------------------
	get_optional_named_arg(env,st,impl,id,tp,Absyn.NAMEDARG(id2,exp)::xs,dexp) => exp''

  rule	get_optional_named_arg(env,st,impl,id,tp,xs,dexp) => exp'
	--------------------------------------------------
	get_optional_named_arg(env,st,impl,id,tp,Absyn.NAMEDARG(id2,exp)::xs,dexp) => exp'
end

(** relation: elab_untyped_cref
 ** This relation elaborates a ComponentRef without adding type information. 
 **  Environment is passed along, such that constant subscripts can be elabed using existing
 ** relations
 **)
relation elab_untyped_cref: (Env.Env, Absyn.ComponentRef, bool (*impl*) ) => Exp.ComponentRef =

  rule	elab_subscripts(env, subs, impl) => (subs',_)
	----------------------------------
	elab_untyped_cref(env, Absyn.CREF_IDENT(id,subs), impl) => Exp.CREF_IDENT(id,subs')

  rule	elab_subscripts(env,subs,impl) => (subs',_) &
	elab_untyped_cref(env, cr,impl) => cr'
	-----------------------------
	elab_untyped_cref(env, Absyn.CREF_QUAL(id,subs,cr),impl) => Exp.CREF_QUAL(id,subs',cr')
end

(** relation: path_to_component_ref
 ** This relation tranlates a typename to a variable name.
 **)
relation path_to_component_ref: Absyn.Path => Exp.ComponentRef =

  axiom	path_to_component_ref(Absyn.IDENT(s)) => Exp.CREF_IDENT(s,[])

  rule	path_to_component_ref(path) => cref
	----------------
	path_to_component_ref(Absyn.QUALIFIED(id,path)) => Exp.CREF_QUAL(id,[],cref)
end

(** relation: component_ref_to_path
 ** This relation translates a variable name to a type name.
 **)
relation component_ref_to_path: Exp.ComponentRef => Absyn.Path =

  axiom	component_ref_to_path(Exp.CREF_IDENT(s,[])) => Absyn.IDENT(s)

  rule	component_ref_to_path(cref) => path
	----------------
	component_ref_to_path(Exp.CREF_QUAL(id,_,cref)) => Absyn.QUALIFIED(id,path)
end

(* relation: generate_compiled_function 
 ** TODO: This currently only works for top level functions. For functions inside packages 
 ** we need to reimplement without using lookup functions, since we can not build
 ** correct env for packages containing functions.   
   *)
relation generate_compiled_function: (Env.Env, Absyn.ComponentRef, Exp.Exp, Types.Properties, Interactive.InteractiveSymbolTable option) =>
	(Interactive.InteractiveSymbolTable option) =

(*  axiom generate_compiled_function(_,_,_,_,NONE) => NONE *)
	
  rule	Debug.fprintln("sei", "generate_compiled_function: start1") &
	Absyn.cref_to_path(fn) => pfn &
	is_function_in_cflist (cflist,pfn) => true
	-----------------------------------------------
	generate_compiled_function(env,fn,e,prop,SOME(st as Interactive.SYMBOLTABLE(p,_,_,_,cflist))) => SOME(st)

	(* Don not compile if is "known" external function, e.g. math lib.*)
  rule	Absyn.cref_to_path(fn) => path &
	Lookup.lookup_class(env,path,false) => (cdef,env') &
	let SCode.CLASS(fid,_,_,SCode.R_EXT_FUNCTION,SCode.PARTS(_,_,_,_,_,extdecl)) = cdef &
	let SOME(Absyn.EXTERNALDECL(id,lan,out,args,_)) = extdecl &
	Ceval.is_known_external_func(fid,id) 
	----------------------------------	
	generate_compiled_function(env,fn,e,prop,st) => st

  rule	Debug.fprintln("sei", "generate_compiled_function: start2") &
	Absyn.cref_to_path(fn) => path &
	is_function_in_cflist (cflist, path) => false &
	SCode.elaborate(p) => p' &
	Debug.fprintln("sei", "generate_compiled_function: elaborated") &
(*	Inst.instantiate_implicit(p') => d & *)
	Lookup.lookup_class(env, path, false (*message*)) => (cls, env') &
	Debug.fprintln("sei", "generate_compiled_function: class looked up") &
	Inst.implicit_function_instantiation(env', Types.NOMOD,
					     Prefix.NOPRE, 
					     Connect.empty_set, cls, [], false)
	  => (env'',d) &
	Debug.fprintln("sei", "generate_compiled_function: function instantiated") &
	Print.clear_buf() &
	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Codegen.generate_functions(d') => libs &
	Debug.fprintln("sei", "generate_compiled_function: function generated") &
	ModUtil.path_string2 (path,"_") => pathstr &	
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\\n\");\n      return 1;\n    }\n" &
	Print.print_buf "    _" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)& Print.clear_buf() &
	System.compile_c_file(filename) &
	Types.get_prop_type prop => t
(*	& Debug.fprintln("sei", "generate_compiled_function: compiled")*)
	-----------------------------------------------
	generate_compiled_function(env,fn,e,prop,SOME(st as Interactive.SYMBOLTABLE(p,a,b,c,cflist))) => SOME(Interactive.SYMBOLTABLE(p,a,b,c,(path,t)::cflist))



  rule	Debug.fprintln("sei", "generate_compiled_function: start3")
	-----------------------------------------------
	generate_compiled_function(env,fn,e,prop,NONE) => NONE
	(* PROP_TUPLE? *)

(*
  rule	(* If fails, skip it. *)
	--------------------------------------------------
	generate_compiled_function(_,_,_,_,st) => st
*)

  rule	Debug.fprintln("failtrace", "- generate_compiled_function failed4") &
	Dump.print_component_ref_str cr => str1 &
	Exp.print_exp_str exp => str2 &
	Debug.fprint("failtrace", str1) &
	Debug.fprint("failtrace", " -- ") &
	Debug.fprintln("failtrace", str2)
	------------------------------------------------------------------
	generate_compiled_function(env,cr,exp,prop,st) => st

  rule	(* If fails, skip it. *)
	--------------------------------------------------
	generate_compiled_function(_,_,_,_,st) => st

end

(** relation: is_function_in_cflist
 **
 ** This relation returns true if a function, named by an Absyn.Path, 
 ** is present in the list of precompiled functions that can be executed
 ** in the interactive mode.
 **)

relation is_function_in_cflist : ((Absyn.Path * Types.Type) list, (* list of compiled functions*)
				  Absyn.Path)  (* function name *)
	  => bool =

  axiom	is_function_in_cflist ([],_) => false

  rule	ModUtil.path_equal (path1, path2) => true
	-----------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => true

  rule	ModUtil.path_equal (path1, path2) => false &
	is_function_in_cflist (rest, path2) => res
	------------------------------------------
	is_function_in_cflist ((path1, ty)::rest, path2) => res
end

(** relation: elab_call_args
 **
 ** Given the name of a function and two lists of expression and 
 ** NamedArg respectively to be used 
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, 
			   Absyn.Path, 
			   Absyn.Exp list, 
			   Absyn.NamedArg list, 
			   bool (* impl *),
			   Interactive.InteractiveSymbolTable option)
	=> (Exp.Exp, Types.Properties) =

	  (* Record constructors, user defined or implicit *)	
  rule	Lookup.lookup_type(env,fn,true) => (t as (Types.T_FUNCTION(fargs,outtype as (Types.T_COMPLEX(ClassInf.RECORD(_),_),_)),_),env') &
	make_empty_slots(fargs) => slots &
	elab_input_args(env,args,nargs,slots,impl) => (args',newslots, constlist) &
	Util.list_reduce(constlist,Types.const_and) => const &
	elab_consts(outtype,const) => tyconst &
	get_properties(outtype,tyconst) => prop &
	Lookup.lookup_record_constructor_class(env',fn) => (cl,env'') &	
	fill_default_slots(newslots,cl,env'',impl) => newslots2 &
	exp_list_from_slots(newslots2) => args'' 
	------------------------------------
	elab_call_args(env,fn,args,nargs,impl,st) => (Exp.CALL(fn,args'',false (*tuple*),false (*builtin*)), prop)


	(* ..Other functions *)
  rule	(* PR. A function can have several types. Taking an array with
	 different dimensions as parameter for example. Because of this we
	 cannot just lookup the function name and trust that it
	 returns the correct function. It returns just one
	 functiontype of several possibilites. The solution is to send
	 in the funktion type of the user function and check both the
	 funktion name and the function's type. 
	 *)
	Lookup.lookup_functions_in_env(env,fn) => typelist &
	(* The constness of a function depends on the inputs. If all inputs are
	 * constant the call itself is constant.
	 *)
	elab_types (env, args, typelist,impl) 
	  => (args', constlist, restype, functype,vect_dims, slots) &

	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple &
	is_builtin_func fn' => builtin &
	Util.list_reduce(constlist,Types.const_and) => const &
	elab_consts(restype,const) => tyconst &
	get_properties(restype,tyconst) => prop &
	vectorize_call(Exp.CALL(fn',args',tuple,builtin),restype,
		       vect_dims,slots,prop) 
	  => (call_exp,prop')
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,impl,st) => (call_exp, prop')

  rule	(* Rule above failed. Also consider koening lookup. *)
	get_koening_function_types(env,fn,args,nargs,impl) => ktypelist &
	elab_types (env, args, ktypelist,impl) 
	  => (args', constlist, restype, functype,vect_dims,slots) &
	deoverload_funcname(fn,functype) => fn' &
	is_tuple restype => tuple &
	is_builtin_func fn' => builtin &
	Util.list_reduce(constlist,Types.const_and) => const &
	elab_consts(restype,const) => tyconst &
	get_properties(restype,tyconst) => prop &
	vectorize_call(Exp.CALL(fn',args',tuple,builtin),restype,
		       vect_dims,slots,prop) 
	  => (call_exp,prop')
	-----------------------------------------------
	elab_call_args (env,fn,args,nargs,impl,st) => (call_exp, prop)


	(* no matching type found. *)
  rule	Lookup.lookup_functions_in_env(env,fn) => typelist &
	Util.list_map(typelist,Types.unparse_type) => t_lst &
	Absyn.path_string fn => fn_str &
	Util.string_delimit_list(t_lst,"\n -") => types_str &
	Util.string_append_list(
	   ["Error, no matching function found for ", fn_str,
	    ", candidates are: \n -",types_str, ".\n"]) => str &
	Print.print_error_buf str
	-------------------------
	elab_call_args(env,fn,args,nargs,impl,st) => fail

  rule	not Lookup.lookup_type(env,fn,false (*msg*)) => (_,_) &	
	Print.print_error_buf "# Couldn't find function " & 
	Absyn.path_string fn => s & Print.print_error_buf s &
	Print.print_error_buf "\n" 
	-------------------------------------------------------------------
	elab_call_args(env,fn,args,nargs,impl,st) => fail

  rule	(*elab_exp(env, e) => (e',Types.PROP(t,_)) &*)
	Debug.fprint("failtrace", "- elab_call_args failed\n")
	---------------------------------
	elab_call_args(env,fn,args,nargs,impl,st) => fail

end

(** relation: vectorize_call
 ** author: PA
 **
 ** Takes an expression and a list of array dimensions and the Slot list.
 ** It will vectorize the expression over the dimension given as array dim
 ** for the slots which have that dimension.
 ** For example foo:(Real,Real[:])=> Real
 ** foo(1:2,[1,2;3,4]) vectorizes with arraydim {2} to 
 ** {foo(1,{1,2}),foo(2,{3,4})}
 **)

relation vectorize_call: (Exp.Exp, (* exp *)
			  Types.Type, (* exp_type *)
			  Types.ArrayDim list, 
			  Slot list,
			  Types.Properties) 
	  => (Exp.Exp,Types.Properties) = 

  axiom	vectorize_call(e,e_type,[],_,prop) => (e,prop)


	(* Scalar expression, i.e function call *)
  rule	Types.elab_type(e_type) => exp_type & 
	vectorize_call_scalar(Exp.CALL(fn,args,tuple,builtin),
			      exp_type,dim,slots) 
	  => vect_exp &
	vectorize_call(vect_exp,e_type,ad,slots,prop) 
	  => (vect_exp',Types.PROP(tp,c)) &

	Types.lift_array(tp,SOME(dim)) => tp'
	------------------------------
	vectorize_call(Exp.CALL(fn,args,tuple,builtin),e_type,
		       Types.DIM(SOME(dim))::ad,slots, prop) 
	  => (vect_exp',Types.PROP(tp',c))

	  (* array expression of function calls *)
  rule	Types.elab_type(e_type) => exp_type & 
	vectorize_call_array(Exp.ARRAY(tp,scalar,expl),
			      exp_type,dim,slots) 
	  => vect_exp &

	vectorize_call(vect_exp,e_type,ad,slots,prop) 
	  => (vect_exp',Types.PROP(tp,c)) &
	Types.lift_array(tp,SOME(dim)) => tp'
	------------------------------
	vectorize_call(Exp.ARRAY(tp,scalar,expl),e_type,
		       Types.DIM(SOME(dim))::ad,slots, prop) 
	  => (vect_exp',Types.PROP(tp',c))

  rule	Debug.fprint("failtrace","-vectorize_call failed\n")
	---------------------------
	vectorize_call(_,_,_,_,_)=> fail
end

(** relation : vectorize_call_array
 ** author: PA
 **
 ** Helper relation to vectorize_call, vectoriezes ARRAY expression to
 ** an array of array expressions.
 **)
 relation vectorize_call_array:(Exp.Exp, 
				Exp.Type,
				int, (* cur_dim *)	
				Slot list) => Exp.Exp =
	 
  rule	vectorize_call_array_2(expl,exp_tp,cur_dim,slots) => arr_expl &
	Exp.type_builtin(exp_tp) => scalar' &
	let res_exp = Exp.ARRAY(tp,scalar',arr_expl)
	-----------------------------
	vectorize_call_array(Exp.ARRAY(tp,scalar,expl),exp_tp,cur_dim,slots)
	  => res_exp
end

(** relation: vectorize_call_array_2
 ** author: PA
 **
 ** Helper relation to vectorize_call_array
 **)

relation vectorize_call_array_2: (Exp.Exp list, Exp.Type, int, Slot list) 
 	  => Exp.Exp list =

  axiom	vectorize_call_array_2([],tp,cur_dim,slots) => []

  rule	vectorize_call_array_3(e,e_tp,cur_dim,slots) => e' &
	vectorize_call_array_2(es,e_tp,cur_dim,slots) => es'
	-----------------------------------
	vectorize_call_array_2(e::es,e_tp,cur_dim,slots) => e'::es'
end

(** relation: vectorize_call_array_3
 ** author: PA
 **
 ** Helper relation to vectorize_call_array_2
 **)

relation vectorize_call_array_3:(Exp.Exp, 
				 Exp.Type, 
				 int, (* cur_dim *)
				 Slot list) 
	  => Exp.Exp =


  rule	vectorize_call_scalar(e,e_tp,cur_dim,slots) => e'
	-----------------------
	vectorize_call_array_3(e as Exp.CALL(_,_,_,_),e_tp,cur_dim,slots) => e'

  rule	vectorize_call_array(e,e_tp,cur_dim,slots) => e'
	---------------------------
	vectorize_call_array_3(e as Exp.ARRAY(_,_,_),e_tp,cur_dim,slots) => e'
end

(** relation: vectorize_call_scalar
 ** author: PA
 **
 ** Helper relation to vectorize_call, vectorizes CALL expressions to 
 ** array expressions.
 **)

relation vectorize_call_scalar:(Exp.Exp, 
				Exp.Type,
				int, (* cur_dim *)
				Slot list) => Exp.Exp =

  rule	vectorize_call_scalar_2(args,slots,1,dim,callexp) => expl &
	Exp.type_builtin(e_type) => scalar &
	let new_exp = Exp.ARRAY(e_type,scalar,expl)
	-------------------
	vectorize_call_scalar(callexp as Exp.CALL(fn,args,tuple,builtin),
			      e_type,dim,slots)
	  => new_exp

  rule	Debug.fprint("failtrace","-vectorize_call_scalar failed\n")
	-------------------------
	vectorize_call_scalar(_,_,_,_) => fail
end

(** relation: vectorize_call_scalar_2
 ** author: PA
 **
 ** Iterates through vectorized dimension an creates argument list according
 ** to vectorized dimension in corresponding slot.
**)
relation vectorize_call_scalar_2: (Exp.Exp list, 
				   Slot list, 
				   int, (* cur_dim - current indx in dim *)
				   int, (* dim - dimension size *)
				   Exp.Exp) 
	=> Exp.Exp list =
	 
  rule	int_le(cur_dim,dim) => true &
	vectorize_call_scalar_3(expl,slots,cur_dim) => callargs &
	int_add(cur_dim,1) => cur_dim' &
	vectorize_call_scalar_2(expl,slots,cur_dim',dim,Exp.CALL(fn,args,t,b)) 
	  => res
	  ---------------------
	vectorize_call_scalar_2(expl,slots,cur_dim,dim,Exp.CALL(fn,args,t,b))
	  => Exp.CALL(fn,callargs,t,b)::res
	  
  axiom	vectorize_call_scalar_2(_,_,_,_,_) => []
end

(** relation: vectorize_call_scalar_3
 ** author: PA
 **
 ** Helper relation to vectorize_call_scalar_2
 **)
relation vectorize_call_scalar_3: (Exp.Exp list, Slot list, int (* dim_indx *))
	=> Exp.Exp list =

  axiom	vectorize_call_scalar_3([],[],_) => [] 

	(* scalar argument *)
  rule	vectorize_call_scalar_3(es,ss,dim_indx) => res
	----------------------------------------
	vectorize_call_scalar_3(e::es,SLOT(_,_,_,[])::ss,dim_indx) => e::res

	(* foreach argument *)
  rule	vectorize_call_scalar_3(es,ss,dim_indx) => res &
	Exp.simplify(Exp.ASUB(e,dim_indx)) => asub_exp
	-----------------------------------
	vectorize_call_scalar_3(e::es,SLOT(_,_,_,_::_)::ss,dim_indx) 
	  => asub_exp::res
end

(** relation: deoverload_funcname
 **
 ** This relation is used to deoverload function calls. It investigates the
 ** type of the function to see if it has the optional functionname set. If 
 ** so this is returned. Otherwise return input.
**)

relation deoverload_funcname: (Absyn.Path, Types.Type) => Absyn.Path =

  axiom	deoverload_funcname(fn,(Types.T_FUNCTION(_,_),SOME(fn'))) => fn'

  axiom	deoverload_funcname(fn,(_,_)) => fn

end

(** relation: is_tuple
 **
 ** Return true if Type is a Tuple type.
 **)

relation is_tuple : Types.Type => bool =

  axiom is_tuple((Types.T_TUPLE(_),_)) => true
  axiom	is_tuple( (_,_) )  => false

end

(** relation: elab_types 
 **
 ** Elaborate input parameters to a function and select matching function 
 ** type from a list of types.
 **)

relation  elab_types:  (Env.Env, 
			Absyn.Exp list, (* argument expressions *)
			Types.Type list, (* function candidate types *)
			bool (*impl*) ) 
	  => (Exp.Exp list, 
	      Types.Const list (*const*), 
	      Types.Type(*result type*), 
	      Types.Type(*function type*),
	      Types.ArrayDim list (* Vectorized dimensions*),
	      Slot list (* slots, needed for vectorization *)
	      ) =

	(* We found a match.*)
  rule	make_empty_slots(params) => slots &
	elab_input_args(env, args, [], slots,impl ) 
	  => (args',newslots, clist) &
	slots_vectorizable(newslots) => dims 
	------------------
        elab_types(env, args, (t as (Types.T_FUNCTION(params,restype),_))::trest,impl)
	  => (args', clist, restype, t, dims,newslots)

	(* We did not found a match, try next function type *)
  rule	elab_types(env, args, trest,impl) 
	  => (args',clist, restype,t,dims,slots) 
        -------------------------------------------------------------
        elab_types(env, args, (Types.T_FUNCTION(params,restype),_)::trest,impl)
	  => (args', clist, restype,t,dims,slots)

  rule	Debug.fprintln("failtrace","- elab_types failed.") 
	--------------
	elab_types(env,_,_,_) => fail
end

(** relation: slots_vectorizable
 ** author: PA
 **
 ** This relation checks all vectorized array dimensions in the slots and
 ** confirms that they all are of same dimension,or no dimension, i.e. not
 ** vectorized. The uniform vectorized array dimension is returned.
 **)

relation slots_vectorizable:(Slot list) => Types.ArrayDim list =

  axiom	slots_vectorizable([]) => []

  rule	same_slots_vectorizable(rest,ad) 
	-------------------------------
	slots_vectorizable(SLOT(_,_,_,ad as _::_)::rest) => ad

  rule	slots_vectorizable(rest) => ad
	----------------------------
	slots_vectorizable(SLOT(_,_,_,[])::rest) => ad

  rule	Debug.fprint("failtrace", "-slots_vectorizable failed\n")
	-------------------------
	slots_vectorizable(_) => fail
end

(** relation: same_slots_vectorizable
 ** author: PA
 ** 
 ** This relation succeds if all slots in the list either has the array 
 ** dimension as given by the second argument or no array dimension at all.
 ** The array dimension must match both in dimension size and number of 
 ** dimensions.
 **)
relation same_slots_vectorizable: (Slot list, Types.ArrayDim list) => () =

  axiom	same_slots_vectorizable([],_) 

	(* arraydim must match *)
  rule	same_arraydim_lst(ad, slot_ad) &
	same_slots_vectorizable(rest, ad)
	---------------------------
	same_slots_vectorizable(SLOT(_,_,_,slot_ad as (_::_))::rest, ad) 

	(* empty arradim matches too *)
  rule	same_slots_vectorizable(rest, ad)
	---------------------------
	same_slots_vectorizable(SLOT(_,_,_,[])::rest, ad)
end

(** relation: same_arraydim_lst
 ** author: PA
 **
 **  Helper relation to same_slots_vectorizable. 
 **)

relation same_arraydim_lst: (Types.ArrayDim list, Types.ArrayDim list) => () =

  axiom	same_arraydim_lst([],[])

  rule	i1 = i2 &
	same_arraydim_lst(ads1,ads2)
	--------------------
	same_arraydim_lst(Types.DIM(SOME(i1))::ads1,Types.DIM(SOME(i2))::ads2)

  rule	same_arraydim_lst(ads1,ads2)
	--------------------
	same_arraydim_lst(Types.DIM(NONE)::ads1,Types.DIM(NONE)::ads2)
end

(** relation: get_properties
 ** This relation creates a Properties object from a Types.Type and a 
 ** Types.TupleConst value.
 **)

relation get_properties : (Types.Type, Types.TupleConst)  => Types.Properties =

	(* At least two elements in the type list, this is a tuple. *)
	(* LS: Tuples are fixed before here *)
  axiom	get_properties (tt as (Types.T_TUPLE(_),_), const) => Types.PROP_TUPLE(tt, const)

	(* One type, this is a tuple with one element. The resulting properties 
	 * is then identical to that of a single expression. *)
  axiom	get_properties(t, Types.TUPLE_CONST(Types.CONST(b)::[]))  => Types.PROP(t, b)

  axiom	get_properties(t, Types.TUPLE_CONST(Types.CONST(b)::[]))  => Types.PROP(t, b)

  axiom	get_properties(t, Types.CONST(b))  => Types.PROP(t, b)

  rule	Debug.fprint("failtrace", "- get_properties failed: ") &
	Types.unparse_type ty => tystr &
	Types.unparse_tupleconst const => conststr &
	Debug.fprint("failtrace", tystr) &
	Debug.fprint("failtrace", ", ") &
	Debug.fprintln("failtrace", conststr)
	------------------------------------------------------
	get_properties (ty,const) => fail
end


(** relation: build_tuple_const
 ** author: LS
 ** 
 ** Build a TUPLE_CONST (Types.TupleConst) for a PROP_TUPLE for a function call
 ** from a list of bools derived from arguments
 **
 ** We should check functions actual arguments instead of their formal
 ** parameters as done below
 **)

relation build_tuple_const : Types.Const list => Types.TupleConst =

  rule	build_tuple_const_list blist => clist
	-------------------------------------
	build_tuple_const blist => Types.TUPLE_CONST(clist)
end

(** relation: build_tuple_const_list
 **
 ** Helper relation to build_tuple_const
 **)

relation build_tuple_const_list : Types.Const list => Types.TupleConst list =

  axiom	build_tuple_const_list [] => []
	
  rule build_tuple_const_list crest => restlist
       ----------------------------------------
       build_tuple_const_list c::crest => Types.CONST(c)::restlist

end

(** relation: elab_consts
 ** author: PR
 **
 ** This just splits the properties list into a type list and a const list. 
 ** LS: Changed to take a Type, which is the functions return type.
 ** LS: Update: const is derived from the input arguments and sent here.
 **)

relation elab_consts : (Types.Type, Types.Const)  => Types.TupleConst =

  rule	check_consts (tys,c) => consts
	-------------------------------
	elab_consts((Types.T_TUPLE(tys),_),c) => Types.TUPLE_CONST(consts)

  (* LS: If not a tuple then one normal type, T_INTEGER etc, but we make a list of types
     with one element and call the same check_consts, so that we always have Types.TUPLE_CONST as result
   *)
  rule	check_consts ([ty],c) => consts
	-----------------------
	elab_consts (ty,c) => Types.TUPLE_CONST(consts)

end

(** relation: check_consts
 ** 
 ** LS: Changed to take a Type list, which is the functions return type. Only
 **  for functions returning a tuple 
 ** LS: Update: const is derived from the input arguments and sent here 
 **)
relation check_consts : (Types.Type list, Types.Const) 
	  => Types.TupleConst list =	

  axiom	check_consts ([],_) => []

  rule  check_const(a,const) => c &
	check_consts(rest,const) => rest'
	-------------------------------
	check_consts (a::rest,const) => c::rest'

end


(** relation: check_const
 ** author: PR
 **  At the moment this make all outputs non cons.
 ** All ouputs should be checked in the function body for constness. 
 ** LS: but it says true? 
 ** LS: Adapted to check one type instead of funcarg, since it just checks 
 ** return type 
 ** LS: Update: const is derived from the input arguments and sent here 
 **)

relation check_const : (Types.Type, Types.Const) => Types.TupleConst  =	
	
  rule	Print.print_error_buf("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const ((Types.T_TUPLE(_),_), c) => fail

  axiom	check_const((_,_), c) => Types.CONST(c)
	
end

(** relation: split_props
 **
 ** Splits the properties list into the separated types list and const list. 
 **)

relation split_props : (Types.Properties list) 
	  => (Types.Type list, Types.TupleConst list) =

  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,Types.CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP(t,c)::props)=> (t::types,Types.CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (Types.PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end

(** relation: get_types
 **
 ** This relatoin returns the types of a Types.FuncArg list.
 **)

relation get_types :(Types.FuncArg list) => Types.Type list =

  rule	(* print("\nDebug: Got a type for output of function. ") & *)
	get_types(rest) => types 
	-----------------
	get_types ((n,t)::rest) => t::types
	
  axiom	get_types ([]) => []
	
end


(** relation: function_params
 **
 ** A function definition is just a clas definition where all publi
 ** components are declared as either inpu or outpu.  This
 ** relation_ find all those components and_ separates them into two
 ** separate lists.
 **)

(* LS: This can probably replaced by Types.get_input_vars and
   Types.get_output_vars *)

relation function_params : Types.Var list => (Types.FuncArg list,
					      Types.FuncArg list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	(*Debug.print("protected") &*)
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	(*Debug.print("not protected. intput") &*)
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	(*Debug.print("not protected. output") &*)
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	Print.print_error_buf "# Components in functions must be INPUT or OUTPUT\n" &
	Print.print_error_buf "    component: " & 
	Print.print_error_buf n & Print.print_error_buf "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	Print.print_error_buf "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(* * relation_: elab_input_args
 **
 ** This relation_ elaborates on a number of expressions and_ matches
 ** them to a number of `Types.Var' objects, applying type_ conversions
 ** on the expressions when necessary to match the type_ of the
 ** `Types.Var'.
 * *)

(* PA: Positional arguments and named arguments are filled in the argument slots as:
 1. Positional arguments fill the first slots according to their position.
 2. Named arguments fill slots with the same name as the named argument.
 3. Unfilled slots are checks so that they have default values, otherwise error.
*)
relation elab_input_args : (Env.Env, Absyn.Exp list, Absyn.NamedArg list, 
			    Slot list, bool (* impl *) )
	=> (Exp.Exp list, Slot list, Types.Const list (*const*)) =

	  (* Fill slots with positional arguments*)
  rule	funcarg_lst_from_slots(slots) => farg &
 	elab_positional_input_args(env,exp,farg,slots,impl) => (slots',clist1) &
	(* recursive call fills named arguments *)
	elab_input_args(env,[],narg,slots',impl) => (_,newslots,clist2) &
	list_append(clist1,clist2) => clist &
 	exp_list_from_slots(newslots) => explst
	----------------------------------------------------------------
	elab_input_args(env,exp as _::_,narg,slots,impl) 
	  => (explst,newslots,clist)

	(* Fill slots with named arguments *)
  rule	funcarg_lst_from_slots(slots) => farg &
	elab_named_input_args(env,narg,farg,slots,impl) => (newslots,clist) &
	exp_list_from_slots(newslots) => newexp 
	------------------------------------------------------------
	elab_input_args(env,[],narg as _::_,slots,impl) 
	  => (newexp,newslots,clist)
	
  axiom	elab_input_args(env,[],[],slots,impl) => ([],slots,[])
	
(*  rule	Print.print_buf "#Error, elab_input_args failed.\n"
	-----------------------------------------
	elab_input_args(_,_,_,_,_) => fail*)
end

(** relation: make_empty_slots
 **
 ** Helper relation to elab_input_args.
 ** Creates the slots to be filled with arguments. Intially they are empty.
 **)

relation make_empty_slots : (Types.FuncArg list) => Slot list =
	
  axiom	make_empty_slots([]) => []
	
  rule	make_empty_slots(fs) => ss
	--------------------------
	make_empty_slots(fa::fs) => SLOT(fa,false,NONE,[])::ss
end

(** relation: funcarg_lst_from_slots
 **
 ** Converts slots to Types.Funcarg
 **)

relation funcarg_lst_from_slots : Slot list => Types.FuncArg list =
	
  axiom	 funcarg_lst_from_slots [] => [] 

  rule	funcarg_lst_from_slots(xs) => fs
	-------------------------------
	funcarg_lst_from_slots(SLOT(fa,_,_,_)::xs) => fa::fs
end 

(** relation exp_list_from_slots
 **
 ** Convers slots to expressions 
 **)

relation exp_list_from_slots: (Slot list ) => Exp.Exp list =
	
  axiom	exp_list_from_slots [] => []
	
  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,SOME(e),_)::xs) => e::lst

  rule	exp_list_from_slots(xs) => lst
	------------------------------
	exp_list_from_slots(SLOT(_,_,NONE,_)::xs) => lst
end

(** relation: fill_default_slots
 **
 ** This function takes a slot list and a class definition of a function 
 ** and fills  default values into slots which have not been filled.
 **)

relation fill_default_slots: (Slot list , SCode.Class, Env.Env, bool (*impl*)) 
	  => Slot list =
	
  rule	fill_default_slots(xs,class,env,impl) => res
	----------------------------
	fill_default_slots ( SLOT(fa,true,e,ds)::xs,class,env,impl) 
	  => SLOT(fa,true,e,ds)::res

  rule	fill_default_slots(xs,class,env,impl) => res &
	SCode.get_element_named(id,class) => SCode.COMPONENT(_,_,_,_,_,_,SCode.MOD(_,_,_,SOME(dexp)),_,_) &
	elab_exp (env,dexp,impl,NONE) => (exp,Types.PROP(t,c1),_) &
	Types.match_type(exp,t,tp) => (exp',_) 
	-----------------------------------------------------------------------
	fill_default_slots (SLOT((id,tp),false,e,ds)::xs,class,env,impl) 
	  => SLOT((id,tp),true,SOME(exp'),ds)::res

  rule	fill_default_slots(xs,class,env,impl) => res &
	Print.print_error_buf "#Error filling slot, id = " &
	Print.print_error_buf id &
	Print.print_error_buf "\n"
	----------
	fill_default_slots (SLOT((id,tp),false,e,ds)::xs,class,env,impl) 
	  => SLOT((id,tp),true,e,ds)::xs

  axiom	fill_default_slots([],_,_,_) => []
end

(** relation print_slots_str
 **
 ** prints the slots to a string
 **)

relation print_slots_str: Slot list => string =

  rule	Types.print_farg_str farg => farg_str &
	Util.if(filled,"filled","not filled") => filled &
	Dump.get_option_str(exp,Exp.print_exp_str) => str &
	Util.list_map(ds,Types.get_arraydim_str) => str_lst &
	Util.string_delimit_list(str_lst,", ") => s &
	Util.string_append_list(["SLOT(",farg_str,", ",filled,", ",str,", [",
				 s,"])\n"]) => s1 &
	print_slots_str(xs) => s2 &
	string_append(s1,s2) => res
	---------------
	print_slots_str (SLOT(farg,filled,exp,ds)::xs) => res

  axiom	print_slots_str([] ) => ""
end 

(** relation: elab_positional_input_args
 **
 ** This relation elaborates the positional input arguments of a function.
 ** A list of slots is filled from the beginning with types of each 
 ** positional argument.
 ** 
 **)

relation elab_positional_input_args : (Env.Env, Absyn.Exp list, 
				       Types.FuncArg list,  Slot list, 
				       bool (* impl *) ) 
	  => (Slot list, Types.Const list (*const*)) =
	  
  axiom	elab_positional_input_args(_, [], _, slots, impl) => (slots, [])
	
	(* Exact match *)
  rule	elab_exp(env, e,impl,NONE) => (e',Types.PROP(t, c1),_) &
	Types.match_type(e', t, vt) => (e'',_) &
	elab_positional_input_args(env, es, vs,slots,impl) => (slots',clist) &
	fill_slot(farg, e'',[](* no vectorized dim*),slots') => newslots
	-------------------------------------
	elab_positional_input_args(env, e::es, (farg as (_,vt))::vs, slots, impl) 
	    => (newslots, c1::clist)

	(* check if vectorized argument *)
  rule	elab_exp(env, e,impl,NONE) => (e',Types.PROP(t, c1),_) &
	Types.vectorizable_type(e', t, vt) => (e'',_,ds) &
	elab_positional_input_args(env, es, vs,slots,impl) => (slots',clist) &
	fill_slot(farg, e'',ds,slots') => newslots
	-------------------------------------
	elab_positional_input_args(env, e::es, (farg as (_,vt))::vs, slots, impl) 
	    => (newslots, c1::clist)
end

(** relation elab_named_input_args
 **
 ** This relation takes an Env, a NamedArg list, a Types.FuncArg list and a 
 ** Slot list.
 ** It builds up a new slot list and a list of elaborated expressions.
 ** If a slot is filled twice the relation fails. If a slot is not filled at 
 ** all and the 
 ** value is not a parameter or a constant the relation also fails.
 **)

relation elab_named_input_args : (Env.Env, Absyn.NamedArg list, 
				  Types.FuncArg list, Slot list, bool (*impl*) ) 
	=> (Slot list, Types.Const list (*const*)) =

(**  TODO: implement check_slots_filled.
 
 ** rule	check_slots_filled(env,slots) 
 **	----------------------------
 **	elab_named_input_args(env,[],farg,slots) => ([],slots) 
 **)

  rule	elab_exp(env, e,impl,NONE) => (e',Types.PROP(t, c1),_) &
	find_named_arg_type(id,farg) => vt &
	Types.match_type(e', t, vt) => (e'',_) &
	fill_slot((id,vt), e'', [], slots) => slots' &
	elab_named_input_args(env, nas, farg ,slots',impl) => (newslots, clist)
	---------------------
	elab_named_input_args (env, Absyn.NAMEDARG(id,e)::nas,farg,slots,impl) 
	  => (newslots, c1::clist)

axiom elab_named_input_args (_,[],_,slots,impl) => (slots,[])

  rule	Debug.fprint("failtrace", "- elab_named_input_args failed\n") 
	-----------------
	elab_named_input_args(env,narg,farg,_,impl) => fail
end

(** relation find_named_arg_type
 **
 ** This relation takes an Ident and a FuncArg list, and returns the FuncArg
 ** which has  that identifier.
 ** Used for instance when looking up named arguments from the function type.
 **)

 relation find_named_arg_type : (Ident, Types.FuncArg list) => Types.Type =
	 
  rule	 id = id2
	 -----------------
	 find_named_arg_type (id, ((id2,farg))::ts) => farg
  rule	 not id = id2  &
	 find_named_arg_type (id,ts) => farg
	 ----------------------------------
	 find_named_arg_type(id,(farg as (id2,_))::ts) => farg
end

(** relation: fill_slot
 **
 ** This relation takses a `FuncArg' and an Exp.Exp and a Slot list and fills 
 ** the slot holding the FuncArg, by setting the boolean value of the slot 
 ** and setting the expression. The relation fails if the slot is allready set.
 **)

relation fill_slot:(Types.FuncArg, Exp.Exp, Types.ArrayDim list,Slot list) 
	  => Slot list =
	
  rule	fa1 = fa2
	---------
	fill_slot((fa1,_), exp,ds, SLOT((fa2,b),false,_,_)::xs) 
	  => SLOT((fa2,b),true,SOME(exp),ds)::xs

  rule	fa1 = fa2 &
	Print.print_error_buf "#Error, slot in functional argument allready filled.\b" 
	--------------------------------------------------------------
	fill_slot((fa1,_),exp, ds, SLOT((fa2,b),true,_,_)::xs) => fail

  rule	not fa1 = fa2 &
	fill_slot(farg,exp,ds,xs) => newslots
	------------------------------
	fill_slot((farg as (fa1,_)), exp,ds, (s1 as SLOT((fa2,_),_,_,_))::xs) => s1::newslots

  rule  Print.print_error_buf "#Error, slot not found in function type.\n"
	---------------------------------------------------
	fill_slot(_,_,_,_) => fail
end


(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef, bool (*impl*) )
	  => (Exp.Exp, Types.Properties, SCode.Accessibility) =

  rule	elab_cref_subs (env,c,impl) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc') 
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c,impl) => (exp, Types.PROP(t, const), acc')


  rule	elab_cref_subs (env,c,impl) => (c', const) &
	Print.print_error_buf "# Unknown component: " & 
	Dump.print_component_ref_str c => s & 
	Print.print_error_buf s &
	Print.print_error_buf " in scope " &
	Env.print_env_path_str env => str &
	Print.print_error_buf str &
	Print.print_error_buf "\n" 
	-----------------------------------------------------
	elab_cref(env, c,impl) => fail

  rule	Debug.fprint("failtrace", "- elab_cref failed: ") & 
	Debug.fcall("failtrace",Dump.print_component_ref, c) & 
	Debug.fprint("failtrace", "\n")
	------------------------------
	elab_cref (env,c,impl) => fail
end

(** relation: fill_cref_subscripts
 *
 ** This is a helper relation to elab_cref2.
 ** It investigates a Types.Type in order to fill the subscript lists of a 
 ** component reference. For instance, the name 'a.b' with the type array of 
 ** one dimension will become 'a.b[:]'.
 **)

relation fill_cref_subscripts : (Exp.ComponentRef,Types.Type)
	  => Exp.ComponentRef =

  axiom	fill_cref_subscripts (e as Exp.CREF_IDENT(_,[]),t) => e

  rule	fill_subscripts (subs,t) => subs'
	------------------
	fill_cref_subscripts (Exp.CREF_IDENT(id,subs),t)
	  => Exp.CREF_IDENT(id,subs')

  rule	fill_cref_subscripts (cref,t) => cref'
	-----------------------------
	fill_cref_subscripts (Exp.CREF_QUAL(id,subs,cref),t)
			      => Exp.CREF_QUAL(id,subs,cref') 
end

(** relation: fill_subscripts
 ** 
 ** Helper relation to fill_cref_subscripts.
 **)

relation fill_subscripts : (Exp.Subscript list, Types.Type) 
	  => Exp.Subscript list =

rule	fill_subscripts ([],t) => subs' &
	list_append([Exp.WHOLEDIM],subs') => subs''
	------------
	fill_subscripts ([],(Types.T_ARRAY(_,t),_)) => subs''

  rule	fill_subscripts (subs,t) => subs' 
	------------
	fill_subscripts (fs::subs,(Types.T_ARRAY(_,t),_)) => fs::subs'

  axiom	fill_subscripts (subs,_) => subs

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 ** Constant values are e.g.: 1+5, c1+c2, ps1*2   ,where c1 and c2 are modelica constants,
 **						    ps1 and ps2 are structural parameters.
 ** Non Constant values are e.g. : p1+p2, x1*x2  ,where p1,p2 are modelica parameters, 
 **						  x1,x2 modelica variables.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, SCode.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,
	      Types.Const,
	      SCode.Accessibility) =

	  (* If type not yet determined, component must be referencing itself. 
	   ** constantness undecidable since binding not available, 
	   ** return C_VAR **)
  rule	Types.elab_type t => t' 
	----------------
	elab_cref2(_,cr,acc,_,t as (Types.T_NOTYPE,_),_) 
	  => (Exp.CREF(cr,t'),Types.C_VAR,acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------------------------
	elab_cref2 (_,cr, acc, SCode.VAR, tt,_) 
	  => (Exp.CREF(cr',t),Types.C_VAR, acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	-----------------------------------
	elab_cref2 (_,cr, acc, SCode.DISCRETE,tt,_)
	  =>(Exp.CREF(cr',t),Types.C_VAR,acc)

  rule	value_exp v => e &
	Types.type_of_value(v) => et &
	Types.match_type(e,et,t) => (e',_)
	-----------------------------------
	elab_cref2 (_,cr,_,SCode.CONST,t, Types.VALBOUND(v)) 
	  => (e',Types.C_CONST,SCode.RO)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e'
	-----------------------------------
  	elab_cref2 (env,cr,acc,SCode.PARAM,tt, Types.VALBOUND(v)) 
	  => (e',Types.C_PARAM,acc)

  rule	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	value_exp v => e'
	----------------
  	elab_cref2 (env,cr,acc,SCode.STRUCTPARAM,tt, Types.VALBOUND(v)) => (e',Types.C_PARAM,acc)

  rule	(* Constants with equal binings should be constant, i.e. true
	 but const is passed on, allowing constants to have wrong bindings
	 This must be caught later on.*)
	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e' 
	-----------------------------------
	elab_cref2 (env,cr,acc,SCode.CONST,tt, Types.EQBOUND(exp,_,const))
	  => (e',const,acc)

  rule	(* ...the same goes for structural parameters.*)
	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e' 
	-----------------------------------
	elab_cref2 (env,cr,acc,SCode.STRUCTPARAM,tt, Types.EQBOUND(exp,_,const))
	  => (e',const,acc)

  rule	(* parameters with equal binding becomes C_PARAM *)
	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e' 
	-----------------------------------
	elab_cref2 (env,cr,acc,SCode.PARAM,tt, Types.EQBOUND(exp,_,const))
	  => (e',Types.C_PARAM,acc)

  rule	(* ..the rest should be non constant, even if they have a 
	 constant binding.*)
	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr' &
	cref_vectorize(Exp.CREF(cr',t),tt) => e' 
	-----------------------------------
	elab_cref2 (env,cr,acc,_,tt, Types.EQBOUND(exp,_,const))
	  => (e',Types.C_VAR,acc)
	  (* Enum constants does not have a value expression *)
  rule	Types.elab_type tt => t
	-----------------
	elab_cref2(env,cr,acc,_,tt as (Types.T_ENUM,_),_) 
	  => (Exp.CREF(cr,t),Types.C_CONST,acc)


  rule	(* If value not constant, but references another parameter, which has a value *)
	(* We need to perform value propagation. *)
	Lookup.lookup_var(env,cref) => (Types.ATTR(_,acc',variability',_),
				       t',
				       binding') &
	elab_cref2(env,cref,acc',variability',t',binding') => (e,const,acc)
	--------------------------------------------------
	elab_cref2 (env,cr,acc, variability,tp,Types.EQBOUND( Exp.CREF(cref,t),_,Types.C_VAR)) 
	  => (e,const,acc)



  rule	Print.print_error_buf "# Constant or parameter with a non-constant initializer\n" &
	Print.print_error_buf "# component: " & 
	Exp.print_component_ref_str cr => s & 
	Print.print_error_buf " = " &
	Exp.print_exp_str exp => str &
	Print.print_error_buf str & Print.print_error_buf "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,_,Types.C_VAR)) => fail

	(* constants without value produce error. *)
  rule	Print.print_error_buf "# Constant without a value\n" &
	Print.print_error_buf "# component: " & 
	Exp.print_component_ref_str cr => s & 
	Print.print_error_buf s &
	Print.print_error_buf "\n" 
	----------------------------------------------
	elab_cref2 (env,cr,_,SCode.CONST,_,Types.UNBOUND) => fail

	(* Parameters without value produce warning *)
  rule	Print.print_error_buf "# Warning, Parameter without a value\n" &
	Print.print_error_buf "# component: " & 
	Exp.print_component_ref_str cr => s &
	Print.print_error_buf s &
	Print.print_error_buf "\n" &
	Types.elab_type tt => t &
	fill_cref_subscripts (cr,tt) => cr'
	----------------------------------------------
	elab_cref2 (env,cr,acc,SCode.PARAM,tt,Types.UNBOUND) 
	  => (Exp.CREF(cr',t),Types.C_PARAM, acc)

  rule	Debug.fprint("failtrace","-elab_cref2 failed\n") 
	----------------------------------------
	elab_cref2 (env,cr,acc,var,tp,bind) => fail

end	

(** relation: cref_vectorize
 **
 ** This relation takes a 'Exp.Exp' and a 'Types.Type' and if the expression
 ** is a ComponentRef and the type is an array it returns an array of 
 ** component references with subscripts for each index.
 ** For instance, parameter Real x[3];   
 ** gives cref_vectorize('x', <arraytype>) => '{x[1],x[2],x[3]}'
 ** This is needed since the DAE does not know what the variable 'x' is, it only
 ** knows the variables 'x[1]', 'x[2]' and 'x[3]'.
 ** NOTE: Currently only works for one and two dimensions.
**)

relation cref_vectorize: (Exp.Exp,Types.Type) => Exp.Exp =


  rule	create_cref_array_2d(cr,1,ds,ds2,exptp,t) => e
	-----------------------------------
	cref_vectorize(Exp.CREF(cr,exptp),(Types.T_ARRAY(Types.DIM(SOME(ds)),(Types.T_ARRAY(Types.DIM(SOME(ds2)),t),_)),_)) =>  e

  rule	create_cref_array(cr,1,ds,exptp,t) => e
	-----------------------------------
	cref_vectorize(Exp.CREF(cr,exptp),(Types.T_ARRAY(Types.DIM(SOME(ds)),t),_)) =>  e

  axiom	cref_vectorize(e,_) => e
end

(** relation: call_vectorize
 ** author: PA
 **
 ** Takes an expression that is a function call and an expresion list
 ** and maps the call to each expression in the list.
 ** For instance, call_vectorize(Exp.CALL(XX("der",),...),{1,2,3}))
 ** => {Exp.CALL(XX("der"),[1]), Exp.CALL(XX("der"),[2]),Exp.CALL(XX("der",[3]))}
 ** NOTE: the vectorized expression is inserted first in the argument list
** of the call, so if extra arguments should be passed these can be given as
** input to the call expression.	    
**)
relation call_vectorize: (Exp.Exp, Exp.Exp list) => Exp.Exp list =

	axiom call_vectorize(e,[]) => []

  rule	call_vectorize(callexp,es) => es' 
	--------------------------------
	call_vectorize(callexp as Exp.CALL(fn,args,tuple,builtin),e::es)
	  => Exp.CALL(fn,e::args,tuple,builtin)::es'

  rule	Debug.fprint("failtrace", "-call_vectorize failed\n")
	-----------------------------
	call_vectorize(_,_) => fail
end
				 
 

(** relation: create_cref_array
 **
 ** helper relation to cref_vectorize, creates each individual cref, 
 ** e.g. {x[1],x[2], ...} from x.
 **)

relation create_cref_array: (Exp.ComponentRef,
			     int, (* index iterator *)
			     int, (* dimension size *)
			     Exp.Type, 
			     Types.Type) => Exp.Exp =

  rule	int_gt(indx,ds) => true
	------------------------
	create_cref_array(cr,indx,ds,et,t) => Exp.ARRAY(et,false,[])

  rule	int_add(indx,1) => indx' &
	create_cref_array(cr,indx',ds,et,t) => Exp.ARRAY(_,_,expl) &
	Exp.subscript_cref(cr,[Exp.INDEX(Exp.ICONST(indx))]) => cr' &
	cref_vectorize(Exp.CREF(cr',et),t) => e'
	------------------------
	create_cref_array(cr,indx,ds,et,t) => Exp.ARRAY(et,false,e'::expl)

  rule	Debug.fprint("failtrace","create_cref_array failed\n")
	------------------------
	create_cref_array(cr,indx,ds,et,t) => fail
end

(** relation: create_cref_array_2d
 **
 ** helper relation to cref_vectorize, creates each individual cref, 
 ** e.g. {x[1,1],x[2,1], ...} from x.
 **)

relation create_cref_array_2d: (Exp.ComponentRef,
				int, (* index iterator *)
				int, (* dimension size 1*)
				int, (* dimension size 2*)
				Exp.Type, 
				Types.Type) => Exp.Exp =

  rule	int_gt(indx,ds) => true
	------------------------
	create_cref_array_2d(cr,indx,ds,ds2,et,t) => Exp.ARRAY(et,false,[])

  rule	int_add(indx,1) => indx' &
	create_cref_array(cr,indx',ds,et,t) => Exp.ARRAY(_,_,expl) &
	Exp.subscript_cref(cr,[Exp.INDEX(Exp.ICONST(indx))]) => cr' &
	cref_vectorize(Exp.CREF(cr',et),t) => e'
	------------------------
	create_cref_array_2d(cr,indx,ds,ds2,et,t) => Exp.ARRAY(et,false,e'::expl)

  rule	Debug.fprint("failtrace","create_cref_array failed\n")
	------------------------
	create_cref_array_2d(cr,indx,ds,ds2,et,t) => fail
end


(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef, bool (*impl*) )
	  => (Exp.ComponentRef, Types.Const) =

  rule	Lookup.lookup_var (env,Exp.CREF_IDENT(id,[])) => (_,t,_) &
	Types.get_dimension_sizes t => sl &
	elab_subscripts_dims(env,ss,sl,impl) => (ss', const) 
 (*   elab_subscripts (env, ss) => (ss', const) *)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss),impl)
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss, impl) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss),impl)
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss, impl) => (ss', const1) &
	elab_cref_subs(env,subs,impl) => (cr, const2) &
	Types.const_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs),impl)
	  => (Exp.CREF_QUAL(id,ss',cr), const)


  rule	Debug.fprint("failtrace", "- elab_cref_subs failed\n")
	---------------------
	elab_cref_subs(_,_,impl) => fail
end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 ** HJ: not checking for constant, returning if constant or not
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list, bool (*impl*) )
	  => (Exp.Subscript list, Types.Const) =

  axiom	elab_subscripts (_,[],_) => ([], Types.C_CONST)

  rule	elab_subscript (env,sub,impl) => (sub',const1) &
	elab_subscripts (env,subs,impl) => (subs',const2) &
	Types.const_and (const1, const2) => const 
	-----------------------------------
	elab_subscripts (env,sub::subs,impl) => (sub'::subs', const)
end

(** relation: elab_subscripts_dims
 **
 ** Helper relation to elab_subscripts
 **)

relation elab_subscripts_dims : (Env.Env, 
				 Absyn.Subscript list, 
				 int list, 
				 bool (*impl*) )
	  => (Exp.Subscript list, Types.Const) =

  axiom	elab_subscripts_dims (_,[],_,_) => ([], Types.C_CONST)
	
	(* If constant, call ceval. *)
  rule	elab_subscript (env,sub,impl) => (sub',const1) &
	elab_subscripts_dims (env,subs,restdims,impl) => (subs',const2) &
	Types.const_and (const1, const2) => Types.C_CONST &
	Ceval.ceval_subscripts(env, sub'::subs',dim::restdims,impl,Ceval.MSG) => ss
	-----------------------------------
	elab_subscripts_dims (env,sub::subs,dim::restdims,impl) 
	  => (ss, Types.C_CONST)

  rule	elab_subscript (env,sub,impl) => (sub',const1) &
	elab_subscripts_dims (env,subs,restdims,impl) => (subs',const2) &
	Types.const_and (const1, const2) => const
	-----------------------------------
	elab_subscripts_dims (env,sub::subs,dim::restdims,impl) => (sub'::subs', const)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript, bool (*impl*) )
	  => (Exp.Subscript, Types.Const) =

  axiom	elab_subscript (_,Absyn.NOSUB,impl) => (Exp.WHOLEDIM, Types.C_CONST)

  rule elab_exp (env,sub,impl,NONE) => (sub', Types.PROP(ty, const),_) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub),impl) => (sub'', const)

end

(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type ((Types.T_INTEGER(_),_),_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type ((Types.T_ARRAY(_,(Types.T_INTEGER(_),_)),_),_,sub)
	  => Exp.SLICE(sub)

  rule	Print.print_error_buf "# Subscript is not an integer or integer array\n" &
	Print.print_error_buf "    expression: " & Dump.print_exp_str e => s &
	Print.print_error_buf s &
 	Print.print_error_buf " :: " & Types.unparse_type t => s & 
	Print.print_error_buf s &
	Print.print_error_buf "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c,_), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type ((Types.T_ARRAY(Types.DIM(_),t),_),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type ((Types.T_ARRAY(dim,t),p),
			Exp.SLICE(_)::subs)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type ((Types.T_ARRAY(dim,t),p),
			Exp.WHOLEDIM::subs)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	Print.print_buf "- subscript_type failed (" & Types.print_type t &
	Print.print_buf " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Env.Env,
		       Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties,
		       Exp.Exp, Types.Properties,
		       bool,Interactive.InteractiveSymbolTable option)
	  => (Exp.Exp, Types.Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c &
	ceval_ifexp_if_constant(env,e1,e2,e3,c1,impl,st) => exp
	-----------------------------
	elab_ifexp(env,e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3),impl,st) => (exp, Types.PROP(t2, c))

  rule	Types.match_type(e2,t2,t3) => (e2',t2') & (* then-part type converted to match else-part *)
	const_ifexp(e1,c1,c2,c3) => c &
	ceval_ifexp_if_constant(env,e1,e2',e3,c1,impl,st) => exp
	-----------------------------
	elab_ifexp(env,e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3),impl,st) => (exp, Types.PROP(t2', c))

  rule	Types.match_type(e3,t3,t2) => (e3',t3') & (* else-part type converted to match then-part *)
	const_ifexp(e1,c1,c2,c3) => c &
	ceval_ifexp_if_constant(env,e1,e2,e3',c1,impl,st) => exp
	-----------------------------
	elab_ifexp(env,e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),
		   e3,Types.PROP(t3,c3),impl,st) => (exp, Types.PROP(t2, c))

  rule	not t1 = ((Types.T_BOOL([]),NONE)) &
	Print.print_error_buf "# conditional in if expression has to be boolean\n" &
	Print.print_error_buf "    got type: " & 
	Types.unparse_type t1 => s &
	Print.print_error_buf "\n" &
	Print.print_error_buf "    expression: " & 
	Exp.print_exp_str e1 => s &
	Print.print_error_buf s & 
	Print.print_error_buf "\n"
	--------------------------------------------------------
	elab_ifexp(env,e1,Types.PROP(t1,c1),e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3),impl,st) => fail

  rule	Types.equivtypes(t2,t3) => false &
	Print.print_error_buf "# Type mismatch in if-expression\n" &
	Print.print_error_buf "    true branch : " & 
	Exp.print_exp_str e2  => s &
	Print.print_error_buf s & 
 	Print.print_error_buf " :: " & 
	Types.unparse_type t2 => s & 
	Print.print_error_buf s & 
	Print.print_error_buf "\n" &
	Print.print_error_buf "    false branch: " & 
	Exp.print_exp_str e3 => s &
	Print.print_error_buf s & 
 	Print.print_error_buf " :: " & Types.unparse_type t3 => s &
	Print.print_error_buf s & 
	Print.print_buf "\n"
	-----------------------------------------------
	elab_ifexp(env,e1,Types.PROP((Types.T_BOOL(_),_),c1),
		   e2,Types.PROP(t2,c2),e3,Types.PROP(t3,c3),impl,st) => fail

  rule	Print.print_buf "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_,_,_,_) => fail

end

(** relation: ceval_ifexp_if_constant
 ** author: PA
 **
 ** Constant evaluates the condition of an expression if it is constants and
 ** elimitates the if expressions by selecting branch.
 **)

 relation ceval_ifexp_if_constant:(Env.Env,Exp.Exp, Exp.Exp, Exp.Exp, Types.Const,
				   bool,Interactive.InteractiveSymbolTable option) 
	  => Exp.Exp =

  axiom	ceval_ifexp_if_constant(env,e1,e2,e3, Types.C_VAR,impl,st) 
	  => (Exp.IFEXP(e1,e2,e3))
 
  axiom	ceval_ifexp_if_constant(env,e1,e2,e3, Types.C_PARAM,impl,st) 
	  => (Exp.IFEXP(e1,e2,e3))

  rule	Ceval.ceval(env,e1,impl,st,NONE,Ceval.MSG) => (Values.BOOL(cond),_) &
	Util.if(cond,e2,e3) => res
	-----------------------
	ceval_ifexp_if_constant(env,e1,e2,e3,Types.C_CONST,impl,st) => res
end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, Types.Const, Types.Const, Types.Const) 
	  => Types.Const =

  rule	Util.list_reduce([c1,c2,c3], Types.const_and) => const
	---------------------------
	const_ifexp(_,c1,c2,c3) => const
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY(Exp.OTHER,false,[])

  rule	Util.list_map(x::xs, value_exp) => explist &
	value_type x => vt &
	Types.elab_type vt => t &
	Types.is_array vt => a
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(t,a,explist)

  rule	Util.list_map(vallist, value_exp) => explist
	--------------------------------------------
	value_exp (Values.TUPLE(vallist)) => Exp.TUPLE(explist)

  rule	Print.print_error_buf "- value_exp failed: " &	
	Values.val_string v => vs &
	Print.print_error_buf vs &
	Print.print_error_buf "\n"
	----------------------------
	value_exp v => fail

end

(* FIXME: Already a relation in Types called type_of_value *)

(** relation: value_type
 ** This relation investigates a Value and return the Type of this value.
 **)

(* LS: Removed. Using Types.type_of_value instead *)
(*
relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => ((Types.T_INTEGER([]),NONE))
  axiom	value_type Values.REAL(x)    => ((Types.T_REAL([]),NONE))
  axiom value_type Values.STRING(x)  => ((Types.T_STRING([]),NONE))
  axiom value_type Values.BOOL(x)    => ((Types.T_BOOL([]),NONE))

  axiom	value_type Values.ENUM(x) => ((Types.T_ENUM,NONE))

  rule	value_type vlfirst => eltype &
	list_length(vlrest) => dim &
	int_add(dim,1) => dim'
	----------------------------
	value_type Values.ARRAY(vlfirst::vlrest) => ((Types.T_ARRAY(Types.DIM(SOME(dim')), eltype),NONE))

  rule	Util.list_map(vl, value_type) => tylist
	---------------------------------------
	value_type Values.TUPLE(vl) => ((Types.T_TUPLE(tylist),NONE))

  rule	Types.values_to_vars(vl,ids) => vars &
	Absyn.path_string(cname) => cname_str
	---------------------------------------
	value_type Values.RECORD(cname,vl,ids) => ((Types.T_COMPLEX(ClassInf.RECORD(cname_str),vars),NONE))

  rule	Print.print_error_buf "- value_type failed: " &	
	Values.val_string v => vs &
	Print.print_error_buf vs &
	Print.print_error_buf "\n"
	----------------------------
	value_type v => fail

end
*)

relation value_type : Values.Value => Types.Type =

  rule	Types.type_of_value v => t
	--------------------------
	value_type v => t

end	


(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref2  : (Env.Env, Exp.ComponentRef, int list, bool (*impl*) )
	  => Exp.ComponentRef =

  rule	Ceval.ceval_subscripts (env,ss,sl,impl,Ceval.MSG) => ss'
	--------------------------------
	canon_cref2 (env, Exp.CREF_IDENT(n,ss),sl,impl) => Exp.CREF_IDENT(n,ss')
end

(** relation: canon_cref
 **
 ** Transform expression to canonical form by constant evaluating all 
 ** subscripts.
**)

relation canon_cref : (Env.Env, Exp.ComponentRef, bool (*impl*) ) 
	  => Exp.ComponentRef =

  rule	Lookup.lookup_var (env,Exp.CREF_IDENT(n,[])) => (_,t,_) &
	Types.get_dimension_sizes t => sl & 
	Ceval.ceval_subscripts (env,ss,sl,impl,Ceval.MSG) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss),impl) => Exp.CREF_IDENT(n,ss')

  rule	
	Lookup.lookup_var (env,Exp.CREF_QUAL(n,[],c)) => (_,t,_) &
	Types.get_dimension_sizes t => sl &
	Ceval.ceval_subscripts (env,ss,sl,impl,Ceval.MSG) => ss' &
	canon_cref2 (env,c,sl,impl) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c),impl) => Exp.CREF_QUAL(n,ss',c')

end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> (Exp.Exp list,Types.Type list) =

  axiom	elab_arglist ([],[]) => ([],[])

  rule	Types.match_type(arg, atype, pt) => (arg',atype') &
	elab_arglist (pts, args) => (args',atypes')
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => (arg'::args',atype'::atypes')

(* This relation should fail sometimes. Thus it is not a good idea to print stuff here... *)

end

(** relation: deoverload
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	Debug.fprint_list("dovl",params,Types.print_type,"\n") & 
	Debug.fprint("dovl","\n===\n") &
	elab_arglist (params, args) => (args',types') &
	compute_return_type(op, types', rtype) => rtype'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype')

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	Print.print_error_buf "# Can't resolve type of expression: " &
	Dump.print_exp_str exp => s &
	Print.print_error_buf s & 
	Print.print_error_buf "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

(** relation: compute_return_type
 ** This relation determines the return type of an operator and the types of 
 ** the operands.
 **)

relation compute_return_type : (Exp.Operator, Types.Type list, Types.Type) => Types.Type =

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_error_buf "# +: Incompatible argument types " &
	Types.unparse_type typ1 => s  &
	Print.print_error_buf s & 
	Print.print_error_buf ", " & Types.unparse_type typ2 => s &	
	Print.print_error_buf s & 
	Print.print_error_buf "\n"
	----------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Print.print_error_buf "# -: Incompatible argument types " &
	Types.unparse_type typ1 => s & 
	Print.print_error_buf s & 
	Print.print_error_buf ", " & Types.unparse_type typ2 => s &	
	Print.print_error_buf s & 
	Print.print_error_buf "\n"
	----------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true 
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Types.subtype(typ1,typ2) => true 
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Print.print_error_buf "# *-: Incompatible argument types " &
	Types.unparse_type typ1 => s & 	
	Print.print_error_buf "ltype: " & 
	Print.print_error_buf s & 
	Types.unparse_type typ2 => s &
	Print.print_error_buf "rtype: " & 
	Print.print_error_buf s & 
	Print.print_error_buf "\n"
	----------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),[typ1,typ2],rtype) => fail

  rule	n_dims typ1 => 1 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n1 &
	dim_size(typ2,1) => n2 &
	dim_size(typ2,2) => m &
	n1 = n2 &
	element_type typ1 => etype &
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(m)),etype),NONE))
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 1 &
	dim_size(typ1,1) => n & 
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	m1 = m2 &
	element_type typ2 => etype & 
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(n)),etype),NONE))
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	dim_size(typ2,2) => p &
	m1 = m2 &
	element_type typ1 => etype &
	let rtype = ((Types.T_ARRAY(Types.DIM(SOME(n)),
				  (Types.T_ARRAY(Types.DIM(SOME(p)),etype),NONE)),NONE))
	-----------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	Print.print_error_buf "# *-----: Incompatible argument types " &
	Types.unparse_type typ1 => s & 	
	Print.print_error_buf "ltype: " & 
	Print.print_error_buf s & 
	Types.unparse_type typ2 => s &
	Print.print_error_buf "rtype: " & 
	Print.print_error_buf s & 
	Print.print_error_buf "\n"	
	-----------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],rtype) => fail

	
  axiom compute_return_type (Exp.MUL_SCALAR_ARRAY(_),[typ1,typ2],rtype) => typ2 (*rtype*)
 
 
 
  axiom	compute_return_type (Exp.MUL_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1(* rtype*)

  axiom	compute_return_type (Exp.DIV_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1(* rtype*)


  axiom	compute_return_type (Exp.ADD(_),_,typ) => typ
  axiom	compute_return_type (Exp.SUB(_),_,typ) => typ
  axiom	compute_return_type (Exp.MUL(_),_,typ) => typ
  axiom	compute_return_type (Exp.DIV(_),_,typ) => typ
  axiom	compute_return_type (Exp.POW(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS_ARR(_),typ1::_,_) => typ1
  axiom	compute_return_type (Exp.UPLUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UPLUS_ARR(_),typ1::_,_) => typ1
  axiom	compute_return_type (Exp.AND,_,typ) => typ
  axiom	compute_return_type (Exp.OR,_,typ) => typ
  axiom	compute_return_type (Exp.NOT,_,typ) => typ
  axiom	compute_return_type (Exp.LESS(_),_,typ) => typ
  axiom	compute_return_type (Exp.LESSEQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATER(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATEREQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.EQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.NEQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.USERDEFINED(_),_,typ) => typ
end 

(** relation n_dims
 ** Returns the number of dimensions of a Type.
 **)
relation n_dims : Types.Type => int =
	
  axiom	n_dims((Types.T_INTEGER(_),_)) => 0
  axiom	n_dims((Types.T_REAL(_),_)) => 0
  axiom	n_dims((Types.T_STRING(_),_)) => 0
  axiom	n_dims((Types.T_BOOL(_),_)) => 0

  rule	n_dims t => ns &
	int_add(ns,1) => n
	-----------------------------
	n_dims((Types.T_ARRAY(_,t),_)) => n

end

(** relation: dim_size
 ** Returns the dimension size of the given dimesion.
 **)

relation dim_size : (Types.Type,int (*n:th dimension*)) => 
	int (* size of n:nth dimension *) =

  axiom	dim_size((Types.T_ARRAY(Types.DIM(SOME(n)),_),_),1) => n

  rule	int_gt(d,1) => true &
	int_sub(d,1) => d' &
	dim_size(t,d') => n
	----------------------
	dim_size((Types.T_ARRAY(_,t),_),d) => n
end

(** relation: element_type
 ** Returns the element type of a type, i.e. for arrays, return the element type, and for 
 ** bulitin scalar types return the type itself.
 **)

relation element_type : Types.Type => Types.Type =
	
  axiom	element_type(t as (Types.T_INTEGER(_),_)) => t
  axiom	element_type(t as (Types.T_REAL(_),_)) => t
  axiom	element_type(t as (Types.T_STRING(_),_)) => t
  axiom	element_type(t as (Types.T_BOOL(_),_)) => t

  rule	element_type(t) => t'
	---------------------------
	element_type((Types.T_ARRAY(_,t),_)) => t'

end


(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode. It produces a list of available
 ** types for a specific operator, that the overload relation chooses from.
 ** Therefore, in order for the builtin type conversion from Integer to 
 ** Real to work, operators that work on both Integers and Reals must 
 ** return the Integer type -before- the Real type in the list.
 **)

relation operators : (Absyn.Operator, Env.Env, Types.Type, Types.Type)
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  rule	(* The ADD operator *)
	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	array_type_list(9, (Types.T_STRING([]),NONE)) => stringarrtypes &
	
	operator_return(Exp.ADD_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.ADD_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &

	operator_return(Exp.ADD_ARR(Exp.STRING), 
			stringarrtypes, 
			stringarrtypes, 
			stringarrtypes) => stringarrs &
	
	let scalars = [(Exp.ADD(Exp.INT),
			[(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
			(Types.T_INTEGER([]),NONE)),
		       (Exp.ADD(Exp.REAL),
			[(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
			(Types.T_REAL([]),NONE)),
		       (Exp.ADD(Exp.STRING),
			[(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
			(Types.T_STRING([]),NONE))
		       ] &
	get_koening_operator_types("plus",env,t1,t2) => userops &
	Util.list_flatten([intarrs,realarrs,stringarrs]) => arrays &
	Util.list_flatten([scalars,arrays,userops]) => types 
	------------------------
	operators (Absyn.ADD,env,t1,t2) => types


  rule	(* the SUB operator *)
	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	
	operator_return(Exp.SUB_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.SUB_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.SUB(Exp.INT),
			[(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
			(Types.T_INTEGER([]),NONE)),
		       (Exp.SUB(Exp.REAL),
			[(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
			(Types.T_REAL([]),NONE))		  
		       ] &
	get_koening_operator_types("minus",env,t1,t2) => userops &
	Util.list_flatten([scalars,intarrs,realarrs,userops]) => types
	---------------------------
	operators(Absyn.SUB,env,t1,t2) => types

  rule	(* The MUL operator *)
	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	n_types(9, (Types.T_INTEGER([]),NONE)) => inttypes &
	n_types(9, (Types.T_REAL([]),NONE)) => realtypes &
	
	let int_mul = Exp.MUL(Exp.INT) &
	let real_mul = Exp.MUL(Exp.REAL) &
	let int_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.INT) &
	let real_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.REAL) &
	let int_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.INT) &
	let real_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.REAL) &
	
	let int_scalar = (Types.T_INTEGER([]),NONE) &
	let int_vector = (Types.T_ARRAY(Types.DIM(NONE),int_scalar),NONE) &
	let int_matrix = (Types.T_ARRAY(Types.DIM(NONE), int_vector),NONE) &
	let real_scalar = (Types.T_REAL([]),NONE) &
	let real_vector = (Types.T_ARRAY(Types.DIM(NONE),real_scalar),NONE) &
	let real_matrix = (Types.T_ARRAY(Types.DIM(NONE), real_vector),NONE) &


	let scalars = [
		       (int_mul,[int_scalar, int_scalar], int_scalar),
		       (real_mul,[real_scalar, real_scalar], real_scalar)
		       ] &


	
	let scalarprod = [
			  (int_mul_sp,[int_vector, int_vector],int_scalar),
			  (real_mul_sp,[real_vector,real_vector],real_scalar)
			  ] &
			
	let matrixprod = [
			  (int_mul_mp, [int_vector, int_matrix], int_vector),
			  (int_mul_mp, [int_matrix, int_vector], int_vector),
			  (int_mul_mp, [int_matrix, int_matrix], int_matrix),
			  (real_mul_mp,[real_vector,real_matrix],real_vector),
			  (real_mul_mp,[real_matrix,real_vector],real_vector),
			  (real_mul_mp,[real_matrix, real_matrix],real_matrix)
			  ] &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.INT), 
			inttypes, 
			intarrtypes, 
			intarrtypes) => intscalararrs &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.REAL), 
			realtypes, 
			realarrtypes, 
			realarrtypes) => realscalararrs &
	
	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.INT), 
			intarrtypes, 
			inttypes, 
			intarrtypes) => intarrsscalar &

	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.REAL), 
			realarrtypes, 
			realtypes, 
			realarrtypes) => realarrsscalar &	

	get_koening_operator_types("times",env,t1,t2) => userops &
	
	Util.list_flatten([scalars, intscalararrs, realscalararrs, intarrsscalar,
			   realarrsscalar,scalarprod,matrixprod,userops]) => types
	--------------------------------------------------------------------------
	operators(Absyn.MUL,env,t1,t2) => types

  rule	(* The DIV operator *)
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	n_types(9, (Types.T_REAL([]),NONE)) => realtypes &
	let real_div = Exp.DIV(Exp.REAL) &
	let real_scalar = (Types.T_REAL([]),NONE) &
	let scalars = [(real_div,[real_scalar, real_scalar], real_scalar)] &

	operator_return(Exp.DIV_ARRAY_SCALAR(Exp.REAL),
			realarrtypes,
			realtypes,
			realarrtypes) => realarrscalar &
	get_koening_operator_types("divide",env,t1,t2) => userops &
	Util.list_flatten([scalars,realarrscalar,userops]) => types
	-----------------------------------------------------------
	operators(Absyn.DIV,env,t1,t2) => types

  rule	(* The POW operator. a^b is only defined for integer exponents, i.e. b must
	 * be of type Integer *)
	let real_scalar = (Types.T_REAL([]),NONE) &
	let int_scalar = (Types.T_INTEGER([]),NONE) &
	let real_vector = (Types.T_ARRAY(Types.DIM(NONE),real_scalar),NONE) &
	let real_matrix = (Types.T_ARRAY(Types.DIM(NONE), real_vector),NONE) &
	let real_pow = Exp.POW(Exp.REAL) &
	let int_pow = Exp.POW(Exp.INT) &

	let scalars = [(int_pow, [int_scalar, int_scalar], int_scalar),
		       (real_pow,[real_scalar, real_scalar], real_scalar)] &
		       

	let arrscalar = [(Exp.POW_ARR(Exp.REAL),
			  [real_matrix,int_scalar],
			  real_matrix)] &
	get_koening_operator_types("power",env,t1,t2) => userops &
	Util.list_flatten([scalars,arrscalar,userops]) => types
	-------------------------------------------------------
	operators(Absyn.POW,env,t1,t2) => types

  rule	(* The UMINUS operator, unary minus *)
	let scalars = [(Exp.UMINUS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE)],
	       (Types.T_INTEGER([]),NONE)),
	      (Exp.UMINUS(Exp.REAL),
	       [(Types.T_REAL([]),NONE)],
	       (Types.T_REAL([]),NONE))] &
	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	
	operator_return_unary(Exp.UMINUS_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return_unary(Exp.UMINUS_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes) => realarrs &
	get_koening_operator_types("unaryMinus",env,t1,t2) => userops &
	Util.list_flatten([scalars,intarrs,realarrs,userops]) => types
	---------------------------------------------
	operators (Absyn.UMINUS,env,t1,t2) => types

  rule	(* The UPLUS operator, unary plus.*)
	let scalars = [(Exp.UPLUS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE)],
	       (Types.T_INTEGER([]),NONE)),
	      (Exp.UPLUS(Exp.REAL),
	       [(Types.T_REAL([]),NONE)],
	       (Types.T_REAL([]),NONE))] &
	array_type_list(9, (Types.T_INTEGER([]),NONE)) => intarrtypes &
	array_type_list(9, (Types.T_REAL([]),NONE)) => realarrtypes &
	
	operator_return_unary(Exp.UPLUS(Exp.INT), 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return_unary(Exp.UPLUS(Exp.REAL), 
			realarrtypes, 
			realarrtypes) => realarrs &
	get_koening_operator_types("unaryPlus",env,t1,t2) => userops &
	Util.list_flatten([scalars,intarrs,realarrs,userops]) => types
	---------------------------------------------
	operators(Absyn.UPLUS,env,t1,t2) => types

	(**  Logical operators *) (* Not considered for overloading yet. *)

  axiom	operators(Absyn.AND,env,t1,t2)
	  => [(Exp.AND,
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

  axiom	operators(Absyn.OR,env,t1,t2)
	  => [(Exp.OR,
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

  axiom	operators(Absyn.NOT,env,t1,t2)
	  => [(Exp.NOT,
	       [(Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))]

	(**  Relational operators *)

  rule (* '<' operator *)
	let scalars = [(Exp.LESS(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.LESS(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("less",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
 	operators(Absyn.LESS,env,t1,t2) => types

  rule	(* '<=' operator *)
	let scalars = [(Exp.LESSEQ(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.LESSEQ(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("lessEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.LESSEQ,env,t1,t2) => types

  rule	(* '>' operator *)
	let scalars = [(Exp.GREATER(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.GREATER(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("greater",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATER,env,t1,t2) => types

  rule	(* '>=' operator *)
	let scalars = [(Exp.GREATEREQ(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.GREATEREQ(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("greaterEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.GREATEREQ,env,t1,t2) => types

  rule	(* '==' operator *)
	let scalars = [(Exp.EQUAL(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.STRING),
	       [(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.EQUAL(Exp.BOOL),
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("equal",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.EQUAL,env,t1,t2) => types

  rule	(* '!=' operator *)
	let scalars = [(Exp.NEQUAL(Exp.INT),
	       [(Types.T_INTEGER([]),NONE), (Types.T_INTEGER([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.REAL),
	       [(Types.T_REAL([]),NONE), (Types.T_REAL([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.STRING),
	       [(Types.T_STRING([]),NONE), (Types.T_STRING([]),NONE)],
	       (Types.T_BOOL([]),NONE)),
	      (Exp.NEQUAL(Exp.BOOL),
	       [(Types.T_BOOL([]),NONE), (Types.T_BOOL([]),NONE)],
	       (Types.T_BOOL([]),NONE))] &
	get_koening_operator_types("notEqual",env,t1,t2) => userops &
	Util.list_flatten([scalars,userops]) => types
	---------------------------------------------
	operators(Absyn.NEQUAL,env,t1,t2) => types


  rule	Debug.fprint("failtrace", "-operators failed, op: ")  &
	Dump.op_symbol op => s &
 	Debug.fprint("failtrace",s) &
	Debug.fprint("failtrace","\n")
	----------------------------
	operators(op,env,t1,t2) => fail
end

(** relation: get_koening_function_types
 **
 ** Used for userdefined function overloads.
 ** This relation will search the types of the arguments for matching function definitions 
 ** corresponding to the koening C++ lookup rule.
 ** Question: What happens if we have A.foo(x,y)? Should we search for function A.foo in
 ** scope where type of x and y are defined? Or is it an error?
 ** See also: get_koening_operator_types
 ** Note: The reason for having two relations here is that operators and functions differs a lot.
 ** Operators have fixed no of arguments, functions can both have positional and named 
 ** arguments, etc. Perhaps these two could be unified. This would require major refactoring.
 **)
relation get_koening_function_types: (Env.Env, Absyn.Path, Absyn.Exp list,
				      Absyn.NamedArg list, bool (*impl*) )
	=> Types.Type list =

  rule	elab_exp(env,e1,impl,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => p1  &
	Lookup.lookup_class(env,p1,false (*msg*)) => (c,f::_) &
	
	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn,false) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,exps,na,impl) => typelist2 &
	list_append(typelist,typelist2) => res
	--------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na,impl) => res 

  rule	get_koening_function_types(env,fn,exps,na,impl) => typelist
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),e1::exps,na,impl) => typelist
	
  rule	elab_exp(env,exp,impl,NONE) => (_,Types.PROP(t,_),_) &
	Types.get_classname(t) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,f::_) &
	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],fn,false) => (_,f'::_) &

	Lookup.lookup_functions_in_env([f'],fn) => typelist &
	get_koening_function_types(env,fn,[],na,impl) => typelist2 &
	list_append(typelist,typelist2) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],Absyn.NAMEDARG(id,exp)::na,impl) 
	  => res

  rule	get_koening_function_types(env,fn,[],na,impl) => res
	------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.IDENT(_),[],_::na,impl) => res

  axiom	get_koening_function_types(env,fn as Absyn.IDENT(_),[],[],impl) => []
	
  rule	Print.print_error_buf "# Error, koening lookup of non-simple function name, " &
	Absyn.path_string fn => fnstr & Print.print_error_buf fnstr & 
	Print.print_error_buf "\n"
	-------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_,impl) => fail

(*  rule	Debug.fprint("failtrace", "- get_koening_function_types failed\n") 
	------------------------------------------------------------------
	get_koening_function_types(env,fn as Absyn.QUALIFIED(_,_),_,_) => fail
*)
end

(** relation: get_koening_operator_types
 **
 ** Used for userdefined operator overloads.
 ** This relation will search the scopes of the classes of the two 
 ** corresponding types and look for user defined operator overloaded
 ** functions, such as 'plus', 'minus' and 'times'. This corresponds
 ** to the koening C++ lookup rule.
 **)

relation get_koening_operator_types: (string, Env.Env, Types.Type, Types.Type)
	=> (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* Both types user defined *)
	Types.get_classname(t1) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res1 &
	Types.get_classname(t2) => (p2 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t2*)
	not Types.get_classname(t1) => Absyn.QUALIFIED(_,_) &
	Types.get_classname(t2) => (p2 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p2,false) => (c,env2) &
	get_koening_operator_types_in_scope(op,env2) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* User defined types only in t1*)
	not Types.get_classname(t2) => Absyn.QUALIFIED(_,_) &
	Types.get_classname(t1) => (p1 as Absyn.QUALIFIED(_,_)) &
	Lookup.lookup_class(env,p1,false) => (c,env1) &
	get_koening_operator_types_in_scope(op,env1) => res
	---------------------------------------------------
	get_koening_operator_types(op,env,t1,t2) => res

  rule	(* No User defined types at all. *)
	not Types.get_classname(t1) => Absyn.QUALIFIED(_,_) &
	not Types.get_classname(t2) => Absyn.QUALIFIED(_,_) 
	--------------------------------
	get_koening_operator_types(op,env,t1,t2) => []

  axiom	get_koening_operator_types(op,env,t1,t2) => []

end

(** relation: get_koening_operator_types_in_scope
 **
 ** This relation is a help relation to get_koening_operator_types
 ** and it will look for functions in the current scope of the passed
 ** environment, according to the koening rule. 
**)

relation get_koening_operator_types_in_scope: (string, Env.Env) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  rule	(* To make sure the function is implicitly instantiated.*)
	Lookup.lookup_type([f],Absyn.IDENT(funcname),false) => (_,f'::_) &

	(* TODO: Fix so lookup_functions_in_env also does instantiation to get type *)
	Lookup.lookup_functions_in_env([f'],Absyn.IDENT(funcname)) => tplst &
	list_length(tplst) => tplen &
	Inst.make_fully_qualified(f'::fs,Absyn.IDENT(funcname)) => fullfuncname &
	build_operator_types(tplst,fullfuncname) => res
	--------------------------------------------------
	get_koening_operator_types_in_scope(funcname,f::fs) => res
end

(** relation: build_operator_types
 **
 ** This relation takes the types operator overloaded user functions and
 ** builds  the type list structure suitable for the deoverload relation. 
**)
relation build_operator_types: (Types.Type list,Absyn.Path) 
	  => (Exp.Operator * Types.Type list * Types.Type) list =

  axiom	build_operator_types([],_) => []

  rule	Util.list_map(args,Util.tuple2_2) => argtypes &
	build_operator_types(tps,funcname) => rest
	------------------------------------
	build_operator_types((Types.T_FUNCTION(args,tp),_)::tps,funcname) 
	  => ((Exp.USERDEFINED(funcname),argtypes,tp)::rest) 
end


(** relation: n_dim_array
 ** Returns a type based on the type given as input but as an array type with
 ** n dimensions.
 **)

relation n_dim_array : (int(*n*), Types.Type(* orig type *)) => 
	Types.Type (* array type of n dimensions with element type = orig type *) =

  axiom	n_dim_array (0, t) => t

  rule	int_sub(n,1) => n' &
	n_dim_array (n',t) => t'
	------------------------
	n_dim_array (n, t) => ((Types.T_ARRAY(Types.DIM(NONE),t'),NONE))

end

(** relation: n_types
 ** Creates n copies of the type type.
 ** This could instead be accomplished with Util.list_fill...
 **)

relation n_types : (int, Types.Type) => Types.Type list =

  axiom	n_types (0,_) => []

  rule	int_sub(n,1) => n' & 
	n_types(n',t) => l
	-----------------------
	n_types (n, t) => t::l

end

(** relation: operator_return
 ** This relation collects the types and operator lists into a tuple list, suitable
 ** for the deoverloading relation for binary operations.
**)
relation operator_return : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return (_,[],[],[]) => []

  rule	operator_return (op, lr, rr, rer) => rest & 
	(* list contains two types, i.e. BINARY operations*)
	let t = (op,[l,r],re)
	---------------------------------------
	operator_return (op, l::lr, r::rr, re::rer) => t::rest

end

(** relation: operator_return_unary
 ** This relation collects the types and operator lists into a tuple list, 
 ** suitable for the deoverloading relation to be used for unary 
 ** expressions.
**)
relation operator_return_unary : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return_unary (_,[],[]) => []

  rule	operator_return_unary (op, lr,  rer) => rest & 
	(* list only contains one type, i.e. for UNARY operations*)
	let t = (op,[l],re)
	---------------------------------------
	operator_return_unary (op, l::lr, re::rer) => t::rest
end

(** relation: array_type_list
 ** This relation creates a list of types using the original type passed as input, but 
 ** as array types up to n dimensions.
 **)
relation array_type_list : (int (* n *), Types.Type(* orig type *)) => 
	Types.Type list (* array types *)
	=
  
  axiom array_type_list (0,_) => []

  rule	int_sub(n,1) => n' &
	n_dim_array(n,t) => f &
	array_type_list (n', t) => r
	-----------------------------
	array_type_list (n, t) => f::r
 
end

