(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id$
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The main entrypoint for this module is the relation "dump" which
 ** takes an entire program as an argument, and prints it all in
 ** Modelica source form. The other interface relations can be used
 ** to print smaller portions of a program.
 **)


module Dump:
  
  with "Absyn.rml"
  with "Interactive.rml"							  

  type Ident = string

(* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation unparse_str: Absyn.Program => string
  relation unparse_class_list: (int, Absyn.Class list) => string 
  relation dump_istmt: Interactive.InteractiveStmts => ()
  relation direction_symbol: Absyn.Direction => string
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_code_str: Absyn.Code => string 
  relation print_component: Absyn.Component => () 
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_subscripts_str : Absyn.Subscript list => string 
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_arraydim_str: Absyn.ArrayDim => string 
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation print_named_arg: Absyn.NamedArg => () 
  relation print_import : Absyn.Import => () 
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_bool_str : bool => string 
  relation print_select: (bool,string,string) => ()
  relation print_option : (('a option),('a => ())) => () 
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
  relation get_option_str: ('a option, 'a => string) => string 
  relation get_option_with_concat_str: ('a option, 'a => string,string) => string 
  relation unparse_annotation_option: (int, Absyn.Annotation option) => string 
  relation unparse_within: (int, Absyn.Within) => string 
  relation unparse_import_str : Absyn.Import => string 
  relation indent_str: (int) => string 
  relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string 
  relation variability_symbol: Absyn.Variability => string
  relation unparse_modification_str: Absyn.Modification => string 

  relation unparse_comment_option: (Absyn.Comment option) => string
end




(*!ignorecode*)

with "ClassInf.rml"
with "RTOpts.rml"
with "Print.rml"
with "Util.rml"
with "Debug.rml"

(* Relations *)

(** relation: dump
 **
 ** Prints a program, i.e. the whole AST, to the Print buffer.
 **)

relation dump : Absyn.Program => () =
		
  rule	Print.print_buf "Absyn.PROGRAM([\n" &
	print_list(cs, print_class, ", ") &
	Print.print_buf "]," &
	dump_within(w) &
	Print.print_buf(")\n")
	------------------------
	dump Absyn.PROGRAM(cs,w) => ()
end

(** relation: unparse_str
 ** 
 ** Prettyprints the Program, i.e. the whole AST, to a string.
 **)

relation unparse_str : Absyn.Program => string =
	
  axiom	unparse_str Absyn.PROGRAM([],_) => ""
	
  rule	unparse_within(0,w) => s1 &
	unparse_class_list(0,cs) => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3,"\n") => str
	------------------------
	unparse_str Absyn.PROGRAM(cs,w) => str

  axiom	unparse_str (_) => "unparsing failed\n" 
end

(** relation: unparse_class_list
 **
 ** Prettyprints a list of classes
 **)

relation unparse_class_list: (int, Absyn.Class list) => string =

  axiom	unparse_class_list(_,[]) => ""
	
  rule	unparse_class_str(i,c,"","","") => s1 &
	unparse_class_list(i,cs) => s2 &
	Util.string_append_list([s1,";\n",s2]) => res
	---------------------
	unparse_class_list(i, c::cs) => res
end

(** relation: unparse_within
 **
 ** Prettyprints a within statement.
 **)

relation unparse_within: (int, Absyn.Within) => string =

  axiom unparse_within (_, Absyn.TOP) => ""
	
  rule	indent_str(i) => s1 &
	Absyn.path_string p => s2 &
	Util.string_append_list([s1, "within ", s2, ";\n"]) => str
	------------------------------
	unparse_within (i, Absyn.WITHIN(p)) => str
end

(** relation: dump_within
 **
 ** Dumps within to the Print buffer.
 **)
relation dump_within:(Absyn.Within) => () =

  rule	Print.print_buf "Absyn.TOP"
	-----------------
	dump_within(Absyn.TOP) 

  rule	Print.print_buf ("Absyn.WITHIN(") & 
	dump_path p &
	Print.print_buf "\n"
	-------------------
	dump_within(Absyn.WITHIN(p))
end

(** relation: unparse_class_str
 **
 ** Prettyprints a Class.
 **)
	    
relation unparse_class_str: (int, Absyn.Class,string,string,string) => string =
	
  rule	indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	int_add(i,1) => i' &
	unparse_class_part_str_lst(i',parts,true) => s4 &
	unparse_string_comment_option(optcmt) => s5 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3, " ", n, s5, "\n", s4, is, "end ", n]) => str
	-----------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,optcmt),_),fi,re,io) => str

  rule	indent_str(indent) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 & 
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_elementattr_str attr => s4 &
	string_append(s1,s2) => s5 &
	Absyn.path_string i => s6 &
	get_option_str(dim,print_arraydim_str) => s7 &
	unparse_mod1_str m => s8 &
	unparse_comment_option(optcmt) => s9 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= ",s4,s5,s6,s7,s8,s9]) 
	  => str
	------------------------------
	unparse_class_str(indent,Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,dim,attr,m,optcmt),_),fi,re,io) => str
	
  rule	indent_str(i) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_enumliterals(l) => s4 &
	unparse_comment_option(cmt) => s5 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= enumeration(",s4,")",s5]) => str
	-------------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(Absyn.ENUMLITERALS(l),cmt),_),fi,re,io) => str    

  rule	indent_str(i) => is &
	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r)  => s3 &
	unparse_comment_option(cmt) => s5 &
	Util.string_append_list([is,s2',s1,s2,re,io,s3," ",n,"= enumeration(:)",s5]) => str
	-------------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(ENUM_COLON,cmt),_),fi,re,io) => str    

  rule	indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	int_add(i,1) => i' &
	unparse_class_part_str_lst(i',parts,true) => s4 &
	unparse_mod1_str(cmod) => s5 &
	unparse_string_comment_option(optcmt) => s6 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3, " extends ",
				 name, s5, s6, "\n", s4, is, "end ", name]) => str
	-----------------------------
	unparse_class_str(i, Absyn.CLASS(n,p,f,e,r,Absyn.CLASS_EXTENDS(name,cmod,optcmt,parts),_),fi,re,io) => str

  rule  indent_str(i) => is &
	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	select_string(e, "encapsulated ","") => s2' &
	unparse_restriction_str (r) => s3 &
	Absyn.path_string fname => s4 &
	Util.string_delimit_list(vars,", ") => s5 &
	Util.string_append_list([is, s2', s1, s2, re, io, s3," ",n, " = der(",
				 s4,", ",s5,")"]) => str
	---------------------------
	unparse_class_str(i,Absyn.CLASS(n,p,f,e,r,Absyn.PDER(fname,vars),_),fi,re,io) => str 

end 

(** relation: unparse_comment_option
 **
 ** Prettyprints a Comment.
 **)

relation unparse_comment_option: (Absyn.Comment option) => string =

	axiom unparse_comment_option(NONE) => ""
	
  rule	unparse_annotation_option(0,annopt) => s1 &
	Util.string_append_list([" \"",cmt,"\"", s1]) => str
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => str
	
  rule	unparse_annotation_option(0,annopt) => str 
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => str
	
end

(** relation: dump_comment_option
 **
 ** Prints a Comment to the Print buffer.
 **)

relation dump_comment_option: (Absyn.Comment option) => () =

  rule	Print.print_buf "NONE"
	------------------------
	dump_comment_option(NONE) => ()
	
  rule	Print.print_buf "SOME(Absyn.COMMENT(" &
	dump_annotation_option(annopt) => () &
	Util.string_append_list(["SOME(\"",cmt,
				 "\")))"]) => str &
 	Print.print_buf str 
	---------------------------------------------
	dump_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => ()
	
  rule	Print.print_buf "SOME(Absyn.COMMENT(" &
	dump_annotation_option(annopt) => () &
	Print.print_buf ",NONE))" 			 
	---------------------------------------------
	dump_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => ()	
end

(** relation: dump_annotation_option
 **
 ** Dumps an annotation option to the Print buffer.
 **)

relation dump_annotation_option: (Absyn.Annotation option) => () =	

  rule	Print.print_buf "NONE" 
	-------------------------
	dump_annotation_option(NONE)

  rule	Print.print_buf "SOME(Absyn.ANNOTATION(" &
	print_mod1 mod &
	Print.print_buf "))" 
	----------------------------
	dump_annotation_option(SOME(Absyn.ANNOTATION(mod))) => ()

end

(** relation: unparse_enumliterals
 **
 ** Prettyprints enumeration literals, each consisting of an identifier
 ** and an optional comment.
 **)

relation unparse_enumliterals : Absyn.EnumLiteral list => string =
	
  axiom	unparse_enumliterals([]) => ""
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_enumliterals(a::b)=> s2 &
	Util.string_append_list([str,s1,", ",s2]) => res
	---------------------------
 	unparse_enumliterals(Absyn.ENUMLITERAL(str,optcmt)::a::b) => res
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_comment_option(optcmt2) => s2 &
	Util.string_append_list([str," ",s1,", " ,str2,
				 " ",s2]) => res
	---------------------------
	unparse_enumliterals([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => res
end

(** relation: print_enumliterals
 **
 ** Prints enumeration literals, each consisting of an identifier
 ** and an optional comment to the Print buffer.
 **)

relation print_enumliterals : Absyn.EnumLiteral list => () =

  rule	Print.print_buf "[" &
	print_enumliterals2(lst) &
	Print.print_buf "]" 
	------------------------
	print_enumliterals (lst) =>  ()
end

(** relation: print_enumliterals2
 **
 ** Helper relation to print_enumliterals
 **)

relation print_enumliterals2 : Absyn.EnumLiteral list => () =

  axiom	print_enumliterals2([]) => ()
	
  rule	Print.print_buf "Absyn.ENUMLITERAL(\"" &
	Print.print_buf str &
	Print.print_buf "\"," &
	dump_comment_option(optcmt) &
	Print.print_buf "), " &
	print_enumliterals2(a::b) 
	---------------------------
	print_enumliterals2(Absyn.ENUMLITERAL(str,optcmt)::a::b) => ()
	
  rule	Print.print_buf "Absyn.ENUMLITERAL(\"" &
	Print.print_buf str &
	Print.print_buf "\"," &
	dump_comment_option(optcmt) &
	Print.print_buf "), Absyn.ENUMLITERAL(\"" &
	Print.print_buf str2 &
	Print.print_buf "\"," &
	dump_comment_option(optcmt2) &
	Print.print_buf ")"
	---------------------------
	print_enumliterals2([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => ()
end

(** relation: unparse_restriction_str
 **
 ** Prettyprints the class restriction.
 **)

relation unparse_restriction_str : Absyn.Restriction => string =
	
  axiom	unparse_restriction_str Absyn.R_CLASS			=> "class"
  axiom	unparse_restriction_str Absyn.R_MODEL			=> "model"
  axiom	unparse_restriction_str Absyn.R_RECORD			=> "record"
  axiom	unparse_restriction_str Absyn.R_BLOCK			=> "block"
  axiom	unparse_restriction_str Absyn.R_CONNECTOR		=> "connector"
  axiom	unparse_restriction_str Absyn.R_EXP_CONNECTOR		=> "expandable connector"
  axiom	unparse_restriction_str Absyn.R_TYPE			=> "type"
  axiom	unparse_restriction_str Absyn.R_PACKAGE			=> "package"
  axiom	unparse_restriction_str Absyn.R_FUNCTION			=> "function"
  axiom	unparse_restriction_str  Absyn.R_PREDEFINED_INT		=> "Integer"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_REAL		=> "Real"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_STRING	=> "String"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_BOOL		=> "Boolean"
	
end

(** relation: dump_istmt
 **
 ** Dumps an interactive statement to the Print buffer.
 **)

relation dump_istmt : Interactive.InteractiveStmts => () =
  rule	Print.print_buf ("IALG(") &
	print_algorithmitem(alg) => () &
	Print.print_buf ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)],_)) => ()
	
  rule	Print.print_buf ("IEXP(") &
	print_exp(expr) &
	Print.print_buf ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)],_)) => ()
	
  rule Print.print_buf "IALG(" &
	print_algorithmitem(alg) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l,sc)) => ()
	
  rule Print.print_buf "IEXP(" &
	print_exp(expr) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l,sc)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l,sc)) => ()
	
  axiom	dump_istmt(_) => ()
end

(** relation: print_class
 **
 ** Dumps a Class to the Print buffer.
 **)

relation print_class: Absyn.Class => () =
	
  rule	Print.print_buf("Absyn.CLASS(\"") &
	Print.print_buf n &
	Print.print_buf("\", ") &
	print_bool(p) &
	Print.print_buf(", ") &
	print_bool(f) &
	Print.print_buf(", ") &
	print_bool(e) &
	Print.print_buf(", ") &
	print_class_restriction(r) &
	Print.print_buf(", ") &
	print_classdef(cdef) &
	Print.print_buf(",\"") &
	Print.print_buf filename &
	Print.print_buf("\")\n")
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,cdef,filename)) => ()
end

(** relation: print_classdef
 **
 ** Prints a ClassDef to the Print buffer.
 **)

relation print_classdef: Absyn.ClassDef => () =
	
  rule	Print.print_buf "Absyn.PARTS([" &
	print_list_debug("print_classdef",parts, print_class_part, ", ") &
	Print.print_buf "], " &
	print_string_comment_option comment  &
	Print.print_buf ")" 
	----------------------------
	print_classdef(Absyn.PARTS(parts,comment))

  rule	Print.print_buf "Absyn.DERIVED(" &
	dump_path(path) &
	Print.print_buf ", " &
	print_arraydim_opt(arrdim) &
	Print.print_buf ", " &
	print_elementattr(attr) &
	Print.print_buf ",[" &
	print_list(earg,print_element_arg,",") &
	Print.print_buf "], " &
	unparse_comment_option comment => s &
	Print.print_buf s &
	Print.print_buf ")" 
	----------------------------
	print_classdef(Absyn.DERIVED(path,arrdim,attr,earg,comment))

  rule	Print.print_buf "Absyn.ENUMERATION(" &
	print_enumliterals (enumlst) &
	Print.print_buf ", " &
	dump_comment_option comment  &
	Print.print_buf ")" 
	----------------------------
	print_classdef(Absyn.ENUMERATION(Absyn.ENUMLITERALS(enumlst), comment))

  rule	Print.print_buf "Absyn.ENUMERATION( :, " &
	dump_comment_option comment  &
	Print.print_buf ")" 
	----------------------------
	print_classdef(Absyn.ENUMERATION(Absyn.ENUM_COLON, comment))

  rule	Print.print_buf "Absyn.OVERLOAD( fill in )"
 	------------------------
 	print_classdef(Absyn.OVERLOAD(_,_))
end

(** relation: print_class_restriction
 **
 ** Prints the class restriction to the Print buffer.
 *)

relation print_class_restriction: Absyn.Restriction => () =

  rule	Print.print_buf "Absyn.R_CLASS" 
	-----------------------
	print_class_restriction Absyn.R_CLASS

  rule	Print.print_buf "Absyn.R_MODEL" 
	-----------------------
	print_class_restriction Absyn.R_MODEL

  rule	Print.print_buf "Absyn.R_RECORD" 
	-----------------------
	print_class_restriction Absyn.R_RECORD

  rule	Print.print_buf "Absyn.R_BLOCK" 
	-----------------------
	print_class_restriction Absyn.R_BLOCK

  rule	Print.print_buf "Absyn.R_CONNECTOR" 
	-----------------------
	print_class_restriction Absyn.R_CONNECTOR

  rule	Print.print_buf "Absyn.R_EXP_CONNECTOR" 
	-----------------------
	print_class_restriction Absyn.R_EXP_CONNECTOR

  rule	Print.print_buf "Absyn.R_TYPE" 
	-----------------------
	print_class_restriction Absyn.R_TYPE

  rule	Print.print_buf "Absyn.R_PACKAGE" 
	-----------------------
	print_class_restriction Absyn.R_PACKAGE

  rule	Print.print_buf "Absyn.R_FUNCTION" 
	-----------------------
	print_class_restriction Absyn.R_FUNCTION

  rule	Print.print_buf "Absyn.R_ENUMERATION" 
	-----------------------
	print_class_restriction Absyn.R_ENUMERATION

  rule	Print.print_buf "Absyn.R_PREDEFINED_INT" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_INT

  rule	Print.print_buf "Absyn.R_PREDEFINED_REAL" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_REAL

  rule	Print.print_buf "Absyn.R_PREDEFINED_STRING" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_STRING

  rule	Print.print_buf "Absyn.R_PREDEFINED_BOOL" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_BOOL

  rule	Print.print_buf "Absyn.R_PREDEFINED_ENUM" 
	-----------------------
	print_class_restriction Absyn.R_PREDEFINED_ENUM


  axiom	print_class_restriction _
end

(** relation: print_class_modification
 **
 ** Prints a class modification to a print buffer.
 **)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	Print.print_buf "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & Print.print_buf ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

(** relation: unparse_class_modification_str
 **
 ** Prettyprints a class modification to a string.
 **)

relation unparse_class_modification_str: Absyn.Modification => string =

  axiom	unparse_class_modification_str(Absyn.CLASSMOD([],_)) => ""
	
  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &	
	string_append("(",s1) => s2 &
	string_append(s2,")") => str 
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(l,NONE)) => str

  rule	print_exp_str e => s1 &
	Util.string_append_list(["=",s1]) => str
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(_,SOME(e))) => str
end


(** relation: print_element_arg
 **
 ** Prints an ElementArg to the Print buffer.
 **)

relation print_element_arg =
	
  rule	Print.print_buf "Absyn.MODIFICATION(" &
	print_bool(f)  &
	Print.print_buf ", " &
	dump_each each &
	Print.print_buf ", " &
	print_component_ref(r) &
	Print.print_buf ", " &
	print_opt_modification(optm) &
	Print.print_buf ", " &
	print_string_comment_option optcmt &
	Print.print_buf ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,each,r,optm,optcmt))

  rule	Print.print_buf "Absyn.REDECLARATION(" &
	print_bool(f) &
	print_elementspec spec &
	Print.print_buf ",_)"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,keywords,each,spec,_))

end

(** relation: unparse_element_arg_str
 **
 ** Prettyprints an ElementArg to a string.
 **)

relation unparse_element_arg_str: (Absyn.ElementArg) => string =
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","") => s2 &
	print_component_ref_str(r) => s3 &
	unparse_opt_modification_str(optm) => s4 &
	unparse_string_comment_option(optstr) => s5 &
	Util.string_append_list([s1, s2, s3, s4, s5]) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.MODIFICATION(f,each,r,optm,optstr)) => str
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_redeclarekeywords (keywords) => s3 &
	unparse_elementspec_str(0, spec,s2,"","") => s4 &
	unparse_elementspec_str(0,constropt,"","","") => s5 &
	Util.string_append_list([s1,s2,s3,s4," ",s5]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,keywords,each, spec,SOME(constropt))) => str


  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_redeclarekeywords (keywords) => s3 &
	unparse_elementspec_str(0, spec,s2,"","") => s4 &
	Util.string_append_list([s1,s2,s3,s4]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,keywords,each, spec,NONE)) => str

end

(** relation: unparse_redeclarekeywords
 ** 
 ** Prettyprints the redeclare keywords, i.e 'replaceable' and 'redeclare'
 **)

 relation unparse_redeclarekeywords: Absyn.RedeclareKeywords => string =

  axiom	unparse_redeclarekeywords Absyn.REDECLARE => "redeclare "
  axiom	unparse_redeclarekeywords Absyn.REPLACEABLE => "replaceable "
  axiom	unparse_redeclarekeywords Absyn.REDECLARE_REPLACEABLE => "redeclare replaceable "
end

(** relation: unparse_each_str
 **
 ** Prettyprints the each keyword.
 **)

relation unparse_each_str: (Absyn.Each) => string =

  axiom	unparse_each_str(Absyn.EACH) => "each "

  axiom	unparse_each_str(Absyn.NON_EACH) => ""
end

(** relation: dump_each
 **
 ** Print the each keyword to the Print buffer
 **)
relation dump_each: (Absyn.Each) => () =

  rule	Print.print_buf "Absyn.EACH"
	--------------------------
	dump_each(Absyn.EACH) 

  rule	Print.print_buf "Absyn.NON_EACH"
	------------------
	dump_each(Absyn.NON_EACH)
end
(** relation: print_class_part
 **
 ** Prints the ClassPart to the Print buffer.
 **)
				
relation print_class_part: Absyn.ClassPart => () =

  rule	Print.print_buf "Absyn.PUBLIC(" & 
	print_elementitems(el) & Print.print_buf ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	Print.print_buf "Absyn.PROTECTED(" & 
	print_elementitems(el) & Print.print_buf ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	Print.print_buf "Absyn.EQUATIONS([" &
	print_list(eqs,print_equationitem,", ") &
	Print.print_buf "])"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))

  rule	Print.print_buf "Absyn.INITIALEQUATIONS([" &
	print_list(eqs,print_equationitem, ", ") &
	Print.print_buf "])"
	--------------------------------------
	print_class_part(Absyn.INITIALEQUATIONS(eqs))
	
  rule	Print.print_buf "Absyn.ALGORITHMS(" &
	print_list(algs,print_algorithmitem, ", ") &
	Print.print_buf ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(algs))

  rule	Print.print_buf "Absyn.INITIALALGORITHMS([" &
	print_list(algs,print_algorithmitem,", ") &
	Print.print_buf "])"
	--------------------------------------
	print_class_part(Absyn.INITIALALGORITHMS(algs))

  rule	Print.print_buf "Absyn.EXTERNAL(" &
	print_external_decl (edecl) &
	Print.print_buf ")"
	-------------------
	print_class_part(Absyn.EXTERNAL(edecl,_))

end

(** relation: print_external_decl
 **
 ** Prints an external declaration to the Print buffer.
 **)

relation print_external_decl : Absyn.ExternalDecl => () =

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	Util.string_append_list([idstr, ", ", crefstr, ", (",
				 expstr, ")"]) => str &
	Print.print_buf str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, NONE, cref, exps,_)

  rule	get_option_str (id, identity) => idstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	Util.string_append_list([idstr, ", \"", lang, "\", ", crefstr, ", (",
				 expstr, ")"]) => str &
	Print.print_buf str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, SOME(lang), cref, exps,_)

end

(** relation: unparse_class_part_str_lst
 **
 ** Prettyprints a ClassPart list to a string.
 **)

relation unparse_class_part_str_lst: (int, Absyn.ClassPart list,bool) 
	  => string =

  axiom	unparse_class_part_str_lst (_,[],false) => ""

  rule	unparse_class_part_str(i,x,skippublic) => s1 &
	unparse_class_part_str_lst(i,xs,false) => s2 &
	string_append(s1,s2) => res
	----------------------
	unparse_class_part_str_lst(i,x::xs,skippublic) => res
end

relation unparse_class_part_str: (int, Absyn.ClassPart,bool) => string =

axiom	unparse_class_part_str(i, Absyn.PUBLIC([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.PROTECTED([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.EQUATIONS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.INITIALEQUATIONS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.ALGORITHMS([]),_) => ""
axiom	unparse_class_part_str(i, Absyn.INITIALALGORITHMS([]),_) => ""

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),true) => str
	
  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"public \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.PUBLIC(el),false) => str

  rule	unparse_elementitem_str_lst(i,el) => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"protected \n",s1]) => str 
	---------------------------------------
	unparse_class_part_str(i, Absyn.PROTECTED(el),_) => str
	
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.EQUATIONS(eqs),_) => str
				
  rule	unparse_equationitem_str_lst(i,eqs,";\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"initial equation \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.INITIALEQUATIONS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"algorithm \n",s1]) => str 
	--------------------------------------
	unparse_class_part_str(i, Absyn.ALGORITHMS(eqs),_) => str

  rule	unparse_algorithm_str_lst(i,eqs,"\n") => s1 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"initial algorithm \n",s1]) => str 
	-----------------------------------------------
	unparse_class_part_str(i, Absyn.INITIALALGORITHMS(eqs),_) => str

  rule	get_extlang_str(lang) => langstr &
	print_component_ref_str output => outputstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n", is, "external ",langstr," ", outputstr, "=",ident,"(",expstr,") ",annstr,";",annstr2,"\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,SOME(output),expl,ann),ann2),_)
	    => str

  rule	get_extlang_str(lang) => langstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	indent_str(i) => is &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n", is, "external ", langstr," ",ident,"(",expstr,") ",annstr,"; ",annstr2,"\n"]) => str
	--------------------------------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,NONE,expl,ann),ann2),_) 
	    => str

  rule	indent_str(i) => is &
	get_extlang_str(lang) => langstr &
	unparse_annotation_option (i,ann) => annstr &
	unparse_annotation_option_semi(i,ann2) => annstr2 &
	Util.string_append_list(["\n",is,"external ",langstr," ",annstr,";",annstr2,"\n"]) => res
	-----------------
	unparse_class_part_str(i, Absyn.EXTERNAL(Absyn.EXTERNALDECL(NONE,lang,NONE,_,ann),ann2),_) 
	    => res
end

(** relation: get_extlang_str
 **
 ** Prettyprints the external function language string to a string.
 **)

relation get_extlang_str: (string option) => string =
	
  axiom	get_extlang_str(NONE) => ""

  rule	Util.string_append_list(["\"",str,"\""]) => res
	-------------
	get_extlang_str(SOME(str)) => res
end

(** relation: print_elementitems
 **
 ** Print a list of ElementItems to the Print buffer.
 **)

relation print_elementitems: Absyn.ElementItem list => () =

  rule	Print.print_buf "[" &
	print_elementitems2 (elts) &
	Print.print_buf "]" 
	------------------
	print_elementitems elts => ()
end

(** relation: print_elementitems2
 ** 
 ** Helper relation to print_elementitems
 **)

relation print_elementitems2: Absyn.ElementItem list => () =

  axiom print_elementitems2 [] => ()

  rule  Print.print_buf "Absyn.ELEMENTITEM(" &
	print_element e &
	Print.print_buf ")" 
	---------------
	print_elementitems2[ Absyn.ELEMENTITEM(e)]

  rule	Print.print_buf "Absyn.ANNOTATIONITEM(" &
	print_annotation a &
	Print.print_buf ")" 
	------------------
	print_elementitems2([Absyn.ANNOTATIONITEM(a)])
	
  rule	Print.print_buf "Absyn.ELEMENTITEM(" &
	print_element e &
	Print.print_buf "), " &
	print_elementitems2 els
	---------------
	print_elementitems2 Absyn.ELEMENTITEM(e)::els 

  rule	Print.print_buf "Absyn.ANNOTATIONITEM(" &
	print_annotation a &
	Print.print_buf "), " &
	print_elementitems2 els
	------------------
	print_elementitems2 Absyn.ANNOTATIONITEM(a)::els

  rule	Print.print_buf "Error print_elementitems\n"
	--------------
	print_elementitems2 _ 
end

(** relation: print_annotation
 **
 ** Prints an annotation to the Print buffer.
**)

relation print_annotation: Absyn.Annotation => () =	
  rule	Print.print_buf "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	Print.print_buf ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end

(** relation: unparse_elementitem_str_lst
 **
 ** Prettyprints a list of ElementItem to a string.
 **)

relation unparse_elementitem_str_lst: (int(* indent*), Absyn.ElementItem list) => string =

  axiom	unparse_elementitem_str_lst(_, []) => ""
	
  rule	unparse_elementitem_str(i, x) => s1 &
	unparse_elementitem_str_lst(i, xs) => s2 &
	Util.string_append_list([s1, "\n", s2]) => res
	----------------
	unparse_elementitem_str_lst(i, x::xs) => res
end

(** relation: unparse_elementitem_str
 **
 ** Prettyprints and ElementItem.
 **)

relation unparse_elementitem_str: (int(* indent*), Absyn.ElementItem) 
	  => string =

  rule	unparse_element_str(i, e) => str
	----------------------------
	unparse_elementitem_str (i, Absyn.ELEMENTITEM(e)) => str

  rule	unparse_annotation_option (i,SOME(a)) => s1 &
	string_append(s1,";") => str 
	-------------------------------
	unparse_elementitem_str(i, Absyn.ANNOTATIONITEM(a)) => str
	
end

(** relation: unparse_annotation_option_semi
 **
 ** Prettyprint an annotation and a semicolon if annoation present.
 **)


relation unparse_annotation_option_semi: (int, Absyn.Annotation option) 
	  => string =	

  axiom	unparse_annotation_option_semi(_,NONE) => ""

  rule	unparse_annotation_option(i,ann) => s &
	string_append(s,";") => res
	--------------------------
	unparse_annotation_option_semi(i,ann) => res
end

(** relation: unparse_annotation_option
 **
 ** Prettyprint an annotation.
 **)

relation unparse_annotation_option: (int, Absyn.Annotation option) => string =	
  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	string_append(" annotation",s1) => s2 &
	string_append(s2,"") => str
	----------------------------
	unparse_annotation_option(0, SOME(Absyn.ANNOTATION(mod))) => str

  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	indent_str(i) => is &
	Util.string_append_list([is,"annotation",s1]) => str 
	----------------------------
	unparse_annotation_option(i, SOME(Absyn.ANNOTATION(mod))) => str

  axiom	unparse_annotation_option(_, NONE) => ""
end

(** relation: print_element
 **
 ** Prints an Element to the Print buffer.
 **)

relation print_element: Absyn.Element => () =
	
  rule	Print.print_buf "Absyn.ELEMENT(" & 
	print_bool(final) &
	Print.print_buf ", _" &
	Print.print_buf ", " &
	print_innerouter inout &
	Print.print_buf ", \"" &
	Print.print_buf name &
	Print.print_buf "\", " &
	print_elementspec spec & 
	Print.print_buf ", \"" &
	Print.print_buf filename &
	Print.print_buf "\", " & 
	int_string lineno => s1 &
    	Print.print_buf s1 &
	Print.print_buf ",NONE)"
	---------------------------
	print_element (Absyn.ELEMENT(final,repl,inout,name,spec,filename,lineno,NONE))

  rule	Print.print_buf "Absyn.ELEMENT(" & 
	print_bool(final) &
	Print.print_buf ", _" &
	Print.print_buf ", " &
	print_innerouter inout &
	Print.print_buf ", \"" &
	Print.print_buf name &
	Print.print_buf "\", " &
	print_elementspec spec & 
	Print.print_buf ", \"" &
	Print.print_buf filename &
	Print.print_buf "\", " & 
	int_string lineno => s1 &
    	Print.print_buf s1 &
	Print.print_buf "SOME(...))"
	---------------------------
	print_element (Absyn.ELEMENT(final,repl,inout,name,spec,filename,lineno,SOME(_)))

end

(** relation: unparse_element_str
 **
 ** Prettyprints and Element to a string.
 **)

relation unparse_element_str: (int, Absyn.Element) => string = 

  rule	select_string(final, "final ", "") => s1 &
	unparse_redeclarekeywords repl => s2 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str(i, spec,s1,s2,s3) => s4 &	
	int_string(lineno) => s5 &
	indent_str(i) => is &
        Util.string_append_list([s4, ";"]) => str
(*	Util.string_append_list([s4, " ", filename," ", s5,";"]) => str *)
	----------------------------
	unparse_element_str(i, Absyn.ELEMENT(final,SOME(repl),inout,_,spec,filename,lineno,constr)) => str

  rule	select_string(final, "final ", "") => s1 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str(i, spec,s1,"",s3) => s4 &	
	int_string(lineno) => s5 &
	indent_str(i) => is &
        Util.string_append_list([s4, ";"]) => str
	----------------------------
	unparse_element_str(i, Absyn.ELEMENT(final,NONE,inout,_,spec,filename,lineno,constr)) => str
end


(** relation: print_innerouter
 **
 ** Prints the inner or outer keyword to the Print buffer.
 **)

relation print_innerouter: Absyn.InnerOuter => () =
   rule Print.print_buf "Absyn.INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule Print.print_buf "Absyn.OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule Print.print_buf "Absyn.INNEROUTER "
        ----------------------------------
        print_innerouter(Absyn.INNEROUTER)

   rule Print.print_buf "Absyn.UNSPECIFIED "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end

(** relation: unparse_innerouter_str
 **
 ** Prettyprints the inner or outer keyword to a string.
 **)

relation unparse_innerouter_str: Absyn.InnerOuter => string =
	
  axiom	unparse_innerouter_str(Absyn.INNER) => "inner "

  axiom	unparse_innerouter_str(Absyn.OUTER) => "outer "

  axiom	unparse_innerouter_str(Absyn.INNEROUTER) => "inner outer "

  axiom	unparse_innerouter_str(Absyn.UNSPECIFIED) => ""
end

(** relation: print_elementspec
 **
 ** Prints the ElementSpec to the Print buffer.
 **)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	Print.print_buf "Absyn.CLASSDEF(" & 
	print_bool(repl) &
	Print.print_buf ", " &
	print_class cl & 
	Print.print_buf ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	Print.print_buf "Absyn.EXTENDS(" & 
	dump_path p & Print.print_buf ", [" &
	print_list_debug("print_elementspec",l,print_element_arg,",") & 
	Print.print_buf "])"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	Print.print_buf "Absyn.COMPONENTS(" &
	print_elementattr(attr) & Print.print_buf "," &
	dump_path(t) & Print.print_buf ",[" &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	Print.print_buf "])"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	Print.print_buf "Absyn.IMPORT(" &
	print_import i &
	Print.print_buf ")"
	--------
	print_elementspec(Absyn.IMPORT(i,_))

  rule	Print.print_buf " ##ERROR## "
	-------------------
	print_elementspec(_)

end

(** relation: unparse_elementspec_str
 **
 ** Prettyprints the ElementSpec to a string.
 **)

relation unparse_elementspec_str: (int,(*indent*) 
				   Absyn.ElementSpec,
				   string,
				   string,
				   string) 
	  => string =
	
  rule	unparse_class_str(i,cl,f,r,io) => str 
	-------------------------
	unparse_elementspec_str(i, Absyn.CLASSDEF(repl,cl),f,r,io) => str
	
  rule	Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,f,r,io,s2]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,[]),f,r,io) => str

  rule	Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	get_string_list(l,unparse_element_arg_str,",") => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,f,r,io,s2,"(",s3,")"]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.EXTENDS(p,l),f,r,io) => str

  rule	Absyn.path_string(t) => s1 &
	unparse_elementattr_str(attr) => s2 &
	unparse_arraydim_in_attr(attr) => ad &
	get_string_list(cs, unparse_componentitem_str, ",") => s3 &
	indent_str(i) => is &
	Util.string_append_list([is, f,r,io,s2, s1,ad, " ",  s3]) => str
	------------------------------------------
	unparse_elementspec_str(i, Absyn.COMPONENTS(attr,t,cs),f,r,io) => str
	
  rule	unparse_import_str i => s1 &
	string_append("import ",s1) => s2 &
	indent_str(indent) => is &
	Util.string_append_list([is,f,r,io,s2]) => str
	----------------------------
	unparse_elementspec_str(indent, Absyn.IMPORT(i,_),f,r,io) => str

  rule	Print.print_buf " ##ERROR## "
	-------------------
	unparse_elementspec_str(_,_,_,_,_) => ""
end

(** relation: print_import
 **
 ** Prints an Import to the Print buffer.
 **)

relation print_import : Absyn.Import => () =

  rule	Print.print_buf i & Print.print_buf " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & Print.print_buf ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end

(** relation: unparse_import_str
 **
 ** Prettyprints an Import to a string.
 **)

relation unparse_import_str : Absyn.Import => string =

  rule	string_append(i," = ") => s1 &
	Absyn.path_string p => s2 &
	string_append(s1,s2) => str
	-----------------------
	unparse_import_str(Absyn.NAMED_IMPORT(i,p)) => str

  rule	Absyn.path_string p => str
	-------------
	unparse_import_str(Absyn.QUAL_IMPORT(p)) => str

  rule	Absyn.path_string p => s1 &
	string_append(s1, ".*") => str
	--------------------------
	unparse_import_str(Absyn.UNQUAL_IMPORT(p)) => str
end

(** relation: print_elementattr
 **
 ** Prints ElementAttributes to the Print buffer.
 **)

relation print_elementattr: Absyn.ElementAttributes => () =

  rule	Print.print_buf "Absyn.ATTR(" &
	print_bool(fl) &
	Print.print_buf ", " &	
	variability_symbol(var) => vs &
	Print.print_buf vs &
	Print.print_buf ", " &	
	direction_symbol(dir) => ds &
	Print.print_buf ds &
	Print.print_buf ", " &	
	print_arraydim adim &
	Print.print_buf ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	Print.print_buf " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

(** relation: unparse_elementattr_str
 **
 ** Prettyprints ElementAttributes to a string.
 **)

relation unparse_elementattr_str: Absyn.ElementAttributes => string =

  rule	
	select_string(fl,"flow ","") => fs &
	unparse_variability_symbol_str(var) => vs &
	unparse_direction_symbol_str(dir) => ds &
	Util.string_append_list([fs,vs,ds]) => str
	------------------------------------------
	unparse_elementattr_str(Absyn.ATTR(fl,var,dir,adim)) => str

  rule	Print.print_buf " ##ERROR## unparse_elementattr_str"
	-------------------
	unparse_elementattr_str(_) => ""

end

(** relation: unparse_arraydim_in_attr
 **
 ** Prettyprints the arraydimension in ElementAttributes to a string.
 **)

relation unparse_arraydim_in_attr: Absyn.ElementAttributes => string =

  rule	print_arraydim_str(adim) => str
	-----------------------------------
	unparse_arraydim_in_attr(Absyn.ATTR(_,_,_,adim)) => str
  axiom	unparse_arraydim_in_attr(_) => ""
end


(** relation: variability_symbol
 ** 
 ** Returns a string for the Variability.
 **)

relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => "Absyn.VAR"
  axiom	variability_symbol(Absyn.DISCRETE) => "Absyn.DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "Absyn.PARAM"
  axiom	variability_symbol(Absyn.CONST) => "Absyn.CONST"

end

(** relation: direction_symbol
 ** 
 ** Returns a string for the direction.
 **)

relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => "Absyn.BIDIR"
  axiom	direction_symbol(Absyn.INPUT) => "Absyn.INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "Absyn.OUTPUT"

end

(** relation: unparse_variability_symbol_str
 **
 ** Returns a prettyprinted string of variability.
 **)

relation unparse_variability_symbol_str: Absyn.Variability => string =

  axiom unparse_variability_symbol_str(Absyn.VAR) => ""
  axiom	unparse_variability_symbol_str(Absyn.DISCRETE) => "discrete "
  axiom	unparse_variability_symbol_str(Absyn.PARAM) => "parameter "
  axiom	unparse_variability_symbol_str(Absyn.CONST) => "constant "

end

(** relation: unparse_direction_symbol_str
 **
 ** Returns a prettyprinted string of direction.
 **)

relation unparse_direction_symbol_str: Absyn.Direction => string =

  axiom unparse_direction_symbol_str(Absyn.BIDIR) => ""
  axiom	unparse_direction_symbol_str(Absyn.INPUT) => "input "
  axiom	unparse_direction_symbol_str(Absyn.OUTPUT) => "output "

end

(** relation: print_component
 **
 ** Prints a Component to the Print buffer.
 **)

relation print_component: Absyn.Component => () =

  rule	Print.print_buf "Absyn.COMPONENT(\"" &
	Print.print_buf n &
	Print.print_buf "\"," &
	print_arraydim a &
	Print.print_buf ", " &
	print_option(m,print_modification) &
	Print.print_buf ")"
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

(** relation: print_componentitem
 **
 ** Prints a ComponentItem to the Print buffer.
 **)

relation print_componentitem: Absyn.ComponentItem => () =

  rule	Print.print_buf "Absyn.COMPONENTITEM(" &
	print_component c &	
	Print.print_buf ", " &
	dump_comment_option optcmt &
	Print.print_buf ")" 
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,optcond,optcmt))
end

(** relation: unparse_component_str
 **
 ** Prettyprints a Component to a string.
 **)

relation unparse_component_str: Absyn.Component => string =

  rule	print_arraydim_str a => s1 &
	string_append(n,s1) => s2 &
	get_option_str(m,unparse_modification_str) => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_component_str(Absyn.COMPONENT(n,a,m)) => str
end

(** relation: unparse_componentitem_str
 **
 ** Prettyprints a ComponentItem to a string.
 **)

relation unparse_componentitem_str: Absyn.ComponentItem => string =

  rule	unparse_component_str c => s1 &
	unparse_comment_option cmtopt => s3 &
	unparse_component_condition optcond => s2 &
	Util.string_append_list([s1,s2,s3]) => str
	------------------------------------------
	unparse_componentitem_str(Absyn.COMPONENTITEM(c,optcond,cmtopt)) => str
end

(** relation: unparse_component_condition
 **
 ** Prints a ComponentCondition option to a string.
 **)

relation unparse_component_condition: Absyn.ComponentCondition option 
	  => string =

  rule	print_exp_str(cond) => s1 &
	string_append (" if ",s1) => res
	--------------------------------
	unparse_component_condition(SOME(cond)) => res

  axiom	unparse_component_condition(NONE) => ""
end

(** relation: print_arraydim_opt
 **
 ** Prints an ArrayDim option to the Print buffer.
 **)

relation print_arraydim_opt: Absyn.ArrayDim option => () =
	
  rule	Print.print_buf "NONE"
	------------------------
	print_arraydim_opt( NONE) 

  rule	Print.print_buf "SOME(" &
	print_subscripts(s) &
	Print.print_buf ")" 
	-------------------
	print_arraydim_opt(SOME(s))
end

(** relation: print_arraydim
 **
 ** Prints an ArrayDim to the Print buffer.
 **)

relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

(** relation: print_arraydim_str
 **
 ** Prettyprints an ArrayDim to a string.
 **)

relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

(** relation: print_subscript
 **
 ** Prints an Subscript to the Print buffer.
 **)

relation print_subscript: Absyn.Subscript => () =

  rule	Print.print_buf "Absyn.NOSUB"
	---------
	print_subscript(Absyn.NOSUB)

  rule	Print.print_buf "Absyn.SUBSCRIPT(" &
	print_exp(e1) &
	Print.print_buf ")" 
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

(** relation: print_subscript_str
 **
 ** Prettyprints an Subscript to a string.
 **)

relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(** relation: print_opt_modification
 ** 
 ** Prints a Modification option to the Print buffer.
 **)

relation print_opt_modification: Absyn.Modification option => () =

  rule	Print.print_buf "SOME(" &
	print_modification(m) &
	Print.print_buf ")" 
	----------------------
	print_opt_modification(SOME(m)) => ()

  axiom	print_opt_modification(NONE) => ()
end

(** relation: print_modification
 ** 
 ** Prints a Modification to the Print buffer.
 **)

relation print_modification: Absyn.Modification => () =
	
  rule	Print.print_buf "Absyn.CLASSMOD([" &
	print_mod1 l & 
	Print.print_buf "], " &
	print_mod2 e &
	Print.print_buf ")"
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	Print.print_buf "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

(** relation: print_mod1
 **
 ** Helper relaton to print_modification.
 **)

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	Print.print_buf "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	Print.print_buf ")"
	------------------------------------
	print_mod1 l

end

(** relation: print_mod2
 **
 ** Helper relaton to print_mod1
 **)

relation print_mod2 : Absyn.Exp option => () =

  rule	Print.print_buf "NONE"
	-----------------
	print_mod2 NONE

  rule	Print.print_buf "SOME(" & print_exp(e) &
	Print.print_buf ")" 
	-------------------------
	print_mod2 SOME(e)

end

(** relation: unparse_opt_modification_str
 **
 ** Prettyprints a Modification option to a string.
 **)

relation unparse_opt_modification_str: Absyn.Modification option => string =

  rule	unparse_modification_str(opt) => str
	-------------------
	unparse_opt_modification_str(SOME(opt)) => str

  axiom	unparse_opt_modification_str(NONE) => ""
end

(** relation: unparse_modification_str
 **
 ** Prettyprints a Modification to a string.
 **)

relation unparse_modification_str: Absyn.Modification => string =
	(* Special case for empty modifications *)
  axiom	unparse_modification_str(Absyn.CLASSMOD([],NONE)) => "()"

  rule	unparse_mod1_str l => s1 & 
	unparse_mod2_str e => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_modification_str(Absyn.CLASSMOD(l, e)) => str
	
  rule	Print.print_buf " Failure MODIFICATION \n"
	-------------
	unparse_modification_str(_) => ""	
end

(** relation: unparse_mod1_str
 **
 ** Helper relation to unparse_modification_str
 **)

relation unparse_mod1_str: Absyn.ElementArg list => string =

  axiom	unparse_mod1_str [] => ""

  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str
	------------------------------------
	unparse_mod1_str l => str
end

(** relation: unparse_mod2_str
 **
 ** Helper relation to unparse_mod1_str
 **)

relation unparse_mod2_str : Absyn.Exp option => string =

  axiom	unparse_mod2_str NONE => ""

  rule	print_exp_str(e) => s1 &
	string_append("=",s1) => str
	-------------------------
	unparse_mod2_str SOME(e) => str
end

(* Equations *)

(** relation: print_equation
 **
 ** Prints an Equation to the Print buffer.
 **)

relation print_equation: Absyn.Equation => () =
	

  rule	Print.print_buf "IF (" & print_exp(e) & Print.print_buf ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	Print.print_buf " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	Print.print_buf "EQ_EQUALS(" & print_exp(e1) & Print.print_buf "," &
	print_exp(e2) & Print.print_buf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	Print.print_buf "EQ_CONNECT(" & print_component_ref(e1) & Print.print_buf "," &
	print_component_ref(e2) & Print.print_buf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	Print.print_buf "FOR " & Print.print_buf i & Print.print_buf " in " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_equation",el, print_equationitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	Print.print_buf " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

(** relation: print_equationitem
 **
 ** Prints and EquationItem to the Print buffer.
 **)

relation print_equationitem: Absyn.EquationItem => () =
  rule	Print.print_buf "EQUATIONITEM(" &
	print_equation eq &
	Print.print_buf ", <comment>)\n"
	-------------------------------
	print_equationitem Absyn.EQUATIONITEM(eq,_)
	
  rule	Print.print_buf "EQUATIONITEMANN(<annotation>)\n" 
	--------------
	print_equationitem Absyn.EQUATIONITEMANN(_)
end

(** relation: unparse_equation_str
 **
 ** Prettyprints an Equation to a string.
 **)

relation unparse_equation_str: (int, Absyn.Equation) => string =
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	indent_str(i) => is &
	Util.string_append_list(["if ", s1, " then\n",is, s2,is,"end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,[],[])) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i',tb,";\n") => s2 &
	unparse_eq_elseif_str_lst(i',eb, "\n") => s3 &
	unparse_equationitem_str_lst(i',fb,";\n") => s4 &
	indent_str(i) => is &
	Util.string_append_list([is,"if ", s1, " then\n",s2, s3, "\n",is,"else\n", s4,"\n", is, "end if"]) => str
	----------------------------------------------------
	unparse_equation_str(i, Absyn.EQ_IF(e,tb,eb,fb)) => str
	
  rule	print_exp_str(e1) => s1 &
	print_exp_str(e2) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,s1, "=", s2]) => str
	-------------------------------------------
	unparse_equation_str(i,Absyn.EQ_EQUALS(e1,e2)) => str
	
  rule	print_component_ref_str(e1) => s1 &
	print_component_ref_str(e2) => s2 &
	indent_str(i) => is &
	Util.string_append_list([is,"connect(", s1, ",", s2, ")"]) => str
	-------------------------------------------
	unparse_equation_str(i, Absyn.EQ_CONNECT(e1,e2)) => str
	
  rule	print_exp_str(e) => s1 &
	unparse_equationitem_str_lst(indent,el,";\n") => s2 &
	indent_str(indent) => is &
	Util.string_append_list([is,"for ", i, " in ", s1, " loop\n", s2, "\n",is,"end for"]) => str
	----------------------------------------------------------
	unparse_equation_str (indent,Absyn.EQ_FOR(i,e,el)) => str

  rule	print_function_args_str(fargs) => s2 &
	Util.string_append_list([id,"(",s2,")"]) => str
	-----------------------------------------------
	unparse_equation_str(i, Absyn.EQ_NORETCALL(id,fargs)) => str

  rule	print_exp_str(exp) => s1 &
	int_add(i,1) => i' &
	unparse_equationitem_str_lst(i', eql, ";\n") => s2 &
	indent_str(i) => is &
	unparse_eq_elsewhen_str_lst(i',eqlelse) => s4 &
	Util.string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when"]) => str
	-------------------
	unparse_equation_str(i, Absyn.EQ_WHEN_E(exp,eql,eqlelse)) => str

  rule	Print.print_buf " ** Failure! UNKNOWN EQUATION ** "
	--------------------------------
	unparse_equation_str(_,_) => ""
	
end

(** relation:unparse_equationitem_str_lst
 **
 ** Prettyprints and EquationItem list to a string.
 **)

relation unparse_equationitem_str_lst: (int (* indent *), 
					Absyn.EquationItem list, 
					string) 
	  => string =

  axiom	 unparse_equationitem_str_lst(_,[],_) => ""
	
  rule	unparse_equationitem_str(i, x) => s1 &
	unparse_equationitem_str_lst(i, xs, sep) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	----------------------
	unparse_equationitem_str_lst(i,x::xs,sep) => res
end

(** relation: unparse_equationitem_str
 **
 ** Prettyprints an EquationItem to a string.
 **)

relation unparse_equationitem_str: (int, Absyn.EquationItem) => string =
  rule	
	unparse_equation_str (i, eq) => s1 &
	unparse_comment_option(optcmt) => s2 &
	string_append(s1,s2) => str
	---------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEM(eq,optcmt)) => str 
	
  rule	unparse_annotation_option(i,SOME(ann)) => str
	-------------------------------------------
	unparse_equationitem_str (i, Absyn.EQUATIONITEMANN(ann)) => str
end
	
(** relation: print_eq_elseif
 **
 ** Prints an Elseif branch to the Print buffer.
 **)
	
relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =
	
  rule	Print.print_buf " ELSEIF " & print_exp e & Print.print_buf " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))
end

(** relation: unparse_eq_elseif_str_lst
 **
 ** Prettyprints an elseif branch to a string.
 **)

relation unparse_eq_elseif_str_lst: (int, (Absyn.Exp * Absyn.EquationItem list) list, string) => string =
	
  axiom	 unparse_eq_elseif_str_lst(_,[],_) => ""

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	Util.string_append_list([s1,sep]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1],sep) => res

  rule	unparse_eq_elseif_str_lst(i,xs,sep) => s2 &
	unparse_eq_elseif_str(i,x) => s1 &
	Util.string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_eq_elseif_str_lst(i,x::(xs as _::_),sep) => res

  rule	unparse_eq_elseif_str(i,x1) => s1 &
	unparse_eq_elseif_str(i,x2) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	-------------------------------------
	unparse_eq_elseif_str_lst(i,[x1,x2],sep) => res
end

(** relation: unparse_eq_elseif_str
 **
 ** Helper relation to unparse_eq_elseif_str_lst
 **)

relation unparse_eq_elseif_str : (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	    
  rule	print_exp_str e => s1 &
	unparse_equationitem_str_lst(i,el,";\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list(["\n",is,"elseif ",s1," then\n",s2]) => res
	-----------------------------------
	unparse_eq_elseif_str(i,(e,el)) => res
end

(* Algorithm clauses *)

(** relation: print_algorithmitem
 **
 ** Prints an AlgorithmItem to the Print buffer.
 **)

relation print_algorithmitem: Absyn.AlgorithmItem => () =

  rule	Print.print_buf "ALGORITHMITEM(" &
	print_algorithm(alg)&
	Print.print_buf ")\n"
	-------------------
	print_algorithmitem (Absyn.ALGORITHMITEM(alg,_))

  rule	Print.print_buf "ALGORITHMITEMANN(<annotation>)\n"
	----------------------------------------
	print_algorithmitem(Absyn.ALGORITHMITEMANN(ann))
end

(** relation: print_algorithm
 **
 ** Prints an Algorithm to the Print buffer.
 **)

relation print_algorithm: Absyn.Algorithm => () =
	
  rule	Print.print_buf "ALG_ASSIGN(" & print_component_ref cr &
	Print.print_buf " := " & print_exp(exp) & Print.print_buf ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	Print.print_buf "ALG_TUPLE_ASSIGN(" & print_exp(e1) &
	Print.print_buf " := " & print_exp(e2) & Print.print_buf ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_TUPLE_ASSIGN(e1,e2))

  rule	Print.print_buf "IF (" & print_exp(e) & Print.print_buf ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithmitem, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	Print.print_buf " ELSE " & print_list_debug("print_algorithm",fb, print_algorithmitem, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	Print.print_buf "FOR " & Print.print_buf i & Print.print_buf " in " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",el, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	Print.print_buf "WHILE " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	Print.print_buf "WHEN_E " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	Print.print_buf "WHEN_A " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al,el)
	
  rule	Print.print_buf " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

(** relation: unparse_algorithm_str_lst
 **
 ** Prettyprints an AlgorithmItem list to a string.
 **)

relation unparse_algorithm_str_lst: (int, Absyn.AlgorithmItem list,string)
	  => string =

  axiom unparse_algorithm_str_lst (_,[],_) => ""

  rule	unparse_algorithm_str(i,x) => s1 &
	string_append(s1,sep) => res 
	------------------------------------
	unparse_algorithm_str_lst(i, [x], sep) => res
	
  rule	unparse_algorithm_str(i,x1) => s1 &
	unparse_algorithm_str(i,x2) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	------------------------------------
	unparse_algorithm_str_lst(i, [x1,x2], sep) => res

  rule	unparse_algorithm_str(i,x) => s1 &
	unparse_algorithm_str_lst(i,xs,sep) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	------------------------------------
	unparse_algorithm_str_lst(i, x::xs, sep) => res
end

(** relation: unparse_algorithm_str
 ** 
 ** Helper relation to unparse_algorithm_str
 **)

relation unparse_algorithm_str: (int, Absyn.AlgorithmItem) => string =
	
  rule	print_component_ref_str cr => s1 &
	print_exp_str(exp) => s2 & 
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,s1,":=",s2,s3,";"]) => str
	-------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(cr,exp),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i,tb,"\n") => s2 &
	unparse_alg_elseif_str_lst(i',eb,"\n") => s3 &
	unparse_algorithm_str_lst(i,fb,"\n") => s4 &
	unparse_comment_option(optcmt) => s5 &
	indent_str(i) => is &
	Util.string_append_list([is,"if ",s1," then \n",is, s2, s3, "\n",is, "else ", s4, "\n", is, "end if" , s5, ";"]) => str
	----------------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_IF(e,tb,eb,fb),optcmt)) => str
	
  rule	print_exp_str(e)=> s1 &
	int_add(ident,1) => ident' &
	unparse_algorithm_str_lst(ident',el,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(ident) => is &
	Util.string_append_list([is,"for ", i, " in ", s1, " loop\n",is, s2, "\n",is,"end for", s3, ";"]) => str
	----------------------------------------------------------
        unparse_algorithm_str (ident, Absyn.ALGORITHMITEM(Absyn.ALG_FOR(i,e,el),optcmt)) => str
				     
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i',al,"\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,"while (", s1, ") loop\n", is, s2, "\n", is, "end while", s3, ";"]) => str
	----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHILE(e,al),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	int_add(i,1) => i' &
	unparse_algorithm_str_lst(i', al, "\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	unparse_alg_elsewhen_str_lst(i',al2) => s4 &
	Util.string_append_list([is,"when ", s1, " then\n", is, s2, is, s4, "\n", is, "end when", s3,";"]) => str
        ----------------------------------------------------------
	unparse_algorithm_str (i, Absyn.ALGORITHMITEM(Absyn.ALG_WHEN_A(e,al,al2),optcmt)) => str
	
  rule	print_component_ref_str(cr) => s1 &
	print_function_args_str(fargs) => s2 &
	unparse_comment_option(optcmt) => s3 &
	indent_str(i) => is &
	Util.string_append_list([is,s1,"(",s2,")",s3,";"]) => str
	-----------------------------------------------
	unparse_algorithm_str(i, Absyn.ALGORITHMITEM(Absyn.ALG_NORETCALL(cr,fargs),optcmt)) => str

  rule	unparse_annotation_option(i, SOME(ann)) => str &
	string_append(str,";") => str'
	------------------------------------------
	unparse_algorithm_str (i,Absyn.ALGORITHMITEMANN(ann)) => str'
  
  rule	Print.print_buf " *Failure! UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	unparse_algorithm_str(_,_) => ""
	
end

(** relation: unparse_alg_elsewhen_str_lst
 **
 ** Unparses an elsewhen branch in an algorithm to a string.
 **)

relation unparse_alg_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.AlgorithmItem list) list) => string =

  axiom	unparse_alg_elsewhen_str_lst (_,[]) => ""

  rule	unparse_alg_elsewhen_str(i,x) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x]) => res

  rule	unparse_alg_elsewhen_str(i,x1) => s1 &
	unparse_alg_elsewhen_str(i,x2) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res 
	----------------------------
	unparse_alg_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_alg_elsewhen_str(i,x) => s1 &
	unparse_alg_elsewhen_str_lst(i,xs) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_alg_elsewhen_str_lst(i,x::(xs as _::_)) => res
end

(** relation: unparse_alg_elsewhen_str
 **
 ** Helper relation to unparse_alg_elsewhen_str_lst
 **)

relation unparse_alg_elsewhen_str: (int, (Absyn.Exp * Absyn.AlgorithmItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_algorithm_str_lst(i,algl,"\n") => s1 &
	print_exp_str(exp) => s2 &
	Util.string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_alg_elsewhen_str (i,(exp, algl)) => res
end

(** relation: unparse_eq_elsewhen_str_lst
 **
 ** Prettyprints an equation elsewhen branch to a string.
 **)

relation unparse_eq_elsewhen_str_lst: (int,(Absyn.Exp * Absyn.EquationItem list) list) => string =

  axiom	unparse_eq_elsewhen_str_lst (_,[]) => ""

  rule	unparse_eq_elsewhen_str(i,x) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x]) => res

  rule	unparse_eq_elsewhen_str(i,x1) => s1 &
	unparse_eq_elsewhen_str(i,x2) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,[x1,x2]) => res

  rule	unparse_eq_elsewhen_str(i,x) => s1 &
	unparse_eq_elsewhen_str_lst(i,xs) => s2 &
	Util.string_append_list([s1,"\n",s2]) => res
	----------------------------
	unparse_eq_elsewhen_str_lst(i,x::xs) => res
end

(** relation: unparse_eq_elsewhen_str
 **
 ** Helper relation to unparse_eq_elsewhen_str_lst
 **)

relation unparse_eq_elsewhen_str: (int, (Absyn.Exp * Absyn.EquationItem list)) => string =
	
  rule	indent_str(i) => is &
	unparse_equationitem_str_lst(i,eql,";\n") => s1 &
	print_exp_str(exp) => s2 &
	Util.string_append_list(["elsewhen ",s2, " then\n",s1]) => res
	------------------------
	unparse_eq_elsewhen_str (i,(exp, eql)) => res
end

(** relation: print_alg_elseif
 **
 ** Prints an algorithm elseif branch to the Print buffer.
 **)

relation print_alg_elseif : (Absyn.Exp * Absyn.AlgorithmItem list) => () =

  rule	Print.print_buf " ELSEIF " & print_exp e & Print.print_buf " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithmitem, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end

(** relation: unparse_alg_elseif_str_lst
 **
 ** Prettyprints an algorithm elseif branch to a string.
 **)

relation unparse_alg_elseif_str_lst: (int, (Absyn.Exp * Absyn.AlgorithmItem list) list, string) => string =
	
  axiom	 unparse_alg_elseif_str_lst(_,[],_) => ""

  rule	unparse_alg_elseif_str_lst(i,xs,sep) => s2 &
	unparse_alg_elseif_str(i,x) => s1 &
	Util.string_append_list([s1,sep,s2]) => res
	--------------------
	unparse_alg_elseif_str_lst(i,x::(xs as _::_),sep) => res

  rule	unparse_alg_elseif_str(i,x1) => s1 &
	unparse_alg_elseif_str(i,x2) => s2 &
	Util.string_append_list([s1,sep,s2]) => res
	-------------------------------------
	unparse_alg_elseif_str_lst(i,[x1,x2],sep) => res
end

(** relation: unparse_alg_elseif_str
 **
 ** Helper relation to unparse_alg_elseif_str_lst
 **)

relation unparse_alg_elseif_str : (int,(Absyn.Exp * Absyn.AlgorithmItem list)) => string =

  rule  print_exp_str e => s1 &
	unparse_algorithm_str_lst(i,el,"\n") => s2 &
	int_sub(i,1) => i' &
	indent_str(i') => is &
	Util.string_append_list([is,"elseif ", s1, " then\n", s2]) => str
	-----------------------------------
	unparse_alg_elseif_str(i,(e,el)) => str
end

(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef' to the Print buffer.
 *)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	Print.print_buf "Absyn.CREF_IDENT(\"" &
	Print.print_buf s &
	Print.print_buf "\", " &
	print_subscripts subs &
	Print.print_buf ")" 
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	Print.print_buf "Absyn.CREF_QUAL(\"" &
	Print.print_buf s &
	Print.print_buf "\", " &
	print_subscripts subs &
	Print.print_buf "," &
	print_component_ref cr &
	Print.print_buf ")"
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

(** relation: print_subscripts
 **
 ** Prints a Subscript to the Print buffer.
 **)

relation print_subscripts : Absyn.Subscript list => () =

  rule	Print.print_buf "[]" 
	-------------------
	print_subscripts []

  rule	Print.print_buf "[" & print_list_debug("print_subscripts",l,print_subscript,",") & Print.print_buf "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)

relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''
end

(** relation: print_subscripts_str
 **
 ** Prettyprint a Subscript list to a string.
 **)

relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path : Absyn.Path => () =

  rule	Absyn.path_string p => s & Print.print_buf s
	----------------------------------
	print_path p
end

(** relation: dump_path
 **
 ** Dumps path to the Print buffer
 **)
		    
relation dump_path: Absyn.Path => () =

  rule	Print.print_buf("Absyn.IDENT(\"") &
	Print.print_buf str & 
	Print.print_buf "\")"
	---------------------------
	dump_path(Absyn.IDENT(str)) 
		    
  rule	Print.print_buf("Absyn.QUALIFIED(\"") &
	Print.print_buf str & 
	Print.print_buf "\"," &
	dump_path(path) &
	Print.print_buf ")"
	---------------------------
	dump_path(Absyn.QUALIFIED(str,path)) 
end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path_str : Absyn.Path => string =

  rule	Absyn.path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression to the Print buffer.
 *)

relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & 
	Print.print_buf "Absyn.INTEGER(" &
	Print.print_buf s &
	Print.print_buf ")" 
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & 
	Print.print_buf "Absyn.REAL(" &
	Print.print_buf s &
	Print.print_buf ")" 
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	Print.print_buf "Absyn.CREF(" &
	print_component_ref(c) &
	Print.print_buf ")" 
	---------------------
	print_exp(Absyn.CREF(c))

  rule	Print.print_buf "Absyn.STRING(\"" &
	Print.print_buf s &
	Print.print_buf "\")"
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	Print.print_buf "Absyn.BOOL(false)"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	Print.print_buf "Absyn.BOOL(true)"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	dump_op_symbol(op) => sym & 
	Print.print_buf "Absyn.BINARY(" & 
	print_exp e1 & 
	Print.print_buf "," &
	Print.print_buf sym & 
	Print.print_buf "," &
	print_exp e2 &
	Print.print_buf ")" 
	--------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	dump_op_symbol(op) => sym &
	Print.print_buf "Absyn.UNARY(" &
	Print.print_buf sym &
	Print.print_buf ", " & 
	print_exp e &
	Print.print_buf ")" 
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	dump_op_symbol(op) => sym & 
	Print.print_buf "Absyn.LBINARY(" &
	print_exp e1 & 
	Print.print_buf "," &
	Print.print_buf sym & 
	Print.print_buf "," &
	print_exp e2 &
	Print.print_buf ")" 
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	dump_op_symbol(op) => sym &
	Print.print_buf "Absyn.UNARY(" &
	Print.print_buf sym &
	Print.print_buf ", " & 
	print_exp e &
	Print.print_buf ")" 
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	dump_op_symbol(op) => sym & 
	Print.print_buf "Absyn.RELATION(" &
	print_exp e1 & 
	Print.print_buf "," &
	Print.print_buf sym & 
	Print.print_buf "," &
	print_exp e2 &
	Print.print_buf ")" 
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	Print.print_buf "Absyn.IFEXP(" & print_exp(c) &
	Print.print_buf ", " & print_exp(t) &
	Print.print_buf ", " & print_exp(f) &
	Print.print_buf ")" 
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f,lst))

  rule	Print.print_buf "Absyn.CALL(" &
	print_component_ref(fcn) &
 	Print.print_buf ", " & 
	print_function_args(args) & Print.print_buf ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	Print.print_buf "Absyn.ARRAY([" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.print_buf "])"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	Print.print_buf "Absyn.TUPLE([" &
	Print.print_buf "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.print_buf "])"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	Print.print_buf "Absyn.MATRIX([" &
	print_list_debug("print_exp",es, print_row, ";") &
	Print.print_buf "])"
	---------
	print_exp Absyn.MATRIX(es)

  rule	Print.print_buf "Absyn.RANGE(" & print_exp start & 
	Print.print_buf ",NONE," & print_exp stop & Print.print_buf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	Print.print_buf "Absyn.RANGE(" & print_exp start & 
	Print.print_buf ",SOME(" & print_exp step &
 	Print.print_buf ")," & print_exp stop & Print.print_buf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule Print.print_buf "Absyn.END"
	----------------------------------
	print_exp Absyn.END

  rule	Print.print_buf "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

(** relation: print_function_args
 **
 ** Prints FunctionArgs to Print buffer.
 **)

relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  Print.print_buf "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	Print.print_buf ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	Print.print_buf ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)

  rule  Print.print_buf "FOR_ITER_FARG(" &
	print_exp exp &
	Print.print_buf ", " &
	Print.print_buf id &
	Print.print_buf ", " &
	print_exp iterexp &
	Print.print_buf ")"
	-------------------
	print_function_args Absyn.FOR_ITER_FARG (exp, id, iterexp)
end

(** relation: print_function_args_str
 **
 ** Prettyprint FunctionArgs to a string.
 **)

relation print_function_args_str: Absyn.FunctionArgs => string =
	
  rule	(* Both positional and named arguments *)
	print_list_str(expargs,print_exp_str,", ") => s1 &
	string_append(s1,", ") => s2 &
	print_list_str(nargs,print_named_arg_str,", ") => s3 &
	string_append(s2,s3) => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs as _::_,nargs as _::_) => str

  rule	(* Only named arguments *)
	print_list_str(nargs,print_named_arg_str,", ") => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS([],nargs) => str

  rule	(* Only positional arguments *)
	print_list_str(expargs,print_exp_str,", ") => str 
	---------------------------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs,[]) => str

  rule	print_exp_str exp => estr &
	print_exp_str iterexp => istr &
	Util.string_append_list([estr," for ",id," in ", istr]) => str
	--------------------------------------------------------------
	print_function_args_str Absyn.FOR_ITER_FARG(exp,id,iterexp) => str
	
end

(** relation: print_named_arg
 **
 ** Print NamedArg to the Print buffer.
 **)

relation print_named_arg: Absyn.NamedArg => () =

  rule	Print.print_buf ident &
	Print.print_buf "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

(** relation: print_named_arg_str
 **
 ** Prettyprint NamedArg to a string.
 **)

relation print_named_arg_str: Absyn.NamedArg => string =
  rule	string_append(ident,"=") => s1 &
	print_exp_str(e) => s2 &
	string_append(s1,s2) => str
	---------------------------
	print_named_arg_str Absyn.NAMEDARG(ident,e) => str
end	

(** relation: print_row
 **
 ** Print an Expression list to the Print buffer.
 **)

relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end


(* relation: exp_priority
*
* Returns a priority number for an expression.
* This relation is used to output parenthesis when needed. eg 3*(1+2) should output 3*(1+2) 
* and not 3*1+2
 *)

relation exp_priority: Absyn.Exp => int =

  axiom	exp_priority(Absyn.INTEGER(_)) => 0
  axiom	exp_priority(Absyn.REAL(_)) => 0
  axiom	exp_priority(Absyn.STRING(_)) => 0
  axiom	exp_priority(Absyn.BOOL(_)) => 0
  axiom	exp_priority(Absyn.CREF(_)) => 0
  axiom	exp_priority(Absyn.END) => 0
  axiom	exp_priority(Absyn.CALL(_,_)) => 0
  axiom	exp_priority(Absyn.ARRAY(_)) => 0
  axiom	exp_priority(Absyn.MATRIX(_)) => 0

  axiom	exp_priority(Absyn.BINARY(_,Absyn.POW,_)) => 1 

  axiom	exp_priority(Absyn.BINARY(_,Absyn.DIV,_)) => 2
  axiom	exp_priority(Absyn.BINARY(_,Absyn.MUL,_)) => 3

  axiom	exp_priority(Absyn.UNARY(Absyn.UPLUS,_)) => 4
  axiom	exp_priority(Absyn.UNARY(Absyn.UMINUS,_)) => 4

  axiom	exp_priority(Absyn.BINARY(_,Absyn.ADD,_)) => 5
  axiom	exp_priority(Absyn.BINARY(_,Absyn.SUB,_)) => 5

  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESS,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.LESSEQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATER,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.GREATEREQ,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.EQUAL,_)) => 6
  axiom	exp_priority(Absyn.RELATION(_,Absyn.NEQUAL,_)) => 6

  axiom	exp_priority(Absyn.LUNARY(Absyn.NOT,_)) => 7

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.AND,_)) => 8

  axiom	exp_priority(Absyn.LBINARY(_,Absyn.OR,_)) => 9

  axiom	exp_priority(Absyn.RANGE(_,_,_)) => 10

  axiom	exp_priority(Absyn.IFEXP(_,_,_,_)) => 11

	(* Not valid in inner expressions, only included here for completeness *)
  axiom	exp_priority(Absyn.TUPLE(_)) => 12
	
  axiom	exp_priority(_) => 13
end

(** relation: parenthesize
 **
 ** Adds parentheisis to a string if expression and parent expression 
 ** priorities requires it.
 **)

relation parenthesize: (string, 
			int, (*expressuion prio*)
			int (*parent expr prio*)
			) => string =

  rule	int_gt(pparent,pexpr) => true &
	Util.string_append_list(["(",str,")"]) => str'
	---------------------------
	parenthesize(str,pparent,pexpr) => str'

  axiom	parenthesize(str,_,_) => str
end

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p2,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.BINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.UNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str (e as Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e1 => s &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &	
	parenthesize(s,p1,p) => s' &
	string_append (sym, s') => s''
	----------------------------
	print_exp_str(e as Absyn.LUNARY(op, e1)) => s''

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	exp_priority(e) => p &
	exp_priority(e1) => p1 &
	exp_priority(e2) => p2 &
	parenthesize(s1,p1,p) => s1' &
	parenthesize(s2,p1,p) => s2' &
	string_append (s1', sym) => s &
	string_append (s, s2') => s'
	---------------------------
	print_exp_str(e as Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	exp_priority(e) => p &
	exp_priority(c) => pc &
	exp_priority(t) => pt &
	exp_priority(f) => pf &
	parenthesize(cs,pc,p) => cs' &
	parenthesize(ts,pt,p) => ts' &
	parenthesize(fs,pf,p) => fs' &
	print_elseif_str elseif => el &		       
	Util.string_append_list(["if ", cs', " then ", ts', el, " else ", fs']) => str
	---------------------------------
	print_exp_str(e as Absyn.IFEXP(c,t,f,elseif)) => str

  rule	print_component_ref_str(fcn) => fs &
	print_function_args_str(args) => argsstr &
	string_append(fs, "(") => s &
	string_append(s, argsstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''


  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

  rule	(* Does not need parentheses *)
	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	(* Does not need parentheses *)
	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	Util.string_append_list([ s1', ":", s3']) => s
	--------------------------------
	print_exp_str(e as  Absyn.RANGE(start,NONE,stop)) => s

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	exp_priority(e) => p &
	exp_priority(start) => pstart &
	exp_priority(stop) => pstop &
	exp_priority(step) => pstep &
	parenthesize(s1,pstart,p) => s1' &
	parenthesize(s3,pstop,p) => s3' &
	parenthesize(s2,pstep,p) => s2' &
	Util.string_append_list([s1',":", s2', ":", s3']) => s
	------------------------------------
	print_exp_str (e as Absyn.RANGE(start,SOME(step),stop)) => s

  rule	print_code_str(c) => res &
	Util.string_append_list(["Code(",res,")"]) => res'
	--------------------------
	print_exp_str ( Absyn.CODE(c)) => res'

  axiom print_exp_str Absyn.END => "end"

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end

(** relation: print_code_str
 **
 **  Prettyprint Code to a string.
 **)

relation print_code_str: Absyn.Code => string =
	
  rule	print_path_str p => s
	---------------------
	print_code_str( Absyn.C_TYPENAME(p)) => s

  rule	print_component_ref_str cr => s
	---------------------
	print_code_str( Absyn.C_VARIABLENAME(cr)) => s

  rule	select_string(b,"initial ", "") => s1 &
	unparse_equationitem_str_lst (1,eqitems,";\n") => s2 &
	Util.string_append_list([s1, "equation ",s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_EQUATIONSECTION(b, eqitems)) => res

  rule	select_string(b,"initial ", "") => s1 &
	unparse_algorithm_str_lst (1,algitems,";\n") => s2 &
	Util.string_append_list([s1,"algorithm ", s2]) => res
	------------------------------------------------
	print_code_str( Absyn.C_ALGORITHMSECTION(b, algitems)) => res

  rule	unparse_element_str(1,elt) => res
	------------------------------------------------
	print_code_str( Absyn.C_ELEMENT(elt)) => res

  rule	print_exp_str(exp) => res
	------------------------------------------------
	print_code_str( Absyn.C_EXPRESSION(exp)) => res

  rule	unparse_modification_str(m) => res
	------------------------------------------------
	print_code_str( Absyn.C_MODIFICATION(m)) => res

end

(** relation: print_eleseif_str
 **
 ** Prettyprint elseif to a string
 **)
			       
relation print_elseif_str: (Absyn.Exp * Absyn.Exp) list => string =
  axiom print_elseif_str ([]) => ""

  rule	print_exp_str(ec) => s1 &
	print_exp_str(ee) => s2 &
	print_elseif_str(rest) => s3 &
	Util.string_append_list([" elseif ", s1, " then ", s2, s3]) => str
	-------------------------------------------------------------
	print_elseif_str((ec,ee)::rest) => str
end

(** relation: print_row_str
 **
 ** Prettyprint a list of expressions to a string.
 **)

relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)

relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " and "
  axiom	op_symbol(Absyn.OR) => " or "

  axiom	op_symbol(Absyn.NOT) => "not "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " == "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end


(* relation: dump_op_symbol
 *
 * Make a string describing different operators.
 *)

relation dump_op_symbol : Absyn.Operator => string =
  axiom	dump_op_symbol(Absyn.ADD) => "Absyn.ADD"
  axiom	dump_op_symbol(Absyn.SUB) => "Absyn.SUB"
  axiom	dump_op_symbol(Absyn.MUL) => "Absyn.MUL"
  axiom	dump_op_symbol(Absyn.DIV) => "Absyn.DIV"
  axiom	dump_op_symbol(Absyn.POW) => "Absyn.POW"

  axiom	dump_op_symbol(Absyn.UMINUS) => "Absyn.UMINUS"
  axiom	dump_op_symbol(Absyn.UPLUS) => "Absyn.UPLUS"

  axiom	dump_op_symbol(Absyn.AND) => "Absyn.AND"
  axiom	dump_op_symbol(Absyn.OR) => "Absyn.OR"

  axiom	dump_op_symbol(Absyn.NOT) => "Absyn.NOT"

  axiom	dump_op_symbol(Absyn.LESS)      => "Absyn.LESS"
  axiom	dump_op_symbol(Absyn.LESSEQ)    => "Absyn.LESSEQ"
  axiom	dump_op_symbol(Absyn.GREATER)   => "Absyn.GREATER"
  axiom	dump_op_symbol(Absyn.GREATEREQ) => "Absyn.GREATEREQ"
  axiom	dump_op_symbol(Absyn.EQUAL)     => "Absyn.EQUAL"
  axiom	dump_op_symbol(Absyn.NEQUAL)    => "Absyn.NEQUAL"
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)


(** relation: select_string
 **
 ** Select one of the two strings depending on boolean value.
 **)

relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

(** relation: print_select
 **
 ** Select one of the two string depending on boolean value 
 ** and print it on the Print buffer.
 **)

relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	Print.print_buf res
	-------------------------
	print_select(f,yes,no)

end

(** relation: print_option
 **
 ** Prints an option value given a print relation.
 **)

relation print_option : (('a option),('a => ())) => () =

  rule	Print.print_buf "NONE" 
	------------------------
	print_option(NONE,_) => ()
	
  rule	Print.print_buf "SOME(" &
	r( x ) &
	Print.print_buf ")" 
	-------------------
	print_option(SOME(x),r) => ()
end

(** relation: print_list_debug
 **
 ** Prints a list of values given a print relation and a caller string.
 **)

relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	Debug.fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	Debug.fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	Debug.fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	Debug.fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	Print.print_buf sep & 
	Debug.fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end

(** relation: print_list
 **
 ** Prints a list of values given a print relation.
 **)

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.print_buf sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(** relation get_string_list
 **
 ** Append strings from a list of values output with a relation converting
 ** a value to a string. 
 **)

relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

(** relation: print_bool
 **
 ** Print a bool value to the Print buffer
 **)

relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b
end


(** relation get_option_str
 **
 ** Retrieve the string from a string option.
 ** If NONE return empty string.
 **)

relation get_option_str: ('a option, 'a => string) => string =
  rule  r (a) => str
	------------
	get_option_str (SOME(a),r) => str

  axiom	get_option_str(NONE,_) => ""
end

(** relation: get_option_with_concat_str
 **
 ** Get option string value using a relation translating the value to a string
 ** and concatenate with an additional suffix string.
 **)

relation get_option_with_concat_str: ('a option, 
				      'a => string,
				      string) (* suffix *)
	  => string =
  rule  r (a) => str &
        string_append(default_str,str) => str'
	------------
	get_option_with_concat_str (SOME(a),r,default_str) => str'

  axiom	get_option_with_concat_str(NONE,_,default_str) => ""
end


(** relation: unparse_string_comment_option
 **
 ** Prettyprint a string comment option, which is a string option.
 **)
relation unparse_string_comment_option: string option => string =
	
  axiom unparse_string_comment_option(NONE) => ""
	
  rule	Util.string_append_list([" \"",s,"\""])=> str 
	--------------------------
	unparse_string_comment_option(SOME(s)) => str
end

(** relation: print_string_comment_option
 **
 ** Print a string comment option on the Print buffer
 **)
relation print_string_comment_option: string option => () =
	
  rule	Print.print_buf "NONE" 
	--------------------
	print_string_comment_option(NONE) => ()
	
  rule	Util.string_append_list(["SOME( \"",s,"\")"])=> str &
	Print.print_buf str 
	--------------------------
	print_string_comment_option(SOME(s)) => ()
end

(** relation: identity
 ** 
 ** The identity relation.
 **)
relation identity: ('a) => 'a =
  axiom identity(x) => x
end

(** relation: print_bool_str
**
** Prints a bool to a string.
**)

relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end
(** relation: indent_str
 ** 
 ** Creates an indentation string, i.e. whitespaces, given and indentation 
 ** level.
 **)

relation indent_str: (int) => string =
  axiom	indent_str(0) => ""

  rule	int_sub(i,1) => i' &
	indent_str(i') => s1 &
	(* Indent using two whitespaces *)
	string_append(s1,"  ") => res
	--------------------
	indent_str(i) => res
end
