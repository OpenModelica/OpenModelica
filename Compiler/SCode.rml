(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 scode.rml
 ** module:      SCode
 ** description: SCode intermediate form
 **
 ** RCS: $Id$
 **
 ** This module contains data structures to describe a Modelica model
 ** in a more convenient way than the `Absyn' module does.  The most
 ** important relation in this module is the `elaborate' relation
 ** which turns an abstract syntax tree into an SCode representation.
 **
 ** The SCode representaion is used as input to the Inst module
 **)
module SCode :

  with "Absyn.rml"

  (** Some definitions are borrowed from `Absyn' *)
  type Ident = Absyn.Ident
  type Path = Absyn.Path
  type Subscript = Absyn.Subscript
  datatype Restriction =  R_CLASS
		   | R_MODEL
		   | R_RECORD
		   | R_BLOCK
		   | R_CONNECTOR
		   | R_TYPE
		   | R_PACKAGE
		   | R_FUNCTION
		   | R_EXT_FUNCTION   (* Added c.t. Absyn *)
		   | R_ENUMERATION	
		   | R_PREDEFINED_INT
		   | R_PREDEFINED_REAL
		   | R_PREDEFINED_STRING
		   | R_PREDEFINED_BOOL
		   | R_PREDEFINED_ENUM
							  
  (** - Modifications *)
  datatype Mod = MOD of bool (* final *) 
		      * Absyn.Each 
                      * (SubMod list) 
                      * (Absyn.Exp option)
  	       | REDECL of bool (* final *) * Element list
	       | NOMOD

  (** Modifications are represented in an more structured way than in 
   ** the `Absyn' module.  Modifications using qualified names
   ** (such as in `x.y =  z') are normalized (to `x(y = z)').  And a
   ** special case when arrays are subscripted in a modification.
   **)
  datatype SubMod = NAMEMOD of Ident * Mod         (* A named component *)
		  | IDXMOD of Subscript list * Mod (* An array element *)

  (** - Programs *)
  (** As in the AST, a program is simply a list of class definitions. *)
  type Program = Class list


  (** - Classes *)
  datatype Class = CLASS of Ident		(* Name *)
			  * bool		(* Partial *)
			  * bool		(* Encapsulated *)
			  * Restriction	        (* Restricion *)
			  * ClassDef		(* Parts *)

  (** The major difference between these types and their `Absyn' *)
  (** counterparts is that the `PARTS' constructor contains separate *)
  (** lists for elements, equations and algorithms. *)
  datatype ClassDef = PARTS of Element list
			     * Equation list
			     * Equation list    (* InitialEquation *)
			     * Algorithm list
			     * Algorithm list   (* InitialAlgorithm *)
                             * Absyn.ExternalDecl option  (* Used by external functions*)
		    | DERIVED of Path		(* short class definition *)
			       * Absyn.ArrayDim option
			       * Mod
		    | ENUMERATION of Ident list

		    | OVERLOAD of Absyn.Path list 		 
		    | CLASS_EXTENDS of Ident
				* Mod
				* Element list
				* Equation list
				* Equation list 
				* Algorithm list
				* Algorithm list
		    | PDER of Absyn.Path     (* function name *)
			    * Ident list (* derived variables *)				      

  (* - Equations *)
  datatype Equation = EQUATION of EEquation
				  * Absyn.Path option (*baseclassname if in bclass*)

  (** These are almost identical to the `Absyn' versions.  In `EQ_IF', *)
  (** the `elseif' branches are represented as normal `else' branches *)
  (** with a single `if' statement in them. *)
  datatype EEquation = EQ_IF of Absyn.Exp	(* conditional *)
			     * EEquation list	(* true branch *)  
			     * EEquation list	(* false branch *)
		    | EQ_EQUALS of Absyn.Exp * Absyn.Exp
		    | EQ_CONNECT of Absyn.ComponentRef * Absyn.ComponentRef
		    | EQ_FOR of Ident * Absyn.Exp * EEquation list
		    | EQ_WHEN of Absyn.Exp * EEquation list * (Absyn.Exp * EEquation list) list
		    | EQ_ASSERT of Absyn.Exp * (* condition*) 
				   Absyn.Exp (* message string *)	 
                      | EQ_REINIT of Absyn.ComponentRef * (* state variable *) 
				   Absyn.Exp (* the new value *)         

  (** - Algorithms *)
  (** The `Absyn' module uses the terminology from the grammar, where *)
  (** `algorithm' means an algorithmic statement.  But here, *)
  (** `Algorithm' means a whole algorithm section. *)
  datatype Algorithm = ALGORITHM of Absyn.Algorithm list
				    * Absyn.Path option (* baseclass name if in baseclass*)

  (** - Elements *)
  (** There are four types of elements in a declaration, represented *)
  (** by the constructors `EXTENDS' (for `extends' clauses), *)
  (** `CLASSDEF' (for local class definitions)  `COMPONENT' (for *)
  (** local variables). and `IMPORT' (for `import' clauses) *)
  (** The baseclass name is initially NONE in the translation, and
   ** if an element is inherited from a base class it is filled in during the
   ** instantiation process. *)
  datatype Element = EXTENDS of  Path * Mod
		   | CLASSDEF of Ident		(* name *)
			       * bool		(* final *)
			       * bool		(* replaceable *)
			       * Class
			       * Path option    (* baseclass name if in baseclass*)
		   | IMPORT    of Absyn.Import
		   | COMPONENT of Ident		(* component name *)
				* bool		(* final *)
				* bool		(* replaceable *)
				* bool		(* protected *)
				* Attributes
				* Path		(* type name *)
				* Mod
			        * Path option   (* baseclass name if in baseclass*)
                                * Absyn.Comment option (* this if for extraction comments and annotations from Absyn *)

  (** - Attributes *)
  datatype Attributes = ATTR of Absyn.ArrayDim
			      * bool		(* flow *)
			      * Accessibility   (* RW, RO, WO *)
	  		      * Variability	(* parameter *)
			      * Absyn.Direction (* input, output or bidirectional *)

  datatype Variability = VAR | DISCRETE | PARAM | STRUCTPARAM | CONST 

  (** These are attributes that apply to a declared component. *)
  datatype Accessibility = RW	(* read/write *)
			 | RO	(* read-only *)
			 | WO	(* write-only (not used) *)


  relation elaborate : Absyn.Program => Program
  relation elab_class: Absyn.Class => Class	
  relation build_mod : (Absyn.Modification option, bool (* final *),Absyn.Each) => Mod
  relation strip_submod: Mod => Mod
  relation get_element_named: (Ident, Class) => Element
  relation print_mod : Mod => ()
  relation print_mod_str : Mod => string 
  relation print_element : Element => ()
  relation print_element_str : Element => string 
  relation equation_str : EEquation => string
  relation print_class_str: Class => string
  relation print_element_list : Element list => ()	  
  relation print_restr: Restriction => ()
  relation restr_string : Restriction => string 
  relation variability_string: Variability => string
  relation count_parts: Class => int
  relation component_names: Class => string list	  
  relation is_parameter_or_const: Variability => bool
  relation is_function : Class => bool
  relation class_name : Class => string
  relation class_set_partial: (Class,bool) => Class 

end


with "Dump.rml"
with "Debug.rml"
with "Print.rml"
with "Util.rml"
with "Error.rml"

(** relation: elaborate
 **
 ** This relation takes an `Absyn.Program' and constructs a `Program'
 ** from it.
 **)
relation elaborate : Absyn.Program => Program =

  axiom	elaborate(Absyn.PROGRAM([],_)) => []

  rule	elab_class(c) => c' &
	elaborate(Absyn.PROGRAM(cs,w)) => cs'
	-----------------------------
	elaborate(Absyn.PROGRAM(c::cs,w)) => (c'::cs')

  rule	Debug.fprint("failtrace","-elaborate failed\n") 
	-----------------------
	elaborate(p) => fail
end

(** relation: elab_class
 **
 ** This relations converts an `Absyn.Class' to a `Class'.
 **)
relation elab_class: Absyn.Class => Class =

  rule  elab_classdef d => d' &
	elab_restriction(c,r) => r'
	---------------------
	elab_class(c as Absyn.CLASS(n,p,f,e,r,d,file_info)) => CLASS(n,p,e,r',d')

end

(** relation: elab_restriction
 **
 ** Convert a class restriction.
 **)
relation elab_restriction: (Absyn.Class, Absyn.Restriction) => Restriction =

  rule	contain_external_func_decl(d) => true 
	-------------------------------------------------
	elab_restriction(d,Absyn.R_FUNCTION) 
	    => R_EXT_FUNCTION

  rule	contain_external_func_decl(d) => false 
	-------------------------------------------------
	elab_restriction(d,Absyn.R_FUNCTION)
	    => R_FUNCTION

  axiom	elab_restriction(_,Absyn.R_CLASS) => R_CLASS
  axiom	elab_restriction(_,Absyn.R_MODEL) => R_MODEL
  axiom	elab_restriction(_,Absyn.R_RECORD) => R_RECORD
  axiom	elab_restriction(_,Absyn.R_BLOCK) => R_BLOCK
  axiom	elab_restriction(_,Absyn.R_CONNECTOR) => R_CONNECTOR
  axiom	elab_restriction(_,Absyn.R_EXP_CONNECTOR) => R_CONNECTOR (* fixme *)
  axiom	elab_restriction(_,Absyn.R_TYPE) => R_TYPE
  axiom	elab_restriction(_,Absyn.R_PACKAGE) => R_PACKAGE
  axiom	elab_restriction(_,Absyn.R_ENUMERATION) => R_ENUMERATION
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_INT) => R_PREDEFINED_INT
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_REAL) => R_PREDEFINED_REAL
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_STRING) => R_PREDEFINED_STRING
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_BOOL) => R_PREDEFINED_BOOL
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_ENUM) => R_PREDEFINED_ENUM
end

(** relation: contain_external_func_decl
 **
 ** Returns true if Class contains an external function declaration.
 **)
relation contain_external_func_decl:(Absyn.Class) => bool =
	
  axiom	contain_external_func_decl(Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(Absyn.EXTERNAL(_,_)::_,_),_)) => true
	
  rule	contain_external_func_decl(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt),file_info)) => res
	----------------------
	contain_external_func_decl(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::rest,cmt),file_info)) => res

  axiom	contain_external_func_decl(_) => false
end

(** relation: elab_classdef
 **
 ** This relation converts an `Absyn.ClassDef' to a `ClassDef'.  For
 ** the `DERIVED' case, the conversion is fairly trivial, but for the
 ** `PARTS' case more work is needed.  The result contains separate
 ** lists for elements, equations and algorithms, which are mixed in
 ** the input.
 **)
(** LS: Divided the elab_classdef into separate relations for
 ** collecting the different parts
 **)
relation elab_classdef: Absyn.ClassDef => ClassDef =

  rule	build_mod(SOME(Absyn.CLASSMOD(a, NONE)), false,Absyn.NON_EACH) => mod
	(* TODO: attributes of derived classes *)
	------------------------------------------------
	elab_classdef(Absyn.DERIVED(p,d,attr,a,cmt)) => DERIVED(p,d,mod)


  rule	elab_classdef_elements parts => els &
	elab_classdef_equations parts => eqs &
	elab_classdef_initialequations parts => initeqs &
	elab_classdef_algorithms parts => als &
	elab_classdef_initialalgorithms parts => initals &
	elab_classdef_externaldecls parts => decl
	-------------------------------------
	elab_classdef (Absyn.PARTS(parts,cmt)) 
          => PARTS(els,eqs,initeqs,als,initals,decl)

  rule	elab_enumlist(lst) => lst'
	--------------------------
	elab_classdef(Absyn.ENUMERATION(Absyn.ENUMLITERALS(lst),_)) 
	  => ENUMERATION(lst')

  axiom	elab_classdef(Absyn.ENUMERATION(Absyn.ENUM_COLON,_)) => ENUMERATION([])

  axiom	elab_classdef(Absyn.OVERLOAD(lst,_)) => OVERLOAD(lst)

  rule	elab_classdef_elements parts => els &
	elab_classdef_equations parts => eqs &
	elab_classdef_initialequations parts => initeqs &
	elab_classdef_algorithms parts => als &
	elab_classdef_initialalgorithms parts => initals &
	build_mod(SOME(Absyn.CLASSMOD(cmod, NONE)), false,Absyn.NON_EACH) => mod
	-------------------------------------
	elab_classdef (Absyn.CLASS_EXTENDS(name,cmod,cmt,parts)) 
          => CLASS_EXTENDS(name,mod,els,eqs,initeqs,als,initals)

  axiom	elab_classdef(Absyn.PDER(path,vars)) => PDER(path,vars)
end

(** relation: elab_enumlist
 **
 ** Convert an EnumLiteral list to an Ident list. Comments are lost.
 **)
relation elab_enumlist:(Absyn.EnumLiteral list) => Ident list =

  axiom	elab_enumlist([]) => []
	
  rule	elab_enumlist(rest) => res
	-----------------------------------------
	elab_enumlist(Absyn.ENUMLITERAL(id,_)::rest) => id::res
end

(** relation: elab_classdef_elements
 **
 ** Convert an Absyn.ClassPart list to an Element list.
 **)
relation elab_classdef_elements: Absyn.ClassPart list => Element list =

  axiom	elab_classdef_elements [] => []

  rule	elab_classdef_elements rest => els &
	elab_eitemlist (es, false) => es' &
	list_append (es',els) => els'
	------------------------------
	elab_classdef_elements (Absyn.PUBLIC(es)::rest) => els'

  rule	elab_classdef_elements rest => els &
	elab_eitemlist (es, true) => es' &
	list_append (es',els) => els'
	------------------------------
	elab_classdef_elements (Absyn.PROTECTED(es)::rest) => els'


(** ignore all other than PUBLIC and PROTECTED, i.e. elements **)

  rule	elab_classdef_elements rest => els
	----------------------------------
	elab_classdef_elements _::rest => els

end

(** relation: elab_classdef_equations
 **
 ** Convert an Absyn.ClassPart list to an Equation list.
 **)
relation elab_classdef_equations: Absyn.ClassPart list => Equation list = 

  axiom	elab_classdef_equations [] => []

  rule	elab_classdef_equations rest => eqs &
	elab_equations(eql) => eql' &
	list_append (eqs, eql') => eqs'
	------------------------------
	elab_classdef_equations (Absyn.EQUATIONS(eql)::rest) => eqs'

(** ignore everthing other than equations **)
  rule	elab_classdef_equations rest => eqs
	-----------------------------------
	elab_classdef_equations _::rest => eqs

end

(** relation: elab_classdef_initialequations
 **
 ** Convert an Absyn.ClassPart list to an initial Equation list.
 **)
relation elab_classdef_initialequations: Absyn.ClassPart list => Equation list = 

  axiom	elab_classdef_initialequations [] => []

  rule	elab_classdef_initialequations rest => eqs &
	elab_equations(eql) => eql' &
	list_append (eqs, eql') => eqs'
	------------------------------
	elab_classdef_initialequations (Absyn.INITIALEQUATIONS(eql)::rest) => eqs'

(** ignore everthing other than equations **)
  rule	elab_classdef_initialequations rest => eqs
	-----------------------------------
	elab_classdef_initialequations _::rest => eqs

end


(** relation: elab_classdef_algorithms
 **
 ** Convert an Absyn.ClassPart list to an Algorithm list.
 **)
relation elab_classdef_algorithms: Absyn.ClassPart list => Algorithm list =

  axiom	elab_classdef_algorithms [] => []

  rule	elab_classdef_algorithms rest => als &
	elab_classdef_algorithmitems al => al' &
	let als' = ALGORITHM(al',NONE)::als
	-----------------------------
	elab_classdef_algorithms (Absyn.ALGORITHMS(al)::rest) => als'


(** ignore everthing other than algorithms **)

  rule	elab_classdef_algorithms rest => als
	------------------------------------
	elab_classdef_algorithms _::rest => als

end

(** relation: elab_classdef_initialalgorithms
 **
 ** Convert an Absyn.ClassPart list to an initial Algorithm list.
 **)
relation elab_classdef_initialalgorithms: Absyn.ClassPart list 
	  => Algorithm list =

  axiom	elab_classdef_initialalgorithms [] => []

  rule	elab_classdef_initialalgorithms rest => als &
	elab_classdef_algorithmitems al => al' &
	let als' = ALGORITHM(al',NONE)::als
	-----------------------------
	elab_classdef_initialalgorithms (Absyn.INITIALALGORITHMS(al)::rest) => als'


(** ignore everthing other than algorithms **)

  rule	elab_classdef_initialalgorithms rest => als
	------------------------------------
	elab_classdef_initialalgorithms _::rest => als

end

(** relation: elab_classdef_algorithmitems
 **
 ** Convert an Absyn.AlgorithmItem list to an Absyn.Algorithm list.
 ** Comments are lost.
 **)
relation elab_classdef_algorithmitems: Absyn.AlgorithmItem list 
	  => Absyn.Algorithm list =

  axiom	elab_classdef_algorithmitems [] => []
	
  rule	elab_classdef_algorithmitems(rest) => res
	-----------------------------------------
	elab_classdef_algorithmitems (Absyn.ALGORITHMITEM(alg,_)::rest) => alg::res

  rule	elab_classdef_algorithmitems(rest) => res
	-----------------------------------------
	elab_classdef_algorithmitems (_::rest) => res
end

(** relation: elab_classdef_externaldecls
 **
 ** Converts an Absyn.ClassPart list to an Absyn.ExternalDecl option
 ** The list should only contain one external declaration, so pick the first 
 ** one.
 **)
relation elab_classdef_externaldecls: (Absyn.ClassPart list) => Absyn.ExternalDecl option =

  axiom	elab_classdef_externaldecls(Absyn.EXTERNAL(decl,_)::_) => SOME(decl)

  rule	elab_classdef_externaldecls(rest) => res
	---------------------------------------
	elab_classdef_externaldecls(_::rest) => res

  axiom	elab_classdef_externaldecls([]) => NONE
end

(** relation: elab_eitemlist
 **
 ** This relation converts a list of `Absyn.ElementItem' to a list of
 ** `Element'.  The boolean argument flags whether the elements are
 ** pretected. Annotations are not elaborated, i.e. they are removed when
 ** converting to SCode.
 **)
relation elab_eitemlist : (Absyn.ElementItem list, bool) => Element list =

  axiom	elab_eitemlist([],_) => []

  rule	elab_eitemlist(es,prot) => l
	----------------------------
	elab_eitemlist(Absyn.ANNOTATIONITEM(_)::es,prot) => l

  rule	elab_element(e, prot) => e' &
	elab_eitemlist(es, prot) => es' &
	list_append(e',es') => l
	---------------------
	elab_eitemlist(Absyn.ELEMENTITEM(e)::es, prot) => l
end

(** relation: elab_element
 **
 ** This relation converts an `Absyn.Element' to a list of
 ** `Element's.  The original element may declare several components
 ** at once, and those are separated to several declarations in the
 ** result.
 **)
relation elab_element : (Absyn.Element, bool) => Element list =

  rule	elab_elementspec(f,repl,prot,s) => es
	--------------------------------
	elab_element(Absyn.ELEMENT(f,repl,_,_,s,Absyn.INFO(_,line,_),_), prot) => es

end

(** relation: elab_elementspec
 **
 ** This relation turns an `Absyn.ElementSpec' to a list of
 ** `Element's.  The boolean arguments say if the element is final and
 ** protected, respectively.
 **)
relation elab_elementspec: (bool,Absyn.RedeclareKeywords option,bool,Absyn.ElementSpec) => Element list =

  rule	elab_classdef(de) => de' &
	elab_restriction(cl,re) => re'
	-----------------------
	elab_elementspec(final,repl,prot,
                         Absyn.CLASSDEF(rp,
                                        cl as Absyn.CLASS(n,pa,fi,e,re,de,file_info)))
	  => [CLASSDEF(n,final,rp,CLASS(n,pa,e,re',de'),NONE)]

  rule	build_mod(SOME(Absyn.CLASSMOD(args, NONE)), false,Absyn.NON_EACH) => mod &
	Absyn.path_string(n) => ns
	--------------------------
	elab_elementspec(final,repl,prot,Absyn.EXTENDS(n,args))
	  => [EXTENDS(n,mod)]

  axiom	elab_elementspec(_,_,_,Absyn.COMPONENTS(_,_,[])) => []

  rule	elab_elementspec(final,repl,prot,Absyn.COMPONENTS(attr,t,xs)) => xs' &
	build_mod(m,false,Absyn.NON_EACH) => mod &

	(* PR. This adds the arraydimension that may be specified together with
	 the type of the component.  *)
	elab_variability(pa) => pa' &
	list_append(d,ad) => tot_dim &
	elab_redeclarekeywords(repl) => repl'
	--------------------------------------------------
	elab_elementspec(final,repl,prot,
			 Absyn.COMPONENTS(attr as Absyn.ATTR(fl,pa,di,ad),t,
					  Absyn.COMPONENTITEM(Absyn.COMPONENT(n,d,m),_,comment)::xs))
	  => COMPONENT(n,final,repl',prot,ATTR(tot_dim,fl,RW,pa',di),t,mod,NONE,comment)::xs'

  axiom	elab_elementspec(final,repl,prot,Absyn.IMPORT(imp,_)) => [IMPORT(imp)]

end

(** relation: elab_redeclarekeywords
 ** author: PA
 **
 ** For now, translate to bool, replaceable.
 **)
relation elab_redeclarekeywords: Absyn.RedeclareKeywords option => bool =

  axiom	elab_redeclarekeywords(SOME(Absyn.REPLACEABLE)) => true 
  axiom	elab_redeclarekeywords(SOME(Absyn.REDECLARE_REPLACEABLE)) => true 
  axiom	elab_redeclarekeywords(_) => false
end

(** relation: elab_variability
 **
 ** Converts an Absyn.Variability to Variability.
 **)
relation elab_variability: Absyn.Variability => Variability =

  axiom elab_variability(Absyn.VAR) => VAR
  axiom elab_variability(Absyn.DISCRETE) => DISCRETE
  axiom elab_variability(Absyn.PARAM) => PARAM
  axiom elab_variability(Absyn.CONST) => CONST

end

(** relation: elab_equations
 **
 ** This relation transforms a list of `Absyn.Equation's to a list of
 ** `Equations's, by applying the `elab_equation' relation to each
 ** equation.
 **)
relation elab_equations : Absyn.EquationItem list => Equation list =

  axiom	elab_equations [] => []

  rule	elab_equation e => e' &
	elab_equations es => es'
	------------------------
	elab_equations Absyn.EQUATIONITEM(e,_)::es => EQUATION(e',NONE)::es'

  rule	elab_equations es => es'
	------------------------
	elab_equations Absyn.EQUATIONITEMANN(_)::es => es'

end

(** relation: elab_e_equations
 **
 ** Helper relation to elab_equations
 **)
relation elab_e_equations : Absyn.EquationItem list => EEquation list =

  axiom	elab_e_equations [] => []

  rule	elab_equation e => e' &
	elab_e_equations es => es'
	------------------------
	elab_e_equations Absyn.EQUATIONITEM(e,_)::es => e'::es'

  rule	elab_e_equations es => es'
	------------------------
	elab_e_equations Absyn.EQUATIONITEMANN(_)::es => es'

end

(** relation: equation_str
 ** author: PA
 **
 ** Return the equation as a string.
 **)
relation equation_str : EEquation => string =

  rule	Dump.print_exp_str(exp) => s1 &
	Util.list_map(tb,equation_str) => tb_strs &
	Util.list_map(fb,equation_str) => fb_strs &
	Util.string_delimit_list(tb_strs,"\n") => s2 &
	Util.string_delimit_list(fb_strs,"\n") => s3 &
	Util.string_append_list(["if ",s1," then ", s2,"else ",s3, "end if;"]) => res
	------------------------
	equation_str(EQ_IF(exp, tb,fb)) => res

  rule	Dump.print_exp_str(e1) => s1 &
	Dump.print_exp_str(e2) => s2 &
	Util.string_append_list([s1, " = ",s2,";"]) => res
	----------------------
	equation_str(EQ_EQUALS(e1,e2)) => res

  rule	Dump.print_component_ref_str(cr1) => s1 &
	Dump.print_component_ref_str(cr2) => s2 &
	Util.string_append_list(["connect(",s1,", ", s2,");"]) => res
	----------------------
	equation_str(EQ_CONNECT(cr1,cr2)) => res

  rule	Dump.print_exp_str(exp) => s1 &
	Util.list_map(eqn_lst,equation_str) => str_lst &
	Util.string_delimit_list(str_lst,"\n") => s2 &
	Util.string_append_list(["for ",id," in ",s1, " loop\n", s2, "\nend for;"]) => res
	----------------------
	equation_str(EQ_FOR(id,exp,eqn_lst)) => res

  rule	----------------------
	equation_str(EQ_WHEN(_,_,_)) => "EQ_WHEN(... not impl ...)"

  rule	Dump.print_exp_str(e1) => s1 &
	Dump.print_exp_str(e2) => s2 &
	Util.string_append_list(["assert(",s1,", ",s2,");"]) => res
	----------------------
	equation_str(EQ_ASSERT(e1,e2)) => res

  rule	Dump.print_component_ref_str(cr) => s1 &
	Dump.print_exp_str(e1) => s2 &
	Util.string_append_list(["reinit(",s1,", ",s2,");"]) => res
	----------------------
	equation_str(EQ_REINIT(cr,e1)) => res
end


(** relation: elab_equation
 **
 ** The translation of equations are straightforward, with one
 ** exception.  `If' clauses are translated so that the SCode only
 ** contains simple `if'-`else' constructs, and no `elseif'.
 **)
(* PR Arrays seem to keep their Absyn.rml structure. *)
relation elab_equation : Absyn.Equation => EEquation =

  rule	elab_e_equations tb => tb' &
	elab_e_equations fb => fb'
	------------------------
	elab_equation Absyn.EQ_IF(e,tb,[],fb) => EQ_IF(e,tb',fb')

  rule	elab_equation Absyn.EQ_IF(e,tb,[],[Absyn.EQUATIONITEM(Absyn.EQ_IF(ee,ei,eis,fb),NONE)]) => eq
	------------------------------------------------------------------
	elab_equation Absyn.EQ_IF(e,tb,(ee,ei)::eis,fb) => eq


  rule	elab_e_equations tb => tb' &
	elab_equation Absyn.EQ_WHEN_E(econd,eb,elsewhen) => EQ_WHEN(econd',eb',elsewhen')
	--------------------------
	elab_equation Absyn.EQ_WHEN_E(cond,tb,(econd,eb)::elsewhen) => 
	EQ_WHEN(cond,tb',(econd',eb')::elsewhen')

  rule	elab_e_equations tb => tb'
	--------------------------
	elab_equation Absyn.EQ_WHEN_E(cond,tb,[]) => EQ_WHEN(cond,tb',[])

  axiom	elab_equation Absyn.EQ_EQUALS(e1,e2) => EQ_EQUALS(e1,e2)

  axiom	elab_equation Absyn.EQ_CONNECT(c1,c2) => EQ_CONNECT(c1,c2)

  rule	elab_e_equations l => l'
	----------------------
	elab_equation Absyn.EQ_FOR(i,e,l) => EQ_FOR(i,e,l')

  axiom	elab_equation Absyn.EQ_NORETCALL("assert",Absyn.FUNCTIONARGS([e1,e2],[]))
	  => EQ_ASSERT(e1,e2) 


  axiom	elab_equation Absyn.EQ_NORETCALL("reinit",Absyn.FUNCTIONARGS([Absyn.CREF(cr),e2],[]))
          => EQ_REINIT(cr,e2) 
end

(** - Modification management *)

(** relation: build_mod
 **
 ** Builds an `SCode.Mod' from an `Absyn.Modification'.  The boolean
 ** argument flags whether the modification is `final'.
 **)
relation build_mod : (Absyn.Modification option, 
		      bool, (* final *)
		      Absyn.Each) => Mod =

  axiom build_mod(NONE, _,_) => NOMOD

  axiom	build_mod(SOME(Absyn.CLASSMOD([], e as SOME(_))), final,each)
	  => MOD(final,each,[],e)

  rule	build_args(l) => subs
	---------------------------------
	build_mod(SOME(Absyn.CLASSMOD(l,e)),final,each) => MOD(final,each,subs,e)

end


(** relation: strip_submod
 ** author: PA
 **
 ** Removes all submodifiers from the Mod.
 **)
relation strip_submod: Mod => Mod =

  axiom	strip_submod(MOD(f,each,subs,e)) => MOD(f,each,[],e)

  axiom	strip_submod(m) => m

end


(** relation: build_args
 ** author: LS
 **
 ** Adding elaborate for the elementspec in the redeclaration
 **)
relation build_args : (Absyn.ElementArg list) => SubMod list =

  axiom build_args [] => []

  rule	build_args xs => subs &
	build_mod(mod,final,each) => mod' &
	build_sub(cref,mod') => sub
	----------------------
	build_args((Absyn.MODIFICATION(final,each,cref,mod,cmt)::xs)) => (sub::subs)

  rule	build_args xs => subs &
	Absyn.element_spec_name spec => n &
	(** LS:: don't know what to use for "protected", so using false **)
	(** LS:: don't know what to use for "replaceable", so using false **)
	elab_elementspec(final,NONE,false,spec) => elist
	---------------------------
	build_args((Absyn.REDECLARATION(final,keywords,each,spec,constropt)::xs))
	  => (NAMEMOD(n,REDECL(final,elist))::subs)

end

(** relation: build_sub
 **
 ** This relation converts a `ComponentRef' into a number of nested
 ** `SUBMOD's.
 **)
relation build_sub : (Absyn.ComponentRef,Mod) => SubMod =

	(* First some rules to prevent bad modifications *)

  rule	Dump.print_component_ref_str c  => c_str &
	print_mod_str(mod) => mod_str &
	Error.add_message(Error.ILLEGAL_MODIFICATION,[mod_str,c_str])
	---------------------------------------
	build_sub(c as Absyn.CREF_IDENT(_,_::_),mod as MOD(_,_,_::_,_)) => fail

  rule	Dump.print_component_ref_str c  => c_str &
	print_mod_str(mod) => mod_str &
	Error.add_message(Error.ILLEGAL_MODIFICATION,[mod_str,c_str])
	---------------------------------------
	build_sub(c as Absyn.CREF_QUAL(_,_::_,_),mod as MOD(_,_,_::_,_)) => fail
	
	(* Then the normal rules *)
	
  rule	build_sub_sub (ss,mod) => mod'
	------------------------------
	build_sub(Absyn.CREF_IDENT(i,ss),mod) => NAMEMOD(i,mod')

  rule	build_sub(path,mod) => sub &
	let mod = MOD(false,Absyn.NON_EACH,[sub],NONE) &
	build_sub_sub(ss,mod) => mod'
	--------------------------
	build_sub(Absyn.CREF_QUAL(i,ss,path),mod) => NAMEMOD(i,mod')

end

(** relation: build_sub_sub
 **
 ** This relation is used to handle the case when a array component is
 ** indexed in the modification, so that only one or a limitied number
 ** of array elements should be modified.
 **)
relation build_sub_sub : (Subscript list, Mod) => Mod =

  axiom	build_sub_sub ([], m) => m
  axiom	build_sub_sub (l, m) => MOD(false,Absyn.NON_EACH,[IDXMOD(l,m)],NONE)

end

(** relation: get_element_named
 ** 
 ** Return the Element with the name given as first argument from
 ** the Class.
 **)
relation get_element_named: (Ident, Class) => Element =
	
  rule	get_element_named_from_elts(id,elts) => elt
	----------------------------------------
	get_element_named(id,CLASS(_,_,_,_,PARTS(elts,_,_,_,_,_))) => elt
end

(** relation: get_element_named_from_elts
 **
 ** Helper relation to get_element_named.
 **)
relation get_element_named_from_elts: (Ident, Element list) => Element =

  rule	not id1 = id2 &
	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,COMPONENT(id1,_,_,_,_,_,_,_,_)::xs) => elt
	
  rule	not id1 = id2 &
	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,CLASSDEF(id1,_,_,_,_)::xs) => elt

  rule	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,EXTENDS(_,_)::xs) => elt

  rule	id1 = id2
	--------------------
	get_element_named_from_elts(id2,(comp as COMPONENT(id1,_,_,_,_,_,_,_,_))::_) => comp

  rule	id1 = id2
	--------------------
	get_element_named_from_elts(id2,(cdef as CLASSDEF(id1,_,_,_,_))::_) => cdef

end

(** relation: print_mod
 **
 ** This relation prints a modification.  The code is excluded from
 ** the report for brevity.
 **)
relation print_mod: Mod => () =

  rule	print_mod_str m => s &
	Print.print_buf s 
	--------------
	print_mod m => ()
end 

(** relation: print_mod_str
 **
 ** Prints Mod to a string.
 **)
relation print_mod_str : Mod => string =

  axiom	print_mod_str(NOMOD) => "NOMOD"

  rule	Print.print_buf "redeclare(" & 
	Util.if(b,"final","") => final_str &
	Util.list_map(elist,print_element_str) => strs &
	Util.string_delimit_list(strs,",") => str &
	Util.string_append_list(["redeclare(",final_str,str,")"]) => res
	------------------------------
	print_mod_str REDECL(b,elist) => res
	
  rule	Util.if(final,"final","") => final_str &
	Dump.unparse_each_str each => each_str &
	print_subs1_str subs => subs_str &
	print_eqmod_str ass => ass_str &
	Util.string_append_list([final_str,each_str,subs_str,ass_str]) => res
	------------
	print_mod_str MOD(final,each, subs, ass) => res

  rule	Print.print_buf "#-- print_mod_str failed\n"
	------------------------
	print_mod_str _ => fail

end

(** relation: restr_string
 **
 ** Prints Restriction to a string.
 **)
relation restr_string : Restriction => string =

  axiom restr_string R_CLASS			=> "CLASS"
  axiom	restr_string R_MODEL			=> "MODEL"
  axiom	restr_string R_RECORD			=> "RECORD"
  axiom restr_string R_BLOCK			=> "BLOCK"
  axiom restr_string R_CONNECTOR		=> "CONNECTOR"
  axiom restr_string R_TYPE			=> "TYPE"
  axiom restr_string R_PACKAGE			=> "PACKAGE"
  axiom restr_string R_FUNCTION			=> "FUNCTION"
  axiom	restr_string R_EXT_FUNCTION		=> "EXTFUNCTION"
  axiom restr_string R_PREDEFINED_INT		=> "PREDEFINED_INT"
  axiom restr_string R_PREDEFINED_REAL		=> "PREDEFINED_REAL"
  axiom restr_string R_PREDEFINED_STRING	=> "PREDEFINED_STRING"
  axiom restr_string R_PREDEFINED_BOOL		=> "PREDEFINED_BOOL"
end

(** relation: print_restr
 **
 ** Prints Restriction to the Print buffer.
 **)
relation print_restr : Restriction => () =

  rule	restr_string restr => str &
	Print.print_buf str
	----------------
	print_restr restr
end

(** relation: print_final
 **
 ** Prints "final" to the Print buffer.
 **)
relation print_final : bool => () =

  axiom print_final false

  rule	Print.print_buf " final "
	--------------
       print_final true

end

(** relation: print_subs_str
 ** 
 ** Prints a SubMod list to a string.
 **)
relation print_subs_str : SubMod list => string =

  axiom print_subs_str [] => ""

  rule	Print.print_buf n & print_mod_str mod => s &
	string_append(n,s) => res
	-----------------------
	print_subs_str [NAMEMOD(n,mod)] => res

  rule	print_mod_str mod => mod_str & 
	print_subs_str subs => str &
	Util.string_append_list(["n",mod_str,", ",str]) => res
	---------------
	print_subs_str NAMEMOD(n,mod)::subs => res

  rule	Dump.print_subscripts_str ss => str  & 
	print_mod_str mod => mod_str &
	string_append(str,mod_str) => res 
	------------------
	print_subs_str [IDXMOD(ss,mod)] => res

  rule	Dump.print_subscripts_str ss => str & 
	print_mod_str mod => mod_str &
	print_subs_str subs => sub_str &
	Util.string_append_list([str,mod_str,", ",sub_str]) => res
	--------------
	print_subs_str IDXMOD(ss,mod)::subs => res

end

(** relation: print_subs1_str
 **
 ** Helper relation to print_subs_str.
 **)
relation print_subs1_str : SubMod list => string =

  axiom print_subs1_str [] => ""

  rule	Print.print_buf "(" &
	print_subs_str l => s &
	Print.print_buf ")" &
	Util.string_append_list(["(",s,")"]) => res
	-----------
	print_subs1_str l => res

end

(** relation: print_eqmod_str
 **
 ** Helper relation to print_mod_str.
 **)
relation print_eqmod_str : Absyn.Exp option => string =

  axiom print_eqmod_str NONE => ""

  rule	Dump.print_exp_str e => str &
	string_append(" = ",str) => res
	-----------------------------
	print_eqmod_str SOME(e) => res

end
	
(** relation: print_element_list
 **
 ** Print Element list to Print buffer.
 **)
relation print_element_list : Element list => () =

  axiom	print_element_list([]) => ()

  rule	print_element x &
	print_element_list(xs) => ()
	----------------------
	print_element_list(x::xs) => ()
end

(** relation: print_element
 **
 ** Print Element to Print buffer.
 **)
relation print_element : Element => () =

  rule	print_element_str elt => str &
	Print.print_buf str
	----------------
	print_element(elt) => ()
end
	
(** relation: print_element_str
 **
 ** Print Element to a string.
 **)
relation print_element_str : Element => string =

  rule	Absyn.path_string path => str &
	Util.string_append_list(["EXTENDS(", str, ")"]) => res
	----------------------------------------------------
	print_element_str EXTENDS(path,mod) => res

  rule	Absyn.path_string path => str &
	Util.string_append_list(["CLASSDEF(",n,", from basclass: ",str,")"]) 
	  => res
	---------------------------------------
	print_element_str CLASSDEF(n,final,repl,cl,SOME(path)) => res

  rule	print_mod_str mod => mod_str & 
	Absyn.path_string typath => s &
	variability_string var => vs &
	Absyn.path_string path => str & 
	Util.string_append_list(["COMPONENT(",n,mod_str,s,
				 "var :", vs, ", from baseclass: ",
				 str,")"]) => res
	----------------------------------------
	print_element_str COMPONENT(n,final,repl,prot,ATTR(_,_,_,var,_),typath,mod,SOME(path),comment) => res

  rule	print_class_str(cl) => str &
	Util.string_append_list(["CLASSDEF(",n,",...,",str,")"]) => res
	---------------------------------------
	print_element_str CLASSDEF(n,final,repl,cl,NONE) => res

  rule	print_mod_str mod => mod_str & 
	Absyn.path_string typath => s &
	Util.string_append_list(["COMPONENT(",n, " mod:",mod_str, ", tp: ",
				 s, ")"])=> res 
	----------------------------------------
	print_element_str COMPONENT(n,final,repl,prot,attr,typath,mod,NONE,comment) 
	  => res

  axiom	print_element_str(IMPORT(_)) => "IMPORT(_)"
end	

relation print_class_str: Class => string =

  rule	print_classdef_str(def) => s &
	Util.string_append_list(["CLASS(",id,",_,_,_,",s,")"]) => res
	----------------------
	print_class_str(CLASS(id,p,en,rest,def)) => res
end

relation print_classdef_str: (ClassDef) => string =

  rule	Util.list_map(elts,print_element_str) => elts_str &
	Util.string_delimit_list(elts_str,",\n") => s1 &
	Util.string_append_list(["PARTS(",s1,",_,_,_,_,_)"]) => res
	-----------------
	print_classdef_str(PARTS(elts,eqns,ieqns,alg,ial,ext)) => res

  rule	Absyn.path_string(path) => s1 & 
	Dump.print_arraydim_str(ad) => s2 &
	print_mod_str(mod) => s3 &
	Util.string_append_list(["DERIVED(",s1,",",s2,",",s3,")"]) => res
	-----------------
	print_classdef_str(DERIVED(path,SOME(ad),mod)) => res

  rule	Absyn.path_string(path) => s1 & 
	print_mod_str(mod) => s3 &
	Util.string_append_list(["DERIVED(",s1,",NONE,",s3,")"]) => res
	-----------------
	print_classdef_str(DERIVED(path,NONE,mod)) => res
end


(** relation: variability_string
 **
 ** Print Variability to a string.
 **)
relation variability_string: Variability => string =
  axiom	variability_string(VAR) => "VAR"
  axiom	variability_string(DISCRETE) => "DISCRETE"
  axiom	variability_string(PARAM) => "PARAM" 
  axiom	variability_string(STRUCTPARAM) => "STRUCTPARAM"
  axiom	variability_string(CONST) => "CONST" 
end

(** relation: is_parameter_or_const
 **
 ** Returns true if Variability indicates a parameter or constant.
 **)
relation is_parameter_or_const: Variability => bool =

  axiom	is_parameter_or_const (VAR) => false

  axiom	is_parameter_or_const (DISCRETE) => false

  axiom	is_parameter_or_const (PARAM) => true

  axiom	is_parameter_or_const (STRUCPARAM) => true

  axiom	is_parameter_or_const (CONST) => true

end

(** relation: count_parts
 **
 ** Counts the number of ClassParts of a Class.
 **)
relation count_parts: Class => int =

  rule	list_length(elts) => res
	--------------------
	count_parts CLASS(_,_,_,_,PARTS(elts,_,_,_,_,_)) => res

  axiom	count_parts _ => 0

end

(** relation: component_names
 **
 ** Return a string list of all component names of a class.
 **)
relation component_names: Class => string list =

  rule	component_names_from_elts(elts) => res
	--------------------------
	component_names(CLASS(_,_,_,_,PARTS(elts,_,_,_,_,_))) => res
  axiom	component_names(_) => []
end

(** relation: component_names_from_elts
 **
 ** Helper relation to component_names.
 **)
relation component_names_from_elts:(Element list) => string list =

  axiom	component_names_from_elts([]) => []

  rule	component_names_from_elts(rest) => res 
	--------------------------------------
	component_names_from_elts(COMPONENT(id,_,_,_,_,_,_,_,_)::rest) => id::res
end

(** relation: is_function
 **
 ** Return true if Class is a function.
 **)
relation is_function : Class => bool =

  axiom	is_function CLASS(n,_,_,R_FUNCTION,def) => true
  axiom	is_function CLASS(n,_,_,R_EXT_FUNCTION,def) => true
  axiom	is_function _ => false

end

(** relation: class_name
 **
 ** Returns the class name of a Class.
 **)
relation class_name : Class => string =

  axiom	class_name CLASS(n,_,_,_,_) => n
  axiom	class_name _ => "Not a class"

end

(** relation: class_set_partial
 ** author: PA
 **
 ** Sets the partial attribute of a Class
 **)
relation class_set_partial: (Class,bool) => Class =

  axiom	class_set_partial(CLASS(id,_,enc,restr,def),partial)
	  => CLASS(id,partial,enc,restr,def)
end
