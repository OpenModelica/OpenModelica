// This file defines templates for transforming an internal representation of a
// Modelica program to C code.
//
// When compiling a model the following files will be created:
//
// Model.cpp
// Model_functions.cpp
// Model_init.txt
// Model.makefile
//
// The following template functions generate the content of these files:
//
// cppFile
// functionsFile
// initFile
// makefile

spackage SimCodeC

typeview "SimCodeTV.mo"

// Root template for simulation "target"
translateModel(SimCode simCode) ::=
  case SIMCODE(modelInfo = MODELINFO) then
    # cppFileContent = cppFile(simCode)
    # textFile(cppFileContent, '<modelInfo.name>.cpp')
    # functionsFileContent = functionsCpp('<functions>')
    # textFile(functionsFileContent, '<modelInfo.name>_functions.cpp')
    //initFile(...)
    //makefile(...)
    () // empty result

// Root template for function library "target"
//translateFunction(...) ::=
//    ...

cppFile(SimCode simCode) ::=
case SIMCODE(modelInfo = MODELINFO) then
<<
// Simulation code for <modelInfo.name> generated by the OpenModelica Compiler.

#include "modelica.h"
#include "assert.h"
#include "string.h"
#include "simulation_runtime.h"

#if defined(_MSC_VER) && !defined(_SIMULATION_RUNTIME_H)
  #define DLLExport   __declspec( dllexport )
#else 
  #define DLLExport /* nothing */
#endif 

#include "<modelInfo.name>_functions.cpp"

<globalData(modelInfo)>

<functionGetName(modelInfo)>

<functionDivisionError()>

<functionSetLocalData()>

<functionInitializeDataStruc()>

<functionDeInitializeDataStruc()>

<functionDaeOutput(nonStateContEquations, removedEquations)>

<functionDaeOutput2(nonStateDiscEquations, removedEquations)>

<functionInput(modelInfo)>

<functionOutput(modelInfo)>

<functionDaeRes()>

<functionZeroCrossing(zeroCrossings)>

<functionHandleZeroCrossing(zeroCrossingsNeedSave)>

<functionUpdateDependents(allEquations, helpVarInfo)>

<functionOnlyZeroCrossing(zeroCrossings)>

<functionWhen(whenClauses)>

<functionOde(stateContEquations)>

<functionInitial(initialEquations)>

<functionInitialResidual(residualEquations)>

<functionBoundParameters(parameterEquations)>

<functionCheckForDiscreteVarChanges(helpVarInfo, discreteModelVars)>
>>

globalData(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
#define NHELP <varInfo.numHelpVars>
#define NG <varInfo.numZeroCrossings>
#define NX <varInfo.numStateVars>
#define NY <varInfo.numAlgVars>
#define NP <varInfo.numParams>
#define NO <varInfo.numOutVars>
#define NI <varInfo.numInVars>
#define NR <varInfo.numResiduals>
#define NEXT <varInfo.numExternalObjects>
#define MAXORD 5
#define NYSTR <varInfo.numStringAlgVars>
#define NPSTR <varInfo.numStringParamVars>

static DATA* localData = 0;
#define time localData-\>timeValue
extern "C" { /* adrpo: this is needed for Visual C++ compilation to work! */
  char *model_name="<name>";
  char *model_dir="<directory>";
}

<utilStaticStringArray("state_names", vars.stateVars)>
<utilStaticStringArray("derivative_names", vars.derivativeVars)>
<utilStaticStringArray("algvars_names", vars.algVars)>
<utilStaticStringArray("input_names", vars.inputVars)>
<utilStaticStringArray("output_names", vars.outputVars)>
<utilStaticStringArray("param_names", vars.paramVars)>
<utilStaticStringArray("string_alg_names", vars.stringAlgVars)>
<utilStaticStringArray("string_param_names", vars.stringParamVars)>

<utilStaticStringArrayComment("state_comments", vars.stateVars)>
<utilStaticStringArrayComment("derivative_comments", vars.derivativeVars)>
<utilStaticStringArrayComment("algvars_comments", vars.algVars)>
<utilStaticStringArrayComment("input_comments", vars.inputVars)>
<utilStaticStringArrayComment("output_comments", vars.outputVars)>
<utilStaticStringArrayComment("param_comments", vars.paramVars)>
<utilStaticStringArrayComment("string_alg_comments", vars.stringAlgVars)>
<utilStaticStringArrayComment("string_param_comments", vars.stringParamVars)>

<vars.stateVars of var as SIMVAR: define(it, "states") "\n">
<vars.derivativeVars of var as SIMVAR: define(it, "statesDerivatives") "\n">
<vars.algVars of var as SIMVAR: define(it, "algebraics") "\n">
<vars.paramVars of var as SIMVAR: define(it, "parameters") "\n">
<vars.extObjVars of var as SIMVAR: define(it, "extObjs") "\n">

static char init_fixed[NX+NX+NY+NP] = {
  <[(vars.stateVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.derivativeVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of var as SIMVAR:
      '<boolToInt(var.isFixed)> /* <cref(origName)> */' ",\n")] ",\n">
};

char var_attr[NX+NY+NP] = {
  <[(vars.stateVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.algVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n"),
    (vars.paramVars of var as SIMVAR:
      '<typeAttrInt(type_)>+<discreteAttrInt(isDiscrete)> /* <cref(origName)> */' ",\n")] ",\n">
};
>>

functionGetName(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
char* getName(double* ptr)
{
  <vars.stateVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return state_names[<var.index>];' "\n">
  <vars.derivativeVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return derivative_names[<var.index>];' "\n">
  <vars.algVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return algvars_names[<var.index>];' "\n">
  <vars.paramVars of var as SIMVAR:
    'if (&<cref(name)> == ptr) return param_names[<var.index>];' "\n">
  return "";
}
>>

define(SimVar, String arrayName) ::=
case SIMVAR(arrayCref=SOME(c)) then
  <<
  #define <cref(c)> localData-\><arrayName>[<index>]
  #define <cref(name)> localData-\><arrayName>[<index>]
  >>
case SIMVAR then
  <<
  #define <cref(name)> localData-\><arrayName>[<index>]
  >>

functionDivisionError() ::=
<<
#define DIVISION(a,b,c) ((b != 0) ? a / b : a / division_error(b,c))

int encounteredDivisionByZero = 0;

double division_error(double b, const char* division_str)
{
  if(!encounteredDivisionByZero) {
    fprintf(stderr, "ERROR: Division by zero in partial equation: %s.\n",division_str);
    encounteredDivisionByZero = 1;
  }
  return b;
}
>>

functionSetLocalData() ::=
<<
void setLocalData(DATA* data)
{
  localData = data;
}
>>

functionInitializeDataStruc() ::=
<<
DATA* initializeDataStruc(DATA_FLAGS flags)
{
  DATA* returnData = (DATA*)malloc(sizeof(DATA));

  if(!returnData) //error check
    return 0;

  memset(returnData,0,sizeof(DATA));
  returnData-\>nStates = NX;
  returnData-\>nAlgebraic = NY;
  returnData-\>nParameters = NP;
  returnData-\>nInputVars = NI;
  returnData-\>nOutputVars = NO;
  returnData-\>nZeroCrossing = NG;
  returnData-\>nInitialResiduals = NR;
  returnData-\>nHelpVars = NHELP;
  returnData-\>stringVariables.nParameters = NPSTR;
  returnData-\>stringVariables.nAlgebraic = NYSTR;

  if(flags & STATES && returnData-\>nStates) {
    returnData-\>states = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStates2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>states&&returnData-\>oldStates&&returnData-\>oldStates2);
    memset(returnData-\>states,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStates2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>states = 0;
    returnData-\>oldStates = 0;
    returnData-\>oldStates2 = 0;
  }

  if(flags & STATESDERIVATIVES && returnData-\>nStates) {
    returnData-\>statesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives = (double*) malloc(sizeof(double)*returnData-\>nStates);
    returnData-\>oldStatesDerivatives2 = (double*) malloc(sizeof(double)*returnData-\>nStates);
    assert(returnData-\>statesDerivatives&&returnData-\>oldStatesDerivatives&&returnData-\>oldStatesDerivatives2);
    memset(returnData-\>statesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives,0,sizeof(double)*returnData-\>nStates);
    memset(returnData-\>oldStatesDerivatives2,0,sizeof(double)*returnData-\>nStates);
  } else {
    returnData-\>statesDerivatives = 0;
    returnData-\>oldStatesDerivatives = 0;
    returnData-\>oldStatesDerivatives2 = 0;
  }

  if(flags & HELPVARS && returnData-\>nHelpVars) {
    returnData-\>helpVars = (double*) malloc(sizeof(double)*returnData-\>nHelpVars);
    assert(returnData-\>helpVars);
    memset(returnData-\>helpVars,0,sizeof(double)*returnData-\>nHelpVars);
  } else {
    returnData-\>helpVars = 0;
  }

  if(flags & ALGEBRAICS && returnData-\>nAlgebraic) {
    returnData-\>algebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    returnData-\>oldAlgebraics2 = (double*) malloc(sizeof(double)*returnData-\>nAlgebraic);
    assert(returnData-\>algebraics&&returnData-\>oldAlgebraics&&returnData-\>oldAlgebraics2);
    memset(returnData-\>algebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics,0,sizeof(double)*returnData-\>nAlgebraic);
    memset(returnData-\>oldAlgebraics2,0,sizeof(double)*returnData-\>nAlgebraic);
  } else {
    returnData-\>algebraics = 0;
    returnData-\>oldAlgebraics = 0;
    returnData-\>oldAlgebraics2 = 0;
    returnData-\>stringVariables.algebraics = 0;
  }

  if (flags & ALGEBRAICS && returnData-\>stringVariables.nAlgebraic) {
    returnData-\>stringVariables.algebraics = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
    assert(returnData-\>stringVariables.algebraics);
    memset(returnData-\>stringVariables.algebraics,0,sizeof(char*)*returnData-\>stringVariables.nAlgebraic);
  } else {
    returnData-\>stringVariables.algebraics=0;
  }

  if(flags & PARAMETERS && returnData-\>nParameters) {
    returnData-\>parameters = (double*) malloc(sizeof(double)*returnData-\>nParameters);
    assert(returnData-\>parameters);
    memset(returnData-\>parameters,0,sizeof(double)*returnData-\>nParameters);
  } else {
    returnData-\>parameters = 0;
  }

  if (flags & PARAMETERS && returnData-\>stringVariables.nParameters) {
  	  returnData-\>stringVariables.parameters = (char**)malloc(sizeof(char*)*returnData-\>stringVariables.nParameters);
      assert(returnData-\>stringVariables.parameters);
      memset(returnData-\>stringVariables.parameters,0,sizeof(char*)*returnData-\>stringVariables.nParameters);
  } else {
      returnData-\>stringVariables.parameters=0;
  }

  if(flags & OUTPUTVARS && returnData-\>nOutputVars) {
    returnData-\>outputVars = (double*) malloc(sizeof(double)*returnData-\>nOutputVars);
    assert(returnData-\>outputVars);
    memset(returnData-\>outputVars,0,sizeof(double)*returnData-\>nOutputVars);
  } else {
    returnData-\>outputVars = 0;
  }

  if(flags & INPUTVARS && returnData-\>nInputVars) {
    returnData-\>inputVars = (double*) malloc(sizeof(double)*returnData-\>nInputVars);
    assert(returnData-\>inputVars);
    memset(returnData-\>inputVars,0,sizeof(double)*returnData-\>nInputVars);
  } else {
    returnData-\>inputVars = 0;
  }

  if(flags & INITIALRESIDUALS && returnData-\>nInitialResiduals) {
    returnData-\>initialResiduals = (double*) malloc(sizeof(double)*returnData-\>nInitialResiduals);
    assert(returnData-\>initialResiduals);
    memset(returnData-\>initialResiduals,0,sizeof(double)*returnData-\>nInitialResiduals);
  } else {
    returnData-\>initialResiduals = 0;
  }

  if(flags & INITFIXED) {
    returnData-\>initFixed = init_fixed;
  } else {
    returnData-\>initFixed = 0;
  }

  /*   names   */
  if(flags & MODELNAME) {
    returnData-\>modelName = model_name;
  } else {
    returnData-\>modelName = 0;
  }
  
  if(flags & STATESNAMES) {
    returnData-\>statesNames = state_names;
  } else {
    returnData-\>statesNames = 0;
  }

  if(flags & STATESDERIVATIVESNAMES) {
    returnData-\>stateDerivativesNames = derivative_names;
  } else {
    returnData-\>stateDerivativesNames = 0;
  }

  if(flags & ALGEBRAICSNAMES) {
    returnData-\>algebraicsNames = algvars_names;
  } else {
    returnData-\>algebraicsNames = 0;
  }

  if(flags & PARAMETERSNAMES) {
    returnData-\>parametersNames = param_names;
  } else {
    returnData-\>parametersNames = 0;
  }

  if(flags & INPUTNAMES) {
    returnData-\>inputNames = input_names;
  } else {
    returnData-\>inputNames = 0;
  }

  if(flags & OUTPUTNAMES) {
    returnData-\>outputNames = output_names;
  } else {
    returnData-\>outputNames = 0;
  }

  /*   comments  */
  if(flags & STATESCOMMENTS) {
    returnData-\>statesComments = state_comments;
  } else {
    returnData-\>statesComments = 0;
  }

  if(flags & STATESDERIVATIVESCOMMENTS) {
    returnData-\>stateDerivativesComments = derivative_comments;
  } else {
    returnData-\>stateDerivativesComments = 0;
  }

  if(flags & ALGEBRAICSCOMMENTS) {
    returnData-\>algebraicsComments = algvars_comments;
  } else {
    returnData-\>algebraicsComments = 0;
  }

  if(flags & PARAMETERSCOMMENTS) {
    returnData-\>parametersComments = param_comments;
  } else {
    returnData-\>parametersComments = 0;
  }

  if(flags & INPUTCOMMENTS) {
    returnData-\>inputComments = input_comments;
  } else {
    returnData-\>inputComments = 0;
  }

  if(flags & OUTPUTCOMMENTS) {
    returnData-\>outputComments = output_comments;
  } else {
    returnData-\>outputComments = 0;
  }

  if (flags & EXTERNALVARS) {
    returnData-\>extObjs = (void**)malloc(sizeof(void*)*NEXT);
    if (!returnData-\>extObjs) {
      printf("error allocating external objects\n");
      exit(-2);
    }
    memset(returnData-\>extObjs,0,sizeof(void*)*NEXT);
    setLocalData(returnData); /* must be set since used by constructors*/
  }
  return returnData;
}
>>

functionDeInitializeDataStruc() ::=
<<
void deInitializeDataStruc(DATA* data, DATA_FLAGS flags)
{
  if(!data)
    return;

  if(flags & STATES && data-\>states) {
    free(data-\>states);
    data-\>states = 0;
  }

  if(flags & STATESDERIVATIVES && data-\>statesDerivatives) {
    free(data-\>statesDerivatives);
    data-\>statesDerivatives = 0;
  }

  if(flags & ALGEBRAICS && data-\>algebraics) {
    free(data-\>algebraics);
    data-\>algebraics = 0;
  }

  if(flags & PARAMETERS && data-\>parameters) {
    free(data-\>parameters);
    data-\>parameters = 0;
  }

  if(flags & OUTPUTVARS && data-\>inputVars) {
    free(data-\>inputVars);
    data-\>inputVars = 0;
  }

  if(flags & INPUTVARS && data-\>outputVars) {
    free(data-\>outputVars);
    data-\>outputVars = 0;
  }
  
  if(flags & INITIALRESIDUALS && data-\>initialResiduals){
    free(data-\>initialResiduals);
    data-\>initialResiduals = 0;
  }
  if (flags & EXTERNALVARS && data-\>extObjs) {
    free(data-\>extObjs);
    data-\>extObjs = 0;
  }
}
>>

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations) ::=
# varDecls = ""
# body = (nonStateContEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
# body2 = (removedEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
<<
/* for continuous time variables */
int functionDAE_output()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>
  <body2>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# varDecls = ""
# body = (nonStateDiscEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
# body2 = (removedEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
/* for discrete time variables */
int functionDAE_output2()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>
  <body2>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionInput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
int input_function()
{
  <vars.inputVars of var as SIMVAR:
    '<cref(name)> = localData-\>inputVars[<i0>];' "\n">
  return 0;
}
>>

functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
int output_function()
{
  <vars.outputVars of var as SIMVAR:
    'localData-\>outputVars[<i0>] = <cref(name)>;' "\n">
  return 0;
}
>>

functionDaeRes() ::=
<<
int functionDAE_res(double *t, double *x, double *xd, double *delta,
                    long int *ires, double *rpar, long int* ipar)
{
  int i;
  double temp_xd[NX];
  double* statesBackup;
  double* statesDerivativesBackup;
  double timeBackup;

  statesBackup = localData-\>states;
  statesDerivativesBackup = localData-\>statesDerivatives;
  timeBackup = localData-\>timeValue;
  localData-\>states = x;

  for (i=0; i\<localData-\>nStates; i++) {
    temp_xd[i] = localData-\>statesDerivatives[i];
  }

  localData-\>statesDerivatives = temp_xd;
  localData-\>timeValue = *t;

  functionODE();

  /* get the difference between the temp_xd(=localData-\>statesDerivatives)
     and xd(=statesDerivativesBackup) */
  for (i=0; i \< localData-\>nStates; i++) {
    delta[i] = localData-\>statesDerivatives[i] - statesDerivativesBackup[i];
  }

  localData-\>states = statesBackup;
  localData-\>statesDerivatives = statesDerivativesBackup;
  localData-\>timeValue = timeBackup;

  if (modelErrorCode) {
    if (ires) {
      *ires = -1;
    }
    modelErrorCode =0;
  }

  return 0;
}
>>

functionZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_zeroCrossing(long *neqm, double *t, double *x, long *ng,
                          double *gout, double *rpar, long* ipar)
{
  double timeBackup;
  state mem_state;

  mem_state = get_memory_state();

  timeBackup = localData->timeValue;
  localData->timeValue = *t;
  <varDecls>

  functionODE();
  functionDAE_output();

  <zeroCrossingCode>

  restore_memory_state(mem_state);
  localData->timeValue = timeBackup;

  return 0;
}
>>

// This function should only save in cases. The rest is done in
// function_updateDependents.
functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
<<
int handleZeroCrossing(long index)
{
  state mem_state;

  mem_state = get_memory_state();

  switch(index) {
    <zeroCrossingsNeedSave of vars:
      'case <i0>:<\n><vars of SIMVAR: '  save(<cref(name)>);' "\n"><\n>  break;' "\n">
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionUpdateDependents(list<SimEqSystem> allEquations,
                         list<HelpVarInfo> helpVarInfo) ::=
# varDecls = ""
# eq1 = (allEquations of eq: '<equation_(eq, createSimulationContext(), varDecls)>' "\n")
# hvars = (
  helpVarInfo of (in1, exp, _):
    # preExp = ""
    # expPart = daeExp(exp, createSimulationContext(), preExp, varDecls)
    '<preExp>localData->helpVars[<in1>] = <expPart>;'
  "\n"
)
<<
int function_updateDependents()
{
  state mem_state;
  <varDecls>

  inUpdate=initial()?0:1;

  mem_state = get_memory_state();

  <eq1>
  <hvars>

  restore_memory_state(mem_state);

  inUpdate=0;

  return 0;
}
>>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossings) ::=
# varDecls = ""
# zeroCrossingCode = zeroCrossingsTpl(zeroCrossings, varDecls)
<<
int function_onlyZeroCrossings(double *gout,double *t)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <zeroCrossingCode>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionWhen(list<SimWhenClause> whenClauses) ::=
# varDecls = ""
# cases = whenClauses of whenClause as SIM_WHEN_CLAUSE:
  <<
  case <i0>:
    <whenEqTpl(whenEq, varDecls)>
    <reinits of reinit:
      # preExp = ""
      # body = reinit(reinit, preExp, varDecls)
      '<preExp><\n><body>'
    "\n">
    break;<\n>
  >>
<<
int function_when(int i)
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  switch(i) {
    <cases>
    default:
      break;
  }

  restore_memory_state(mem_state);

  return 0;
}
>>

functionOde(list<SimEqSystem> stateContEquations) ::=
# varDecls = ""
# body = (stateContEquations of eq: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int functionODE()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionInitial(list<SimEqSystem> initialEquations) ::=
# varDecls = ""
# body = (initialEquations of eq as SES_SIMPLE_ASSIGN: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int initial_function()
{
  <varDecls>

  <body>

  <initialEquations of eq as SES_SIMPLE_ASSIGN:
    'if (sim_verbose) { printf("Setting variable start value: %s(start=%f)\n", "<cref(componentRef)>", <cref(componentRef)>); }' "\n">

  return 0;
}
>>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# varDecls = ""
# body = (
  residualEquations of eq as SES_RESIDUAL:
    if exp is DAE.SCONST then
      'localData-\>initialResiduals[i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, createOtherContext(), preExp, varDecls)
      '<preExp>localData-\>initialResiduals[i++] = <expPart>;'
  "\n"
)
<<
int initial_residual()
{
  int i = 0;
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# varDecls = ""
# body = (parameterEquations of eq as SES_SIMPLE_ASSIGN: '<equation_(eq, createOtherContext(), varDecls)>' "\n")
<<
int bound_parameters()
{
  state mem_state;
  <varDecls>

  mem_state = get_memory_state();

  <body>

  restore_memory_state(mem_state);

  return 0;
}
>>

// TODO: Is the -1 thing really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfo,
                                   list<ComponentRef> discreteModelVars) ::=
<<
int checkForDiscreteVarChanges()
{
  int needToIterate = 0;

  <helpVarInfo of (id1, exp, id2):
    if id2 is not -1 then
    'if (edge(localData-\>helpVars[<id1>])) AddEvent(<id2> + localData-\>nZeroCrossing);'
  "\n">

  <discreteModelVars of var:
    'if (change(<cref(var)>)) { needToIterate = 1; }' "\n">
  
  for (long i = 0; i \< localData-\>nHelpVars; i++) {
    if (change(localData-\>helpVars[i])) {
      needToIterate=1;
    }
  }

  return needToIterate;
}
>>

//functionsFile() ::=
//<<
//#ifdef __cplusplus
//extern "C" {
//#endif
//
///* Header part */
///* End of header part */
//
///* Body */
///* End body */
//
//#ifdef __cplusplus
//}
//#endif
//>>
//
//initFile() ::=
//<<
//>>
//
//makefile() ::=
//<<
//>>

reinit(ReinitStatement, Text preExp, Text varDecls) ::=
  case REINIT then
    # val = daeExp(value, createSimulationContext(), preExp, varDecls)
    <<
    <cref(stateVar)> = <val>;
    >>

// TODO: Better name?
zeroCrossingsTpl(list<ZeroCrossing> zeroCrossings, Text varDecls) ::=
  <<
  <zeroCrossings of zeroCrossing as ZERO_CROSSING:
    '<zeroCrossingTpl(i0, relation_, varDecls)>' "\n">
  >>

zeroCrossingTpl(Integer index, Exp relation, Text varDecls) ::=
  match relation
  case RELATION then
    # preExp = ""
    # e1 = daeExp(exp1, createOtherContext(), preExp, varDecls)
    # op = zeroCrossingOpFunc(operator)
    # e2 = daeExp(exp2, createOtherContext(), preExp, varDecls)
    <<
    <preExp>
    ZEROCROSSING(<index>, <op>(<e1>, <e2>));
    >>
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = ""
    # e1 = daeExp(start, createOtherContext(), preExp, varDecls)
    # e2 = daeExp(interval, createOtherContext(), preExp, varDecls)
    <<
    <preExp>
    ZEROCROSSING(<index>, Sample(*t, <e1>, <e2>));
    >>
  case _ then
    <<
    ZERO CROSSING ERROR
    >>

zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"

utilStaticStringArray(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLengthSimVar(items)>] = {<items of item as SIMVAR:
  '"<crefSubscript(origName)>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

utilStaticStringArrayComment(String name, list<SimVar> items) ::=
if items then
<<
char* <name>[<listLengthSimVar(items)>] = {<items of item as SIMVAR:
  '"<item.comment>"' ", ">};
>>
else
<<
char* <name>[1] = {""};
>>

// Residual equations are not handled here
equation_(SimEqSystem eq, Context context, Text varDecls) ::=
case SES_SIMPLE_ASSIGN then
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
<cref(componentRef)> = <expPart>;
>>
case SES_ARRAY_CALL_ASSIGN then // cref_array = call(...)
# preExp = ""
# expPart = daeExp(exp, context, preExp, varDecls)
<<
<preExp>
copy_real_array_data_mem(&<expPart>, &<cref(componentRef)>);
>>
case SES_ALGORITHM then
# stmt = (statements : algStatement(it, context, varDecls) \n) 
<<
<stmt>
>>
case SES_NOT_IMPLEMENTED then
<<
SES_NOT_IMPLEMENTED("<msg>");
>>
case _ then
<<
notimplemented = notimplemented;
>>

whenEqTpl(Option<WhenEquation>, Text varDecls) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, createSimulationContext(), preExp, varDecls)
<<
save(<cref(weq.left)>);

<preExp>
<cref(weq.left)> = <expPart>;
>>

boolToInt(Boolean) ::=
  case true  then "1"
  case false then "0"

// TODO: Correct type? Correct value?
typeAttrInt(DAE.ExpType) ::=
  case ET_REAL   then "1"
  case ET_STRING then "2"
  case ET_INT    then "4"
  case ET_BOOL   then "8"

discreteAttrInt(Boolean isDiscrete) ::=
  case true  then "16"
  case false then "0"

cref(ComponentRef) ::=
  case CREF_IDENT then '<ident>'
  case _ then "CREF_NOT_IDENT"

crefSubscript(ComponentRef) ::=
  case CREF_IDENT then '<ident><subscriptsTpl(subscriptLst)>'
  case _ then "CREF_NOT_IDENT"

subscriptsTpl(list<Subscript> subscripts) ::=
if subscripts then '[<subscripts of s: subscriptTpl(s) ",">]'
else ""

subscriptTpl(Subscript subscript) ::=
case INDEX then (
  match exp
  case ICONST then integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"
)
case _ then "SUBSCRIPT_NOT_CONSTANT"
 
// TODO: Check with Codegen (expTypeStr)
expTypeA(DAE.ExpType, Boolean isArray) ::=
  case ET_COMPLEX     then expTypeShort() // i.e. 'struct <name>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "metamodelica_type"

dotPath(Path) ::=
  case QUALIFIED      then '<name>.<dotPath(path)>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path) ::=
  case QUALIFIED      then '<System.stringReplace(name, "_", "__")>_<underscorePath(path)>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)


recordDeclaration(RecordDeclaration) ::=
  case RECORD_DECL_FULL then
<<
struct <name> {
  <variables of var as VARIABLE :
      if expTypeArrayIf(ty) then '<it> <cref(var.name)>;'
      else '/* <cref(var.name)> is an odd member. */'
  \n>
};
<recordDefinition( dotPath(defPath),
                   underscorePath(defPath),
                   (variables of VARIABLE : '"<cref(name)>"' ",") )>
>> 
  case RECORD_DECL_DEF then 
    recordDefinition( dotPath(path),
                      underscorePath(path),
                      (fieldNames : '"<it>"' ",") )


recordDefinition(String origName, String encName, String fieldNames) ::=
<<
const char* <encName>__desc__fields[] = {<fieldNames>};
struct record_description <encName>__desc = {
  "<encName>", /* package_record__X */
  "<origName>", /* package.record_X */
  <encName>__desc__fields
};
>>


//!! assumes the type is T_ARRAY when array, so no branching by isArray here ... see Codegen.generateReturnDecl,
// ?? initopt dump ? see Codegen.tmpPrintInit usage in generateReturnDecl
functionHeader(String fname, Variables fargs, Variables outVars) ::=
<<
<outVars of VARIABLE : 
'#define <fname>_rettype_<i1> targ<i1>' 
\n>
typedef struct <fname>_rettype_s 
{
  <outVars of VARIABLE :
  '<varType(it)> targ<i1>; /* <cref(name)><if ty is ET_ARRAY then '[<arrayDimensions : if it is SOME(d) then d else ":" ", ">]'> */'
  \n>
} <fname>_rettype;

DLLExport 
<fname>_rettype _<fname>(<fargs of VARIABLE : '<varType(it)> <cref(name)>' ", ">);

DLLExport 
int in_<fname>(type_description * inArgs, type_description * outVar);
>>


functionsCpp(list<Function> functions) ::=
<<
#ifdef __cplusplus
extern "C" {
#endif
/* header part */
<functions of FUNCTION : 
  <<
  /*recordDecls : recordDeclaration() \n*/
  <functionHeader(underscorePath(name), functionArguments, outVars)>
  >> 
\n> 
/* End of header part */

/* Body */
<functions : functionDef() \n>
/* End Body */

#ifdef __cplusplus
}
#endif

>>

varDeclaration(Variable) ::=
case VARIABLE then '<varType(it)> <cref(name)>;<\n>'

varInit(Variable, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # varDecls += varDeclaration(var)
  # instDimsInit = (instDims of exp: daeExp(exp, createOtherContext(), varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<cref(var.name)>, <listLengthExp(instDims)>, <instDimsInit>);<\n>'
    ()
  else
    ()

varOutput(Variable source, String dest, Integer i, Text varDecls, Text varInits) ::=
case var as VARIABLE then
  # instDimsInit = (instDims of exp: daeExp(exp, createOtherContext(), varInits, varDecls) ", ")
  if instDims then
    # varInits += 'alloc_<expTypeShort(var.ty)>_array(&<dest>.targ<i>, <listLengthExp(instDims)>, <instDimsInit>);<\n>'
    <<
    copy_<expTypeShort(var.ty)>_array_data(&<cref(var.name)>, &<dest>.targ<i>);
    >>
  else
    <<
    <dest>.targ<i> = <cref(var.name)>;
    >>

functionDef(Function) ::=
  case FUNCTION then
    # System.tmpTickReset(1)
    # fname = underscorePath(name)
    # retType = '<fname>_rettype'
    # varDecls = ""
    # varInits = ""
    # retVar   = tempDecl(retType, varDecls)
    # stateVar = tempDecl("state", varDecls)
    # foo = (variableDeclarations: varInit(it, varDecls, varInits))
    # bodyPart = (body of stmt : funStatement(stmt, varDecls) \n)
    # outVarsStr = (outVars: varOutput(it, retVar, i1, varDecls, varInits))
    <<
    <retType> _<fname>(<functionArguments of VARIABLE: '<expTypeArrayIf(ty)> <cref(name)>' ", ">)
    {
      <varDecls>
      <stateVar> = get_memory_state();

      <varInits>

      <bodyPart>
      
      _return:
      <outVarsStr>
      restore_memory_state(<stateVar>);
      return <retVar>;
    }
    >>
    

funBody(list<Statement> body) ::=
  # varDecls = ""
  # bodyPart = (body of stmt : funStatement(stmt, varDecls) \n)
<<
<varDecls>
<bodyPart>
>>


funStatement(Statement, Text varDecls) ::=
  case ALGORITHM then (statementLst : algStatement(it, createOtherContext(), varDecls) \n) 
  case BLOCK then "/* not implemented fun statement */"

// Codegen.generateAlgorithmStatement
algStatement(DAE.Statement, Context context, Text varDecls) ::=
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD), exp = e) then
    # preExp = "" 
    # expPart = daeExp(e, context, preExp, varDecls)
    <<
    <preExp>
    <expPart>
    >>
  case STMT_ASSIGN(exp1 = CREF) then
    # preExp = ""
    # expPart = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    <scalarLhsCref(exp1, context, preExp, varDecls)> = <expPart>;
    >>
  case STMT_ASSIGN then
    # preExp = ""
    # expPart1 = daeExp(exp1, context, preExp, varDecls)
    # expPart2 = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    <expPart1> = <expPart2>;
    >>
  case STMT_ASSIGN_ARR then // TODO: this is different depending on context
    # preExp = ""
    # expPart = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    copy_<expTypeArray(type_)>_data(&<expPart>, &<cref(componentRef)>);
    >>
  case STMT_IF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp, varDecls)
    <<
    <preExp>
    if (<condExp>) {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    <elseExpr(else_, context, varDecls)>
    >>
  case STMT_FOR(exp = rng as RANGE) then
    # stateVar = tempDecl("state", varDecls)
    # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
    # identType = expType(type_, boolean)
    # r1 = tempDecl(identType, varDecls)
    # r2 = tempDecl(identType, varDecls)
    # r3 = tempDecl(identType, varDecls)
    # preExp = ""
    # er1 = daeExp(rng.exp, context, preExp, varDecls)
    # er2 = if rng.expOption is SOME(eo) 
            then daeExp(eo, context, preExp, varDecls)
            else "(1)"
    # er3 = daeExp(rng.range, context, preExp, varDecls) 
    <<
    <preExp>
    <r1> = <er1>; <r2> = <er2>; <r3> = <er3>;
    {
    <identType> <ident>;

      for (<ident> = <r1>; in_range_<expTypeShort(type_)>(<ident>, <r1>, <r3>); <ident> += <r2>) {
        <stateVar> = get_memory_state();
        <statementLst : algStatement(it, context, varDecls) \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ >
        restore_memory_state(<stateVar>);
      }
    } /*end for*/
    >>
  case STMT_FOR then
    # stateVar = tempDecl("state", varDecls)
    # arrayType = expTypeArray(type_)
    # dvar = System.tmpTick() // a hack to be precisely the same as original ... see Codegen.generateAlgorithmStatement case FOR
    # tvar = tempDecl("int", varDecls)
    # identType = expType(type_, boolean)
    # ivar = tempDecl(identType, varDecls)
    # preExp = ""
    # evar = daeExp(exp, context, preExp, varDecls)
    # statements = (statementLst: algStatement(it, context, varDecls) \n)
    # id = '<ident>'
    # stmtStuff = if boolean
                  then 'simple_index_alloc_<identType>1(&<evar>, <tvar>, &<ivar>);'
                  else '<id> = *(<arrayType>_element_addr1(&<evar>, 1, <tvar>));'
    <<
    <preExp>
    {
    <identType> <ident>;

      for (<tvar> = 1; <tvar> \<= size_of_dimension_<arrayType>(<evar>, 1); ++<tvar>) {
        <stateVar> = get_memory_state();
        <stmtStuff>
        <statements>
        restore_memory_state(<stateVar>);
      }
    } /* end for*/
    >>
  case STMT_WHILE then
    # preExp = ""
    # var = daeExp(exp, context, preExp, varDecls)
    <<
    while (1) {
      <preExp>
      if (!<var>) break;
      <statementLst: algStatement(it, context, varDecls) \n>
    }
    >>
  case STMT_ASSERT then
    # preExp = ""
    # condVar = daeExp(cond, context, preExp, varDecls)
    # msgVar = daeExp(msg, context, preExp, varDecls)
    <<
    <preExp>
    MODELICA_ASSERT(<condVar>, <msgVar>);
    >>
  case when as STMT_WHEN then if context is SIMULATION
                         then algStatementWhen(when, context, varDecls)
                         else ""
  case _ then "/* not implemented alg statement*/"

// TODO: This and all help templates it calls is really ugly. It is largely due
// to the STMT_WHEN structure. It is not really suited for susan.
algStatementWhen(DAE.Statement, Context context, Text varDecls) ::=
case STMT_WHEN then
  # preIf = algStatementWhenPre(it, varDecls)
  # statements = (statementLst: '<algStatement(it, createSimulationContext(), varDecls)>' "\n")
  # else = algStatementWhenElse(elseWhen, varDecls)
  <<
  <preIf>
  if (<helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

algStatementWhenPre(DAE.Statement, Text varDecls) ::=
case STMT_WHEN(exp=ARRAY(array=el)) then
  # restPre = if elseWhen is SOME(ew)
              then algStatementWhenPre(ew, varDecls) else ""
  # preExp = ""
  # fooRes = foo(el, helpVarIndices, preExp, varDecls)
  <<
  <preExp>
  <fooRes>
  <restPre>
  >>
case when as STMT_WHEN then
  match helpVarIndices
  case {i} then
    # restPre = if when.elseWhen is SOME(ew)
                then algStatementWhenPre(ew, varDecls) else ""
    # preExp = ""
    # res = daeExp(when.exp, createSimulationContext(), preExp, varDecls)
    <<
    <preExp>
    localData-\>helpVars[<i>] = <res>;
    <restPre>
    >>

algStatementWhenElse(Option<DAE.Statement>, Text varDecls) ::=
case SOME(when as STMT_WHEN) then
  # statements = (when.statementLst: '<algStatement(it, createSimulationContext(), varDecls)>' "\n")
  # else = algStatementWhenElse(when.elseWhen, varDecls)
  <<
  else if (<when.helpVarIndices: 'edge(localData-\>helpVars[<it>])' " || ">) {
    <statements>
  }
  <else>
  >>

foo(list<Exp> exps, list<Integer> ints, Text preExp, Text varDecls) ::=
case {} then ""
case (firstExp :: restExps) then
  match ints
  case (firstInt :: restInts) then
    # rest = foo(restExps, restInts, preExp, varDecls)
    <<
    localData-\>helpVars[<firstInt>] = <daeExp(firstExp, createSimulationContext(), preExp, varDecls)>;
    <rest>
    >>

elseExpr(DAE.Else, Context context, Text varDecls) ::= 
  case NOELSE then ()
  case ELSEIF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp, varDecls)
    <<
    else {
    <preExp>
    if (<condExp>)) {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    <elseExpr(else_, context, varDecls)>
    }
    >>
  case ELSE then
    <<
    else {
      <statementLst : algStatement(it, context, varDecls) \n>
    }
    >>

scalarLhsCref(Exp cref, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(cref.componentRef) then
    '<cref(cref.componentRef)>'
  else
    daeExpCrefRhs(cref, context, preExp, varDecls)
case _ then
  "ONLY IDENT SUPPORTED"

//TODO: this wrong for qualified integers !
rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<rhsCrefType(ty)><ident>'
  case CREF_QUAL  then '<rhsCrefType(ty)><ident>.<rhsCref(componentRef,ty)>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType) ::=
  case ET_INT then "(modelica_integer)"
  case _      then ""
  
daeExp(Exp exp, Context context, Text preExp, Text varDecls) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then daeExpSconst(string, preExp, varDecls)
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then daeExpCrefRhs(it, context, preExp, varDecls)
  case BINARY     then daeExpBinary(it, context, preExp, varDecls)
  case UNARY      then daeExpUnary(it, context, preExp, varDecls)
  case LBINARY    then daeExpLbinary(it, context, preExp, varDecls)
  case LUNARY     then daeExpLunary(it, context, preExp, varDecls)
  case RELATION   then daeExpRelation(it, context, preExp, varDecls)
  case IFEXP      then daeExpIf(it, context, preExp, varDecls)
  case CALL       then daeExpCall(it, context, preExp, varDecls)
  // PARTEVALFUNCTION
  case ARRAY      then daeExpArray(it, context, preExp, varDecls)
  case MATRIX     then daeExpMatrix(it, context, preExp, varDecls)
  case RANGE      then "RANGE_NOT_IMPLEMENTED"
  case TUPLE      then "TUPLE_NOT_IMPLEMENTED"
  case CAST       then daeExpCast(it, context, preExp, varDecls)
  case ASUB       then daeExpAsub(it, context, preExp, varDecls)
  case SIZE       then daeExpSize(it, context, preExp, varDecls)
  case CODE       then "CODE_NOT_IMPLEMENTED"
  case REDUCTION  then "REDUCTION_NOT_IMPLEMENTED"
  case END        then "END_NOT_IMPLEMENTED"
  case VALUEBLOCK then "VALUEBLOCK_NOT_IMPLEMENTED"
  case LIST       then "LIST_NOT_IMPLEMENTED"
  case CONS       then "CONS_NOT_IMPLEMENTED"
  // META_TUPLE
  // META_OPTION
  // METARECORDCALL
  case _          then "UNKNOWN_EXP"

daeExpCrefRhs(Exp exp, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if daeExpCrefRhsArrayBox(exp, context, preExp, varDecls) then
    it
  else if crefNoSub(cref.componentRef) then
    # cast = if cref.ty is ET_INT then "(modelica_integer)" else ""
    '<cast><cref(cref.componentRef)>'
  else if crefSubIsScalar(cref.componentRef) then
    // The array subscript results in a scalar
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # dimsLenStr = listLengthSubscript(subs)
    # dimsValuesStr = (subs of INDEX: daeExp(exp, context, preExp, varDecls) ", ")
    <<
    (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
    >>
  else
    // The array subscript denotes a slice
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # tmp = tempDecl(arrayType, varDecls)
    # spec1 = indexSpec(subs, context, preExp, varDecls)
    # preExp += 'index_alloc_<arrayType>(&<arrName>, &<spec1>, &<tmp>);<\n>'
    tmp
case _ then
  "UNKNOWN RHS CREF: ONLY IDENT SUPPORTED"

indexSpec(list<Subscript> subs, Context context, Text preExp, Text varDecls) ::=
# nridx_str = listLengthSubscript(subs)
# idx_str = (subs of sub:
               case INDEX then
                 # expPart = daeExp(exp, context, preExp, varDecls)
                 <<
                 (1), make_index_array(1, <expPart>), 'S'
                 >>
               case WHOLEDIM then
                 <<
                 (1), (0), 'W'
                 >>
               case SLICE then
                 # expPart = daeExp(exp, context, preExp, varDecls)
                 # tmp = tempDecl("modelica_integer", varDecls)
                 # preExp += '<tmp> = size_of_dimension_integer_array(<expPart>, 1);<\n>'
                 <<
                 <tmp>, integer_array_make_index_array(&<expPart>), 'A'
                 >>
             ", ")
# tmp = tempDecl("index_spec_t", varDecls)
# preExp += 'create_index_spec(&<tmp>, <nridx_str>, <idx_str>);<\n>'
tmp

daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp, Text varDecls) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = tempDecl(expTypeArray(aty), varDecls)
    # dimsLenStr = listLengthOptionInt(dims)
    # dimsValuesStr = (dims of dim as SOME(i): i ", ")
    # preExp += '<expTypeShort(aty)>_array_create(&<tmpArr>, &<cref(cref.componentRef)>, <dimsLenStr>, <dimsValuesStr>);<\n>'
    tmpArr

// TODO: Optimize as in Codegen
// TODO: Use this function in other places where almost the same thing is hard
//       coded
arrayScalarRhs(ExpType ty, list<Exp> subs, String arrName, Context context,
               Text preExp, Text varDecls) ::=
  # arrayType = expTypeArray(ty)
  # dimsLenStr = listLengthExp(subs)
  # dimsValuesStr = (subs of exp: daeExp(exp, context, preExp, varDecls) ", ")
  <<
  (*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
  >>

daeExpSconst(String string, Text preExp, Text varDecls) ::=
  # strVar = tempDecl("modelica_string", varDecls)
  # preExp += 'init_modelica_string(&<strVar>,"<Util.escapeModelicaStringToCString(string)>");<\n>'
  strVar  

daeExpBinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case BINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case ADD(ty = ET_STRING) then
    # tmpStr = tempDecl("modelica_string", varDecls)
    # preExp += 'cat_modelica_string(&<tmpStr>,&<e1>,&<e2>);<\n>'
    tmpStr
  case ADD then '(<e1> + <e2>)'
  case SUB then '(<e1> - <e2>)'
  case MUL then '(<e1> * <e2>)'
  case DIV then '(<e1> / <e2>)'
  case POW then 'pow((modelica_real)<e1>, (modelica_real)<e2>)'
  case ADD_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'add_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case SUB_ARR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'sub_alloc_<type>(&<e1>, &<e2>, &<var>);<\n>'
    '<var>'
  case MUL_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'mul_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case DIV_ARRAY_SCALAR then
    # type = if ty is ET_ARRAY(ty=ET_INT) then "integer_array" else "real_array"
    # var = tempDecl(type, varDecls)
    # preExp += 'div_alloc_<type>_scalar(&<e1>, <e2>, &<var>);<\n>'
    '<var>'
  case _   then "daeExpBinary:ERR"

daeExpLbinary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LBINARY then
  # e1 = daeExp(exp1, context, preExp, varDecls)
  # e2 = daeExp(exp2, context, preExp, varDecls)
  match operator
  case AND then '(<e1> && <e2>)'
  case OR  then '(<e1> || <e2>)'
  case _   then "daeExpLbinary:ERR"

daeExpLunary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case LUNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case NOT then '(!<e>)'

daeExpUnary(Exp exp, Context context, Text preExp, Text varDecls) ::=
case UNARY then
  # e = daeExp(exp, context, preExp, varDecls)
  match operator
  case UMINUS     then '(-<e>)'
  case UPLUS      then '(<e>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

daeExpRelation(Exp exp, Context context, Text preExp, Text varDecls) ::=
case rel as RELATION then
  if daeExpRelationSim(exp, context, preExp, varDecls) then
    it
  else
    # e1 = daeExp(rel.exp1, context, preExp, varDecls)
    # e2 = daeExp(rel.exp2, context, preExp, varDecls)
    match rel.operator
    case LESS(ty = ET_BOOL)        then '(!<e1> && <e2>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)         then '(<e1> \< <e2>)'
    case LESS(ty = ET_REAL)        then '(<e1> \< <e2>)'
    case GREATER(ty = ET_BOOL)     then '(<e1> && !<e2>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)      then '(<e1> > <e2>)'
    case GREATER(ty = ET_REAL)     then '(<e1> > <e2>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<e1> || <e2>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)       then '(<e1> \<= <e2>)'
    case LESSEQ(ty = ET_REAL)      then '(<e1> \<= <e2>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<e1> || !<e2>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)    then '(<e1> >= <e2>)'
    case GREATEREQ(ty = ET_REAL)   then '(<e1> >= <e2>)'
    case EQUAL(ty = ET_BOOL)       then '((!<e1> && !<e2>) || (<e1> && <e2>))'
    case EQUAL(ty = ET_STRING)     then '(!strcmp(<e1>, <e2>))'
    case EQUAL(ty = ET_INT)        then '(<e1> == <e2>)'
    case EQUAL(ty = ET_REAL)       then '(<e1> == <e2>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<e1> && <e2>) || (<e1> && !<e2>))'
    case NEQUAL(ty = ET_STRING)    then '(strcmp(<e1>, <e2>))'
    case NEQUAL(ty = ET_INT)       then '(<e1> != <e2>)'
    case NEQUAL(ty = ET_REAL)      then '(<e1> != <e2>)'
    case _                         then "daeExpRelation:ERR"

daeExpRelationSim(Exp exp, Context context, Text preExp, Text varDecls) ::=
case rel as RELATION then
  match context
  case SIMULATION then
    # e1 = daeExp(rel.exp1, context, preExp, varDecls)
    # e2 = daeExp(rel.exp2, context, preExp, varDecls)
    # res = tempDecl("modelica_boolean", varDecls)
    match rel.operator
    case LESS      then # preExp += 'RELATIONLESS(<res>, <e1>, <e2>);<\n>' res
    case LESSEQ    then # preExp += 'RELATIONLESSEQ(<res>, <e1>, <e2>);<\n>' res
    case GREATER   then # preExp += 'RELATIONGREATER(<res>, <e1>, <e2>);<\n>' res
    case GREATEREQ then # preExp += 'RELATIONGREATEREQ(<res>, <e1>, <e2>);<\n>' res

daeExpIf(Exp exp, Context context, Text preExp, Text varDecls) ::=
case IFEXP then
  # condExp = daeExp(expCond, context, preExp, varDecls)
  # condVar = tempDecl("modelica_boolean", varDecls)
  # resVarType = expTypeFromExpArrayIf(expThen)
  # resVar = tempDecl(resVarType, varDecls)
  # preExpThen = ""
  # eThen = daeExp(expThen, context, preExpThen, varDecls)
  # preExpElse = ""
  # eElse = daeExp(expElse, context, preExpElse, varDecls)
  # preExp +=  
  <<
  <condVar> = <condExp>;
  if (<condVar>) {
    <preExpThen>
    <resVar> = <eThen>;
  } else {
    <preExpElse>
    <resVar> = <eElse>;
  }<\n>
  >>
  resVar
//  <<
//  ((<condVar>)?<eThen>:<eElse>)
//  >>

daeExpCall(Exp call, Context context, Text preExp, Text varDecls) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    # retType = '<expTypeArrayIf(arg.ty)>'
    # retVar = tempDecl(retType, varDecls)
    # cast = if arg.ty is ET_INT then "(modelica_integer)" else ""
    # preExp += '<retVar> = <cast>pre(<cref(arg.componentRef)>);<\n>'
    '<retVar>'
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="promote"), expLst={A, n}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # var2 = daeExp(n, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'promote_alloc_<arr_tp_str>(&<var1>, <var2>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="transpose"), expLst={A}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'transpose_alloc_<arr_tp_str>(&<var1>, &<tvar>);<\n>'
    tvar
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="identity"), expLst={A}) then
    # var1 = daeExp(A, context, preExp, varDecls)
    # arr_tp_str = '<expTypeFromExpArray(A)>'
    # tvar = tempDecl(arr_tp_str, varDecls)
    # preExp += 'identity_alloc_<arr_tp_str>(<var1>, &<tvar>);<\n>'
    tvar
  // TODO: add more special builtins (Codegen.generateBuiltinFunction)
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # preExp += '<underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    '/* NORETCALL */'
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    if builtin then '<retVar>' else '<retVar>.<retType>_1'
  // tuple calls (multiple return values)
  case CALL(tuple_=true) then
    # argStr = (expLst of exp: '<daeExp(exp, context, preExp, varDecls)>' ", ")
    # funName = '<underscorePath(path)>'
    # retType = '<funName>_rettype'
    # retVar = tempDecl(retType, varDecls)
    # preExp += '<retVar> = <underscorePrefix(builtin)><funName>(<argStr>);<\n>'
    '<retVar>'

daeExpArray(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ARRAY then
# arrayTypeStr = '<expTypeArray(ty)>'
# arrayVar = tempDecl(arrayTypeStr, varDecls)
# scalarPrefix = if scalar then "scalar_" else ""
# scalarRef = if scalar then "&" else ""
# params = '<array of e: daeExp(e, context, preExp, varDecls) ", ">'
# preExp += 'array_alloc_<scalarPrefix><arrayTypeStr>(&<arrayVar>, <listLengthExp(array)>, <params>);<\n>'
'<arrayVar>'

daeExpMatrix(Exp exp, Context context, Text preExp, Text varDecls) ::=
case MATRIX(scalar={{}}) then
  // special case for empty matrix: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case MATRIX(scalar={}) then
  // special case for empty array: create dimensional array Real[0,1]
  # arrayTypeStr = expTypeArray(ty)
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'alloc_<arrayTypeStr>(&<tmp>, 2, 0, 1);<\n>'
  tmp
case m as MATRIX then
  # arrayTypeStr = expTypeArray(m.ty)
  # vars2 = ""
  # promote = ""
  # catAlloc = (m.scalar of row:
                 # tmp = tempDecl(arrayTypeStr, varDecls)
                 # vars = daeExpMatrixRow(row, arrayTypeStr, context, promote, varDecls)
                 # vars2 += ', &<tmp>'
                 'cat_alloc_<arrayTypeStr>(2, &<tmp>, <listLengthMatrix2(row)><vars>);'
               "\n")
  # preExp += promote
  # preExp += catAlloc
  # preExp += "\n"
  # tmp = tempDecl(arrayTypeStr, varDecls)
  # preExp += 'cat_alloc_<arrayTypeStr>(1, &<tmp>, <listLengthMatrix1(m.scalar)><vars2>);<\n>'
  tmp

daeExpMatrixRow(list<tuple<Exp,Boolean>> row, String arrayTypeStr,
                Context context, Text preExp, Text varDecls) ::=
# varLstStr = ""
# preExp2 = (row of col as (e, b):
               # scalarStr = if b then "scalar_" else ""
               # scalarRefStr = if b then "" else "&"
               # expVar = daeExp(e, context, preExp, varDecls)
               # tmp = tempDecl(arrayTypeStr, varDecls)
               # varLstStr += ', &<tmp>'
               'promote_<scalarStr><arrayTypeStr>(<scalarRefStr><expVar>, 2, &<tmp>);'
             "\n")
# preExp2 += "\n"
# preExp += preExp2
varLstStr

daeExpCast(Exp exp, Context context, Text preExp, Text varDecls) ::=
case CAST then
  # expVar = daeExp(exp, context, preExp, varDecls)
  match ty
  case ET_INT   then '((modelica_int)<expVar>)' // TODO: really int? not integer?
  case ET_REAL  then '((modelica_real)<expVar>)'
  case ET_ARRAY then
    # arrayTypeStr = expTypeArray(ty)
    # tvar = tempDecl(arrayTypeStr, varDecls)
    # to = expTypeShort(ty)
    # from = expTypeFromExpShort(exp)
    # preExp += 'cast_<from>_array_to_<to>(&<expVar>, &<tvar>);<\n>'
    tvar

daeExpAsub(Exp exp, Context context, Text preExp, Text varDecls) ::=
case ASUB(exp=RANGE(ty=t), sub={idx}) then
  'ASUB_EASY_CASE'
case ASUB(exp=ASUB(
            exp=ASUB(
              exp=ASUB(exp=e, sub={ICONST(integer=i)}),
              sub={ICONST(integer=j)}),
            sub={ICONST(integer=k)}),
          sub={ICONST(integer=l)}) then
  'ASUB_4D'
case ASUB(exp=ASUB(
            exp=ASUB(exp=e, sub={ICONST(integer=i)}),
            sub={ICONST(integer=j)}),
          sub={ICONST(integer=k)}) then
  'ASUB_3D'
case ASUB(exp=ASUB(exp=e, sub={ICONST(integer=i)}),
          sub={ICONST(integer=j)}) then
  'ASUB_2D'
case ASUB(exp=e, sub={ICONST(integer=i)}) then
  'ASUB_ARRAY'
case ASUB(exp=cref as CREF, sub=subs) then
  # arrName = daeExpCrefRhs(buildCrefExpFromAsub(cref, subs), context, preExp, varDecls)
  if context is SIMULATION then
    arrayScalarRhs(cref.ty, subs, arrName, context, preExp, varDecls)
  else
    '<arrName>'
case _ then
  'OTHER_ASUB'

daeExpSize(Exp exp, Context context, Text preExp, Text varDecls) ::=
case SIZE(exp=CREF, sz=SOME(dim)) then
  # expPart = daeExp(exp, context, preExp, varDecls)
  # dimPart = daeExp(dim, context, preExp, varDecls)
  # resVar = tempDecl("size_t", varDecls)
  # typeStr = '<expTypeArray(exp.ty)>'
  # preExp += '<resVar> = size_of_dimension_<typeStr>(<expPart>, <dimPart>);<\n>'
  resVar
case _ then "size(X) not implemented"

underscorePrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"

tempDecl(String ty, Text varDecls) ::=
  # newVar = 'tmp<System.tmpTick()>'
  # varDecls += '<ty> <newVar>;<\n>'
  newVar

varType(Variable) ::=
  case var as VARIABLE then
    if instDims then
      expTypeArray(var.ty)
    else
      expTypeArrayIf(var.ty)

expTypeShort(DAE.ExpType) ::=
  case ET_INT     then "integer"
  case ET_REAL    then "real"
  case ET_STRING  then "string"
  case ET_BOOL    then "boolean"
  case ET_OTHER   then "complex"
  case ET_ARRAY   then expTypeShort(ty)   
  case ET_COMPLEX then 'struct <name>'  
  case _          then "expTypeShort:ERROR"

expType(DAE.ExpType ty, Boolean array) ::=
  match array
  case true  then expTypeArray(ty)
  case false then expTypeModelica(ty)

expTypeModelica(DAE.ExpType ty) ::=
  expTypeFlag(ty, 2)

expTypeArray(DAE.ExpType ty) ::=
  expTypeFlag(ty, 3)

expTypeArrayIf(DAE.ExpType ty) ::=
  expTypeFlag(ty, 4)

expTypeFromExpShort(Exp exp) ::=
  expTypeFromExpFlag(exp, 1)

expTypeFromExpArray(Exp exp) ::=
  expTypeFromExpFlag(exp, 3)

expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExpFlag(exp, 4)

expTypeFlag(DAE.ExpType ty, Integer flag) ::=
  match flag
  // we want the short type
  case 1 then expTypeShort(ty)
  // we want the "modelica type"
  case 2 then 'modelica_<expTypeShort(ty)>'
  // we want the "array type"
  case 3 then '<expTypeShort(ty)>_array'
  // we want the "array type" only if type is array, otherwise "modelica type"
  case 4 then
    match ty
    case ET_ARRAY then '<expTypeShort(ty)>_array'
    case _        then 'modelica_<expTypeShort(ty)>'

expTypeFromExpFlag(Exp, Integer flag) ::=
  case ICONST        then if flag is 1 then "integer" else "modelica_integer"
  case RCONST        then if flag is 1 then "real" else "modelica_real"
  case SCONST        then if flag is 1 then "string" else "modelica_string"
  case BCONST        then if flag is 1 then "boolean" else "modelica_boolean"
  case e as BINARY
  case e as UNARY
  case e as LBINARY
  case e as LUNARY
  case e as RELATION then expTypeFromOpFlag(e.operator, flag)
  case IFEXP         then expTypeFromExpFlag(expThen, flag)
  case CALL          then expTypeFlag(ty, flag)
  case c as ARRAY
  case c as MATRIX
  case c as RANGE
  case c as CAST
  case c as CREF
  case c as CODE     then expTypeFlag(c.ty, flag)
  case ASUB          then expTypeFromExpFlag(exp, flag)
  case REDUCTION     then expTypeFromExpFlag(expr, flag)
  case _             then "expTypeFromExpFlag:ERROR"

expTypeFromOpFlag(Operator, Integer flag) ::=
  case o as ADD
  case o as SUB
  case o as MUL
  case o as DIV
  case o as POW
  case o as UMINUS
  case o as UPLUS
  case o as UMINUS_ARR
  case o as UPLUS_ARR
  case o as ADD_ARR
  case o as SUB_ARR
  case o as MUL_ARR
  case o as DIV_ARR
  case o as MUL_SCALAR_ARRAY
  case o as MUL_ARRAY_SCALAR
  case o as ADD_SCALAR_ARRAY
  case o as ADD_ARRAY_SCALAR
  case o as SUB_SCALAR_ARRAY
  case o as SUB_ARRAY_SCALAR
  case o as MUL_SCALAR_PRODUCT
  case o as MUL_MATRIX_PRODUCT
  case o as DIV_ARRAY_SCALAR
  case o as DIV_SCALAR_ARRAY
  case o as POW_ARRAY_SCALAR
  case o as POW_SCALAR_ARRAY
  case o as POW_ARR
  case o as POW_ARR2
  case o as LESS
  case o as LESSEQ
  case o as GREATER
  case o as GREATEREQ
  case o as EQUAL
  case o as NEQUAL then
    expTypeFlag(o.ty, flag)
  case o as AND
  case o as OR
  case o as NOT then
    if flag is 1 then "boolean" else "modelica_boolean"
  case _ then "expTypeFromOpFlag:ERROR"

end SimCodeC;
// vim: filetype=susan sw=2 sts=2
