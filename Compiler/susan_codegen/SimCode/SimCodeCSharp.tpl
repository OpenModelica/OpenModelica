// This file defines templates for transforming Modelica code to C# code.

spackage SimCodeCSharp

typeview "SimCodeTV.mo"

// SECTION: SIMULATION TARGET, ROOT TEMPLATE

translateModel(SimCode simCode) ::=
  case SIMCODE(modelInfo = MODELINFO) then
    # csFileContent = csFile(simCode)
    # textFile(csFileContent, '<modelInfo.name>.cs')
    () // empty result of the top-level template .., only side effects


// SECTION: SIMULATION TARGET, C# FILE SPECIFIC TEMPLATES

csFile(SimCode simCode) ::=
case sc as SIMCODE(modelInfo = MODELINFO) then
<<
// Simulation code for <modelInfo.name> generated by the OpenModelica Compiler.

using System;
using Physiome.Solvers;
namespace Physiome.Models
{
    public class <modelInfo.name> : DAESystem
    {
         
    <modelDataMembers(modelInfo)>

    <functionDaeOutput(nonStateContEquations, removedEquations)>

    <functionDaeOutput2(nonStateDiscEquations, removedEquations)>

    <functionInput(modelInfo)>

    <functionOutput(modelInfo)>

    <functionZeroCrossing(zeroCrossings)>

    <functionHandleZeroCrossing(zeroCrossingsNeedSave)>

    <functionUpdateDependents(allEquations, helpVarInfo)>
    
    <functionUpdateDepend(allEquations, helpVarInfo)>

    <functionOnlyZeroCrossing(zeroCrossings)>

    <functionWhen(whenClauses)>

    <functionOde(stateContEquations)>

    <functionInitial(initialEquations)>

    <functionInitialResidual(residualEquations)>
    
    <functionExtraResudials(allEquations)>
    
    <functionBoundParameters(parameterEquations)>

    <functionCheckForDiscreteVarChanges(sc.helpVarInfo, sc.discreteModelVars)>
    
    }
}
>>

modelDataMembers(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
const int 
  NHELP = <varInfo.numHelpVars>, NG = <varInfo.numZeroCrossings>,
  NX = <varInfo.numStateVars>, NY = <varInfo.numAlgVars>, NP = <varInfo.numParams>,
  NO = <varInfo.numOutVars>, NI = <varInfo.numInVars>, NR = <varInfo.numResiduals>,
  NEXT = <varInfo.numExternalObjects>, NYSTR = <varInfo.numStringAlgVars>, NPSTR = <varInfo.numStringParamVars>;

public override string ModelName  { get { return "<name>"; }}
public override int HelpVarsCount      { get { return NHELP; } }
public override int ZeroCrossingsCount { get { return NG; } }
public override int StatesCount        { get { return NX; } }
public override int AlgebraicsCount    { get { return NY; } }
public override int ParametersCount    { get { return NP; } }
        
public override int OutputsCount   { get { return NO; } }
public override int InputsCount    { get { return NI; } }
public override int ResidualsCount { get { return NR; } }
//public int ExternalObjectsCount { get { return NEXT; } }        
public override int MaximumOrder { get { return 5; } }
public override int StringVarsCount { get { return NYSTR; } }
public override int StringParametersCount { get { return NPSTR; } }


public <name>() {
    states = new double[NX];
    statesDerivatives = new double[NX];
    algebraics = new double[NY];
    parameters = new double[NP];
    initialResiduals = new double[NR];
    helpVars = new double[NHELP];

    oldStates = new double[NX];
    oldStatesDerivatives = new double[NX];
    oldAlgebraics = new double[NY];

    oldStates2 = new double[NX];
    oldStatesDerivatives2 = new double[NX];
    oldAlgebraics2 = new double[NY];

    tempStatesDerivatives = new double[NX];
    
    gout                    = new double[NG];    //array of length zerocrossingcount 
    savedHelpVars           = new double[NHELP]; //array of length HelpVarsCount
    savedStates             = new double[NX];    //length StatesCount
    savedStatesDerivatives  = new double[NX];    //length StetesCount
    savedAlgebraics         = new double[NY];     //length AlgebraicsCount
    
    //TODO: ?? how many events are there ?
    eventQueue = new EventQueue(NG + NHELP);
    
    initialFixed = new bool[NX+NX+NY+NP] {
       <[ if vars.stateVars      then "//states\n" + initFixed(vars.stateVars),
          if vars.derivativeVars then "//derivatives\n" + initFixed(vars.derivativeVars),
          if vars.algVars        then "//algebraics\n" + initFixed(vars.algVars), 
          if vars.paramVars      then "//parameters\n" + initFixed(vars.paramVars)
        ] ",\n">
    };
}

<vars.stateVars of SIMVAR: <<
public double <cref(name)> { get { return states[<index>]; } set { states[<index>] = value; }}
>> \n>
<vars.derivativeVars of SIMVAR: <<
public double <cref(name)> { get { return statesDerivatives[<index>]; } set { statesDerivatives[<index>] = value; }}
>> \n>
  
<vars.algVars of SIMVAR: <<
public double <cref(name)> { get { return algebraics[<index>]; } set { algebraics[<index>] = value; }}
public double Pre_<cref(name)> { get { return savedAlgebraics[<index>]; } set { savedAlgebraics[<index>] = value; }}
>> \n>
<vars.paramVars of SIMVAR: <<
public double <cref(name)> { get { return parameters[<index>]; } set { parameters[<index>] = value; }}
>> \n>

</*
    //a kind of SimulationVarInfo list will be created here
    //and statically promoted to interface/override implementation
	<utilStaticStringArray("StateNames", vars.stateVars)>
	<utilStaticStringArray("DerivativeNames", vars.derivativeVars)>
	<utilStaticStringArray("AlgvarsNames", vars.algVars)>
	<utilStaticStringArray("InputNames", vars.inputVars)>
	<utilStaticStringArray("OutputNames", vars.outputVars)>
	<utilStaticStringArray("ParamNames", vars.paramVars)>
	<utilStaticStringArray("StringAlgNames", vars.stringAlgVars)>
	<utilStaticStringArray("StringParamNames", vars.stringParamVars)>
	
	<utilStaticStringArrayComment("StateComments", vars.stateVars)>
	<utilStaticStringArrayComment("DerivativeComments", vars.derivativeVars)>
	<utilStaticStringArrayComment("algvars_comments", vars.algVars)>
	<utilStaticStringArrayComment("input_comments", vars.inputVars)>
	<utilStaticStringArrayComment("output_comments", vars.outputVars)>
	<utilStaticStringArrayComment("param_comments", vars.paramVars)>
	<utilStaticStringArrayComment("string_alg_comments", vars.stringAlgVars)>
	<utilStaticStringArrayComment("string_param_comments", vars.stringParamVars)>
*/>

>>

initFixed(list<SimVar> simVarLst) ::=
  (simVarLst of SIMVAR: '<isFixed> /* <cref(origName)> */' ",\n")

functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for continuous time variables */
public override void FunDAEOutput()
{
  <nonStateContEquations : equation_(it,contextSimulationNonDescrete) \n>
  <removedEquations      : equation_(it,contextSimulationNonDescrete) \n>
}
>>

functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for discrete time variables */
 public override void FunDAEOutput2()
{
  <nonStateDiscEquations : equation_(it,contextSimulationDescrete) \n>
  <removedEquations      : equation_(it,contextSimulationDescrete) \n>
}
>>

functionInput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void InputFun()
{
  <vars.inputVars of SIMVAR : 
  <<
  <cref(origName)> = inputVars[<i0>];
  >> \n>
}
>>

functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void OutputFun()
{
  <vars.outputVars of SIMVAR :
  <<
  outputVars[<i0>] = <cref(origName)>;
  >> \n>
}
>>


functionZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunZeroCrossing(double t, double[] x, double[] xd, double[] gout)
{
  var timeBackup = time;
  time = t;

  FunODE();
  FunDAEOutput();
  
  <zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n>  

  time = timeBackup;
}
>>

// This function should only save in cases. The rest is done in
// function_updateDependents.
functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
<<
public override void FunHandleZeroCrossing(int index)
{  
  switch(index) {
    <zeroCrossingsNeedSave of vars:
    <<
    case <i0>:
      <vars of SIMVAR: 'Pre_<cref(name)> = <cref(name)>; //save()' \n>
      break;
    >> \n>
    default:
       break;
  }
}
>>

functionUpdateDependents(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDependents()
{
  //inUpdate=initial()?0:1;
  isInUpdate = ! isInit;

  <allEquations : equation_(it, contextSimulationDescrete) \n>
  <helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <preExp>
      helpVars[<in1>] = <expPart>;
      >>
  \n>

  isInUpdate = false;
}
>>

// All when equations should go in here too according to Willi
// And something about if-eqs being sorted ans not just added to end
functionUpdateDepend(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDepend()
{
  isInUpdate = ! isInit;
  
  <allEquations : equation_(it, contextSimulationDescrete) \n>
  <helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <preExp>
      helpVars[<in1>] = <expPart>;
      >>
  \n>

  isInUpdate = false;
}
>>

functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunOnlyZeroCrossings(double t, double[] gout)
{
  <zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n>  
}
>>

zeroCrossing(Exp, Integer index) ::=
  case RELATION then
    # preExp = ""
    # e1 = daeExp(exp1, contextOther, preExp)
    # e2 = daeExp(exp2, contextOther, preExp)
    <<
    {//ZEROCROSSING(<index>, <zeroCrossingOpFunc(operator)>(<e1>, <e2>));
     <preExp>
     var _zen = zeroCrossingEnabled[<index>];
     gout[<index>] = (_zen != 0) ? _zen * (<match operator
                                            case LESS
                                            case LESSEQ    then '<e1>-<e2>'
                                            case GREATER
                                            case GREATEREQ then '<e2>-<e1>'
                                           >) : 1.0;
    }
    >>    
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = ""
    # e1 = daeExp(start, contextOther, preExp)
    # e2 = daeExp(interval, contextOther, preExp)
    <<
    {//ZEROCROSSING(<index>, Sample(*t, <e1>, <e2>));
     <preExp>
     var _zen = zeroCrossingEnabled[<index>];
     gout[<index>] = (_zen != 0) ? _zen * Sample(t, e1, e2) : 1.0;
    }
    >> 
  case _ then
    <<
    ZERO_CROSSING_ERROR
    >>

zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"


functionWhen(list<SimWhenClause> whenClauses) ::=
# System.tmpTickReset(1)
<<
public override void FunWhen(int i)
{
  switch(i) {
    <whenClauses of SIM_WHEN_CLAUSE :
    <<
    case <i0>:
      <functionWhen_caseEquation(whenEq)>
      <reinits of REINIT :
        # preExp = ""
        # valueExp = daeExp(value, contextSimulationDescrete, preExp)
      <<
      <preExp>
      <cref(stateVar)> = <valueExp>;
      >> \n>
      break;
    >> \n>
    default:
      break;
  }
}
>>

functionWhen_caseEquation(Option<WhenEquation>) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, contextSimulationDescrete, preExp)
<<
Pre_<cref(weq.left)> = <cref(weq.left)>; //save()
<preExp>
<cref(weq.left)> = <expPart>;
>>



functionOde(list<SimEqSystem> stateContEquations) ::=
# System.tmpTickReset(1)
<<
public override void FunODE()
{
  <stateContEquations : equation_(it, contextOther) \n>
}
>>

functionInitial(list<SimEqSystem> initialEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialFun()
{
  <initialEquations of SES_SIMPLE_ASSIGN: equation_(it, contextOther) \n>

  //if (sim_verbose) {
    <initialEquations of SES_SIMPLE_ASSIGN:
    <<
    //Debug.WriteLine("Setting variable start value: {0}(start={1})", "<cref(componentRef)>", <cref(componentRef)>);
    >> \n>
  //}
}
>>

functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialResidual()
{
  int _i = 0;

  <residualEquations of SES_RESIDUAL :
    if exp is DAE.SCONST then
      'initialResiduals[_i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationNonDescrete, preExp) // ??contextOther
      <<
      <preExp>
      initialResiduals[_i++] = <expPart>;
      >>
  \n>
}
>>

functionExtraResudials(list<SimEqSystem> allEquations) ::=
# System.tmpTickReset(1)
(allEquations of SES_NONLINEAR:
<<
void ResidualFun<index>(int n, double[] xloc, double[] res, int iflag)
{
   <eqs of SES_RESIDUAL :
     # preExp = ""
     # expPart = daeExp(exp, contextSimulationDescrete, preExp)
   <<
   <preExp>
   res[<i0>] = <expPart>;
   >> \n>
}
>> \n)



functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# System.tmpTickReset(1)
<<
public override void BoundParameters()
{
  <parameterEquations of SES_SIMPLE_ASSIGN : equation_(it, contextOther) \n>
}
>>

// TODO: Is the -1 thing really correct? It seems to work.
functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfoLst,
                                   list<ComponentRef> discreteModelVars) ::=
<<
public override bool CheckForDiscreteVarChanges()
{
  var needToIterate = false;

  //edge(helpVars[i])
  <helpVarInfoLst of (id1, exp, id2):
  if id2 is not -1 then
  <<
  if (helpVars[<id1>]!=0.0 && savedHelpVars[<id1>]==0.0) AddEvent(<id2> + NG);
  >> \n>

  //TODO: changeDiscreteVar(i) and to get the i from ComponentRef
  //if change()
  <discreteModelVars :
  <<
  if (Pre_<cref(it)> != <cref(it)>)) return true; /*needToIterate = true; */
  >> \n>
  
  var _hvs = helpVars;
  var _shvs = savedHelpVars;
  for (int i = 0; i \< _hvs.Length; i++) {
    //change(helpVars[i]) ?? TODO: not sure if it can be only 1.0 or 0.0
    if (_hvs[i] != _shvs[i])
      return true; //needToIterate=true;
  }

  return needToIterate;
}
>>


// Residual equations are not handled here
equation_(SimEqSystem eq, Context context) ::=
case SES_SIMPLE_ASSIGN then
  # preExp = ""
  # expPart = daeExp(exp, context, preExp)
  <<
  <preExp>
  <cref(componentRef)> = <expPart>;
  >>
case _ then
  <<
  equation_NOT_YET_IMPLEMENTED
  >>

// SECTION: SIMULATION TARGET, FUNCTIONS FILE SPECIFIC TEMPLATES
// not yet implemented

// SECTION: GENERAL TEMPLATES, COMPONENT REFERENCES

cref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case _ then "CREF_NOT_IDENT"

crefSubscript(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident) + subscripts(subscriptLst)
  case _ then "CREF_NOT_IDENT"

subscripts(list<Subscript> subscriptsLst) ::=
  if subscriptsLst then '[<subscriptsLst : subscript() ",">]'

subscript(Subscript) ::=
  case INDEX(exp = ICONST) then exp.integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"


// SECTION: GENERAL TEMPLATES, PATHS

dotPath(Path) ::=
  case QUALIFIED      then '<name>.<dotPath(path)>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)

underscorePath(Path) ::=
  case QUALIFIED      then '<System.stringReplace(name, "_", "__")>_<underscorePath(path)>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)


// SECTION: GENERAL TEMPLATES, FUNCTION GENERATION
// not yet implemented




// Codegen.generateStatement
algStatement(DAE.Statement, Context context) ::=
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD), exp = e) then
    # preExp = "" 
    # expPart = daeExp(e, context, preExp)
    <<
    <preExp>
    <expPart>
    >>    
  case STMT_ASSIGN(exp1 = CREF) then
    # preExp = ""
    # expPart = daeExp(exp, context, preExp)
    <<
    <preExp>
    <scalarLhsCref(exp1, context, preExp)> = <expPart>;
    >>
  case STMT_ASSIGN then
    # preExp = ""
    # expPart1 = daeExp(exp1, context, preExp)
    # expPart2 = daeExp(exp, context, preExp)
    <<
    <preExp>
    <expPart1> = <expPart2>;
    >>
  case STMT_IF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    <preExp>
    if (<condExp>) {
      <statementLst : algStatement(it, context) \n>
    }
    <elseExpr(else_, context)>
    >>
  case _ then "NOT_IMPLEMENTED_ALG_STATEMENT"
 /*
  case STMT_FOR(exp = rng as RANGE) then
    <<
    {
      <expTypeA(type_, boolean)> 
        _r1 = <daeExp(rng.exp,isSimulationCode)>,
        _r2 = <if rng.expOption is SOME(eo) then daeExp(eo,isSimulationCode) else "(1)">,
        _r3 = <daeExp(rng.range,isSimulationCode)>,
        <ident>;

      for (<ident> = _r1; in_range_<expShortType(type_)>(<ident>, _r1, _r3); <ident> += _r2) {
        <statementLst : algStatement() \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ >        
      }
    } /*end for*/
    >>
  */

elseExpr(DAE.Else, Context context) ::= 
  case NOELSE then ()
  case ELSEIF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    else {
    <preExp>
    if (<condExp>)) {
      <statementLst : algStatement(it, context) \n>
    }
    <elseExpr(else_, context)>
    }
    >>
  case ELSE then
    <<
    else {
      <statementLst : algStatement(it, context) \n>
    }
    >>
    
//try this
/*
foo(list<Exp> exps, list<Integer> ints, Text varDecls) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp, varDecls) 
    <<
    <preExp>
    localData-\>helpVars[<firstInt>] = <expPart>;
    <foo(restExps, restInts, preExp, varDecls)>
    >>
*/
foo(list<Exp> exps, list<Integer> ints) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp)
    <<
    <preExp>
    localData->helpVars[<firstInt>] = <expPart>;
    <foo(restExps, restInts)>
    >>


scalarLhsCref(Exp cref, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(cref.componentRef) then
    cref(cref.componentRef)
  else
    daeExpCrefRhs(cref, context, preExp)
case _ then
  "ONLY IDENT SUPPORTED"

/*
scalarLhsCref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case CREF_QUAL  then '<ident>.<scalarLhsCref(componentRef)>'
*/

//TODO: this wrong for qualified integers !
rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<rhsCrefType(ty)><replaceDollarWorkaround(ident)>'
  case CREF_QUAL  then '<rhsCrefType(ty)><ident>.<rhsCref(componentRef,ty)>'
  case _          then "rhsCref:ERROR"

rhsCrefType(ExpType) ::=
  case ET_INT then "(int)"
  case _      then ""


replaceDollarWorkaround(String ident) ::=
  stringReplace(
    stringReplace(ident,"$DER","Der_"), 
    "$", "")

// SECTION: GENERAL TEMPLATES, EXPRESSIONS
  
daeExp(Exp exp, Context context, Text preExp) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then '"<Util.escapeModelicaStringToCString(string)>"'
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then daeExpCrefRhs(it, context, preExp)
  case LBINARY
  case BINARY     then daeExpBinary(operator, exp1, exp2, context, preExp)
  case LUNARY
  case UNARY      then daeExpUnary(operator, exp, context, preExp)
  case RELATION   then daeExpRelation(operator, exp1, exp2, context, preExp)
  case IFEXP      then daeExpIf(expCond, expThen, expElse, context, preExp)
  case CALL       then daeExpCall(exp, context, preExp)
  // PARTEVALFUNCTION
  case ARRAY      then "ARRAY_NOT_IMPLEMENTED" //daeExpArray(ty, scalar, array)
  case MATRIX     then "MATRIX_NOT_IMPLEMENTED"
  case RANGE      then "RANGE_NOT_IMPLEMENTED"
  case TUPLE      then "TUPLE_NOT_IMPLEMENTED"
  case CAST       then "CAST_NOT_IMPLEMENTED"
  case ASUB       then "ASUB_NOT_IMPLEMENTED"
  case SIZE       then "SIZE_NOT_IMPLEMENTED"
  case CODE       then "CODE_NOT_IMPLEMENTED"
  case REDUCTION  then "REDUCTION_NOT_IMPLEMENTED"
  case END        then "END_NOT_IMPLEMENTED"
  case VALUEBLOCK then "VALUEBLOCK_NOT_IMPLEMENTED"
  case LIST       then "LIST_NOT_IMPLEMENTED"
  case CONS       then "CONS_NOT_IMPLEMENTED"
  // META_TUPLE
  // META_OPTION
  // METARECORDCALL
  case _          then "UNKNOWN_EXP"
  
daeExpCrefRhs(Exp exp, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if daeExpCrefRhsArrayBox(exp, context, preExp) then
    it
  else if crefNoSub(cref.componentRef) then
    <<
    <if cref.ty is ET_INT then "(int)"
    ><cref(cref.componentRef)>
    >>
  else if crefSubIsScalar(cref.componentRef) then
    // The array subscript results in a scalar
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # dimsLenStr = listLength(subs)
    # dimsValuesStr = (subs of INDEX: daeExp(exp, context, preExp) ", ")
    <<
    !!!TODO:(*<arrayType>_element_addr(&<arrName>, <dimsLenStr>, <dimsValuesStr>))
    >>
  else
    // The array subscript denotes a slice
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # spec1 = daeExpCrefRhsIndexSpec(subs, context, preExp)
    # tmp = ""
    # preExp += '!!!TODO: <tempDecl(arrayType, tmp)> = index_alloc_<arrayType>(&<arrName>, &<spec1>, &<tmp>);<\n>'
    tmp
case _ then
  "UNKNOWN RHS CREF: ONLY IDENT SUPPORTED"

daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context, Text preExp) ::=
# nridx_str = listLength(subs)
# idx_str = (subs :
               case INDEX then
                 # expPart = daeExp(exp, context, preExp)
                 <<
                 (1), make_index_array(1, <expPart>), 'S'
                 >>
               case WHOLEDIM then
                 <<
                 (1), (0), 'W'
                 >>
               case SLICE then
                 # expPart = daeExp(exp, context, preExp)
                 # tmp = ""
                 # preExp += '!!!TODO:<tempDecl("int", tmp)> = size_of_dimension_integer_array(<expPart>, 1);<\n>'
                 <<
                 <tmp>, integer_array_make_index_array(&<expPart>), 'A'
                 >>
             ", ")
# tmp = "" 
# preExp += '!!!TODO:<tempDecl("index_spec_t", tmp)> = create_index_spec(&<tmp>, <nridx_str>, <idx_str>);<\n>'
tmp

daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = ""
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of SOME(i): i ", ")
    # preExp += '!!!TODO:<tempDecl(expTypeArray(aty), tmpArr)> = <expShortType(aty)>_array_create(&<tmpArr>, &<cref(cref.componentRef)>, <dimsLenStr>, <dimsValuesStr>);<\n>'
    tmpArr

    

daeExpBinary(Operator, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  case ADD then '(<e1> + <e2>)'
  case SUB then '(<e1> - <e2>)'
  case MUL then '(<e1> * <e2>)'
  case DIV then '(<e1> / <e2>)'
  case POW then 'Math.Pow(<e1>, <e2>)'
  case AND then '(<e1> && <e2>)'
  case OR  then '(<e1> || <e2>)'
  case _   then "daeExpBinary:ERR"

daeExpUnary(Operator, Exp exp, Context context, Text preExp) ::=
  # e = daeExp(exp, context, preExp)
  case UMINUS     then '(-<e>)'
  case UPLUS      then '(<e>)'
  case NOT        then '(!<e>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

daeExpRelation(Operator op, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  if context is SIMULATION then
	# op1 = match op
            case LESS      then " < "
            case LESSEQ    then " <= "
            case GREATER   then " > "
            case GREATEREQ then " >= "
            case _ then " daeExpRelation:ERR1 "
	# op2 = match op
	        case LESS     case LESSEQ    then " <"
	        case GREATER  case GREATEREQ then " >"
	        case _ then "daeExpRelation:ERR2" 
	# res = ""    
	# preExp += 
	    <<
	    // RELATION( <e1><op1><e2> ) macro expansion
	    <tempDecl("bool", res)>; 
	    if (isInUpdate) {
	       <res> = <e1><op2> <e2>;
	       if(!<res> && (<e1><op2>= <e2>)) {
	         var timeBackup = time; var statesBackup = states; var statesDerivativesBackup = statesDerivatives; var algebraicsBackup = algebraics;
	         time = oldTime; states = oldStates; statesDerivatives = oldStatesDerivatives; algebraics = oldAlgebraics;
	         double res1 = <e1> - <e2>;  time = oldTime2; states = oldStates2; statesDerivatives = oldStatesDerivatives2; algebraics = oldAlgebraics2;
	         double res2 = <e1> - <e2>;  time = timeBackup; states = statesBackup; statesDerivatives = statesDerivativesBackup; algebraics = algebraicsBackup;
	         <res> = res1<op2>= res2;
	       }
	    } else
	       <res> = <e1><op1><e2>;
	    >>
	res  
  else 
    match op
    case LESS(ty = ET_BOOL)        then '(!<e1> && <e2>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)
    case LESS(ty = ET_REAL)        then '(<e1> \< <e2>)'
    case GREATER(ty = ET_BOOL)     then '(<e1> && !<e2>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)
    case GREATER(ty = ET_REAL)     then '(<e1> > <e2>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<e1> || <e2>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)
    case LESSEQ(ty = ET_REAL)      then '(<e1> \<= <e2>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<e1> || !<e2>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)
    case GREATEREQ(ty = ET_REAL)   then '(<e1> >= <e2>)'
    case EQUAL(ty = ET_BOOL)       then '((!<e1> && !<e2>) || (<e1> && <e2>))'
    case EQUAL(ty = ET_STRING)
    case EQUAL(ty = ET_INT)
    case EQUAL(ty = ET_REAL)       then '(<e1> == <e2>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<e1> && <e2>) || (<e1> && !<e2>))'
    case NEQUAL(ty = ET_STRING)
    case NEQUAL(ty = ET_INT)
    case NEQUAL(ty = ET_REAL)      then '(<e1> != <e2>)'
    case _                         then "daeExpRelation:ERR"

daeExpIf(Exp cond, Exp then_, Exp else_, Context context, Text preExp) ::=
<<
(<daeExp(cond, context, preExp)
  > ? <daeExp(then_, context, preExp)> : <daeExp(else_, context, preExp)>)
>>

daeExpCall(Exp, Context context, Text preExp) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    //# retType = expType(arg.ty)
    <<
    <if arg.ty is ET_INT then "(int)"
    >Pre_<cref(arg.componentRef)>
    >>
  // TODO: add more special builtins (Codegen.generateBuiltinFunction)
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # preExp += '<underscorePrefix(builtin)><underscorePath(path)>(<argStr>);<\n>'
    <<
    /* NORETCALL */
    >>
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # funName = underscorePath(path)
    <<
    <underscorePrefix(builtin)
    ><funName>(argStr)<if not builtin then '!!!TODO:.<funName>_rettype_1'>
    >>
  case _ then "daeExpCall:NOT_YET_IMPLEMENTED"
    

underscorePrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"

// SECTION: GENERAL TEMPLATES, TEMPORARY VARIABLES

//newVar parameter is assumed to be empty or it can hold an identifier prefix
tempDecl(String ty, Text newVar) ::=
  # newVar += '_tmp<System.tmpTick()>'
  <<
  <ty> <newVar>
  >>
  


// SECTION: GENERAL TEMPLATES, TYPES

// TODO: Check with Codegen
expShortType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_STRING then "string"
  case ET_BOOL   then "bool"
  case ET_OTHER  then "#complex#"
  case ET_ARRAY then expShortType(ty)   
  case ET_COMPLEX then '/*struct*/<name>'  

expTypeArray(DAE.ExpType ty) ::=
<<
<expShortType(ty)>[]
>>

/*
// TODO: Check with Codegen
expType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_BOOL   then "bool"
  case ET_STRING then "string"
  case ET_COMPLEX(complexClassType = EXTERNAL_OBJ)  then "#complex external obj#" 
  case ET_OTHER  then "#OTHER type#"
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
  case ET_ARRAY then 
    match ty
    case ET_INT    then "int[]"
    case ET_REAL   then "double[]"
    case ET_STRING then "string[]"
    case ET_BOOL   then "bool[]"

// TODO: Check with Codegen (expTypeStr)
expTypeA(DAE.ExpType, Boolean isArray) ::=
  case ET_COMPLEX     then expShortType() // i.e. 'struct <name>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
*/


end SimCodeCSharp;
// vim: filetype=susan sw=2 sts=2
