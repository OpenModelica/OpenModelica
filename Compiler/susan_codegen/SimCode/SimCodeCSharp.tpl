// This file defines templates for transforming Modelica code to C# code.

spackage SimCodeCSharp

typeview "SimCodeTV.mo"

// SECTION: SIMULATION TARGET, ROOT TEMPLATE

template translateModel(SimCode simCode) ::=
  case SIMCODE(modelInfo = MODELINFO) then
    # csFileContent = csFile(simCode)
    # textFile(csFileContent, '<%modelInfo.name%>.cs')
    () // empty result of the top-level template .., only side effects
end translateModel;


// SECTION: SIMULATION TARGET, C# FILE SPECIFIC TEMPLATES

template csFile(SimCode simCode) ::=
case sc as SIMCODE(modelInfo = MODELINFO) then
<<
// Simulation code for <%modelInfo.name%> generated by the OpenModelica Compiler.

using System;
using Bodylight.Solvers;
namespace Bodylight.Models
{
  public partial class <%modelInfo.name%> : DAESystem
  {
         
    <%modelDataMembers(modelInfo)%>

    <%functionDaeOutput(nonStateContEquations, removedEquations)%>

    <%functionDaeOutput2(nonStateDiscEquations, removedEquations)%>

    <%functionInput(modelInfo)%>

    <%functionOutput(modelInfo)%>

    <%functionZeroCrossing(zeroCrossings)%>

    <%functionHandleZeroCrossing(zeroCrossingsNeedSave)%>

    <%functionUpdateDependents(allEquations, helpVarInfo)%>
    
    <%functionUpdateDepend(allEquations, helpVarInfo)%>

    <%functionOnlyZeroCrossing(zeroCrossings)%>

    <%functionStoreDelayed()%>
    
    <%functionWhen(whenClauses)%>

    <%functionOde(stateContEquations)%>

    <%functionInitial(initialEquations)%>

    <%functionInitialResidual(residualEquations)%>
    
    <%functionExtraResudials(allEquations)%>
    
    <%functionBoundParameters(parameterEquations)%>

    <%functionCheckForDiscreteVarChanges(sc.helpVarInfo, sc.discreteModelVars)%>
    
  }
}
>>
end csFile;

template modelDataMembers(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
const int 
  NHELP = <%varInfo.numHelpVars%>, NG = <%varInfo.numZeroCrossings%>,
  NX = <%varInfo.numStateVars%>, NY = <%varInfo.numAlgVars%>, NP = <%varInfo.numParams%>,
  NO = <%varInfo.numOutVars%>, NI = <%varInfo.numInVars%>, NR = <%varInfo.numResiduals%>,
  NEXT = <%varInfo.numExternalObjects%>, NYSTR = <%varInfo.numStringAlgVars%>, NPSTR = <%varInfo.numStringParamVars%>;

public override string ModelName  { get { return "<%name%>"; }}
public override int HelpVarsCount      { get { return NHELP; } }
public override int ZeroCrossingsCount { get { return NG; } }
public override int StatesCount        { get { return NX; } }
public override int AlgebraicsCount    { get { return NY; } }
public override int ParametersCount    { get { return NP; } }
        
public override int OutputsCount   { get { return NO; } }
public override int InputsCount    { get { return NI; } }
public override int ResidualsCount { get { return NR; } }
//public int ExternalObjectsCount { get { return NEXT; } }        
public override int MaximumOrder { get { return 5; } }
public override int StringVarsCount { get { return NYSTR; } }
public override int StringParametersCount { get { return NPSTR; } }

<%vars.stateVars of SIMVAR: <<
public double <%cref(name)%> { get { return states[<%index%>]; } set { states[<%index%>] = value; }}
>> \n%>
<%vars.derivativeVars of SIMVAR: <<
public double <%cref(name)%> { get { return statesDerivatives[<%index%>]; } set { statesDerivatives[<%index%>] = value; }}
>> \n%>
  
<%vars.algVars of SIMVAR: <<
public double <%cref(name)%> { get { return algebraics[<%index%>]; } set { algebraics[<%index%>] = value; }}
public double Pre_<%cref(name)%> { get { return savedAlgebraics[<%index%>]; } set { savedAlgebraics[<%index%>] = value; }}
>> \n%>
<%vars.paramVars of SIMVAR: <<
public double <%cref(name)%> { get { return parameters[<%index%>]; } set { parameters[<%index%>] = value; }}
>> \n%>

private static readonly SimVarInfo[] VariableInfosStatic = new[] {
	<%[  
		(vars.stateVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.State, <%index%>, false)
		>> ",\n"),
		(vars.derivativeVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.StateDer, <%index%>, false)
		>> ",\n"),
		(vars.algVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.Algebraic, <%index%>, false)
		>> ",\n"),
		(vars.paramVars of SIMVAR: <<
		new SimVarInfo( "<%crefSubscript(origName)%>", "<%comment%>", SimVarType.Parameter, <%index%>, true)
		>> ",\n")
	] ",\n\n"%>
};
public override SimVarInfo[] VariableInfos { get { return VariableInfosStatic; } }

private static readonly bool[] InitialFixedStatic = new bool[NX + NX + NY + NP] {
    <%[ if vars.stateVars      then "//states\n" + initFixed(vars.stateVars),
       if vars.derivativeVars then "//derivatives\n" + initFixed(vars.derivativeVars),
       if vars.algVars        then "//algebraics\n" + initFixed(vars.algVars), 
       if vars.paramVars      then "//parameters\n" + initFixed(vars.paramVars)
     ] ",\n"%>
};
public override bool[] InitialFixed { get { return InitialFixedStatic; } }

public <%name%>() {
    CreateData();
}

<%/*
    //a kind of SimulationVarInfo list will be created here
    //and statically promoted to interface/override implementation
	<%utilStaticStringArray("StateNames", vars.stateVars)%>
	<%utilStaticStringArray("DerivativeNames", vars.derivativeVars)%>
	<%utilStaticStringArray("AlgvarsNames", vars.algVars)%>
	<%utilStaticStringArray("InputNames", vars.inputVars)%>
	<%utilStaticStringArray("OutputNames", vars.outputVars)%>
	<%utilStaticStringArray("ParamNames", vars.paramVars)%>
	<%utilStaticStringArray("StringAlgNames", vars.stringAlgVars)%>
	<%utilStaticStringArray("StringParamNames", vars.stringParamVars)%>
	
	<%utilStaticStringArrayComment("StateComments", vars.stateVars)%>
	<%utilStaticStringArrayComment("DerivativeComments", vars.derivativeVars)%>
	<%utilStaticStringArrayComment("algvars_comments", vars.algVars)%>
	<%utilStaticStringArrayComment("input_comments", vars.inputVars)%>
	<%utilStaticStringArrayComment("output_comments", vars.outputVars)%>
	<%utilStaticStringArrayComment("param_comments", vars.paramVars)%>
	<%utilStaticStringArrayComment("string_alg_comments", vars.stringAlgVars)%>
	<%utilStaticStringArrayComment("string_param_comments", vars.stringParamVars)%>
*/%>

>>
end modelDataMembers;

template initFixed(list<SimVar> simVarLst) ::=
  (simVarLst of SIMVAR: '<%isFixed%> /* <%crefSubscript(origName)%> */' ",\n")
end initFixed;

template functionDaeOutput(list<SimEqSystem> nonStateContEquations,
                  list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for continuous time variables */
public override void FunDAEOutput()
{
  <%nonStateContEquations : equation_(it,contextSimulationNonDescrete) \n%>
  <%removedEquations      : equation_(it,contextSimulationNonDescrete) \n%>
}
>>
end functionDaeOutput;

template functionDaeOutput2(list<SimEqSystem> nonStateDiscEquations,
                   list<SimEqSystem> removedEquations) ::=
# System.tmpTickReset(1)
<<
/* for discrete time variables */
public override void FunDAEOutput2()
{
  <%nonStateDiscEquations : equation_(it,contextSimulationDescrete) \n%>
  <%removedEquations      : equation_(it,contextSimulationDescrete) \n%>
}
>>
end functionDaeOutput2;

template functionInput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void InputFun()
{
  <%vars.inputVars of SIMVAR : 
  <<
  <%cref(name)%> = inputVars[<%i0%>];
  >> \n%>
}
>>
end functionInput;

template functionOutput(ModelInfo modelInfo) ::=
case MODELINFO(varInfo = VARINFO, vars = SIMVARS) then
<<
public override void OutputFun()
{
  /* not yet
  <%vars.outputVars of SIMVAR :
  <<
  outputVars[<%i0%>] = <%cref(name)%>;
  >> \n%>
  */
}
>>
end functionOutput;

template functionZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunZeroCrossing(double time, double[] x, double[] xd, double[] gout)
{
  var timeBackup = this.time;
  this.time = time;

  FunODE();
  FunDAEOutput();
  
  <%zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n%>  

  this.time = timeBackup;
}
>>
end functionZeroCrossing;

// This function should only save in cases. The rest is done in
// function_updateDependents.
template functionHandleZeroCrossing(list<list<SimVar>> zeroCrossingsNeedSave) ::=
<<
public override void FunHandleZeroCrossing(int index)
{  
  switch(index) {
    <%zeroCrossingsNeedSave of vars:
    <<
    case <%i0%>:
      <%vars of SIMVAR: 'Pre_<%cref(name)%> = <%cref(name)%>; //save()' \n%>
      break;
    >> \n%>
    default:
       break;
  }
}
>>
end functionHandleZeroCrossing;

template functionUpdateDependents(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDependents()
{
  //inUpdate=initial()?0:1;
  isInUpdate = ! isInit;

  <%allEquations : equation_(it, contextSimulationDescrete) \n%>
  <%helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      helpVars[<%in1%>] = <%expPart%> ? 1.0 : 0.0;<%/*???TODO: ? 1.0 : 0.0;*/%>
      >>
  \n%>

  isInUpdate = false;
}
>>
end functionUpdateDependents;

// All when equations should go in here too according to Willi
// And something about if-eqs being sorted ans not just added to end
template functionUpdateDepend(list<SimEqSystem> allEquations, list<HelpVarInfo> helpVarInfoLst) ::=
# System.tmpTickReset(1)
<<
public override void FunUpdateDepend()
{
  isInUpdate = ! isInit;
  
  <%allEquations : equation_(it, contextSimulationDescrete) \n%>
  <%helpVarInfoLst of (in1, exp, _) :
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      helpVars[<%in1%>] = <%expPart%> ? 1.0 : 0.0;<%/*???TODO: ? 1.0 : 0.0;*/%>
      >>
  \n%>

  isInUpdate = false;
}
>>
end functionUpdateDepend;

template functionOnlyZeroCrossing(list<ZeroCrossing> zeroCrossingLst) ::=
# System.tmpTickReset(1)
<<
public override void FunOnlyZeroCrossings(double time, double[] gout) //TODO:??time in original is *t only ... how is it called?
{
  <%zeroCrossingLst of ZERO_CROSSING : zeroCrossing(relation_, i0) \n%>  
}
>>
end functionOnlyZeroCrossing;

template zeroCrossing(Exp, Integer index) ::=
  case RELATION then
    # preExp = ""
    # e1 = daeExp(exp1, contextOther, preExp)
    # e2 = daeExp(exp2, contextOther, preExp)
    <<
    {<%preExp%>var _zen = zeroCrossingEnabled[<%index%>]; //ZEROCROSSING(<%index%>, <%zeroCrossingOpFunc(operator)%>(<%e1%>, <%e2%>));
    gout[<%index%>] = (_zen != 0) ? _zen * (<%match operator
                                           case LESS
                                           case LESSEQ    then '<%e1%>-<%e2%>'
                                           case GREATER
                                           case GREATEREQ then '<%e2%>-<%e1%>'
                                          %>) : 1.0; }
    >>    
  case CALL(path=IDENT(name="sample"), expLst={start, interval}) then
    # preExp = ""
    # eStart = daeExp(start, contextOther, preExp)
    # eInterval = daeExp(interval, contextOther, preExp)
    <<
    {<%preExp%>var _zen = zeroCrossingEnabled[<%index%>]; //ZEROCROSSING(<%index%>, Sample(*t, <%eStart%>, <%eInterval%>));
    gout[<%index%>] = (_zen != 0) ? _zen * Sample(time, <%eStart%>, <%eInterval%>) : 1.0; }
    >> 
  case _ then
    <<
    ZERO_CROSSING_ERROR
    >>
end zeroCrossing;

template zeroCrossingOpFunc(Operator) ::=
  case LESS      then "Less"
  case GREATER   then "Greater"
  case LESSEQ    then "LessEq"
  case GREATEREQ then "GreaterEq"
end zeroCrossingOpFunc;

// New runtime function. What should it do?
template functionStoreDelayed() ::=
# System.tmpTickReset(1)
<<
public override void FunStoreDelayed()
{  
}
>>
end functionStoreDelayed;

template functionWhen(list<SimWhenClause> whenClauses) ::=
# System.tmpTickReset(1)
<<
public override void FunWhen(int i)
{
  switch(i) {
    <%whenClauses of SIM_WHEN_CLAUSE :
    <<
    case <%i0%>:
      <%functionWhen_caseEquation(whenEq)%>
      <%reinits of REINIT :
        # preExp = ""
        # valueExp = daeExp(value, contextSimulationDescrete, preExp)
      <<
      <%preExp%>
      <%cref(stateVar)%> = <%valueExp%>;
      >> \n%>
      break;
    >> \n%>
    default:
      break;
  }
}
>>
end functionWhen;

template functionWhen_caseEquation(Option<WhenEquation>) ::=
case SOME(weq as WHEN_EQ) then
# preExp = ""
# expPart = daeExp(weq.right, contextSimulationDescrete, preExp)
<<
Pre_<%cref(weq.left)%> = <%cref(weq.left)%>; //save()
<%preExp%>
<%cref(weq.left)%> = <%expPart%>;
>>
end functionWhen_caseEquation;

template functionOde(list<SimEqSystem> stateContEquations) ::=
# System.tmpTickReset(1)
<<
public override void FunODE()
{
  <%stateContEquations : equation_(it, contextOther) \n%>
}
>>
end functionOde;

//TODO:??there is st more in the trunk
template functionInitial(list<SimEqSystem> initialEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialFun()
{
  <%initialEquations of SES_SIMPLE_ASSIGN: equation_(it, contextOther) \n%>

  //if (sim_verbose) {
    <%initialEquations of SES_SIMPLE_ASSIGN:
    <<
    //Debug.WriteLine("Setting variable start value: {0}(start={1})", "<%cref(componentRef)%>", <%cref(componentRef)%>);
    >> \n%>
  //}
}
>>
end functionInitial;

template functionInitialResidual(list<SimEqSystem> residualEquations) ::=
# System.tmpTickReset(1)
<<
public override void InitialResidual()
{
  int _i = 0;

  <%residualEquations of SES_RESIDUAL :
    if exp is DAE.SCONST then
      'initialResiduals[_i++] = 0;'
    else
      # preExp = ""
      # expPart = daeExp(exp, contextSimulationNonDescrete, preExp) // ??contextOther
      <<
      <%preExp%>
      initialResiduals[_i++] = <%expPart%>;
      >>
  \n%>
}
>>
end functionInitialResidual;

template functionExtraResudials(list<SimEqSystem> allEquations) ::=
# System.tmpTickReset(1)
(allEquations of SES_NONLINEAR:
<<
void ResidualFun<%index%>(int n, double[] xloc, double[] res, int iflag)
{
   <%eqs of SES_RESIDUAL :
     # preExp = ""
     # expPart = daeExp(exp, contextSimulationDescrete, preExp)
   <<
   <%preExp%>
   res[<%i0%>] = <%expPart%>;
   >> \n%>
}
>> \n)
end functionExtraResudials;

template functionBoundParameters(list<SimEqSystem> parameterEquations) ::=
# System.tmpTickReset(1)
<<
public override void BoundParameters()
{
  <%parameterEquations of SES_SIMPLE_ASSIGN : equation_(it, contextOther) \n%>
}
>>
end functionBoundParameters;

// TODO: Is the -1 thing really correct? It seems to work.
template functionCheckForDiscreteVarChanges(list<HelpVarInfo> helpVarInfoLst,
                                   list<ComponentRef> discreteModelVars) ::=
<<
public override bool CheckForDiscreteVarChanges()
{
  //var needToIterate = false;

  //edge(helpVars[i])
  <%helpVarInfoLst of (id1, exp, id2):
  if id2 is not -1 then
  <<
  if (helpVars[<%id1%>]!=0.0 && savedHelpVars[<%id1%>]==0.0) EventQueue.Add(<%id2%> + NG);
  >> \n%>

  //TODO: changeDiscreteVar(i) and to get the i from ComponentRef
  //if change()
  <%discreteModelVars :
  <<
  if (Pre_<%cref(it)%> != <%cref(it)%>) return true; /*needToIterate = true; */
  >> \n%>
  
  var _hvs = helpVars;
  var _shvs = savedHelpVars;
  for (int i = 0; i < _hvs.Length; i++) {
    //change(helpVars[i]) ?? TODO: not sure if it can be only 1.0 or 0.0
    if (_hvs[i] != _shvs[i])
      return true; //needToIterate=true;
  }

  return false; //needToIterate;
}
>>
end functionCheckForDiscreteVarChanges;


// Residual equations are not handled here
template equation_(SimEqSystem eq, Context context) ::=
case SES_SIMPLE_ASSIGN then
  # preExp = ""
  # expPart = daeExp(exp, context, preExp)
  <<
  <%preExp%>
  <%cref(componentRef)%> = <%expPart%>;
  >>
case SES_LINEAR then
  # uid = System.tmpTick()
  # size = listLength(vars)
  # aname = 'A<%uid%>'
  # bname = 'b<%uid%>'
  <<
  var <%aname%> = new double[<%size%>*<%size%>]; //declare_matrix(<%aname%>, <%size%>, <%size%>);
  var <%bname%> = new double[<%size%>]; //declare_vector(<%bname%>, <%size%>);
  <%simJac of (row, col, eq as SES_RESIDUAL):
     # preExp = ""
     # expPart = daeExp(eq.exp, context, preExp)
     '<%preExp%><%aname%>[<%row%>+<%col%>*<%size%>] = <%expPart%>; //set_matrix_elt(<%aname%>, <%row%>, <%col%>, <%size%>, <%expPart%>);'
  "\n"%>
  <%beqs:
     # preExp = ""
     # expPart = daeExp(it, context, preExp)
     '<%preExp%><%bname%>[<%i0%>] = <%expPart%>; //set_vector_elt(<%bname%>, <%i0%>, <%expPart%>);'
  "\n"%>
  SolveLinearSystem<%if partOfMixed then "Mixed"%>(<%aname%>, <%bname%>, <%size%>, <%uid%>);
  <%vars of SIMVAR: '<%cref(name)%> = <%bname%>[<%i0%>]; //get_vector_elt(<%bname%>, <%i0%>);' "\n"%>
  >>
case SES_MIXED then
  # contEqs = equation_(cont, context)
  # numDiscVarsStr = listLength(discVars) 
  # valuesLenStr = listLength(values)
  # preDisc = "" /*BUFD*/
  # discLoc2 = 
  	match discEqs
    case { discEq as SES_SIMPLE_ASSIGN } then
      <<
      <%cref(discEq.componentRef)%> = <%daeExp(discEq.exp, context, preDisc /*BUFC*/)%>;
      double discrete_loc2_0 = <%cref(discEq.componentRef)%>;
      >>
  	case discEqs then
      <<
      var discrete_loc2 = new double[<%numDiscVarsStr%>];
      <%discEqs of SES_SIMPLE_ASSIGN:
        <<
        <%cref(componentRef)%> = <%daeExp(exp, context, preDisc /*BUFC*/)%>;
        discrete_loc2[<%i0%>] = <%cref(componentRef)%>;
        >>
        "\n"%>
      >>
  <<
  // *** mixed_equation_system(<%numDiscVarsStr%>) ***
  { int found_solution = 0;
    int cur_value_indx = 0;
    do {
	  <% match discVars
	    case { var as SIMVAR } then
	      <<
	      double discrete_loc_0 = <%cref(var.name)%>;
          >>
	    case discVars then
	      <<
	      var discrete_loc = new double[<%numDiscVarsStr%>] {
	        <%discVars of SIMVAR: cref(name) ",\n"%>
	      };
	      >>
	  %>
	  {
	    <%contEqs%>
	  }
	  <%preDisc%>
	  <%discLoc2%>
	  {
	    // check_discrete_values(<%numDiscVarsStr%>, <%valuesLenStr%>);
	    if (found_solution == -1) { /*system of equations failed*/
            found_solution = 0;
        } else {
            found_solution = 1;
            <% match discVars
	    	  case { SIMVAR } then
	    	    <<
	    	    if ( Math.Abs(discrete_loc_0 - discrete_loc2_0) > 1e-12) {
                    found_solution = 0;
                }
                >>
              case discVars then
                <<
                for (int i=0; i < <%numDiscVarsStr%>; i++) {
	                if ( Math.Abs(discrete_loc[i] - discrete_loc2[i]) > 1e-12) {
	                    found_solution = 0;
	                }
	            }
	            >>
	        %>
        }
        if (found_solution == 0) { //!found_solution
            cur_value_indx++;
            if (cur_value_indx > <%valuesLenStr%>/<%numDiscVarsStr%>) {
                found_solution = -1; //?? failed ??
            }             
        }
	  }
    } while (found_solution == 0);
  } // *** mixed_equation_system_end(<%numDiscVarsStr%>) ***
  >>

case _ then
  <<
  equation_NOT_YET_IMPLEMENTED
  >>
end equation_;

// SECTION: SIMULATION TARGET, FUNCTIONS FILE SPECIFIC TEMPLATES
// not yet implemented

// SECTION: GENERAL TEMPLATES, COMPONENT REFERENCES

template cref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case _ then "CREF_NOT_IDENT"
end cref;

template crefSubscript(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident) + subscripts(subscriptLst)
  case _ then "CREF_NOT_IDENT"
end crefSubscript;

template subscripts(list<Subscript> subscriptsLst) ::=
  if subscriptsLst then '[<%subscriptsLst : subscript() ","%>]'
end subscripts;

template subscript(Subscript) ::=
  case INDEX(exp = ICONST) then exp.integer
  case _ then "SUBSCRIPT_NOT_CONSTANT"
end subscript;


// SECTION: GENERAL TEMPLATES, PATHS

template dotPath(Path) ::=
  case QUALIFIED      then '<%name%>.<%dotPath(path)%>'
  case IDENT          then name
  case FULLYQUALIFIED then dotPath(path)
end dotPath;

template underscorePath(Path) ::=
  case QUALIFIED      then '<%System.stringReplace(name, "_", "__")%>_<%underscorePath(path)%>'
  case IDENT          then System.stringReplace(name, "_", "__")
  case FULLYQUALIFIED then underscorePath(path)
end underscorePath;


// SECTION: GENERAL TEMPLATES, FUNCTION GENERATION
// not yet implemented



// Codegen.generateStatement
template algStatement(DAE.Statement, Context context) ::=
  case STMT_ASSIGN(exp1 = CREF(componentRef = WILD), exp = e) then
    # preExp = "" 
    # expPart = daeExp(e, context, preExp)
    <<
    <%preExp%>
    <%expPart%>
    >>    
  case STMT_ASSIGN(exp1 = CREF) then
    # preExp = ""
    # expPart = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    <%scalarLhsCref(exp1, context, preExp)%> = <%expPart%>;
    >>
  case STMT_ASSIGN then
    # preExp = ""
    # expPart1 = daeExp(exp1, context, preExp)
    # expPart2 = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    <%expPart1%> = <%expPart2%>;
    >>
  case STMT_IF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    <%preExp%>
    if (<%condExp%>) {
      <%statementLst : algStatement(it, context) \n%>
    }
    <%elseExpr(else_, context)%>
    >>
  case _ then "NOT_IMPLEMENTED_ALG_STATEMENT"
 /*
  case STMT_FOR(exp = rng as RANGE) then
    <<
    {
      <%expTypeA(type_, boolean)%> 
        _r1 = <%daeExp(rng.exp,isSimulationCode)%>,
        _r2 = <%if rng.expOption is SOME(eo) then daeExp(eo,isSimulationCode) else "(1)"%>,
        _r3 = <%daeExp(rng.range,isSimulationCode)%>,
        <%ident%>;

      for (<%ident%> = _r1; in_range_<%expShortType(type_)%>(<%ident%>, _r1, _r3); <%ident%> += _r2) {
        <%statementLst : algStatement() \n /* ??CONTEXT(codeContext,expContext,IN_FOR_LOOP(loopContext)*/ %>        
      }
    } /*end for*/
    >>
  */
end algStatement;

template elseExpr(DAE.Else, Context context) ::= 
  case NOELSE then ()
  case ELSEIF then
    # preExp = ""
    # condExp = daeExp(exp, context, preExp)
    <<
    else {
    <%preExp%>
    if (<%condExp%>)) {
      <%statementLst : algStatement(it, context) \n%>
    }
    <%elseExpr(else_, context)%>
    }
    >>
  case ELSE then
    <<
    else {
      <%statementLst : algStatement(it, context) \n%>
    }
    >>
end elseExpr;
    
//try this
/*
template foo(list<Exp> exps, list<Integer> ints, Text varDecls) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp, varDecls) 
    <<
    <%preExp%>
    localData->helpVars[<%firstInt%>] = <%expPart%>;
    <%foo(restExps, restInts, preExp, varDecls)%>
    >>
end foo;
*/

template foo(list<Exp> exps, list<Integer> ints) ::=
  if exps is (firstExp :: restExps) then
  if ints is (firstInt :: restInts) then
    # preExp = ""
    # expPart = daeExp(firstExp, contextSimulationDescrete, preExp)
    <<
    <%preExp%>
    localData->helpVars[<%firstInt%>] = <%expPart%>;
    <%foo(restExps, restInts)%>
    >>

end foo;

template scalarLhsCref(Exp cref, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if crefNoSub(cref.componentRef) then
    cref(cref.componentRef)
  else
    daeExpCrefRhs(cref, context, preExp)
case _ then
  "ONLY IDENT SUPPORTED"
end scalarLhsCref;

/*
template scalarLhsCref(ComponentRef) ::=
  case CREF_IDENT then replaceDollarWorkaround(ident)
  case CREF_QUAL  then '<%ident%>.<%scalarLhsCref(componentRef)%>'
end scalarLhsCref;
*/

//TODO: this wrong for qualified integers !
template rhsCref(ComponentRef, ExpType ty) ::=
  case CREF_IDENT then '<%rhsCrefType(ty)%><%replaceDollarWorkaround(ident)%>'
  case CREF_QUAL  then '<%rhsCrefType(ty)%><%ident%>.<%rhsCref(componentRef,ty)%>'
  case _          then "rhsCref:ERROR"
end rhsCref;

template rhsCrefType(ExpType) ::=
  case ET_INT then "(int)"
  case _      then ""
end rhsCrefType;


template replaceDollarWorkaround(String ident) ::=
  stringReplace(
    stringReplace(ident,"$DER","Der_"), 
    "$", "")
end replaceDollarWorkaround;

// SECTION: GENERAL TEMPLATES, EXPRESSIONS
  
template daeExp(Exp exp, Context context, Text preExp) ::=
  case ICONST     then integer
  case RCONST     then real
  case SCONST     then '"<%Util.escapeModelicaStringToCString(string)%>"'
  case BCONST     then if bool then "(1)" else "(0)"
  case CREF       then daeExpCrefRhs(it, context, preExp)
  case LBINARY
  case BINARY     then daeExpBinary(operator, exp1, exp2, context, preExp)
  case LUNARY
  case UNARY      then daeExpUnary(operator, exp, context, preExp)
  case RELATION   then daeExpRelation(operator, exp1, exp2, context, preExp)
  case IFEXP      then daeExpIf(expCond, expThen, expElse, context, preExp)
  case CALL       then daeExpCall(exp, context, preExp)
  // PARTEVALFUNCTION
  case ARRAY      then daeExpArray(ty, scalar, array, context, preExp)
  case MATRIX     then "MATRIX_NOT_IMPLEMENTED"
  case RANGE      then "RANGE_NOT_IMPLEMENTED"
  case TUPLE      then "TUPLE_NOT_IMPLEMENTED"
  case CAST       then "CAST_NOT_IMPLEMENTED"
  case ASUB       then "ASUB_NOT_IMPLEMENTED"
  case SIZE       then "SIZE_NOT_IMPLEMENTED"
  case CODE       then "CODE_NOT_IMPLEMENTED"
  case REDUCTION  then "REDUCTION_NOT_IMPLEMENTED"
  case END        then "END_NOT_IMPLEMENTED"
  case VALUEBLOCK then "VALUEBLOCK_NOT_IMPLEMENTED"
  case LIST       then "LIST_NOT_IMPLEMENTED"
  case CONS       then "CONS_NOT_IMPLEMENTED"
  // META_TUPLE
  // META_OPTION
  // METARECORDCALL
  case _          then "UNKNOWN_EXP"
end daeExp;
  
template daeExpCrefRhs(Exp exp, Context context, Text preExp) ::=
case cref as CREF(componentRef=CREF_IDENT(subscriptLst=subs)) then
  if daeExpCrefRhsArrayBox(exp, context, preExp) then
    it
  else if crefNoSub(cref.componentRef) then
    <<
    <%if cref.ty is ET_INT then "(int)"
    %><%cref(cref.componentRef)%>
    >>
  else if crefSubIsScalar(cref.componentRef) then
    // The array subscript results in a scalar
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # dimsLenStr = listLength(subs)
    # dimsValuesStr = (subs of INDEX: daeExp(exp, context, preExp) ", ")
    <<
    !!!TODO:(*<%arrayType%>_element_addr(&<%arrName%>, <%dimsLenStr%>, <%dimsValuesStr%>))
    >>
  else
    // The array subscript denotes a slice
    # arrName = cref(cref.componentRef)
    # arrayType = expTypeArray(cref.ty)
    # spec1 = daeExpCrefRhsIndexSpec(subs, context, preExp)
    # tmp = ""
    # preExp += '!!!TODO: <%tempDecl(arrayType, tmp)%> = index_alloc_<%arrayType%>(&<%arrName%>, &<%spec1%>, &<%tmp%>);<%\n%>'
    tmp
case _ then
  "UNKNOWN RHS CREF: ONLY IDENT SUPPORTED"
end daeExpCrefRhs;

template daeExpCrefRhsIndexSpec(list<Subscript> subs, Context context, Text preExp) ::=
# nridx_str = listLength(subs)
# idx_str = (subs :
               case INDEX then
                 # expPart = daeExp(exp, context, preExp)
                 <<
                 (1), make_index_array(1, <%expPart%>), 'S'
                 >>
               case WHOLEDIM then
                 <<
                 (1), (0), 'W'
                 >>
               case SLICE then
                 # expPart = daeExp(exp, context, preExp)
                 # tmp = ""
                 # preExp += '!!!TODO:<%tempDecl("int", tmp)%> = size_of_dimension_integer_array(<%expPart%>, 1);<%\n%>'
                 <<
                 <%tmp%>, integer_array_make_index_array(&<%expPart%>), 'A'
                 >>
             ", ")
# tmp = "" 
# preExp += '!!!TODO:<%tempDecl("index_spec_t", tmp)%> = create_index_spec(&<%tmp%>, <%nridx_str%>, <%idx_str%>);<%\n%>'
tmp
end daeExpCrefRhsIndexSpec;


template daeExpCrefRhsArrayBox(Exp exp, Context context, Text preExp) ::=
case cref as CREF(ty=ET_ARRAY(ty=aty,arrayDimensions=dims)) then
  if context is SIMULATION then
    // For context simulation array variables must be boxed into a real_array
    // object since they are represented only in a double array.
    # tmpArr = ""
    # dimsLenStr = listLength(dims)
    # dimsValuesStr = (dims of SOME(i): i ", ")
    # preExp += '!!!TODO:<%tempDecl(expTypeArray(aty), tmpArr)%> = <%expShortType(aty)%>_array_create(&<%tmpArr%>, &<%cref(cref.componentRef)%>, <%dimsLenStr%>, <%dimsValuesStr%>);<%\n%>'
    tmpArr
end daeExpCrefRhsArrayBox;


template daeExpBinary(Operator, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  case ADD then '(<%e1%> + <%e2%>)'
  case SUB then '(<%e1%> - <%e2%>)'
  case MUL then '(<%e1%> * <%e2%>)'
  case DIV then '(<%e1%> / <%e2%>)'
  case POW then 'Math.Pow(<%e1%>, <%e2%>)'
  case AND then '(<%e1%> && <%e2%>)'
  case OR  then '(<%e1%> || <%e2%>)'
  case _   then "daeExpBinary:ERR"
end daeExpBinary;


template daeExpUnary(Operator, Exp exp, Context context, Text preExp) ::=
  # e = daeExp(exp, context, preExp)
  case UMINUS     then '(-<%e%>)'
  case UPLUS      then '(<%e%>)'
  case NOT        then '(!<%e%>)'
  case UMINUS_ARR then "UMINUS_ARR_NOT_IMPLEMENTED"
  case UPLUS_ARR  then "UPLUS_ARR_NOT_IMPLEMENTED"
  case _          then "daeExpUnary:ERR"

end daeExpUnary;


template daeExpRelation(Operator op, Exp exp1, Exp exp2, Context context, Text preExp) ::=
  # e1 = daeExp(exp1, context, preExp)
  # e2 = daeExp(exp2, context, preExp)
  if  daeExpSimRelation(context, op, e1, e2, preExp) then 
    it
  else //non-SIMULATION context or precise equality 
    match op
    case LESS(ty = ET_BOOL)        then '(!<%e1%> && <%e2%>)'
    case LESS(ty = ET_STRING)      then "# string comparison not supported\n"
    case LESS(ty = ET_INT)
    case LESS(ty = ET_REAL)        then '(<%e1%> < <%e2%>)'
    case GREATER(ty = ET_BOOL)     then '(<%e1%> && !<%e2%>)'
    case GREATER(ty = ET_STRING)   then "# string comparison not supported\n"
    case GREATER(ty = ET_INT)
    case GREATER(ty = ET_REAL)     then '(<%e1%> > <%e2%>)'
    case LESSEQ(ty = ET_BOOL)      then '(!<%e1%> || <%e2%>)'
    case LESSEQ(ty = ET_STRING)    then "# string comparison not supported\n"
    case LESSEQ(ty = ET_INT)
    case LESSEQ(ty = ET_REAL)      then '(<%e1%> <= <%e2%>)'
    case GREATEREQ(ty = ET_BOOL)   then '(<%e1%> || !<%e2%>)'
    case GREATEREQ(ty = ET_STRING) then "# string comparison not supported\n"
    case GREATEREQ(ty = ET_INT)
    case GREATEREQ(ty = ET_REAL)   then '(<%e1%> >= <%e2%>)'
    case EQUAL(ty = ET_BOOL)       then '((!<%e1%> && !<%e2%>) || (<%e1%> && <%e2%>))'
    case EQUAL(ty = ET_STRING)
    case EQUAL(ty = ET_INT)
    case EQUAL(ty = ET_REAL)       then '(<%e1%> == <%e2%>)'
    case NEQUAL(ty = ET_BOOL)      then '((!<%e1%> && <%e2%>) || (<%e1%> && !<%e2%>))'
    case NEQUAL(ty = ET_STRING)
    case NEQUAL(ty = ET_INT)
    case NEQUAL(ty = ET_REAL)      then '(<%e1%> != <%e2%>)'
    case _                         then "daeExpRelation:ERR"
end daeExpRelation;


template daeExpSimRelation(Context, Operator op, Text e1, Text e2, Text preExp) ::=
	case SIMULATION then
	   match op
	   case LESS      then SimRelationSimple(e1, e2, " <", preExp)
	   case LESSEQ    then SimRelationEqual(e1, e2, " <", preExp)
	   case GREATER   then SimRelationSimple(e1, e2, " >", preExp)
	   case GREATEREQ then SimRelationEqual(e1, e2, " >", preExp)
end daeExpSimRelation;


template SimRelationSimple(Text e1, Text e2, String op, Text preExp) ::=
  # res = ""    
  # preExp += 
    <<
    // RELATION( <%e1%><%op%> <%e2%> ) macro expansion
    <%tempDecl("bool", res)%> = <%e1%><%op%> <%e2%>; if (!<%res%> && isInUpdate && (<%e1%><%op%>= <%e2%>)) { SwapOldVars(); double res1 = <%e1%> - <%e2%>;  SwapOldVars12(); <%res%> = res1<%op%>= (<%e1%> - <%e2%>); SwapOldVars2(); }<%\n%>
    >>
  res 
end SimRelationSimple;


template SimRelationEqual(Text e1, Text e2, String op, Text preExp) ::=
  # res = ""    
  # preExp += 
    <<
    // RELATION( <%e1%><%op%>= <%e2%> ) macro expansion
    <%tempDecl("bool", res)%>;  if (isInUpdate) { <%res%> = <%e1%><%op%> <%e2%>;  if(!<%res%> && (<%e1%><%op%>= <%e2%>)) {  SwapOldVars(); double res1 = <%e1%> - <%e2%>;  SwapOldVars12(); <%res%> = res1<%op%>= (<%e1%> - <%e2%>); SwapOldVars2(); }  } else <%res%> = <%e1%><%op%>= <%e2%>;<%\n%>
    >>
  res
end SimRelationEqual;


template daeExpIf(Exp cond, Exp then_, Exp else_, Context context, Text preExp) ::=
  # condExp = daeExp(cond, context, preExp)
  # resVar = ""
  # preExpThen = ""
  # eThen = daeExp(then_, context, preExpThen)
  # preExpElse = ""
  # eElse = daeExp(else_, context, preExpElse)
  # preExp +=  
  <<
  <%tempDecl(expTypeFromExpArrayIf(then_), resVar)%>;
  if (<%condExp%><%/*if expTypeFromExp(cond) is "bool" then " != 0.0"*/%>) { //cond type is <%expTypeFromExp(cond)%>
    <%preExpThen%>
    <%resVar%> = <%eThen%>;
  } else {
    <%preExpElse%>
    <%resVar%> = <%eElse%>;
  }<%\n%>
  >>
  resVar

/*<<
(<%daeExp(cond, context, preExp)
  %> ? <%daeExp(then_, context, preExp)%> : <%daeExp(else_, context, preExp)%>)
>>*/
end daeExpIf;


template daeExpCall(Exp, Context context, Text preExp) ::=
  // special builtins
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="DIVISION"),
            expLst={e1, e2, DAE.SCONST(string=string)}) then
    # var1 = daeExp(e1, context, preExp)
    # msg = Util.escapeModelicaStringToCString(string)
    (match e2 
     case RCONST then 
     	//if rr is 0.0 then 'DivBy0(<%var1%>,0.0,"<%msg%>")'
     	//else 
     	'<%var1%>/<%daeExp(e2, context, preExp)%>'
     case _ then
     	# var2 = daeExp(e2, context, preExp)
    	'(<%var2%>!=0.0 ? <%var1%>/<%var2%> : DivBy0(<%var1%>,<%var2%>,"<%msg%>"))' 
     ) 
    
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="pre"), expLst={arg as CREF}) then
    //# retType = expType(arg.ty)
    <<
    <%if arg.ty is ET_INT then "(int)"
    %>Pre_<%cref(arg.componentRef)%>
    >>
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="min"), expLst={e1,e2}) then
    'Math.Min(<%daeExp(e1, context, preExp)%>,<%daeExp(e2, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="max"), expLst={e1,e2}) then
    'Math.Max(<%daeExp(e1, context, preExp)%>,<%daeExp(e2, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="log"), expLst={s1}) then
    'Math.Log(<%daeExp(s1, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="exp"), expLst={s1}) then
    'Math.Exp(<%daeExp(s1, context, preExp)%>)'
  
  case CALL(tuple_=false, builtin=true,
            path=IDENT(name="sin"), expLst={s1}) then
    'Math.Sin(<%daeExp(s1, context, preExp)%>)'
  
    
  // TODO: add more special builtins (Codegen.generateBuiltinFunction)
  // no return calls
  case CALL(tuple_=false, ty=ET_NORETCALL) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # preExp += '<%underscorePrefix(builtin)%><%underscorePath(path)%>(<%argStr%>);<%\n%>'
    <<
    /* NORETCALL */
    >>
  // non tuple calls (single return value)
  case CALL(tuple_=false) then
    # argStr = (expLst : daeExp(it, context, preExp) ", ")
    # funName = underscorePath(path)
    <<
    <%underscorePrefix(builtin)
    %><%funName%>(<%argStr%>)<%if not builtin then '/* !!!TODO:.<%funName%>_rettype_1 */'%>
    >>
  case _ then "daeExpCall:NOT_YET_IMPLEMENTED"
end daeExpCall;


template daeExpArray(ExpType ty, Boolean scalar, list<Exp> array, Context context, Text preExp) ::=
  # arrayTypeStr = expTypeArray(ty)
  # arrayVar = "" //tempDecl(arrayTypeStr, varDecls /*BUFC*/)
  # scalarPrefix = if scalar then "" else "NON_SCALAR_ARRAY_notYetImplemeted"
  # scalarRef = if scalar then "&" else ""
  # params = '<%array of e: '(<%expTypeFromExp(e)%>)<%daeExp(e, context, preExp)%>' ", "%>'
  # preExp += '<%scalarPrefix%><%tempDecl(arrayTypeStr,arrayVar)%> = new <%arrayTypeStr%>{ <% ["0.0",params] ", "%> };<%\n%>'
  arrayVar
end daeExpArray;


template underscorePrefix(Boolean builtin) ::=
  case true then ""
  case false then "_"
end underscorePrefix;

// SECTION: GENERAL TEMPLATES, TEMPORARY VARIABLES

//newVar parameter is assumed to be empty or it can hold an identifier prefix
template tempDecl(String ty, Text newVar) ::=
  # newVar += '_tmp<%System.tmpTick()%>'
  <<
  <%ty%> <%newVar%>
  >>
end tempDecl;
  


// SECTION: GENERAL TEMPLATES, TYPES

// TODO: Check with Codegen
template expShortType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_STRING then "string"
  case ET_BOOL   then "bool"
  case ET_OTHER  then "#complex#"
  case ET_ARRAY then expShortType(ty)   
  case ET_COMPLEX then '/*struct*/<%underscorePath(name)%>'  
end expShortType;


template expTypeArray(DAE.ExpType ty) ::=
<<
<%expShortType(ty)%>[]
>>
end expTypeArray;


template expTypeFromExpArrayIf(Exp exp) ::=
  expTypeFromExp(exp)
end expTypeFromExpArrayIf;


template expTypeFromExp(Exp) ::=
  case ICONST    then "int"
  case RCONST    then "double"
  case SCONST    then "string"
  case BCONST    then "bool"
  case BINARY
  case UNARY
  case LBINARY
  case LUNARY
  case RELATION   then expTypeFromOp(operator)
  case IFEXP      then expTypeFromExp(expThen)
  case CALL       then expShortType(ty)
  case ARRAY
  case MATRIX
  case RANGE
  case CAST
  case CREF
  case CODE       then expShortType(ty)
  case ASUB       then expTypeFromExp(exp)
  case REDUCTION  then expTypeFromExp(expr)
  case _          then "expTypeFromExp:ERROR"
end expTypeFromExp;


template expTypeFromOp(Operator) ::=
  case ADD
  case SUB
  case MUL
  case DIV
  case POW
  case UMINUS
  case UPLUS
  case UMINUS_ARR
  case UPLUS_ARR
  case ADD_ARR
  case SUB_ARR
  case MUL_ARR
  case DIV_ARR
  case MUL_SCALAR_ARRAY
  case MUL_ARRAY_SCALAR
  case ADD_SCALAR_ARRAY
  case ADD_ARRAY_SCALAR
  case SUB_SCALAR_ARRAY
  case SUB_ARRAY_SCALAR
  case MUL_SCALAR_PRODUCT
  case MUL_MATRIX_PRODUCT
  case DIV_ARRAY_SCALAR
  case DIV_SCALAR_ARRAY
  case POW_ARRAY_SCALAR
  case POW_SCALAR_ARRAY
  case POW_ARR
  case POW_ARR2
  case LESS
  case LESSEQ
  case GREATER
  case GREATEREQ
  case EQUAL
  case NEQUAL       then  expShortType(ty)
  case AND
  case OR
  case NOT then "bool"
  case _ then "expTypeFromOp:ERROR"
end expTypeFromOp;


/*
// TODO: Check with Codegen
template expType(DAE.ExpType) ::=
  case ET_INT    then "int"
  case ET_REAL   then "double"
  case ET_BOOL   then "bool"
  case ET_STRING then "string"
  case ET_COMPLEX(complexClassType = EXTERNAL_OBJ)  then "#complex external obj#" 
  case ET_OTHER  then "#OTHER type#"
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
  case ET_ARRAY then 
    match ty
    case ET_INT    then "int[]"
    case ET_REAL   then "double[]"
    case ET_STRING then "string[]"
    case ET_BOOL   then "bool[]"
end expType;

// TODO: Check with Codegen (expTypeStr)
template expTypeA(DAE.ExpType, Boolean isArray) ::=
  case ET_COMPLEX     then expShortType() // i.e. 'struct <%name%>'  
  case ET_LIST
  case ET_METATUPLE
  case ET_METAOPTION
  case ET_UNIONTYPE
  case ET_POLYMORPHIC then "#metamodelica_type#"
end expTypeA;
*/


end SimCodeCSharp;
// vim: filetype=susan sw=2 sts=2
