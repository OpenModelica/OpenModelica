(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:        Values.rml
 ** module:      Values
 ** description: Evaluated expression values
 **
 ** RCS: $Id$
 ** 
 ** The module `Values' contains data structures for representing
 ** constant Modelica values.  These include integer, real, string and
 ** boolean values, and also arrays of any dimensionality and type.
 ** Multidimensional arrays are represented as arrays of arrays.
 **
 ** The code is excluded from the report, since they convey no
 ** semantic information.
 **)

module Values :
with "Exp.rml"
with "Absyn.rml"
  datatype Value = INTEGER of int
		 | REAL of real
		 | STRING of string
		 | BOOL of bool
		 | ENUM of string
		 | ARRAY of Value list
		 | TUPLE of Value list 
		 | RECORD of Absyn.Path * (* record name *)
			     Value list * (* orderd set of values *)
			     Exp.Ident list(* comp names for each value*)
		 | CODE of Absyn.Code
		(* A record consist of value * Ident pairs *)

  relation val_string : Value => string
  relation print_val : Value => ()
  relation add_elementwise_arrayelt: (Value list, Value list) => Value list
  relation sub_elementwise_arrayelt: (Value list, Value list) => Value list
  relation value_neg: (Value ) => Value
  relation sum_arrayelt: (Value list) => Value	  
  relation mult_scalar_arrayelt: (Value, Value list) => Value list
  relation mult_scalar_product: (Value list, Value list) => Value
  relation mult_matrix: (Value list,Value list) => Value list
  relation div_arrayelt_scalar: (Value, Value list) => Value list
  relation intlist_to_value : int list => Value
  relation array_values: Value => Value list 
  relation make_array: Value list => Value	  
  relation is_array : Value => bool
  relation nth_arrayelt: (Value,int) => Value
  relation write_to_file_as_args: (Value list,string) => ()
  relation type_convert: (Exp.Type, Exp.Type,Value list) => Value list
  relation unparse_values: (Value list) => string
  relation reverse_matrix: (Value ) => Value
  relation write_ptolemyplot_dataset: (string,Value,string list,string) => int
end

with "Print.rml"
with "System.rml"
with "Util.rml"
with "Dump.rml"
with "Error.rml"

(** relation: type_convert
 **
 ** Apply type conversion on a list of Values
 **)

relation type_convert: (Exp.Type, Exp.Type, Value list) => Value list =

  axiom type_convert(_,_,[]) => []

  rule	type_convert(from,to,vrest) => vallst &
	int_real (i) => rval
	------------------------------------
	type_convert(from as Exp.INT, to as Exp.REAL, INTEGER(i)::vrest) 
	  =>  REAL(rval)::vallst

  rule	type_convert(from,to,vrest) => vallst &
	real_int (r) => ival
	------------------------------------
	type_convert(from as Exp.REAL, to as Exp.INT, REAL(r)::vrest) 
	  =>  INTEGER(ival)::vallst

  rule	type_convert(from,to,vals) => vallst &
        type_convert(from,to,vrest) => vallst2 
	------------------------------------
	type_convert(from, to, ARRAY(vals)::vrest) 
	  =>  ARRAY(vallst)::vallst2
end


(** relation: is_array
 **
 ** Return true if Value is an array.
 **)

relation is_array: Value => bool = 
  axiom	is_array(INTEGER(_)) => false
  axiom	is_array(REAL(_)) => false
  axiom	is_array(STRING(_)) => false
  axiom	is_array(BOOL(_)) => false
  axiom is_array(TUPLE(_)) => false
  axiom	is_array(ARRAY(_)) => true	
end

(** relation: nth_arrayelt
 ** author: PA
 **
 ** Return the nth value of an array, indexed from 1..n
 **)

relation nth_arrayelt: (Value,int) => Value =

  rule	int_sub(n,1) => n' &
	list_nth(vlst,n') => res
	--------------
	nth_arrayelt(ARRAY(vlst),n) => res
end

(** relation: unparse_values
 **
 ** Prints a list of Value to a string.
 **)

relation unparse_values: (Value list) => string =

  rule	unparse_description([v]) => s1 &
	unparse_value_numbers([v]) => s2 &
	unparse_values(vallst) => s3 &
	Util.string_append_list([s1,s2,"\n",s3]) => str
	-----------------------------
	unparse_values(v::vallst) => str

  axiom	unparse_values([]) => ""
end

(** relation: unparse_value_numbers
 **
 ** Helper relation to unparse_values. 
 ** Prints all the numbers of the values.
 **)

relation unparse_value_numbers: (Value list) => string =

  rule	unparse_value_numbers(lst) => s1 &
	unparse_value_numbers(xs) => s2 &
	string_append(s1,s2) => res 
	---------------------------
	unparse_value_numbers (TUPLE(lst)::xs)=> res
	
  rule	unparse_value_numbers(lst) => s1 &
	unparse_value_numbers(xs) => s2 &
	string_append(s1,s2) => res 
	---------------------------
	unparse_value_numbers (ARRAY(lst)::xs)=> res
	
  rule	unparse_value_numbers(xs) => s1 &
	int_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(INTEGER(i)::xs) => res

  rule	unparse_value_numbers(xs) => s1 &
	real_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(REAL(i)::xs) => res

  rule	unparse_value_numbers(xs) => s1 &
	string_append(sval," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(STRING(sval)::xs) => res

	axiom unparse_value_numbers([]) => ""

end

(** relation: unparse_description
 **
 ** Helper relation to unparse_values. Creates a description string
 ** for the type of the value.
 **)

relation unparse_description:(Value list) => string =

  rule	unparse_description(xs) => s1 &
	string_append("# i!\n",s1) => str 
	--------------------------------
	unparse_description(INTEGER(_)::xs)=> str

  rule	unparse_description(xs) => s1 &
	string_append("# r!\n",s1) => str
	-------------------------------
	unparse_description(REAL(_)::xs)=> str

  rule	unparse_description(xs) => s1 &
	string_length sval => slen &
	int_string slen => slenstr &
	Util.string_append_list(["# s! 1 ", slenstr, "\n"]) => str
	-------------------------------
	unparse_description(STRING(sval)::xs)=> str
	
  rule	unparse_description(xs) => s1 &
	unparse_array_description(vallst) => s2 &
	string_append(s2,s1) => s4 &
	string_append(s4," \n") => str
	-------------------------------
	unparse_description(ARRAY(vallst)::xs)=> str

  axiom unparse_description([]) => ""
end

(** relation: unparse_array_description
 **
 ** Helper relation to unparse_description.
 **)

relation unparse_array_description:(Value list) => string  =

  rule	unparse_prim_type (lst) => pt &
	string_append("# ",pt) => s1 &
	string_append(s1,"[") => s2 &
	unparse_num_dims(lst) => i1 &
	int_string(i1) => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," ") => s5 &
	unparse_dim_sizes(lst) => s6 &
	string_append(s5,s6) => str
	------------------
	unparse_array_description(lst) => str
end

(** relation: unparse_prim_type
 **
 ** Helper relation to unparse_array_description.
 **)

relation unparse_prim_type: (Value list) => string =

  rule	unparse_prim_type(elts) => res
	------------------------------
	unparse_prim_type(ARRAY(elts)::_) => res
  axiom	unparse_prim_type(INTEGER(_)::_) => "i"
  axiom	unparse_prim_type(REAL(_)::_) => "r"
  axiom	unparse_prim_type(STRING(_)::_) => "s"
  axiom	unparse_prim_type(BOOL(_)::_) => "b"
  axiom	unparse_prim_type(_) => "error"
end

(** relation: unparse_num_dims
 **
 ** Helper relation to unparse_array_description.
 **)

relation unparse_num_dims: (Value list) => int =
	
  rule	unparse_num_dims(vals) => i1 &
	int_add(i1,1) => res
	--------------------
	unparse_num_dims(ARRAY(vals)::_) => res

  axiom	unparse_num_dims(_) => 1
end

(** relation: unparse_dim_sizes
 **
 ** Helper relation to unparse_array_description.
 **)

relation unparse_dim_sizes: (Value list) => string =

  rule	list_length(lst) => i1 &
	int_string(i1) => s1 &
	string_append(s1, " ") => s2 &
	unparse_dim_sizes(vals) => s3 &
	string_append(s2,s3) => res
	-------------------
	unparse_dim_sizes (lst as (ARRAY(vals)::_)) => res

  rule	list_length(lst) => len &
	int_string(len) => res 
	----------------------
	unparse_dim_sizes(lst) => res
end

(** relation: write_to_file_as_args
 **
 ** Write a list of Values to a file. This relation is used when 
 ** writing the formal input arguments of a function call to a file before
 ** executing the function.
 **)

relation write_to_file_as_args: (Value list,string) => () =
	
  rule	unparse_values(vallst) => str &
	System.write_file(filename,str) 
	-------------------------------
	write_to_file_as_args(vallst,filename)
end

(** relation: add_elementwise_arrayelt
 **
 ** Perform elementwise addition of two arrays.
 **)

relation add_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	add_elementwise_arrayelt(v1lst,v2lst) => reslst &
	add_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	add_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  rule	string_append(v1,v2) => res & (* Addition of strings is string concatenation *)
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
 	add_elementwise_arrayelt(STRING(v1)::rest1,STRING(v2)::rest2) 
	    => STRING(res)::res2

  axiom	add_elementwise_arrayelt([],[]) => []

end

(** relation: sub_elementwise_arrayelt
 **
 ** Perform element subtraction of two arrays of values
 **)

relation sub_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	sub_elementwise_arrayelt(v1lst,v2lst) => reslst &
	sub_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	sub_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  axiom	sub_elementwise_arrayelt([],[]) => []
end

(** relation: value_neg
 ** author: PA
 **
 ** Negates a Value
 **)
relation value_neg: (Value) => Value =

  rule	real_neg(r) => r' 
	----------------
	value_neg(REAL(r)) => REAL(r')

  rule	int_neg(i) => i' 
	---------------------
	value_neg(INTEGER(i)) => INTEGER(i')
end

(** relation: sum_arrayelt
 **
 ** Calculate the sum of a list of Values.
 **)

relation sum_arrayelt: (Value list) => Value =

  axiom	sum_arrayelt([INTEGER(v1)]) => INTEGER(v1)

  axiom	sum_arrayelt([REAL(v1)]) => REAL(v1)

  axiom	sum_arrayelt([ARRAY(v1)]) => ARRAY(v1)

  rule	sum_arrayelt(xs) => INTEGER(v1) &
	int_add(v1,v2) => v3
	--------------------
	sum_arrayelt(INTEGER(v2)::xs) => INTEGER(v3) 
	
  rule	sum_arrayelt(xs) => REAL(v1) &
	real_add(v1,v2) => v3
	--------------------
	sum_arrayelt(REAL(v2)::xs) => REAL(v3) 
	
  rule	sum_arrayelt(arr) => ARRAY(v1) &
	add_elementwise_arrayelt(v1,v2) => v3
	------------------------------------
	sum_arrayelt(arr as ARRAY(v2)::_) => ARRAY(v3)

end

(** relation: mult_scalar_arrayelt
 **
 ** Multiply a scalar with an list of Values, i.e. array.
 **)

relation mult_scalar_arrayelt: (Value, Value list) => Value list =

  rule	mult_scalar_arrayelt(sval,vals) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval,ARRAY(vals)::rest) => ARRAY(r1)::r2
 
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),INTEGER(v2)::rest) => INTEGER(r1)::r2

  rule	int_real(v2) => v2' &
	real_mul(v1,v2') => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),INTEGER(v2)::rest) => REAL(r1)::r2

  rule	int_real(v1) => v1' &
	real_mul(v1',v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),REAL(v2)::rest) => REAL(r1)::r2

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),REAL(v2)::rest) => REAL(r1)::r2

	axiom mult_scalar_arrayelt(_,[]) => []
end

(** relation: mult_scalar_product
 **
 ** Calculate the scalar product of two vectors / arrays.
 **)

relation mult_scalar_product: (Value list, Value list) => Value =
	
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => INTEGER(r2) & 
	int_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (INTEGER(v1)::(v1lst as (_::_)),INTEGER(v2)::(v2lst as (_::_)))
	    => INTEGER(res)

  rule	int_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([INTEGER(v1)],[INTEGER(v2)]) 
	    => INTEGER(res)

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => REAL(r2) &
	real_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (REAL(v1)::(v1lst as (_::_)),REAL(v2)::(v2lst as (_::_)))
	    => REAL(res)

  rule	real_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([REAL(v1)],[REAL(v2)]) 
	    => REAL(res)

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (INTEGER(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],INTEGER(_)::_) => ARRAY([])

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (REAL(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],REAL(_)::_) => ARRAY([])


  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => INTEGER(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([INTEGER(v)])

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => REAL(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([REAL(v)])

  rule	Print.print_buf "mult_scalar_product failed\n lst1 len:" &
	list_length(lst1) => len &
	int_string(len) => lenstr &
	Print.print_buf lenstr & Print.print_buf "lst2 len:" &
	list_length(lst2) => len2 &
	int_string(len2) => len2str & 
	Print.print_buf len2str & Print.print_buf "\n" 
	--------------------------
	mult_scalar_product(lst1,lst2) => fail
end

(** relation: mult_matrix
 **
 ** Calculate a matrix multiplication of two matrices, i.e. two dimensional 
 ** arrays.
 **)

relation mult_matrix: (Value list,Value list) => Value list =
	
  rule	mult_scalar_product(v1lst,m2) => res1 &
	mult_matrix(rest1,m2) => res2
	-----------------------------
	mult_matrix(m1 as (ARRAY(v1lst)::rest1),m2 as (ARRAY(_)::_)) => res1::res2
	
  axiom	 mult_matrix([],_) => []
	
end

(** relation: div_arrayelt_scalar
 **
 ** Divide each array element with a scalar.
 **)


relation div_arrayelt_scalar: (Value, Value list) => Value list =

  rule	v1 = 0.0 &
	unparse_values(vlst) => s2 &
	Error.add_message(Error.DIVISION_BY_ZERO,["0.0",s2])
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),vlst) => fail
	
  rule	v1 = 0 &
	unparse_values(vlst) => s2 &
	Error.add_message(Error.DIVISION_BY_ZERO,["0",s2])
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),vlst) => fail
	
  rule	div_arrayelt_scalar(sval,vals) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval,ARRAY(vals)::rest) => ARRAY(r1)::r2
 
  rule	int_div(v2,v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),INTEGER(v2)::rest) => INTEGER(r1)::r2


  rule	int_real(v2) => v2' &
	real_div(v2',v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),INTEGER(v2)::rest) => REAL(r1)::r2
 
  rule	int_real(v1) => v1' &
	real_div(v2,v1') => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as INTEGER(v1),REAL(v2)::rest) => REAL(r1)::r2

  rule	real_div(v2,v1) => r1 &
	div_arrayelt_scalar(sval,rest) => r2
	------------------------------------
	div_arrayelt_scalar (sval as REAL(v1),REAL(v2)::rest) => REAL(r1)::r2

	axiom div_arrayelt_scalar(_,[]) => []
end



(** relation: matrix_strip_first_column
 **
 ** This relation takes a Value list representing a matrix and strips the 
 ** first column of the matrix, i.e. for each sub list it removes the first 
 ** element. Returning both the stripped column and the resulting matrix.
 **)

relation matrix_strip_first_column: Value list => (Value,Value list) =

  rule	matrix_strip_first_column(rest) => (ARRAY(resl),resl2)
	---------------------------------------------------
	matrix_strip_first_column (ARRAY(v1::vrest)::rest) 
	    => (ARRAY(v1::resl),ARRAY(vrest)::resl2)

  axiom	matrix_strip_first_column( []) => (ARRAY([]),[])
end

(** relation: intlist_to_value
 **
 ** Takes a list of integers and builds a Value from it, i.e. an
 ** array of integers.
 **)

relation intlist_to_value : int list => Value =

  axiom	intlist_to_value([]) => ARRAY([])

  rule	intlist_to_value(lst) => ARRAY(res)
	-----------------------------------
	intlist_to_value(i::lst) => ARRAY(INTEGER(i)::res)
end

(** relation: array_values
 ** 
 ** Return the values of an array.
 **)

relation array_values: Value => Value list =

  axiom	array_values(ARRAY(v_lst)) => v_lst

end

(** relation: make_array
 **
 ** Construct an array of a list of Values.
 **)

relation make_array: Value list => Value =

  axiom	make_array(vlst) => ARRAY(vlst)

end

(** relation: val_string
 **
 ** This relation returns a textual representation of a value.
 **)

relation val_string : Value => string =

  rule	int_string n => s
	-----------------
	val_string INTEGER(n) => s

  rule	real_string x => s
	------------------
	val_string REAL(x) => s

  rule	Util.string_append_list(["\"",s,"\""]) => s'
	--------------------------
	val_string STRING(s) => s'

  axiom	val_string BOOL(false) => "false"
  axiom	val_string BOOL(true) => "true"

  rule	val_list_string vs => s &
	string_append("{",s) => s' &
	string_append(s',"}") => s''
	----------------------------
	val_string ARRAY(vs) => s''

  rule	val_list_string vs => s &
	string_append("(",s) => s' &
	string_append(s',")") => s''
	----------------------------
	val_string TUPLE(vs) => s''

  rule	val_record_string(r) => s &
	Util.string_append_list(["record\n",s,"end record"]) => res
	---------------------------
	val_string (r as RECORD(_,_,_)) => res

  rule	Dump.print_code_str(c) => res &
	Util.string_append_list(["Code(",res,")"]) => res'
	-----------------------
	val_string (CODE(c)) => res'

  rule	Print.print_buf "- val_string failed\n"
	-----------------------------
	val_string _ => fail

end

(** relation: val_record_string
 **
 ** This relation returns a textual representation of a record,
 separating each value with a comma.
 **)
relation val_record_string: Value => string =

  axiom	val_record_string(RECORD(cname,[],[])) => ""

  rule	val_string(x) => s1 &
	val_record_string(RECORD(cname,xs,ids))=> s2 &
	Util.string_append_list([id, " = ",s1,",\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(cname,x::(xs as _::_),id::(ids as _::_))) => res

  rule	val_string(x) => s1 &
	val_record_string(RECORD(cname,xs,ids))=> s2 &
	Util.string_append_list(["    ", id, " = ",s1,"\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(cname,x::xs,id::ids)) => res
end

(** relation: val_list_string
 **
 ** This relation returns a textual representation of a list of
 ** values, separating each value with a comman.
 **)

relation val_list_string : Value list => string =

  axiom	val_list_string [] => ""

  rule	val_string v => s
	-----------------
	val_list_string [v] => s

  rule	val_string v => s &
	val_list_string vs => s' &
	string_append (s,",") => s'' &
	string_append (s'',s') =>s'''
	------------------------------
	val_list_string v::vs => s'''

  rule	Print.print_buf "- val_list_string failed\n"
	----------------------------------
	val_list_string _ => fail

end

(** relation: write_ptolemyplot_dataset
 **
 ** This relation writes a data set in the pltolemy plot format to a file.
 ** The first column of the dataset matrix should be the time variable.
 ** The message string will be displayed in the plot window of ptplot.
 **)

relation write_ptolemyplot_dataset: (string, (* filename *)
				     Value, (* values *)
				     string list, (* Variable names *)
				     string ) (* message string *) 
	  => int =

  rule	unparse_ptolemy_values(time,rest,varnames) => datasets &
	Util.string_append_list(["#Ptolemy Plot generated by OpenModelica\n",
				 "TitleText: ",message,"\n",
				 datasets])=> str &
	System.write_file(filename,str) => ()
	------------------------------------
	write_ptolemyplot_dataset(filename,ARRAY(time::rest),timevar::varnames,message) => 0
end

(** relation: unparse_ptolemy_values
 **
 ** Helper relation to write_ptolemyplot_dataset.
 **)

relation unparse_ptolemy_values: (Value, Value list,string list) => string =
  axiom	unparse_ptolemy_values(_,[],_) => ""

  rule	unparse_ptolemy_set(time,s1,v1) => str &
	unparse_ptolemy_values(time,xs,vs) => str2 &
	string_append(str,str2) => res
	------------------------------
	unparse_ptolemy_values(time,s1::xs,v1::vs) => res
end

(** relation: unparse_ptolemy_set
 **
 ** Helper relation to unparse_ptolemy_values.
 **)

relation unparse_ptolemy_set: (Value, Value, string) => string =
	
  rule	unparse_ptolemy_set_2(v1,v2) => str &
	Util.string_append_list(["DataSet: ",varname,"\n",str]) => res 
	------------------
	unparse_ptolemy_set(v1,v2,varname) => res
end

(** relation: unparse_ptolemy_set_2
 ** 
 ** Helper relation to unparse_ptolemy_set
 **)

relation unparse_ptolemy_set_2: (Value,Value) => string =

  axiom	unparse_ptolemy_set_2 (ARRAY([]),ARRAY([])) => ""

  rule	val_string(v1) => s1 &
	val_string(v2) => s2 &
	unparse_ptolemy_set_2(ARRAY(v1s),ARRAY(v2s)) => res &
	Util.string_append_list([s1,",",s2,"\n",res]) => res'
	----------------------------------------------------
	unparse_ptolemy_set_2 (ARRAY(v1::v1s),ARRAY(v2::v2s)) => res'
end
(** relation: reverse_matrix
 ** 
 ** Reverses each line and each row of a matrix.
 ** Implementation reverses all dimensions...
 **)

relation reverse_matrix: Value => Value =

  rule	Util.list_map(lst,reverse_matrix) => lst' &
	list_reverse(lst') => lst''
	-----------------------------------
	reverse_matrix(ARRAY(lst)) => ARRAY(lst'')

  axiom	reverse_matrix(value) => value

end

(** relation: print_val
 **
 ** This relation prints a value.
 **)

relation print_val : Value => () =

  rule	val_string v => s &
	Print.print_buf s
	-------
	print_val v

end

