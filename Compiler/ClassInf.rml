(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 ClassInf.rml
 ** module:      ClassInf
 ** description: Class restrictions
 **
 ** RCS:	 $Id$
 **
 ** This module deals with class inference, i.e. determining if a
 ** class definition adhers to one of the class restrictions, and, if
 ** specifically declared in a restrictied form, if it breaks that
 ** restriction.
 **
 ** The inference is implemented as a finite state machine.  The
 ** relation `start' initializes a new machine, and the relation
 ** `trans' signals transitions in the machine.  Finally, the state
 ** can be checked agains a restriction with the `valid' relation.
 ** 
 **)

module ClassInf :

  with "SCode.rml"

  (** - Machine states, the string contains the classname. *)
  datatype State = UNKNOWN       of string
		 | MODEL	 of string
		 | RECORD	 of string
		 | BLOCK	 of string
		 | CONNECTOR	 of string
		 | TYPE		 of string
		 | PACKAGE	 of string
		 | FUNCTION	 of string
		 | ENUMERATION   of string
		 | HAS_EQUATIONS of string
		 | IS_NEW        of string
		 | TYPE_INTEGER  of string
		 | TYPE_REAL     of string
		 | TYPE_STRING   of string
		 | TYPE_BOOL     of string
		 | TYPE_ENUM of string

  (** - Events *)
  datatype Event = FOUND_EQUATION     (* There are definitions inside the current definition *)
		 | NEWDEF	      (* This is not a derived class *)
  (** The `Event' type contains the different events during *)
  (** instantiation that signals a possible machine transition. *)

  (** - Exported relations *)

  relation start : (SCode.Restriction, string (*ident*)) => State

  (** relation: trans
   **
   ** This is the state machine transition relation.  It describes the
   ** transitions between states at different events.
   **)
  relation trans : (State, Event) => State

  (** relation: valid
   **
   ** This is the validity relation which determines if a state is valid
   ** according to one of the restrictions.  This means, that if a class
   ** definition is to be used as, say, a connector, the state of the
   ** state machine is checked against the `SCode.R_CONNECTOR'
   ** restriction using this relation to find out if it is an error to
   ** use this class definition as a connector.
   **)
   relation valid : (State, SCode.Restriction) => ()

  (* `assert_valid' is identical to 'valid'.  The only difference is *)
  (* that it prints an error message when it fails. *)
  relation assert_valid : (State, SCode.Restriction) => ()
  
  (* Succeeds if state is FUNCTION *)
  relation is_function: State => ()

  relation is_connector: State => ()

  relation matching_state : (State, State list) => bool

  (* Debug relation *)
  relation print_state : State => ()
  relation print_state_str : State => string
  relation get_state_name : State => string

end


with "Print.rml"
with "Error.rml"
(* adrpo -- not used
with "Absyn.rml"
*)

(** - Printing *)
(**)
(** Some relations for printing error and debug information about the *)
(** state machine.
 **
 ** The code is excluded from the report.
 **)
relation print_state_str : State => string =

  axiom	print_state_str UNKNOWN(s) => "unknown"
  axiom	print_state_str MODEL(s) => "model"
  axiom	print_state_str RECORD(s)=> "record"
  axiom	print_state_str BLOCK(s) => "block"

  axiom	print_state_str CONNECTOR(s) => "connector"
  axiom	print_state_str TYPE(s) => "type"
  axiom	print_state_str PACKAGE(s) => "package"

  axiom	print_state_str FUNCTION(s) => "function"
  axiom	print_state_str TYPE_INTEGER(s) => "Integer"
  axiom	print_state_str TYPE_REAL(s) => "Real"

  axiom	print_state_str TYPE_STRING(s) => "String"
  axiom	print_state_str TYPE_BOOL(s) => "Boolean"
  axiom	print_state_str IS_NEW(s) => "new def"
  axiom	print_state_str HAS_EQUATIONS(s) => "has eqn"

end

relation print_state : State => () =

  rule	Print.printBuf "UNKNOWN " & Print.printBuf s
	----------------------------
	print_state UNKNOWN(s)

  rule	Print.printBuf "MODEL " & Print.printBuf s
	----------------------------
	print_state MODEL(s)

  rule	Print.printBuf "RECORD " & Print.printBuf s
	----------------------------
	print_state RECORD(s)

  rule	Print.printBuf "BLOCK " & Print.printBuf s
	----------------------------
	print_state BLOCK(s)

  rule	Print.printBuf "CONNECTOR " & Print.printBuf s
	----------------------------
	print_state CONNECTOR(s)

  rule	Print.printBuf "TYPE " & Print.printBuf s
	----------------------------
	print_state TYPE(s)

  rule	Print.printBuf "PACKAGE " & Print.printBuf s
	----------------------------
	print_state PACKAGE(s)

  rule	Print.printBuf "FUNCTION " & Print.printBuf s
	----------------------------
	print_state FUNCTION(s)

  rule	Print.printBuf "TYPE_INTEGER " & Print.printBuf s
	----------------------------
	print_state TYPE_INTEGER(s)

  rule	Print.printBuf "TYPE_REAL " & Print.printBuf s
	----------------------------
	print_state TYPE_REAL(s)

  rule	Print.printBuf "TYPE_STRING " & Print.printBuf s
	----------------------------
	print_state TYPE_STRING(s)

  rule	Print.printBuf "TYPE_BOOL " & Print.printBuf s
	----------------------------
	print_state TYPE_BOOL(s)

  rule	Print.printBuf "IS_NEW " & Print.printBuf s
	----------------------------
	print_state IS_NEW(s)

  rule	Print.printBuf "HAS_EQUATIONS " & Print.printBuf s
	----------------------------
	print_state HAS_EQUATIONS(s)

end

(** relation: get_state_name
 ** 
 ** Returns the classname of the state.
 **)
relation get_state_name : State => string =

  axiom	get_state_name UNKNOWN(s)	=> s
  axiom	get_state_name MODEL(s)		=> s
  axiom	get_state_name RECORD(s)	=> s
  axiom	get_state_name BLOCK(s)		=> s
  axiom	get_state_name CONNECTOR(s)	=> s
  axiom	get_state_name TYPE(s)		=> s
  axiom	get_state_name PACKAGE(s)	=> s
  axiom	get_state_name FUNCTION(s)	=> s
  axiom	get_state_name TYPE_INTEGER(s)	=> s
  axiom	get_state_name TYPE_REAL(s)	=> s
  axiom	get_state_name TYPE_STRING(s)	=> s
  axiom	get_state_name TYPE_BOOL(s)	=> s
  axiom	get_state_name IS_NEW(s)	=> s
  axiom	get_state_name HAS_EQUATIONS(s)	=> s

end


(** relation: print_event *)
relation print_event : Event => () =

  rule	Print.printBuf "FOUND_EQUATION"
	----------------------
	print_event FOUND_EQUATION

  rule	Print.printBuf "NEWDEF"
	--------------
	print_event NEWDEF

end

(*!includecode*)

(** - Transitions *)

(** 
 ** This is the state machine initialization relation.
 **)
relation start : (SCode.Restriction, string) => State =

  axiom	start (SCode.R_CLASS, s) 	       => UNKNOWN(s)
  axiom	start (SCode.R_MODEL, s) 	       => MODEL(s)
  axiom	start (SCode.R_RECORD, s)            => RECORD(s)
  axiom	start (SCode.R_BLOCK, s)             => BLOCK(s)
  axiom	start (SCode.R_CONNECTOR, s)         => CONNECTOR(s)
  axiom	start (SCode.R_TYPE, s)              => TYPE(s)
  axiom	start (SCode.R_PACKAGE, s)           => PACKAGE(s)
  axiom	start (SCode.R_FUNCTION, s)          => FUNCTION(s)
  axiom	start (SCode.R_EXT_FUNCTION, s)      => FUNCTION(s)
  axiom start (SCode.R_ENUMERATION,s)	     => ENUMERATION(s)
  axiom	start (SCode.R_PREDEFINED_INT, s)    => TYPE_INTEGER(s)
  axiom	start (SCode.R_PREDEFINED_REAL, s)   => TYPE_REAL(s)
  axiom	start (SCode.R_PREDEFINED_STRING, s) => TYPE_STRING(s)
  axiom	start (SCode.R_PREDEFINED_BOOL, s)   => TYPE_BOOL(s)
  axiom	start (SCode.R_PREDEFINED_ENUM, s)   => TYPE_ENUM(s)

end

(** relation: trans
 **
 ** This is the state machine transition relation.  It describes the
 ** transitions between states at different events.
 **)
relation trans : (State, Event) => State =

	(** Event `NEWDEF' *)

  axiom	trans(UNKNOWN(s),        NEWDEF) => IS_NEW(s)
  axiom	trans(MODEL(s),          NEWDEF) => MODEL(s)
  axiom	trans(RECORD(s),         NEWDEF) => RECORD(s)
  axiom	trans(BLOCK(s),          NEWDEF) => BLOCK(s)
  axiom	trans(CONNECTOR(s),      NEWDEF) => CONNECTOR(s)

  rule	Error.add_message(Error.TYPE_NOT_FROM_PREDEFINED,[s])
	-----------------------------------------------
	trans(TYPE(s),           NEWDEF) => fail

  axiom	trans(PACKAGE(s),        NEWDEF) => PACKAGE(s)
  axiom	trans(FUNCTION(s),       NEWDEF) => FUNCTION(s)
  axiom trans(ENUMERATION(s),	 NEWDEF) => ENUMERATION(s)
  axiom	trans(IS_NEW(s),         NEWDEF) => IS_NEW(s)
  axiom	trans(TYPE_INTEGER(s),   NEWDEF) => TYPE_INTEGER(s)
  axiom	trans(TYPE_REAL(s),      NEWDEF) => TYPE_REAL(s)
  axiom	trans(TYPE_STRING(s),    NEWDEF) => TYPE_STRING(s)
  axiom	trans(TYPE_BOOL(s),      NEWDEF) => TYPE_BOOL(s)
  axiom trans(TYPE_ENUM(s),NEWDEF) => TYPE_ENUM(s)
	(** Event `FOUND_EQUATION' *)

  axiom	trans(UNKNOWN(s),        FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(IS_NEW(s),         FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(MODEL(s),          FOUND_EQUATION) => MODEL(s)

  rule	Error.add_message(Error.EQUATION_IN_RECORD,[s])
	-----------------------------------------------
	trans(RECORD(s),         FOUND_EQUATION) => fail

  axiom	trans(BLOCK(s),          FOUND_EQUATION) => BLOCK(s)

  rule	Error.add_message(Error.EQUATION_IN_CONNECTOR,[s])
	-----------------------------------------------
	trans(CONNECTOR(s),      FOUND_EQUATION) => fail

  axiom	trans(TYPE(s),           FOUND_EQUATION) => fail (* CORRECT? *)
  axiom	trans(PACKAGE(s),        FOUND_EQUATION) => fail
  axiom	trans(FUNCTION(s),       FOUND_EQUATION) => fail
  axiom	trans(HAS_EQUATIONS(s),  FOUND_EQUATION) => HAS_EQUATIONS(s)

  rule	Print.printBuf "- trans failed: " & print_state st &
 	Print.printBuf ", " & print_event ev & Print.printBuf "\n"
	--------------------------------------------------------
	trans(st, ev) => fail

end

(** relation: valid
 **
 ** This is the validity relation which determines if a state is valid
 ** according to one of the restrictions.  This means, that if a class
 ** definition is to be used as, say, a connector, the state of the
 ** state machine is checked against the `SCode.R_CONNECTOR'
 ** restriction using this relation to find out if it is an error to
 ** use this class definition as a connector.
 **)
relation valid : (State, SCode.Restriction) => () =

  axiom	valid(UNKNOWN(s), _)

  axiom	valid(IS_NEW(s),        SCode.R_CLASS)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_CLASS)

  axiom	valid(MODEL(s),         SCode.R_MODEL)
  axiom	valid(IS_NEW(s),        SCode.R_MODEL)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_MODEL)

  axiom	valid(RECORD(s),        SCode.R_RECORD)
  axiom	valid(IS_NEW(s),        SCode.R_RECORD)

  axiom	valid(BLOCK(s),         SCode.R_BLOCK)
  axiom	valid(HAS_EQUATIONS(s), SCode.R_BLOCK)

  axiom	valid(CONNECTOR(_),     SCode.R_CONNECTOR)
  axiom	valid(IS_NEW(_),        SCode.R_CONNECTOR)
  axiom valid(TYPE_INTEGER(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_REAL(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_STRING(_),	SCode.R_CONNECTOR)
  axiom valid(TYPE_BOOL(_),	SCode.R_CONNECTOR)

  axiom	valid(TYPE(s),          SCode.R_TYPE)
  axiom	valid(TYPE_INTEGER(s),  SCode.R_TYPE)
  axiom	valid(TYPE_REAL(s),     SCode.R_TYPE)
  axiom	valid(TYPE_STRING(s),   SCode.R_TYPE)
  axiom	valid(TYPE_BOOL(s),     SCode.R_TYPE)

  axiom	valid(IS_NEW(s),        SCode.R_PACKAGE)
  axiom	valid(PACKAGE(s),       SCode.R_PACKAGE)

  axiom	valid(IS_NEW(s),        SCode.R_FUNCTION)
  axiom	valid(FUNCTION(s),      SCode.R_FUNCTION)

end

(** relation: assert_valid
 **
 ** This relation has the same semantical meaning as the relation
 ** `valid'.  However, it prints an error message when it fails.
 **)
relation assert_valid : (State, SCode.Restriction) => () =

  rule	valid(st,re)
	------------
	assert_valid(st,re)

  rule	Print.printErrorBuf "# Restriction violation: " & 
	get_state_name st => str &
	Print.printErrorBuf str &
	Print.printErrorBuf " is not a " &
	SCode.restr_string re => str &
	Print.printErrorBuf str &
	Print.printErrorBuf "\n" 
	-------------------------------------------
	assert_valid(st,re) => fail

end

(** relation: matching_state
 ** 
 ** Finds a State in the list that matches the state given as first argument.
 ** NOTE: Currently not used anywhere.
 **)
relation matching_state : (State, State list) => bool =
	
  axiom	matching_state (st, []) => false

  axiom	matching_state (UNKNOWN(_),	  UNKNOWN(_)::rest) => true
  axiom matching_state (MODEL(_),	  MODEL(_)::rest) => true
  axiom matching_state (RECORD(_),	  RECORD(_)::rest) => true
  axiom matching_state (BLOCK(_),	  BLOCK(_)::rest) => true
  axiom matching_state (CONNECTOR(_),	  CONNECTOR(_)::rest) => true
  axiom matching_state (TYPE(_),	  TYPE(_)::rest) => true
  axiom matching_state (PACKAGE(_),	  PACKAGE(_)::rest) => true
  axiom matching_state (FUNCTION(_),	  FUNCTION(_)::rest) => true
  axiom matching_state (ENUMERATION(_),	  ENUMERATION(_)::rest) => true
  axiom matching_state (HAS_EQUATIONS(_), HAS_EQUATIONS(_)::rest) => true
  axiom matching_state (IS_NEW(_),	  IS_NEW(_)::rest) => true
  axiom matching_state (TYPE_INTEGER(_),  TYPE_INTEGER(_)::rest) => true
  axiom matching_state (TYPE_REAL(_),	  TYPE_REAL(_)::rest) => true
  axiom matching_state (TYPE_STRING(_),	  TYPE_STRING(_)::rest) => true
  axiom matching_state (TYPE_BOOL(_),	  TYPE_BOOL(_)::rest) => true
  axiom matching_state (TYPE_ENUM(_),	  TYPE_ENUM(_)::rest) => true

  rule	matching_state (st, rest) => res
	--------------------------------
	matching_state (st, first::rest) => res
end

(** relation: is_function
 **
 ** Fails for states that are not FUNCTION.
 **)
relation is_function: State => () =
  axiom is_function FUNCTION(_) => ()
end

(** relation: is_connector
 **
 ** Fails for states that are not CONNECTOR.
 **)
relation is_connector: State => () =
  axiom is_connector CONNECTOR(_) => ()
end

