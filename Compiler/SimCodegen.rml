(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 SimCodegen.rml
 ** module:      SimCodegen
 ** description: Generate Simulation code for connecting to solver.
 ** This can be done in two different ways.
 ** 1. Generation of simulation code on residual form. This will generate 
 ** code on the form g(\dot{x},x,y,t)=0.
 ** 2. Generation of simulation code on solved form. This will generate
 ** code on ode form. \dot{x} = f(x,y,t). This means that "function" f will
 ** contain code for solving states from equations, some of them might be 
 ** system of equations, linear or non-linear.
 **
 ** Outputs: the simulation code in C/C++ to a given filename.
 ** Input: DAELow
 ** Uses: DAELow, Absyn, Exp
 **
 **
 ** RCS: $Id$
 **
 **)


module SimCodegen:

  with "DAE.rml"
  with "DAELow.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "SCode.rml"

  relation generate_simulation_code: (DAE.DAElist,
				    DAELow.DAELow, 		      
				    int vector, (* ass1 *)
				    int vector, (* ass2 *)
				    DAELow.IncidenceMatrix,
				    DAELow.IncidenceMatrixT,
				    int list list, (* blocks*)
				    Absyn.Path,  (* classname *)
				    string,
                                      string) => ()
	  	  
  relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
				string,real,real,real)  => ()
	  
  relation generate_makefile: (string, (*filename*)
			       string, (* classname *)
			       string list (* libs *)
			       ) => ()
	  
  relation print_exp_cpp_str : Exp.Exp => string 
	  
  relation cref_modelica_str : Exp.ComponentRef => string 
	  
  relation generate_functions: (SCode.Program,DAE.DAElist, DAELow.DAELow, Absyn.Path, string) => (string list (* libs *))

  relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list
  relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list
  relation print_exp_opt_str_if_const:(Exp.Exp option) => string 
  relation change_name_for_derivative:(string) => string 
	  
end

val TAB = "    " (* TAB is four whitespaces *)

with "Util.rml"
with "RTOpts.rml"
with "Debug.rml"
with "System.rml"
with "Values.rml"
with "Codegen.rml"
with "Print.rml"
with "ModUtil.rml"
with "VarTransform.rml"
with "Dump.rml"
with "Inst.rml"

(** relation: generate_makefile
 **
 ** This relation generates a makefile for the simulation code.
 ** It uses OPENMODELICAHOME as a reference to find c_runtime with libraries.
 **)

relation generate_makefile: (string, (*filename*)
			     string, (* classname *)
			     string list (* libs *)
			     ) => () =
			      
  rule	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_delimit_list(libs, " ") => libs' &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CXX=g++\n",
				 cname,": ",cpp_file, "\n",
				 "\t $(CXX) -o ",cname,".exe ", (* ".exe" is needed for a class that is in a package. *) 
                                 cpp_file, 
		                 " -L$(OPENMODELICAHOME)/c_runtime/",
				 " -I$(OPENMODELICAHOME)/c_runtime/ ",
				 " -lsim -lg2c -lc_runtime ",libs', "\n"
				 ]) => str &
	System.write_file(filename,str) 
	-------------------------
	generate_makefile(filename,cname,libs)
end


(** relation: generate_simulation_code
 **
 ** Outputs simulation code from a DAELow suitable for connection to DASSL.
 ** The state calculations are generated on residual form, i.e. 
 ** g(\dot{x},x,y,t) = 0.
 ** and on explicit ode form, \dot{x}=f(x,y,t)
 **)

relation generate_simulation_code: (DAE.DAElist,
				  DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string,
                                    string) => () =

  rule  Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_output_function_code(dlow) => (out_str,n_o) &
	generate_input_function_code(dlow) => (in_str,n_i) &
	generate_event_checking_code(dlow,blt_states,ass1,ass2,m,mt,class) 
	  => (c_eventchecking, helpVarInfo) & 
	  list_length helpVarInfo => n_h &
        generate_global_data(class,dlow,n_o,n_i,n_h) => cglobal &  
        generate_compute_output(cname,dae,dlow,ass1,ass2,blt_no_states) 
	  => coutput &
          generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blt_states) 
	  => cstate &
	  generate_ode_code(dlow,blt_states,ass1,ass2,m,mt,class) => c_ode &
	generate_initial_value_code(dlow) => s_code &
	generate_when_clauses(cname,dae,dlow,ass1,ass2,comps) => cwhen &
	generate_zero_crossing(cname,dae,dlow,ass1,ass2,comps,helpVarInfo) => czerocross & 
	Util.string_append_list(["//Simulation code for ",cname,
				 "\n//Generated by OpenModelica.\n",
				 "\n#include \"modelica.h\"\n",
				 "\n#include \"",funcfilename,"\"\n",
				 cglobal,coutput,in_str,out_str,cstate,czerocross,cwhen,
				 c_ode,s_code,c_eventchecking]) => res &
	System.write_file(filename,res) 
	---------------------------------------------------------------------
	generate_simulation_code(dae,dlow,ass1,ass2,m,mt,comps,class,filename,funcfilename) => ()


  rule	print "-generate_simulation_code failed\n" &
	Print.print_error_buf "# Generation of simulation code failed\n" 
	-----------------------
	generate_simulation_code(_,_,_,_,_,_,_,_,_,_) => fail
end

(** relation: filter_ng
 ** This relation sets the number of zero crossings to zero if events are disabled
 **)
relation filter_ng: int => int =

  rule	use_zerocrossing => false
	----------------------------------------
	filter_ng _ => 0

  axiom	filter_ng ng => ng

end

(** relation: generate_global_data
 **
 ** This relation generates the C-code for the global data: arrays for states,
 ** derivatives and algebraic variables, etc.
 ** arg1
 ** arg2
 ** arg3 an int which shows the number of output variables on top level
 ** arg4 an int which shows the number of input variables on top level
 ** arg5 an int which shows the number of help variables
 **)
 relation generate_global_data:(Absyn.Path,DAELow.DAELow,int,int,int) => string  =

  rule	DAELow.calculate_sizes(dlow) => (nx,ny,np,ng) &
	filter_ng ng => ng' &
	Absyn.path_string(class) => class_str &
	int_string(nx) => nx_str &
	int_string(ny) => ny_str &
	int_string(np) => np_str &
	int_string(ng') => ng_str &
        int_string(no) => no_str &
        int_string(ni) => ni_str &
        int_string(nh) => nh_str &
	generate_var_names_and_comments(dlow,nx,ny) => (varnames,comments,varnames_old) &
	Util.string_append_list(["\n",
				 "#define NHELP ", nh_str, "\n",
				 "#define NG ",ng_str,"\n",
				 "#define NX ",nx_str,"\n",
				 "#define NY ",ny_str,"\n",
				 "#define NP ",np_str," // number of paramters\n",
				 "#define NO ",no_str," // number of outputvar on topmodel\n",
				 "#define NI ",ni_str," // number of inputvar on topmodel\n",
				 "#define MAXORD 5\n",
				 "#define time (*t)\n",
				 "\n",
                                 "#if NHELP > 0 /* some c-compilers does not like a static array of |a|==0 */\n",
				 "double h[NHELP];\n",
                                 "#else\n",
				 "double *h;\n",
				 "#endif\n",
                                 "#if NX > 0\n",
				 "double x[NX];  // STATES\n",
                                 "#else\n",
				 "double *x;\n",
				 "#endif\n",
                                 "#if NX > 0\n",
				 "double xd[NX]; // DERIVATIVES\n",
                                 "#else\n",
				 "double *xd;\n",
                                 "#endif\n",
                                 "#if NX > 0\n",
				 "double dummy_delta[NX];\n",
                                 "#else\n",
				 "double *dummy_delta;\n",
                                 "#endif\n",
                                 "#if NY > 0\n",
				 "double y[NY]; // ALGVARS\n",
                                 "#else\n",
				 "double *y;\n",
                                 "#endif\n",
                                 "#if NP > 0\n",
				 "double p[NP];  // PARAMETERS\n",
                                 "#else\n",
				 "double *p;\n",
                                 "#endif\n",
                                 "#if NO > 0\n",
				 "double out_y[NO]; // OUTPUTVARS\n",
				 "#else\n",
				 "double *out_y;\n",
                                 "#endif\n",
                                 "#if NG > 0\n",
				 "long jroot[NG];\n",
                                 "#else\n",
				 "long *jroot;\n",
                                 "#endif\n",
				 "double rwork[50+(MAXORD+4)*NX+NX*NX+3*NG];\n",
                                 "#if NI > 0\n",
				 "double in_y[NI]; // INPUTVARS\n",
				 "#else\n",
				 "double *in_y;\n",
                                 "#endif\n",
				 "long iwork[20+NX];\n",
				 "long liw = 20+NX;\n", 
				 "long lrw = 50+(MAXORD+4)*NX+NX*NX+3*NG;\n",
				 "long nx = NX; // STATES\n",
				 "long ny = NY; // ALGVARS\n",
				 "long np = NP; // PARAMETERS\n",
				 "long ng = NG; \n",
				 "long no = NO; // OUTPUTVARS\n",
				 "long ni = NI; // INPUTVARS \n",
				 "long nhelp = NHELP;\n",
				 "char *model_name=\"",class_str,
				 "\";\n",
				 varnames,"\n",
                                 varnames_old,"// this is generated for compatibility with openmodelica simulation_runtime","\n",
                                 comments,"\n"]
				 )  => str 
	---------------------------
	generate_global_data(class, dlow,no,ni,nh) => str
	
  rule	Print.print_error_buf "Internal Error, generate_global_data failed\n" 
	 ---------------------
	 generate_global_data(_,_,_,_,_) => fail
end



(** relation: generate_var_names_and_comments
 **
 ** Generates an array of the original variable names.
 **)

relation generate_var_names_and_comments:(DAELow.DAELow,int, int) => (string,string,string) =

  rule	


        DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
        

        generate_var_names_and_comments2(var_lst,
                                         (*names,comments,numberof*)
                                         "","",0,(* state*)
                                         "","",0,(* derivative  *)
                                         "","",0,(* algvars *)
                                         "","",0,(* input *)
                                         "","",0,(* output *)
                                         "","",0 (* param *)
                                         )
        
          => (state_str',state_comments',num_state',(* state *)
              derivative_str',derivative_comments',num_derivative',(* derivative *)
              algvars_str',algvars_comments',num_algvars',(* algvars *)
              input_str',input_comments',num_input',(* input *)
              output_str',output_comments',num_output',(* output *)
              param_str',param_comments',num_param' (* param *)) &


        generate_var_names_and_comments2(knvar_lst,
                                         (*names,comments,numberof*)
                                         state_str',state_comments',num_state',(* state *)
                                         derivative_str',derivative_comments',num_derivative',(* derivative *)
                                         algvars_str',algvars_comments',num_algvars',(* algvars *)
                                         input_str',input_comments',num_input',(* input *)
                                         output_str',output_comments',num_output',(* output *)
                                         param_str',param_comments',num_param' (* param *)) 
        
          => (state_str'',state_comments'',num_state'',(* state *)
              derivative_str'',derivative_comments'',num_derivative'',(* derivative *)
              algvars_str'',algvars_comments'',num_algvars'',(* algvars *)
              input_str'',input_comments'',num_input'',(* input *)
              output_str'',output_comments'',num_output'',(* output *)
              param_str'',param_comments'',num_param'' (* param *)) &

        

        Util.string_delimit_list_no_empty([state_str'',derivative_str'',algvars_str''],", ") => var_names &
        int_add(num_state'',num_derivative'') => num_var_names &
        int_add(num_var_names,num_algvars'') => num_var_names' &

        generate_c_decl_for_string_array("varnames",var_names,num_var_names') => var_names' &

        generate_c_decl_for_string_array("state_names",state_str'',num_state'') => state_str''' &
        generate_c_decl_for_string_array("derivative_names",derivative_str'',num_derivative'') =>der_str'''  &
        generate_c_decl_for_string_array("algvars_names",algvars_str'',num_algvars'') => algvar_str''' &
        generate_c_decl_for_string_array("input_names",input_str'',num_input'') => inputvar_str''' &
        generate_c_decl_for_string_array("output_names",output_str'',num_output'') => outputvar_str''' &
        generate_c_decl_for_string_array("param_names",param_str'',num_param'') => paramvar_str''' &
        
	Util.string_append_list([
                                 state_str''',der_str''',algvar_str''',inputvar_str''',outputvar_str''',paramvar_str'''
                                 ]) => res &

        generate_c_decl_for_string_array("state_comments",state_comments'',num_state'') => state_comment_lst' &
        generate_c_decl_for_string_array("derivative_comments",derivative_comments'',num_derivative'') =>der_comment_lst'  &
        generate_c_decl_for_string_array("algvars_comments",algvars_comments'',num_algvars'') => algvar_comment_lst' &
        generate_c_decl_for_string_array("input_comments",input_comments'',num_input'') => inputvar_comment_lst' &
        generate_c_decl_for_string_array("output_comments",output_comments'',num_output'') => outputvar_comment_lst' &
        generate_c_decl_for_string_array("param_comments",param_comments'',num_param'') => paramvar_comment_lst' &

	Util.string_append_list([
                                 state_comment_lst',der_comment_lst',algvar_comment_lst',
                                 inputvar_comment_lst',outputvar_comment_lst',paramvar_comment_lst'
                                 ]) => res2
        ----------------------------------------
	generate_var_names_and_comments(DAELow.DAELOW(vars,knvars,_,_,_,_,_),nx,ny) => (res,res2,var_names')
        
end

(**relation generate_c_decl_for_string_array
 **author x02lucpo
 **
 **generates a static C-array with char* <name>[<number>] or only a char** depending it the int parameters is > 0
 **)
relation generate_c_decl_for_string_array:(string,string,int) => string =
        
  rule  int_eq(number_of_strings,0) => true &
        Util.string_append_list(["char** ",array_name,";\n"]) => res
        -----------------------------------
        generate_c_decl_for_string_array(array_name,_,number_of_strings) => res
        
        
  rule  int_string(number_of_strings) => number_of_strings_str &
        Util.string_append_list(["char* ",array_name,"[",number_of_strings_str,"]={",array_str,"};\n"]) => res
        -----------------------------------
        generate_c_decl_for_string_array(array_name,array_str,number_of_strings) => res
        
        
end

(** relation: generate_var_names_and_comments2
 **
 ** Helper relation to generate_var_names_and_comments2
 **)
                   
relation generate_var_names_and_comments2:(DAELow.Var list, 
                                           (*names,comments,numberof*)
                                           string,string,int,(* state*)
                                           string,string,int,(* derivative  *)
                                           string,string,int,(* algvars *)
                                           string,string,int,(* input *)
                                           string,string,int,(* output *)
                                           string,string,int (* param *)
                                           ) 

          => (
              string,string,int,(* state *)
              string,string,int,(* derivative *)
              string,string,int,(* algvars *)
              string,string,int,(* input *)
              string,string,int,(* output *)
              string,string,int (* param *)
              ) =

 

  rule  
        ---------------------------
        generate_var_names_and_comments2([],
                                         state_str,state_comments,num_state,(* state *)
                                         derivative_str,derivative_comments,num_derivative,(* derivative *)
                                         algvars_str,algvars_comments,num_algvars,(* algvars *)
                                         input_str,input_comments,num_input,(* input *)
                                         output_str,output_comments,num_output,(* output *)
                                         param_str,param_comments,num_param (* param *)) 
          => (state_str,state_comments,num_state,(* state *)
              derivative_str,derivative_comments,num_derivative,(* derivative *)
              algvars_str,algvars_comments,num_algvars,(* algvars *)
              input_str,input_comments,num_input,(* input *)
              output_str,output_comments,num_output,(* output *)
              param_str,param_comments,num_param (* param *)) 
        
  rule  (*generate INPUTS names*)
        generate_var_names_and_comments2(vs,
                                         state_str,state_comments,num_state,(* state *)
                                         derivative_str,derivative_comments,num_derivative,(* derivative *)
                                         algvars_str,algvars_comments,num_algvars,(* algvars *)
                                         input_str,input_comments,num_input,(* input *)
                                         output_str,output_comments,num_output,(* output *)
                                         param_str,param_comments,num_param (* param *)) 
          => (state_str',state_comments',num_state',(* state *)
              derivative_str',derivative_comments',num_derivative',(* derivative *)
              algvars_str',algvars_comments',num_algvars',(* algvars *)
              input_str',input_comments',num_input',(* input *)
              output_str',output_comments',num_output',(* output *)
              param_str',param_comments',num_param' (* param *)) &
        
        (*generate INPUTS names*)
        generate_var_names_and_comments_inputs(var,num_input') => (origname',comment',num_input'') &
        Util.string_delimit_list_no_empty([origname',input_str'],", ") => input_str'' &
        Util.string_delimit_list_no_empty([comment',input_comments'],", ") => input_comments'' &

        (*generate OUTPUT names*)
        generate_var_names_and_comments_outputs(var,num_output') => (origname',comment',num_output'') &
        Util.string_delimit_list_no_empty([origname',output_str'],", ") => output_str'' &
        Util.string_delimit_list_no_empty([comment',output_comments'],", ") => output_comments'' &

        (*generate PARAM names*)
        generate_var_names_and_comments_params(var,num_param') => (origname',comment',num_param'') &
        Util.string_delimit_list_no_empty([origname',param_str'],", ") => param_str'' &
        Util.string_delimit_list_no_empty([comment',param_comments'],", ") => param_comments'' &

        (*generate STATE names*)
        (*generate DERIVATIVES names because the same combination of var_kind and direction*)
        generate_var_names_and_comments_states_and_derivatives(var,num_state') => (origname',comment',
                                                                                   der_origname, num_state'') &
        Util.string_delimit_list_no_empty([origname',state_str'],", ") => state_str'' &
        Util.string_delimit_list_no_empty([comment',state_comments'],", ") => state_comments'' &
        Util.string_delimit_list_no_empty([der_origname,derivative_str'],", ") => derivative_str'' &
        Util.string_delimit_list_no_empty([comment',derivative_comments'],", ") => derivative_comments'' &
        let num_derivative'' = num_state'' &

        (*generate ALGVARS names*)
        generate_var_names_and_comments_algvars(var,num_algvars') => (origname',comment',num_algvars'') &
        Util.string_delimit_list_no_empty([origname',algvars_str'],", ") => algvars_str'' &
        Util.string_delimit_list_no_empty([comment',algvars_comments'],", ") => algvars_comments'' 

        -----------------------
        generate_var_names_and_comments2((var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow))::vs,
                                         state_str,state_comments,num_state,(* state *)
                                         derivative_str,derivative_comments,num_derivative,(* derivative *)
                                         algvars_str,algvars_comments,num_algvars,(* algvars *)
                                         input_str,input_comments,num_input,(* input *)
                                         output_str,output_comments,num_output,(* output *)
                                         param_str,param_comments,num_param (* param *))
        
          => (state_str'',state_comments'',num_state'',(* state *)
              derivative_str'',derivative_comments'',num_derivative'',(* derivative *)
              algvars_str'',algvars_comments'',num_algvars'',(* algvars *)
              input_str'',input_comments'',num_input'',(* input *)
              output_str'',output_comments'',num_output'',(* output *)
              param_str'',param_comments'',num_param'' (* param *)) 



  rule  print "generate_var_names_and_comments2 failed \n"
	-----------------------
	generate_var_names_and_comments2(_::vs, 
                                         state_str,state_comments,num_state,(* state *)
                                         derivative_str,derivative_comments,num_derivative,(* derivative *)
                                         algvars_str,algvars_comments,num_algvars,(* algvars *)
                                         input_str,input_comments,num_input,(* input *)
                                         output_str,output_comments,num_output,(* output *)
                                         param_str,param_comments,num_param (* param *)) 
        
          => fail

end

(** relation generate_var_names_and_comments_inputs
 ** Checks and generates a comment and input for a input variable
 ** author x02lucpo
 **)

relation generate_var_names_and_comments_inputs:(DAELow.Var, (* the variable to checked *)
                                           int) (* the old number of variables generated *)
          => (string, (* name of the from "a" *)
              string, (* comment of the from "a afhalk" *)
              int) = (* number of generated strings *) 
                                                                           
  rule  DAELow.is_var_on_top_level_and_input(var) => true &
        Util.string_append_list(["\"",origname,"\""]) => name' &
        Dump.unparse_comment_option(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' 
        --------------------------------
        generate_var_names_and_comments_inputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => (name',comment',n_vars')


  axiom generate_var_names_and_comments_inputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => ("","",n_vars)


end


(** relation generate_var_names_and_comments_outputs
 ** Checks and generates a comment and input for a output variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_outputs:(DAELow.Var, (* the variable to checked *)
                                           int) (* the old number of variables generated *)
          => (string, (* name of the from "a" *)
              string, (* comment of the from "a afhalk" *)
              int) = (* number of generated strings *) 
                                                                           
  rule  DAELow.is_var_on_top_level_and_output(var) => true &
        Util.string_append_list(["\"",origname,"\""]) => name' &
        Dump.unparse_comment_option(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' 
        --------------------------------
        generate_var_names_and_comments_outputs(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => (name',comment',n_vars')


  axiom generate_var_names_and_comments_outputs(DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => ("","",n_vars)


end

(** relation generate_var_names_and_comments_algvars
 ** Checks and generates a comment and input for a algvar variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_algvars:(DAELow.Var, (* the variable to checked *)
                                           int) (* the old number of variables generated *)
          => (string, (* name of the from "a" *)
              string, (* comment of the from "a afhalk" *)
              int) = (* number of generated strings *) 
                                                                           
  rule  let kind_lst =  [DAELow.VARIABLE,DAELow.DISCRETE,
                         DAELow.DUMMY_DER,DAELow.DUMMY_STATE] &
        Util.list_getmember(kind,kind_lst) => _ & (* if this fails then the var is not added to list*)
        Util.string_append_list(["\"",origname,"\""]) => name' &
        Dump.unparse_comment_option(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' 
        --------------------------------
        generate_var_names_and_comments_algvars(DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => (name',comment',n_vars')


  axiom generate_var_names_and_comments_algvars(DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => ("","",n_vars)


end

(** relation generate_var_names_and_comments_params
 ** Checks and generates a comment and input for a param variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_params:(DAELow.Var, (* the variable to checked *)
                                           int) (* the old number of variables generated *)
          => (string, (* name of the from "a" *)
              string, (* comment of the from "a afhalk" *)
              int) = (* number of generated strings *) 
                                                                           
  rule  DAELow.is_param(var) => true &
        Util.string_append_list(["\"",origname,"\""]) => name' &
        Dump.unparse_comment_option(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' 
        --------------------------------
        generate_var_names_and_comments_params(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => (name',comment',n_vars')


  axiom generate_var_names_and_comments_params(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => ("","",n_vars)


end

(** relation generate_var_names_and_comments_states_and_derivatives
 ** Checks and generates a comment and input for a state and derivative variable
 ** author x02lucpo
 **)
relation generate_var_names_and_comments_states_and_derivatives:(DAELow.Var, (* the variable to checked *)
                                           int) (* the old number of variables generated *)
          => (string, (* name of the from "a" *)
              string, (* comment of the from "a afhalk" *)
              string, (* name of the from "der(a)" *)
              (*no need for comments because of there are the same as states-comments*)
             int) = (* number of generated strings *) 
                                                                           
  rule  DAELow.is_state_var(var) => true &
        Util.string_append_list(["\"",origname,"\""]) => name' &
        change_name_for_derivative(origname) => der_origname' &
        Util.string_append_list(["\"",der_origname',"\""]) => der_name' &
        Dump.unparse_comment_option(comment) => comment &
        int_add(n_vars,1) => n_vars' &
        generate_empty_string(comment) => comment' 
        --------------------------------
        generate_var_names_and_comments_states_and_derivatives(var as DAELow.VAR(cr,kind,dir,_,_,_,
				                                          _,value,indx,origname,_,dae_var_attr,comment,flow),
                                                               n_vars) => (name',comment',der_name',n_vars')
        

  axiom generate_var_names_and_comments_states_and_derivatives(DAELow.VAR(cr,kind,dir,_,_,_,
				                    _,value,indx,origname,_,dae_var_attr,comment,flow),
                                         n_vars) => ("","","",n_vars)


end


(**relation change_name_for_derivative
 **author x02lucpo
 **
 **helper relation to generate_var_names_and_comments. 
 **Changes a string from "a.b.c" to "a.b.der(c)"
 **)
 relation change_name_for_derivative:(string) => string =
        

        (*catch the variable names a *)
        
  rule  Util.string_split_at_char(origname,#".") => [var_name] &
	Util.string_append_list(["der(",var_name,")"]) => der_var_name' 
        ------------------------------------
        change_name_for_derivative(origname) => der_var_name'

  rule  Util.string_split_at_char(origname,#".") => origname_lst &
         Util.list_last(origname_lst) => var_name &
         Util.list_strip_last(origname_lst) => origname_lst' &
	 Util.string_append_list(["der(",var_name,")"]) => der_var_name' &
         Util.string_delimit_list(origname_lst',".") => prefix &
         Util.string_append_list([prefix,".",der_var_name']) => ret_str 
        ------------------------------------
        change_name_for_derivative(origname) => ret_str

  rule  (* print "change_name_for_derivative FAILED"  *)
        --------------------------------
        change_name_for_derivative(origname') => origname'

end




(** relation: generate_empty_string
 **
 ** This relation adds citation chars to an empty string. Non empty strings
 ** are returned as is.
**)
		 
relation generate_empty_string: (string) => string =

  axiom	generate_empty_string("") => "\"\""

  axiom	generate_empty_string(s) => s 
end
	




(** relation: generate_input_function_code
 **
 **  Generates the input_function for all the variables
 **  that are INPUT and on top model
**)

relation generate_input_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        generate_input_function_code2(knvars_lst,0) => res1 &
        list_length(res1) => lst_lenght &
        Util.string_delimit_list_no_empty(res1,"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nvoid input_function(double *in_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "\n}\n"]) => res
        -------------------------------------

        generate_input_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => (res,lst_lenght)

  rule	Print.print_error_buf "Internal Error, generate_input_function_code failed\n" 
	----------------------
	generate_input_function_code(_) => fail
end

(** relation: generate_input_function_code2
 **
 ** Helper relation to generate_input_function_code
 **)

relation generate_input_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_input_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_input(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list([cr_str," = in_x[",i_str,"];"]) => assign_str &
        generate_input_function_code2(rest,i') => res
        --------------------------
        generate_input_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_input_function_code2(rest,index) => res
        --------------------------------
        generate_input_function_code2(var::rest,
                                       index) => res

end

(** relation: generate_output_function_code
 **
 **  Generates the output_function for all the variables
 **  that are OUTPUT and on top model
**)

relation generate_output_function_code:(DAELow.DAELow) => (string,int) = 

  rule  DAELow.var_list(knvars) => knvars_lst &
        DAELow.var_list(vars) => vars_lst &
        list_append(knvars_lst,vars_lst) => vars_lst' &
        generate_output_function_code2(vars_lst',0) => res1 &
        list_length(res1) => lst_lenght &
        Util.string_delimit_list_no_empty(res1,"\n  ") => res1' &
        Util.string_append_list(["\n/*\n*/\nvoid output_function(double *out_x,double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n  ",
                                 res1',
                                 "\n}\n"]) => res
        -------------------------------------
        generate_output_function_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => (res,lst_lenght)

  rule	Print.print_error_buf "Internal Error, generate_output_function code failed\n"
	-----------------------
	generate_output_function_code(_) => fail
end

(** relation: generate_output_function_code2
 **
 ** Helper relation to generate_output_function_code
 **)

relation generate_output_function_code2:(DAELow.Var list,int) => string list =

  axiom  generate_output_function_code2([],int) => []

  rule  DAELow.is_var_on_top_level_and_output(var) => true &
        int_string(i) => i_str &
        int_add(i,1) => i' &
        Exp.print_component_ref_str(cr) => cr_str &
        
        Util.string_append_list(["out_y[",i_str,"] =",cr_str,";"]) => assign_str &
        generate_output_function_code2(rest,i') => res
        --------------------------
        generate_output_function_code2((var as DAELow.VAR(cr,_,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow))::rest,
                                       i)
          => assign_str::res

  rule generate_output_function_code2(rest,index) => res
        --------------------------------
        generate_output_function_code2(var::rest,
                                       index) => res

end


(** relation: generate_initial_value_code
 **
 ** This relation generates the code for solving the initial value problem.
 ** Information is gathered from the start and fixed attributes of variables
 ** and from initial equations.
 **)

relation generate_initial_value_code:(DAELow.DAELow) => string =

  rule  DAELow.var_list(vars) => vars_lst &
	DAELow.equation_list(ie) => initial_eqns1 &
	generate_initial_equations_from_start(vars_lst) => initial_eqns2 &
	generate_initial_assignments_from_start(vars_lst) => start_assigns &
	
	list_append(initial_eqns1,initial_eqns2) => initial_eqns &
	DAELow.list_equation(initial_eqns) => initial_eqns' &
	list_array([]) => arr &
	let empty_eqn = DAELow.EQUATION_ARRAY(0,0,arr) &

	let initial_dae = DAELow.DAELOW(vars,knvars,initial_eqns',empty_eqn,empty_eqn,al,ev) &
	(* States are no longer special, they are just a variable that 
	 * needs an initial value. *)
	DAELow.make_all_states_algebraic(initial_dae) => initial_dae' &
 	DAELow.incidence_matrix(initial_dae') => m &
 	DAELow.transpose_matrix(m) => mT &
	(* once dae has been translated, state or not should not matter *)
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.abs_incidence_matrix(mT) => mT' &
	(*DAELow.dump initial_dae' &
	DAELow.dump_incidence_matrix m' &*)
	(* index reduction for intitial equations makes no sense.. *)
	DAELow.matching_algorithm(initial_dae',m',mT',(DAELow.NO_INDEX_REDUCTION,DAELow.ALLOW_UNDERCONSTRAINED)) 
	  => (ass1,ass2,initial_dae',m,mT) &
	DAELow.strong_components(m',mT',ass1,ass2) => blocks &
	generate_ode_blocks(initial_dae',ass1,ass2,blocks)
	  => (block_code,extra_funcs) &
        Util.string_append_list([extra_funcs,
				 "\n/*\n*/\nvoid initial_function(double *x, double *xd, double *y, double *p,\n",
                                 "                   int nx, int ny, int np)\n",
                                 "{\n",
				 start_assigns,
                                 block_code,
                                 "\n}\n"]) => res 
        ----------------------------------
        generate_initial_value_code(DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev)) => res
        
  axiom generate_initial_value_code(_) => ""

end

(** relation: generate_initial_equations_from_start
 **
 ** This relation generates equations from the expressions in the start 
 ** attributes of variables. Only variables with a start value and 
 ** fixed set to true is converted by this relation. Fixed set to false
 ** means an initial guess, and is not considered here.
 **)

relation generate_initial_equations_from_start: DAELow.Var list 
	  => DAELow.Equation list =

  axiom	generate_initial_equations_from_start ([]) => []
	
	(* add equations for variables with fixed = true*)
  rule	DAELow.var_fixed(attr,kind) => true &
	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start(DAELow.VAR(cr,kind,_,_,_,_,_,SOME(startv),_,_,_,attr,_,_)::vars)
	  => DAELow.EQUATION(Exp.CREF(cr,Exp.OTHER),startv)::eqns

  rule	generate_initial_equations_from_start(vars) => eqns 
	--------------------------
	generate_initial_equations_from_start(_::vars)
	  => eqns
end

(** relation: generate_initial_assignments_from_start
 **
 **)

relation generate_initial_assignments_from_start: DAELow.Var list 
	  => string =

  axiom	generate_initial_assignments_from_start ([]) => ""
	

	  (*also add an assignment for variables that have non-constant
	   * expressions, e.g. parameter values, as start.
	   NOTE: such start attributes can then not be changed in the text
	   file, since the initial calc. will override those entries!
	   *)
  rule	Exp.is_const(startv) => false &
	generate_initial_assignments_from_start(vars) => strs &
	Exp.print_component_ref_str(cr) => cr_str &
	print_exp_cpp_str(startv) => startv_str &
	Util.string_append_list([cr_str," = ",startv_str,";\n",strs]) => str
	--------------------------
	generate_initial_assignments_from_start(DAELow.VAR(cr,kind,_,_,_,_,_,SOME(startv),_,_,_,attr,_,_)::vars)
	  => str

  rule	generate_initial_assignments_from_start(vars) => str
	--------------------------
	generate_initial_assignments_from_start(_::vars)
	  => str
end

(** relation generate_ode_code
 ** Outputs simulation code from a DAELow. 
 ** The state calculations are generated on explicit ode form: 
 ** \dot{x} := f(x,y,t)
**)
relation generate_ode_code: (DAELow.DAELow, 
			     int list list, (* components*)
			     int vector, (* ass1 *)
			     int vector, (* ass2 *)
			     DAELow.IncidenceMatrix,
			     DAELow.IncidenceMatrixT,
			     Absyn.Path) => string =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dlow,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_ode_blocks(dlow,ass1,ass2,blt_states) 
	  => (block_code, extra_funcs) &
	generate_ode_header() => cheader &
	generate_ode_footer() => cfooter &
	Util.string_append_list([extra_funcs,cheader,block_code,cfooter]) => res
	-------------------------------------------
	generate_ode_code(dlow,comps,ass1,ass2,m,mt,class) => res

  rule	Print.print_error_buf "Internal Error, generate_ode_code failed\n" 
	-------------------------------
	generate_ode_code(dlow,comps,ass1,ass2,m,mt,class) => fail
end


(** relation: build_when_condition_checks3
 ** Helper function to build_when_condition_checks
 **)
relation build_when_condition_checks3: (Exp.Exp list (* list of condition expressions*), 
					int (* when clause index *), 
					int (*next help var index*)) 
	  => (string, (int (* helpvar ind *) * 
		       Exp.Exp (* helpvar binding *) * 
		       int (* when clause index *) ) list ) =

  axiom	build_when_condition_checks3([],_,_) => ("",[])

  rule   int_string i => i_str &
	int_string helpVarIndex => helpVarIndexStr &
	let helpInfo = (helpVarIndex,e,i) &
	Util.string_append_list(["  if (edge(h[",helpVarIndexStr,"])) AddEvent(", i_str," + ng);\n"]) => res &
        helpVarIndex + 1 => helpVarIndex' &
         build_when_condition_checks3(el, i, helpVarIndex') => (resx, helpVarInfoList) &
	string_append(res, resx) => res' 
	----------------------------------------
	build_when_condition_checks3(e::el,i,helpVarIndex) => (res', helpInfo::helpVarInfoList)

  rule   print "-build_when_condition_checks3 failed.\n"
	----------------------------------------
	build_when_condition_checks3(_,_,_) => fail
end

(**
 ** This relation outputs checks for all when clauses that do not have equations but reinit statements
 **)
relation build_when_condition_checks2: (DAELow.WhenClause list, int (* whenClauseIndex *), int (*NextHelpVarIndex*) ) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index *) ) list ) =

  axiom  build_when_condition_checks2([],_,_) => ("",[])

	(* skip if there are no reinit statements *)
  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res,helpVarInfoList) 
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(_,[]))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3(el, i, nextHelpIndex') => (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(Exp.ARRAY(_,_,el),_))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	i + 1 => i' &
	build_when_condition_checks2(xs, i',nextHelpIndex) => (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3([e], i,nextHelpIndex') => (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList
	----------------------------------------
	build_when_condition_checks2((wc as DAELow.WHEN_CLAUSE(e,_))::xs, i, nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule   print "-build_when_condition_checks2 failed.\n"
	----------------------------------------
	build_when_condition_checks2(_,_,_) => fail
end

(** relation: build_when_condition_checks4
 ** Helper function to build_when_condition_checks
 **)
relation build_when_condition_checks4: (int list, DAELow.Equation list, DAELow.WhenClause list, int (*NextHelpVarIndex*) ) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index *) ) list ) =

  axiom  build_when_condition_checks4([],_,_,_) => ("",[])

  rule	eqn - 1 => eqn' &
	list_nth(eqnl, eqn') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(ind,cr,e)) &
	ind - 1 => ind' & 
	list_nth(whenClauseList,ind) => DAELow.WHEN_CLAUSE(Exp.ARRAY(_,_,el),_) &
	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3(el,ind,nextHelpIndex') =>  (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList	
	--------------------------------------------------
	build_when_condition_checks4(eqn::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)
	
  rule	eqn - 1 => eqn' &
	list_nth(eqnl, eqn') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(ind,cr,e)) &
	ind - 1 => ind' & 
	list_nth(whenClauseList,ind) => DAELow.WHEN_CLAUSE(e,_) &
	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res2,helpVarInfoList2) &
	list_length helpVarInfoList2 => numberOfNewHelpVars &
	nextHelpIndex + numberOfNewHelpVars => nextHelpIndex' &
	build_when_condition_checks3([e],ind,nextHelpIndex') =>  (res1,helpVarInfoList1) &
	string_append(res1,res2) => res &
	list_append(helpVarInfoList1,helpVarInfoList2) => helpVarInfoList	
	--------------------------------------------------
	build_when_condition_checks4(eqn::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)

  rule	build_when_condition_checks4(rest,eqnl,whenClauseList,nextHelpIndex) =>  (res,helpVarInfoList) 
	--------------------------------------------------
	build_when_condition_checks4(_::rest,eqnl,whenClauseList,nextHelpIndex) 
	  => (res,helpVarInfoList)
	
  rule   print "-build_when_condition_checks4 failed.\n"
	----------------------------------------
	build_when_condition_checks4(_,_,_,_) => fail

end


(** relation: add_missing_equations
 ** Helper function to build_when_condition_checks
 ** Given an integer and a list of integers completes the list with missing 
 ** integers upto the given integer.
 **)
relation add_missing_equations: (int, int list) => int list =

  axiom	add_missing_equations(0,lst) => lst

  rule	n - 1 => n' &
	add_missing_equations(n',lst) => lst' &
	Util.list_getmember(n,lst) => _
	--------------------------------------------------
	add_missing_equations(n,lst) => lst'


  rule	n - 1 => n' &
	add_missing_equations(n',lst) => lst' 
	--------------------------------------------------
	add_missing_equations(n,lst) => n::lst'
end


(** relation:  build_when_condition_checks
 **)
relation build_when_condition_checks: (DAELow.DAELow, int list list) 
	  => (string,(int (* helpvar ind *) * 
		      Exp.Exp (* helpvar binding *) * 
		      int (* when clause index  *) ) list ) =
	
  rule	generate_equation_order(blocks) => orderOfEquations &
         DAELow.equation_list(eqns) => eqnl &
         list_length(eqnl) => n &
	add_missing_equations(n, orderOfEquations) => orderOfEquations' &
	build_when_condition_checks4(orderOfEquations',eqnl, whenClauseList, 0) => (res1, helpVarInfo1) &
	list_length(helpVarInfo1) => n &
	build_when_condition_checks2(whenClauseList,0,n) => (res2,helpVarInfo2) &
	string_append(res1,res2) => res &
	list_append(helpVarInfo1,helpVarInfo2) => helpVarInfo
	----------------------------------------
	build_when_condition_checks(dlow as DAELow.DAELOW(_,_,eqns,_,_,_,DAELow.EVENT_INFO(whenClauseList,_)),blocks) => (res, helpVarInfo)
	
  rule   print "-build_when_condition_checks failed.\n"
	----------------------------------------
	build_when_condition_checks(_,_) => fail
end 



(** relation:  generate_event_checking_code
 ** 
**)
relation generate_event_checking_code: (DAELow.DAELow, 
			     int list list, (* components*)
			     int vector, (* ass1 *)
			     int vector, (* ass2 *)
			     DAELow.IncidenceMatrix,
			     DAELow.IncidenceMatrixT,
			     Absyn.Path) 
	  => (string, (int (* helpvar ind *) * 
		       Exp.Exp (* helpvar binding *) * 
		       int (* when clause index *) ) list) =

  rule	use_zerocrossing => usezc &
	build_when_condition_checks(dlow,comps) => (check_code, helpVarInfo) & 
	Util.if(usezc,check_code,"") => check_code' &
	Util.string_append_list(["void\ncheckForDiscreteVarChanges(double *t)\n{\n",
				 check_code', "}\n"]) => res
	-------------------------------------------
	generate_event_checking_code(dlow,comps,ass1,ass2,m,mt,class) => (res, helpVarInfo)

  rule	Print.print_error_buf "Internal error, generate_event_checking_code failed\n"
	----------------------------------------
	generate_event_checking_code(_,_,_,_,_,_,_) => fail
end

(** relation: generate_ode_header
 ** author: PA
 **
 ** Geneates the header of the function for calcuating the explicit ode
 **)
relation generate_ode_header: () => string =
	
  rule	Util.string_append_list(
	[
	 "void functionODE(double *x, double *xd, double *y, double *p, \n",
	 "                  int nx, int ny, int np, double *t)\n",
	 "{\n"
	 ]) => res
	------------------------
	generate_ode_header() => res

end	

(** relation: generate_ode_footer
 ** author: PA
 **
 ** Geneates the footer of the function for calcuating the explicit ode
 **)
relation generate_ode_footer: () => string =
	
  rule	Util.string_append_list(
	[
	 "}\n"

	 ]) => res
	------------------------
	generate_ode_footer() => res
end	

(** relation: generate_ode_blocks
 ** author: PA
 **
 ** Generates the simulation code for the ode code.
 ** 
**)
relation generate_ode_blocks:(DAELow.DAELow, int vector, int vector, int list list) 
	  => (string, (* block code*)
	      string) (* extra functions code*) =

  axiom	generate_ode_blocks(_,_,_,[]) => ("","")

  rule	(* For system of equations *)
	generate_ode_system(dae,ass1,ass2,block) => (s1,f1)  &
	generate_ode_blocks(dae,ass1,ass2,blocks) => (s2,f2) &
	string_append(s1,s2) => res &
	string_append(f1,f2) => res2 
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks) 
	  => (res,res2)
	
  rule	(* for single equations *)
	generate_ode_equation(dae,ass1,ass2,eqn) => (s1,f1) &
	generate_ode_blocks(dae,ass1,ass2,blocks) => (s2,f2) &
	string_append(s1,s2) => res &
	string_append(f1,f2) => res2 
	-------------------------------------
	generate_ode_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => (res,res2)

  rule	print "-generate_ode_blocks failed\n" 
	-----------------
	generate_ode_blocks(_,_,_,_) => fail
end

(** relation: generate_ode_system
 ** author: PA
 **
 ** Generates code for a subsystem of equations, both linear and non-linear.
 **)
relation generate_ode_system: (DAELow.DAELow, int vector, int vector, int list) 
	  => (string, (* system code *)
	      string) = (* extra function code*) 

  rule	(** extract the variables and equations of the block.*)
	Util.list_map_3_2(block,get_equation_and_solved_var,eqns,vars,ass2) 
	  => (eqn_lst,var_lst) &
	Util.list_map(var_lst,transform_x_to_xd) => var_lst' &  
	DAELow.list_var(var_lst') => vars' &
	DAELow.list_equation(eqn_lst) => eqns' &
	let subsystem_dae = DAELow.DAELOW(vars',knvars(* not used*),eqns',se,ie,al,ev) &
	
	DAELow.incidence_matrix(subsystem_dae) => m &
	DAELow.abs_incidence_matrix(m) => m' &
	DAELow.transpose_matrix(m') => mt' &
	(* calculate jacobian. If constant, linear system of equations. Otherwise nonlinear *)
	
	DAELow.calculate_jacobian(vars',eqns',m',mt') => jac &
	DAELow.analyze_jacobian(subsystem_dae,jac) => jac_tp &
	generate_ode_system2(subsystem_dae,jac,jac_tp) => (str,f1) &
	DAELow.jacobian_type_str jac_tp => jac_tp_str &
	Util.string_append_list(["/* system of equations of type ",jac_tp_str, "*/\n",
				 str,
				 "/* End system of equations */\n"
				 ]) 
	  => res
	-------------------------
	generate_ode_system(daelow as DAELow.DAELOW(vars,knvars,eqns,se,ie,al,ev),ass1,ass2,block) 
	  => (res,f1)
end

(** relation: generate_ode_system2
 ** author: PA
 ** 
 ** Generates the actual simulation code for the system of equation, once
 ** its jacobian and type has been given.
 **)
relation generate_ode_system2: (DAELow.DAELow, (* the daelow for the subsystem*)
				(int * int * DAELow.Equation) list, (* jacobian *)
				DAELow.JacobianType) (* Type of jacobian, constant,etc.*)
	=> (string, (* system code *)
	    string) =  (* extra functions code *)


	  (* constant jacobians. Linear system of equations (A x = b) where
	   A and b are constants. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	generate_ode_system2(d,jac,DAELow.JAC_TIME_VARYING) => (s1,f1)
	------------------------------
 	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,
			     DAELow.JAC_CONSTANT) => (s1,f1)
	

	(* Time varying jacobian. Linear system of equations that needs to 
	 * be solved during runtime. *)
  rule	DAELow.equation_size(eqn) => eqn_size &
	generate_ode_system2_declaration(eqn_size) => s1 &
	generate_ode_system2_populate_Ab(jac,v,eqn) => s2 &
	generate_ode_system2_solve_call(eqn_size) => s3 &
	generate_ode_system2_collect_results(v) => s4 &
	Util.string_append_list([s1,s2,s3,s4]) => str
	--------------------
	generate_ode_system2(d as DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,DAELow.JAC_TIME_VARYING) => (str,"")

	(* Time varying nonlinear jacobian. Non-linear system of equations*)
  rule	DAELow.equation_list(eqn) => eqn_lst &
	DAELow.var_list(v) => var_lst &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	generate_ode_system2_nonlinear_residuals(crefs,eqn_lst) => (str,f1) 
	------------------------------------------------------
	generate_ode_system2(DAELow.DAELOW(v,kv,eqn,_,_,_,_),jac,DAELow.JAC_NONLINEAR) 
	  => (str,f1)


  rule	print "-generate_ode_system2 failed\n" 
	-------------------------
	generate_ode_system2(_,_,_) => fail
end

(** relation: generate_ode_system2_nonlinear_residuals
 ** author: PA
 **
 ** Generates residual statements for nonlinear equation systems.
 **)

relation generate_ode_system2_nonlinear_residuals:  (Exp.ComponentRef list,
						     DAELow.Equation list) 
	  => (string, (* solve code *)
	      string) = (* extra functions: residual func*)

  rule	make_residual_replacements(crs) => repl &
	generate_ode_system2_nonlinear_residuals2(eqns,0,repl) => s1 &
	tick() => id &
	int_string(id) => str_id &
	list_length(eqns) => eqn_size & int_string(eqn_size) => size_str &
	Util.string_append_list(["void residualFunc",str_id,
				 "(int* n, double* xloc, double*res, int* iflag)\n",
				 "{\n",
				 s1,
				 "}\n"]) => func &
	generate_ode_system2_nonlinear_setvector(crs,0) => s2 &
	generate_ode_system2_nonlinear_call(str_id) => s3 &
	generate_ode_system2_nonlinear_store_results(crs,0) => s4 &
	Util.string_append_list([TAB,"start_nonlinear_system(",size_str,");\n",
				 s2,s3,s4,
				 TAB, "end_nonlinear_system();\n"]) => res
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns) 
	  => (res,func)

  rule	print "generate_ode_system2_nonlinear_residuals failed\n" 
	-----------------------------------------------------------
	generate_ode_system2_nonlinear_residuals(crs,eqns) 
	  => fail
end

(** relation: make_residual_replacements
 ** author: PA
 **
 ** This relation makes replacement rules for variables occuring in a 
 ** nonlinear equation system. They should be replaced by x[index], i.e.
 ** an unique index in the x vector.
 **)

relation make_residual_replacements:(Exp.ComponentRef list) => 
	VarTransform.VariableReplacements =

  rule	VarTransform.empty_replacements() => repl &
	make_residual_replacements2(repl,crefs,0) => repl'
	---------------------
	make_residual_replacements(crefs) => repl'
end

(** relation make_residual_replacements2
 ** author: PA
 ** 
 ** Helper relation to make_residual_replacements
 **)

relation make_residual_replacements2:(VarTransform.VariableReplacements,
				      Exp.ComponentRef list,
				      int) => 
	VarTransform.VariableReplacements =

  axiom	make_residual_replacements2(repl,[],_) => repl

  rule	int_string(pos) => pstr &
	Util.string_append_list(["xloc[",pstr,"]"]) => str &
	VarTransform.add_replacement(repl,cr,Exp.CREF_IDENT(str,[])) => repl' &
	pos + 1 => pos' &
	make_residual_replacements2(repl',crs,pos') => repl''
	------------------------------
	make_residual_replacements2(repl,cr::crs,pos) => repl''
end


(** relation: generate_ode_system2_nonlinear_setvector
 ** author: PA
 **
 ** Generates code for setting the values for the x vector when solving 
 ** nonlinear equation systems.
 **)

relation generate_ode_system2_nonlinear_setvector: (Exp.ComponentRef list,
						    int (* index iterator *)) 
	  => string =

  axiom	generate_ode_system2_nonlinear_setvector([],_) => ""

  rule  Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_setvector(crs,indx') => s1 &
	Util.string_append_list([TAB,"nls_x[",indx_str,"] = ",cr_str,";\n",
				 s1]) => res
	----------------------------------------
	generate_ode_system2_nonlinear_setvector(cr::crs,indx) 
	  => res
end

(** relation: generate_ode_system2_nonlinear_call
 ** author: PA
 **
 ** Generates the call to the nonlinear equation solver.
 **)

relation generate_ode_system2_nonlinear_call: (string (* residual func id *)) 
	  => string =

  rule	Util.string_append_list([TAB,"hybrd_(residualFunc",func_id,
				 ",&n, nls_x,nls_fvec,&xtol,&maxfev,&ml,&mu,",
				 "&epsfcn,\n",TAB,TAB,"nls_diag,&mode,&factor,&nprint,",
				 "&info,&nfev,nls_fjac,&ldfjac,\n",TAB,TAB,"nls_r,",
				 "&lr,nls_qtf,nls_wa1,nls_wa2,nls_wa3,",
				 "nls_wa4);\n",
				 TAB,"if (info == 0) {\n",
				 TAB,TAB,"printf(\"improper ",
				 "input parameters to nonlinear eq. syst.\\n\");\n",
				 TAB, "}\n",
				 TAB,"if (info >= 2 && info <= 5) {\n",
				 TAB,TAB,"printf(\"error solving nonlinear",
				 " system.\\n\");\n",
				 TAB,"}\n"
				 ]) => res
	---------------------------
	generate_ode_system2_nonlinear_call(func_id) => res
end


(** relation: generate_ode_system2_nonlinear_store_results
 ** author: PA
 ** 
 ** Generates the storing of the results of the solution to a nonlinear equation
 ** system.
**)
	    
relation generate_ode_system2_nonlinear_store_results: (Exp.ComponentRef list, int)
	=> string =
  axiom	generate_ode_system2_nonlinear_store_results([],_) => ""

  rule	Exp.print_component_ref_str(cr) => cr_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_store_results(crs,indx') => s1 &
	Util.string_append_list([TAB,cr_str," = nls_x[",indx_str,"];\n",s1]) 
	  => res
	--------------------------------
	generate_ode_system2_nonlinear_store_results(cr::crs,indx) =>  res
end


(** relation: generate_ode_system2_nonlinear_residuals2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_nonlinear_residuals
 **)

relation generate_ode_system2_nonlinear_residuals2: (DAELow.Equation list, 
						     int, (* index iterator*) 
						     VarTransform.VariableReplacements)
	  => string =

  axiom	generate_ode_system2_nonlinear_residuals2([],_,_) => ""

  rule	Exp.typeof(e1) => tp &
	let res_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	Exp.simplify(res_exp) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
        print_exp_cpp_str(res_exp'') => exp_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl) => s1 &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",exp_str, ";\n",s1])=> res
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.EQUATION(e1,e2)::rest,indx,repl) 
	  => res

  rule	Exp.simplify(e) => res_exp' &
	VarTransform.replace_exp(res_exp',repl) => res_exp'' &
        print_exp_cpp_str(res_exp'') => exp_str &
	int_string(indx) => indx_str &
	indx + 1 => indx' &
	generate_ode_system2_nonlinear_residuals2(rest,indx',repl) => s1 &
	Util.string_append_list([TAB,"res[",indx_str,"] = ",exp_str, ";\n",s1])=> res
	-----------------------
	generate_ode_system2_nonlinear_residuals2(DAELow.RESIDUAL_EQUATION(e)::rest,indx,repl) 
	  => res
end


(** relation: generate_ode_system2_declaration
 ** author: PA
 ** 
 ** Generates code for the declaration of A and b when
 ** solving linear systems of equations.
 **)

relation generate_ode_system2_declaration: (int) => string =

  rule	int_string(size) => size_str &
	
	Util.string_append_list([TAB,"declare_matrix(A,",size_str,",",
				 size_str,");\n",
				 TAB,"declare_vector(b,",size_str,");\n"])
	  => res
	-----------------------
	generate_ode_system2_declaration(size)  => res
end

(** relation: generate_ode_system2_populate_Ab
 ** author: PA
 ** 
 ** Generates code for the population of A and b when
 ** solving linear system of equations.
 **)
	    
relation generate_ode_system2_populate_Ab:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =

  rule	generate_ode_system2_populate_A(jac,vars,eqns) => s1 &
	generate_ode_system2_populate_b(jac,vars,eqns) => s2 &
	string_append(s1,s2) => res
	---------------------------
	generate_ode_system2_populate_Ab(jac,vars,eqns) => res
end

(** relation: generate_ode_system2_populate_A
 ** author: PA
 ** 
 ** Generates code for the population of A 
 ** solving linear system of equations.
 **)
relation generate_ode_system2_populate_A:((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =


  rule	DAELow.equation_size(eqns) => n_rows &
	generate_ode_system2_populate_A2(jac,vars,eqns,n_rows) => res
	-----------------------------
	generate_ode_system2_populate_A(jac,vars,eqns) => res

end

(** relation: generate_ode_system2_populate_A2
 ** author: PA
 **
 ** Helper relation to generate_ode_system2_populate_A
 **)

relation generate_ode_system2_populate_A2:((int * int * DAELow.Equation) list,
					  DAELow.Variables,
					  DAELow.EquationArray,
					  int) (* n rows *)
	  => string =

  axiom	generate_ode_system2_populate_A2([],_,_,_) => ""

  rule  r - 1 => r' &
	c - 1 => c' &
	int_string(r') => rs &
	int_string(c') => rc &
	int_string(n_rows) => n_rows_str &
	print_exp_cpp_str(exp) => es &
	generate_ode_system2_populate_A(jac,vars,eqn) => s1 &
	Util.string_append_list([TAB,"set_matrix_elt(A,",rs,", ",rc,", ",
				 n_rows_str,", ",es,");\n",s1]) => res
	--------------------------------------------------------------
	generate_ode_system2_populate_A2((r,c,DAELow.RESIDUAL_EQUATION(exp))::jac,vars,eqn,n_rows) => res
end

(** relation: generate_ode_system2_populate_b
 ** author: PA
 **
 ** Generates code for the population of A 
 ** solving linear system of equations.
 **)

relation generate_ode_system2_populate_b: ((int * int * DAELow.Equation) list,
					   DAELow.Variables,
					   DAELow.EquationArray)
	  => string =

  rule	DAELow.equation_list(eqns) => eqn_lst &
	generate_ode_system2_populate_b2(eqn_lst,vars,0) => res
	--------------------------------
	generate_ode_system2_populate_b(jac,vars,eqns) => res
end

(** relation: generate_ode_system2_populate_b2
 ** author: PA
 ** Helper relation to generate_ode_system2_populate_b
 **)

relation generate_ode_system2_populate_b2: (DAELow.Equation list,
					    DAELow.Variables,
					    int (* index iterator*)) 
	  => string =

  axiom	generate_ode_system2_populate_b2([],_,_) => ""


  rule	Exp.typeof(e1) => tp &
	let new_exp = Exp.BINARY(e1,Exp.SUB(tp),e2) &
	DAELow.get_eqnsys_rhs_exp(new_exp,v) => rhs_exp &
	let rhs_exp' = Exp.UNARY(Exp.UMINUS(tp),rhs_exp) &
	Exp.simplify(rhs_exp') => rhs_exp'' &
	print_exp_cpp_str(rhs_exp'') => rhs_str &
	int_string(index) => index_str &
	index + 1 => index'  &
	generate_ode_system2_populate_b2(rest,v,index') => s1 &
	Util.string_append_list([TAB,"set_vector_elt(b,",index_str,
				 ", ",rhs_str, ");\n",s1]) => res
	--------------------------------------------------------
	generate_ode_system2_populate_b2(DAELow.EQUATION(e1,e2)::rest,v,index) 
	  => res
end


(** relation: generate_ode_system2_solve_call
 ** author: PA
 ** 
 ** Generates code for the call, including setup, for solving
 ** a linear system of equations.
 **)

relation generate_ode_system2_solve_call:(int (* size of system *)) 
	  => string =


  rule	int_string(eqn_size) => size_str &
	Util.string_append_list([TAB,"solve_linear_equation_system(A,b,",
				 size_str,");\n"]) 
 	  => res
	---------------------------
	generate_ode_system2_solve_call(eqn_size) => res
end

(** relation: generate_ode_system2_collect_results
 ** author: PA
 **
 ** Generates the code for storing the result of solving
 ** a linear system of equations into the affected variables .
 **)

relation generate_ode_system2_collect_results:(DAELow.Variables) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	list_reverse(var_lst) => var_lst' &
	Util.list_map(var_lst,DAELow.var_cref) => crefs &
	Util.list_map(crefs,Exp.print_component_ref_str) => strs &
	generate_ode_system2_collect_results2(strs,0) => res
	-------------------------------
	generate_ode_system2_collect_results(vars) => res
end
(** relation: generate_ode_system2_collect_results2
 ** author: PA
 ** 
 ** Helper relation to generate_ode_system2_collect_results
**)
relation generate_ode_system2_collect_results2: (string list,int)
	  => string =
	  
  axiom	generate_ode_system2_collect_results2([],_) => "" 
	
  rule	index + 1 => index' &
	generate_ode_system2_collect_results2(strs,index') => s1 &
	int_string(index) => index_str &
	Util.string_append_list([TAB,str," = get_vector_elt(b,",index_str,");\n",s1])
	=> res
	----------------------
	generate_ode_system2_collect_results2(str::strs,index) => res    
end

(** relation transform_x_to_xd
 ** author: PA
 ** this relation transforms x variables (in the state vector)
 ** to corresponding xd variable (in the derivatives vector)
 **)

relation transform_x_to_xd: DAELow.Var => DAELow.Var =

  rule	int_string(index) => index_str &
	Util.string_append_list(["xd[",index_str, "]"]) => res
	-------------------------
	transform_x_to_xd(DAELow.VAR(cr,DAELow.STATE,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow)) 
	  => DAELow.VAR(Exp.CREF_IDENT(res,[]),DAELow.STATE,dir,tp,exp,v,dim,st,index,name,classes,attr,comment,flow)

  axiom	transform_x_to_xd(v) => v 
end

(** relation: get_equation_and_solved_var
 ** author: PA
 ** Retrieves the equation and the variable solved in that equation
 ** given an equation number and the variable assignments2
 **)
relation get_equation_and_solved_var: (int, (* equation no. *)
				       DAELow.EquationArray, 
				       DAELow.Variables,
				       int vector (* assignments2*)
				       ) 
	  => (DAELow.Equation, DAELow.Var) =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => eqn &
	vector_nth(ass2,e') => v &
	DAELow.get_var_at(vars,v) => var
	-------------------------------
	get_equation_and_solved_var(e,eqns,vars,ass2) => (eqn,var)	
end

(** relation: is_non_state
 ** failes if the given variable kind is state
 **)
relation is_non_state: DAELow.VarKind => () =

  axiom	is_non_state (DAELow.VARIABLE) => ()
  axiom	is_non_state (DAELow.DUMMY_DER) => ()
  axiom	is_non_state (DAELow.DUMMY_STATE) => ()
  axiom	is_non_state (DAELow.DISCRETE) => ()
end 

(** relation: generate_ode_equation
 ** author: PA
 **
 **  Generates code for a single equation for the ode code generation, see
 ** genrerate_ode_code.
 **)

relation generate_ode_equation: (DAELow.DAELow, 
				 int vector, (*assignements 1 *)
				 int vector, (* assignements 2 *)
				 int) (* equation number*)
	  => (string, (* equation code *)
	      string) = (* extra functions *)

  rule	(* Solving for non-states *)
	
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &
	is_non_state kind &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	print_exp_cpp_str(expr) => expr_str &
	Exp.print_component_ref_str(cr) => cr_str &
	Util.string_append_list(["  ",cr_str,"=",expr_str,";\n"]) => res
	-----------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,"")

  rule	(* Solving the state s means solving for der(s) *)
	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &
	Util.string_append_list(["xd[",indxs,"]"]) => id &
	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
	print_exp_cpp_str(expr) => expr_str &
	Exp.print_component_ref_str(cr') => cr_str &
	Util.string_append_list(["  ",cr_str,"=",expr_str,";\n"]) => res
	----------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,"")

	(* state nonlinear *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (eqn as DAELow.EQUATION(e1,e2),
	      DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow)) &
	int_string(indx) => indxs &
	Util.string_append_list(["xd[",indxs,"]"]) => id &
	let cr' = Exp.CREF_IDENT(id,[]) &
	let varexp = Exp.CREF(cr',Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	generate_ode_system2_nonlinear_residuals([cr'],[eqn])
	  => (res,f1)
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) 
	  => (res,f1)

	(* When equations ignored *)
  rule	get_equation_and_solved_var(e,eqns,vars,ass2) 
	  => (DAELow.WHEN_EQUATION(_),_) 
	-------------------------------------
	generate_ode_equation(DAELow.DAELOW(vars,_,eqns,_,_,_,_),ass1,ass2,e) => ("","")
end

(** relation: generate_nonlinear_equations
 ** author: PA
 ** 
 ** This relation generates a nonlinear system of equations.
 **)

relation generate_nonlinear_equations: (Exp.ComponentRef list, (* variables *)
				     Exp.Exp list) (* residuals *)
	=> string =
  axiom	generate_nonlinear_equations(_,_) 
	  => "/* Generate non-linear equations not impl. yet.*/\n"
end

(** relation generate_functions
 **
 ** Finds the called functions in daelow and generates code for them
 ** from the given DAE. Hence, the functions must exist in the DAE.Element list.
**)
relation generate_functions: (SCode.Program, (* Needed to instantiate functions*)
			      DAE.DAElist, 
			      DAELow.DAELow, 
			      Absyn.Path, 
			      string) => (string list (* libs *)) =

  rule	get_called_functions(dae, dlow) => funcpaths & 
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(funcpaths, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	generate_functions_2(p,funcpaths) => funcelems &
	Print.get_string => debugstr &
	Print.clear_buf &
	(*debug*) Debug.fprintln("info", "Generating functions, call Codegen.\n") &
 	Codegen.generate_functions(DAE.DAE(funcelems)) => libs &
	Print.write_buf(filename)
	--------------------------------------------------
	generate_functions (p,dae as DAE.DAE(elements), dlow, path, filename) 
	  => libs


  rule	print "-generate_functions failed\n" & 
	Print.print_error_buf "# Generate functions failed\n" 
	-------------------------------------
	generate_functions (_, _, _, _, _) => fail

end

(** relation: generate_functions_2
 ** author: PA
 **
 ** Helper relation to generate_functions.
 **)

relation generate_functions_2: (SCode.Program, Absyn.Path list) 
	  => DAE.Element list =
  rule	generate_functions_3(p,paths,paths) => dae
	-------------------
	generate_functions_2(p,paths) => dae
end

(** relation: generate_functions_3
 **
 ** Helper relation to generate_functions_2
 **)
relation generate_functions_3: (SCode.Program, 
				Absyn.Path list, (* iterated over *)
				Absyn.Path list) (* complete list *)
	  => DAE.Element list =

  axiom	generate_functions_3(_,[],allpaths) => ([])

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.FUNCTION(_,dae,t)]) = fdae &
	let patched_dae = DAE.DAE([DAE.FUNCTION(path,dae,t)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.FUNCTION(path,dae,t)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	Inst.instantiate_class_implicit(p,path) => (fdae,_) &
	let DAE.DAE([DAE.EXTFUNCTION(_,dae,t,extdecl)]) = fdae &
        let patched_dae = DAE.DAE([DAE.EXTFUNCTION(path,dae,t,extdecl)]) &
	get_called_functions_in_function(path,patched_dae) => subfuncs &
	append_nonpresent_paths(subfuncs,allpaths,paths) 
	  => (allpaths',paths') &
	generate_functions_3(p,paths',allpaths') => elts &
	list_append(elts,[DAE.EXTFUNCTION(path,dae,t,extdecl)]) => res
	---------------------------------------
	generate_functions_3(p,path::paths,allpaths) => res

  rule	print "generate_functions_3 failed\n" 
	--------------------------
	generate_functions_3(_,_,_) => fail
    
end

(** relation: append_nonpresent_paths
 ** 
 **
 ** Appends the paths in first argument to the two path lists given as second
 ** and third argument, given that the path is not present in the second 
 ** path list.
 **
 **)

relation append_nonpresent_paths:(Absyn.Path list, (* paths to append*)
				  Absyn.Path list, (* all paths *)
				  Absyn.Path list) (* iterated paths *)
	  => (Absyn.Path list, (* updated all paths *)
	      Absyn.Path list) = (* update iterated paths *)

  axiom	append_nonpresent_paths([],allpaths,iterpaths) => (allpaths,iterpaths)

  rule	Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	append_nonpresent_paths(paths,allpaths,iterpaths) 
	  => (allpaths,iterpaths)
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths,iterpaths)

  rule	not Util.list_getmember_p(path,allpaths,ModUtil.path_equal) => _ &
	list_append(allpaths,[path]) => allpaths' &
	list_append(iterpaths,[path]) => iterpaths' &
	append_nonpresent_paths(paths,allpaths',iterpaths') 
	  => (allpaths'',iterpaths'')
	------------------------------------------
	append_nonpresent_paths(path::paths, allpaths, iterpaths)
	  => (allpaths'',iterpaths'')
end


(** relation generate_init_data
 **
 ** This relation generates initial values for the simulation
 ** by investigating values of variables.
 **)

relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
			      string(* filename *),
			      real, (* start time*)
			      real, (* stop time *)
			      real) (* step size *)
	  => () =

   rule	real_string(start) => start_str &
	real_string(stop) => stop_str &
	real_string(step) => step_str &
 	DAELow.calculate_sizes(dlow) => (nx,ny,np,_) &
 	int_string(nx) => nx_str &
 	int_string(ny) => ny_str &
 	int_string(np) => np_str &
 	generate_init_data2(dlow,nx,ny,np) => init_str &
 	Util.string_append_list([start_str, " // start value\n",
				 stop_str, " // stop value\n",
 				 step_str, " // step value\n",
 				 nx_str, " // n states\n",
 				 ny_str, " // n alg vars\n",
 				 np_str, " //n parameters\n",
 				 init_str]) => str &
 	System.write_file(filename,str) 
 	--------------------------
 	generate_init_data(dlow,class,filename,start,stop,step)

  rule	print "-generate_init_data failed\n"
 	------------------------------------
	generate_init_data(_,_,_,_,_,_) => fail
end

(** relation: generate_init_data2
 **
 ** Helper relation to generate_init_data
 ** Generates init data for states, variables and parameters.
 ** nx - number of states.
 ** ny - number of alg. vars. 
 ** np - number of parameters.
 **)
relation generate_init_data2:(DAELow.DAELow,
			      int(*nx*),
			      int(*ny*),
			      int(*np*)) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	array_create(nx,"") => nxarr &
	array_create(nx,"0.0") => nxdarr &
	array_create(ny,"") => nyarr &
	array_create(np,"") => nparr &
	generate_init_data3(var_lst,nxarr,nxdarr,nyarr,nparr) 
	  =>(nxarr1,nxdarr1,nyarr1,nparr1) &
	generate_init_data3(knvar_lst,nxarr1,nxdarr1,nyarr1,nparr1)
	  =>(nxarr2,nxdarr2,nyarr2,nparr2) &
	generate_init_data4(knvar_lst,nxarr2,nxdarr2,nyarr2,nparr2)  
	  =>(nxarr3,nxdarr3,nyarr3,nparr3) &
	array_list(nxarr3) => nx_lst &
	array_list(nxdarr3) => nxd_lst &
	array_list(nyarr3) => ny_lst &
	array_list(nparr3) => np_lst &
	Util.list_flatten([nx_lst,nxd_lst,ny_lst,np_lst]) => whole_lst &
	Util.string_delimit_list_no_empty(whole_lst,"\n") => res
	-----------------------------
	generate_init_data2(DAELow.DAELOW(vars,knvars,_,_,initeqn,alg,_),nx,ny,np) => res


end

(** relation: print_exp_str_opt
 **
 ** Helper relation to generate_init_data2
 ** Prints expression value that is opional for initial values.
 ** If NONE is passed. The default value 0.0 is returned.
 **)
relation print_exp_str_opt: Exp.Exp option => string =

  axiom	print_exp_str_opt NONE => "0.0"

  rule	Exp.print_exp_str e => str 
 	--------------------------
 	print_exp_str_opt SOME(e) => str 
end

(** relation: generate_init_data3
 **
 ** This relation is a help relation to generate_init_data2
 ** It Traverses Var lists and adds initial values to the specific
 ** string array depending on the type of the variable.
 ** For instance, state variables write their start value to the
 ** x array at given index.
**)

relation generate_init_data3:(DAELow.Var list,
			      string array, (* state strings *)
			      string array, (* derivative strings*)
			      string array, (* alg. var strings *)
			      string array) (* param. strings *)
	  => (string array, (* updated state strings *)
	      string array, (* updated derivative strings*)
	      string array, (* updated alg. var strings *)
	      string array) (* updated param. strings *)
	=

  axiom	generate_init_data3([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.DISCRETE,_,_,_,_,
				_,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

   rule	(* State variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nxarr,indx,str) => nxarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)
	--------------------
	 generate_init_data3(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,
                                        start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* dummy derivatives => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,
                                       start,indx,origname,_,dae_var_attr,comment,flow)::rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)

  rule	(* Dummy states => algebraic variables *)
	print_exp_opt_str_if_const(start) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
 	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				       _,start,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	----------------------
	generate_init_data3(_::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr',nxdarr',nyarr',nparr')
end

(** relation: print_exp_opt_str_if_const
 **
 ** Helper relation to generate_init_data3.
 **)

relation print_exp_opt_str_if_const:(Exp.Exp option) => string =
       
  rule  Exp.is_const(e) => true &
        print_exp_str_opt(SOME(e)) => res
        --------------------
        print_exp_opt_str_if_const(SOME(e)) => res
     
  rule  print_exp_str_opt(NONE) => res
        --------------------
        print_exp_opt_str_if_const(_) => "0.0"

end

(** relation: generate_init_data4
 **
 ** Helper relation to generate_init_data2
 ** Traverses parameters.
 **)

relation generate_init_data4: (DAELow.Var list, 
			       string array,
			       string array,
			       string array,
			       string array)  
	  => (string array,
	      string array,
	      string array,
	      string array)   =
  axiom	generate_init_data4([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr) 
	
  rule	(* Parameters *)
	Values.val_string(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Parameters without value binding. Should normally not happen *)
	Util.string_append_list(["0.0  // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				_,indx,origname,_,dae_var_attr,comment,flow)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Skip alg. vars that are removed 
	 In future we should compare eliminated variables 
	 intial values to their aliases to detect inconsistent
	 initial values.
	 *)
	generate_init_data4(vs,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	-----------------------------------
	generate_init_data4(_::vs,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr',nxdarr',nyarr',nparr')
end

(** relation: dump_when_clauses_str
 **
 ** Prints when clauses to a string.
 **)

relation dump_when_clauses_str: (DAELow.WhenClause list) => string =

  axiom	dump_when_clauses_str [] => ""

  rule	dump_when_clause_str c => str &
	dump_when_clauses_str xs => str2 &
	string_append(str, str2) => res
	------------------------------
	dump_when_clauses_str c::xs => res
end

(** relation: dump_when_clause_str
 **
 ** Prints a when clause to a string.
 **)
relation dump_when_clause_str: (DAELow.WhenClause) => string =

  rule	Exp.print_exp_str exp => str1 &
	Util.string_append_list ["when ", str1, "\n"] => res
	----------------------------------------
	dump_when_clause_str DAELow.WHEN_CLAUSE(exp,_) => res

end

(** relation: generate_helpvar_updates
 ** Gerates code for updateing help variables
 **)
relation generate_helpvar_updates: ((int (*helpvar index*) * 
				     Exp.Exp (*binding expression*) * 
				     int (*when clause index using this help var*)) list) 
	  => string =
  
  axiom	generate_helpvar_updates([]) => ""
	
  rule	Exp.get_relations(e) => [] &
	print_exp_cpp_str(e) => eStr &
	int_string hindex => hindStr &
	generate_helpvar_updates(rest) => restStr &
	Util.string_append_list(["  h[",hindStr,"] = ", eStr, ";\n",restStr]) => res 
	--------------------------------------------------
	generate_helpvar_updates((helpvar as (hindex,e,_))::rest) => res

  rule	generate_helpvar_updates(rest) => restStr 
	--------------------------------------------------
	generate_helpvar_updates(_::rest) => restStr

end

(** relation: generate_zero_crossing
 ** Generates code for handling zerocrossings as well as the 
 ** zero crossing function given to the solver
 **)
relation generate_zero_crossing: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list, (* blocks *) 
				  (int * Exp.Exp * int) list )
	  => string =
	  
  rule	
	generate_zero_crossing2(zc,0,dae,dlow,ass1,ass2,blocks,helpVarInfo) => (zc_str,zc_eq_str) &
	generate_ode_blocks(dlow,ass1,ass2,blocks) => (eqs_str,extra_funcs) &
         generate_helpvar_updates(helpVarInfo) => helpvarUpdateStr &
	Util.string_append_list([extra_funcs,
				 "\nint\nfunction_zeroCrossing(long *neqm, double *t, double *x, long *ng, double *gout,\n"
				 ,"             double *rpar, long* ipar)\n"
				 ,"{\n"
				 ,   zc_str
				 ,"  return 0;\n"
				 ,"}\n\n"
				 ,"void\nhandleZeroCrossing(long index, double *t)\n"
				 ,"{\n"
				 ,"  switch(index) {\n"
				 ,   zc_eq_str
				 ,"  default: break;\n"
				 ,"  }\n"
				 ,"}\n\n"
				 ,"void function_updateDependents(double *t)\n"
				 ,"{\n"
				 ,   eqs_str
				 ,   helpvarUpdateStr
				 ,"}\n\n"
				 ]) => res
	--------------------------------------------------
	generate_zero_crossing(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,DAELow.EVENT_INFO(_,zc)),ass1,ass2,blocks,helpVarInfo) => res

  rule	Print.print_error_buf "Internal Error, generate_zero_crossing failed\n"
	----------------------------------------
	generate_zero_crossing(_,_,_,_,_,_,_) => fail
end

(** relation: generate_zero_crossing2
 ** Helper function to generate_zero_crossing
 **)
relation generate_zero_crossing2: (DAELow.ZeroCrossing list, int,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list, (* blocks *) 
				   (int * Exp.Exp * int) list )
	  => (string,string) =

  axiom	generate_zero_crossing2([],_,_,_,_,_,_,_) => ("","")

  rule	use_zerocrossing => false 
	----------------------------------------
	generate_zero_crossing2(_,_,_,_,_,_,_,_) => ("","")

  rule   dump_zero_crossing_str zc => zc_str &
	int_string index => index_str &
	index + 1 => index' &
	generate_zero_crossing2(xs,index',dae,dlow,ass1,ass2,blocks,helpVarInfo) => (rest1,rest2) &
	Util.string_append_list(["  ZEROCROSSING(",index_str, ",",zc_str,");\n",rest1]) => res1 &
         Util.list_select_1(helpVarInfo,(index,dlow),isZeroCrossingAffectingHelpVar) => usedHelpVars &
 	build_zero_crossing_eqns (dae,dlow,ass1,ass2,eql) => zc_eq_str &
         build_help_var_assignments (usedHelpVars) => help_var_str &
	Util.string_append_list(["  case ", index_str, ":\n", zc_eq_str, help_var_str,"    break;\n",rest2]) => res2
	--------------------------------------------------
	generate_zero_crossing2((zc as DAELow.ZERO_CROSSING(_,eql,_))::xs,
				index,dae,dlow,ass1,ass2,blocks,helpVarInfo) => (res1,res2)

  rule	dump_zero_crossing_str zc => zc_str &
	Util.string_append_list(["Internal Error generating zero crossing :",
				 zc_str,"\n"]) => res &
	Print.print_error_buf res 
	------------------------
	generate_zero_crossing2((zc as DAELow.ZERO_CROSSING(_,eql,_))::xs,
				index,dae,dlow,ass1,ass2,blocks,helpVarInfo) 
	  => fail
end


relation dump_zero_crossing_str: (DAELow.ZeroCrossing) => string =

  rule	print_exp_cpp_str(e1) => e1_str &
	print_exp_cpp_str(e2) => e2_str &
	print_zero_crossing_op_str(op) => op_str &
	Util.string_append_list([op_str,"(",e1_str,",",e2_str,")"]) => zc_str
	----------------------------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(Exp.RELATION(e1,op,e2),_,_)) => zc_str

  rule	print_exp_cpp_str(start) => e1_str &
	print_exp_cpp_str(interval) => e2_str &
	Util.string_append_list(["Sample(*t,",e1_str,",",e2_str,")"]) => zc_str
	----------------------------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(Exp.CALL(Absyn.IDENT("sample"),[start,interval],_,_),_,_)) => zc_str

  rule  print_exp_cpp_str(e) => e_str &
	Util.string_append_list(["/*Unknown zero crossing: ",e_str," */"]) 
	  => zc_str
	-------------------
	dump_zero_crossing_str (DAELow.ZERO_CROSSING(e,_,_)) => zc_str

end

relation isZeroCrossingAffectingHelpVar: ((int * Exp.Exp * int), (int * DAELow.DAELow)) => bool =

  rule	whenClauseIndex + 1 => whenClauseIndex' &
	DAELow.get_zero_crossing_indices_from_when_clause(dlow,whenClauseIndex') => zeroCrossings &
	Util.list_getmember(zcIndex, zeroCrossings) => _
	--------------------------------------------------
	isZeroCrossingAffectingHelpVar((_,e,whenClauseIndex), (zcIndex, dlow)) => true

  axiom	isZeroCrossingAffectingHelpVar(_,_) => false
end

relation build_help_var_assignments: ( (int * Exp.Exp * int) list ) => string =

  axiom build_help_var_assignments([]) => ""

  rule	print_exp_cpp_str(e) => expr_str &
	int_string helpVarIndex => ind_str &
	Util.string_append_list(["    h[", ind_str,"] = ", expr_str, ";\n"]) => res1 &
	build_help_var_assignments(rest) => res2 &
	string_append(res1,res2) => res
	--------------------------------------------------
	build_help_var_assignments((helpVarIndex, e,_)::rest) => res

  rule	Print.print_error_buf "Internal Error, build_help_var_assignments failed\n" 
	--------------------------------------------------
	build_help_var_assignments(_) => fail
end

relation print_zero_crossing_op_str: (Exp.Operator) => string =
  axiom	print_zero_crossing_op_str(Exp.LESS(_)) => "Less"
  axiom	print_zero_crossing_op_str(Exp.GREATER(_)) => "Greater"
  axiom	print_zero_crossing_op_str(Exp.LESSEQ(_)) => "LessEq"
  axiom	print_zero_crossing_op_str(Exp.GREATEREQ(_)) => "GreaterEq"
end

(** relation: generate_when_clauses
 **
 ** Generate code for when clauses.
 **)

relation generate_when_clauses: (string,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list) (* blocks *) 
	  => string =
	  
  rule	
	generate_when_clauses2(wc,0,dae,dlow,ass1,ass2,blocks) => when_str &
	Util.string_append_list([
				 "void\nfunction_when(int i, double *t)\n"
				 ,"{\n"
				 ,"  switch(i) {\n"
				 ,     when_str
				 ,"  default: break;\n"
				 ,"  }\n"
				 ,"}\n"
				 ]) => res
	--------------------------------------------------
	generate_when_clauses(cname,dae,dlow as DAELow.DAELOW(_,_,_,_,_,_,DAELow.EVENT_INFO(wc,_)),ass1,ass2,blocks) => res

  rule	Print.print_error_buf "Internal Error, generate_when_clauses failed\n"
	----------------------------------------
	generate_when_clauses(_,_,_,_,_,_) => fail
end

relation generate_when_clauses2: (DAELow.WhenClause list, int,
				 DAE.DAElist,
				 DAELow.DAELow,
				 int vector, (* assignments1 *) 
				 int vector, (* assignments2 *)
				 int list list) (* blocks *) 
	  => string =

  axiom	generate_when_clauses2([],_,_,_,_,_,_) => ""

  rule  dump_when_clause_str wc => wc_str &
	Exp.get_cref_from_exp(cond) => cond_cref_list &
	Util.list_map(cond_cref_list,Exp.print_component_ref_str) 
	  => cond_cref_str_list &
         Util.string_delimit_list(cond_cref_str_list,");\n    save(") 
	  => save_cond_str &
	Util.string_append_list(["    save(",save_cond_str,");\n"]) 
	  => save_cond_str &
	Util.list_map(reinit,build_reinit_str) => reinit_str &
	Util.string_append_list(reinit_str) => reinit_str' &
	int_string index => index_str &
	build_when_blocks(dae,dlow,ass1,ass2,blocks,index) => when_str &
	index + 1 => index' &
	generate_when_clauses2(xs,index',dae,dlow,ass1,ass2,blocks) => rest &
	Util.string_append_list(["  case ",index_str, ": //",wc_str,
				 when_str,reinit_str',(*save_cond_str,*)"    break;\n",rest]) => res 
	--------------------------------------------------
	generate_when_clauses2((wc as DAELow.WHEN_CLAUSE(cond,reinit))::xs,
			       index,dae,dlow,ass1,ass2,blocks) => res
end

relation build_reinit_str : (DAELow.ReinitStatement) => string =

  rule	Exp.print_component_ref_str(cr) => cr_str &
	print_exp_cpp_str(exp) => exp_str &
	Util.string_append_list(["    ",cr_str," = ", exp_str, ";\n"]) => eqn_str
	----------------------------------------
	build_reinit_str(DAELow.REINIT(cr,exp)) => eqn_str

end

(** relation: build_when_blocks
 **
 ** Helper relation to build_when_clauses.
 **)
relation build_when_blocks : (DAE.DAElist,DAELow.DAELow, int vector, int vector, int list list, int) => string =

  axiom build_when_blocks(_,_,_,_,[],_) => ""

  rule	build_when_equation(dae,dlow,ass1,ass2,eqn,index) => eqn_str &
	build_when_blocks(dae,dlow,ass1,ass2,blocks,index) => eqn_str2 &
	string_append(eqn_str, eqn_str2) => res
	----------------------------------------
	build_when_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks,index) => res

  axiom build_when_blocks(_,_,_,_,_,_) => ""
end

relation build_zero_crossing_eqns : (DAE.DAElist,DAELow.DAELow, int vector, int vector, int list) => string =

  axiom build_zero_crossing_eqns(_,_,_,_,[]) => ""

  rule	build_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	eqn - 1 => eqn' &
         vector_nth(ass2,eqn') => v &
	v - 1 => v' &
	DAELow.vararray_nth(vararr,v') => (DAELow.VAR(cr,_,_,_,_,_,_,_,_,_,_,_,_,_)) &  
	Exp.print_component_ref_str(cr) => cr_str &
	build_zero_crossing_eqns(dae,dlow,ass1,ass2,rest) => eqn_str2 &
	Util.string_append_list(["    save(",cr_str,");\n","  ",eqn_str, eqn_str2]) => res
	----------------------------------------
	build_zero_crossing_eqns(dae,dlow as DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_),ass1,ass2,eqn::rest) => res

  axiom build_zero_crossing_eqns(_,_,_,_,_) => ""
end

(** relation: build_when_equation
 **
 ** Helper relation to build_when_blocks.
 **)

relation build_when_equation: (DAE.DAElist,
			       DAELow.DAELow, 
			       int vector, (* assignments1*)
			       int vector, (* assignments2*)
			       int, (* equation no. *)
			       int
			       ) => string =

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(DAELow.WHEN_EQ(wc_ind,cr,expr)) &
	int_eq(index,wc_ind) => true &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
         Exp.print_component_ref_str(cr) => assignedVar &
	build_assignment(dae,cr,expr,origname) => assignment_string &
	Util.string_append_list(["    save(",assignedVar,");\n  ", assignment_string]) => assignment_string'
	------------------------------------------------------------
	build_when_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e,index) => assignment_string'

  axiom	build_when_equation(_,_,_,_,_,_) => ""
end
	

(** relation: generate_compute_residual_state
 **
 ** This relation generates the code for the calculation of the 
 ** state variables on residual form. Called from generate_simulation_code.
 **)

relation generate_compute_residual_state:(string,
					  DAE.DAElist,
					  DAELow.DAELow,
					  int vector, (* assignments1 *) 
					  int vector, (* assignments2 *)
					  int list list) (* blocks *) 
	  => string =
          
  rule	
        build_residual_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cstate &
        Util.string_append_list(["int\nfunctionDAE_res(double *t, double *x, double *xd, double *delta, long int *ires, double *rpar, long int* ipar)\n{\n",cstate,TAB,"return 0;\n\n}\n"]) 
	  => res
        -------------------------------------------------------------
        generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => res

  rule	Print.print_error_buf "Internal Error, generate_compute_residual_state failed\n" 
	----------------------------
	generate_compute_residual_state(cname,dae,dlow,ass1,ass2,blocks) => fail
end


(** relation: generate_compute_output
 **
 ** This relation generates the code for the calculation of the output
 ** variables.
 **)

 relation generate_compute_output:(string,
				   DAE.DAElist,
                                   DAELow.DAELow,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule	let func_header = "int\nfunctionDAE_output(double *t, double* x, double* xd, double* y, double* p)\n{\n" &
	 let func_footer = "return 0;\n\n}\n" &
	 (*build_solved_blocks(dae,dlow,ass1,ass2,blocks) => eqn_str_lst &*)
	 generate_ode_blocks(dlow,ass1,ass2,blocks) => (body,extra_funcs) &
	 generate_compute_removed_eqns(dlow) => body2 &
	 Util.list_flatten([[extra_funcs],[func_header],[body], body2,
			    [func_footer]]) => res &
         Util.string_append_list(res) => coutput 
         -------------------------------------------------------------
         generate_compute_output(cname,dae,dlow,ass1,ass2,blocks) => coutput

  rule	Print.print_error_buf "Internal Error, generate_compute_output failed\n" 
	 -----------------
	 generate_compute_output(_,_,_,_,_,_) => fail
 end

(** relation: generate_compute_removed_eqns
 ** author: PA
 **
 ** Generates compute code for the removed equations
 **)
relation generate_compute_removed_eqns: (DAELow.DAELow) => string list =

  rule	DAELow.equation_list(reqns) => eqn_lst &
	generate_compute_removed_eqns_2(eqn_lst) => res
	-----------------
	generate_compute_removed_eqns(DAELow.DAELOW(_,_,_,reqns,_,_,_)) => res
end

(** relation: generate_compute_removed_eqns_2
 **
 ** Helper relation to generate_computed_remove_eqns
 **)
relation generate_compute_removed_eqns_2: DAELow.Equation list  => string list =

  axiom	generate_compute_removed_eqns_2([]) => []

  rule	generate_compute_removed_eqns_2(rest) => res &
	Exp.print_component_ref_str(cr) => cr_str &	
	print_exp_cpp_str(exp) => exp_str &
	Util.string_append_list(["  ",cr_str," = ",exp_str,";\n"]) => s1 
	------------------------------
	generate_compute_removed_eqns_2(DAELow.SOLVED_EQUATION(cr,exp)::rest)
	  => s1::res
end

(** relation: all_same_algorithm
 **
 ** Checks that a block consists only of one algorithm in different -nodes-
**)

relation all_same_algorithm: (DAELow.DAELow,
			      int list) (* blocks*)
	  => bool =

  rule	(* extract index of first algorithm and check that entire block
	 * has that index. *)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,_,_) &
	all_same_algorithm2(dlow, block,indx) => res
	----------------------
	all_same_algorithm(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),block as e::_) 
	  => res

  axiom	all_same_algorithm(_,_) => false
end

(** relation: all_same_algorithm2
 **
 ** Helper relation to all_same_algorithm. Checks all equations in the block
 ** and returns true if they all are algorithms with the same index. 
 **)

relation all_same_algorithm2:(DAELow.DAELow, 
			      int list, (* block *)
			      int (* alg. index*)) => bool =
  axiom	all_same_algorithm2(_,[],_) => true

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => true &
	all_same_algorithm2(dlow,es,indx) => b1 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => b1

  rule	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx2,_,_) &
	int_eq(indx,indx2) => false 
	--------------------------------------
	all_same_algorithm2(dlow as DAELow.DAELOW(_,_,eqns,_,_,alg,_),e::es,indx) => false

  axiom	all_same_algorithm2(_,_,_) => false

end


relation build_non_discrete_equation:(DAE.DAElist, DAELow.DAELow, int vector, int vector, int) => string =

  rule	int_sub(e,1) => e' &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (DAELow.VAR(_,kind,_,_,_,_,_,_,_,_,_,_,_,_)) &  
	DAELow.is_discrete kind 
	--------------------------------
	build_non_discrete_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_),_,ass2,e) => ""
      
  rule	build_equation(dae,dlow,ass1,ass2,eqn) => str
	----------------------------------------
	build_non_discrete_equation(dae,dlow,ass1,ass2,eqn) => str
end

(** relation build_equation 
 **
 ** This returns the code string for a specific equation in the dae.
 ** It is used both for state variables and regular variables
 **)

relation build_equation:(DAE.DAElist, 
			 DAELow.DAELow, 
			 int vector, (* assignments1*)
			 int vector, (* assignments2*)
			 int) (* equation no*)
	  => string =
	     
  rule  (* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	DAELow.is_non_state kind => true &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
        
	
  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	let new_varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,new_varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(dae,cr ,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	
  rule	(* probably, solved failed in rule above. This means that we have 
	 a non-linear equation. *)
 	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
 	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail

  rule	(* Algorithms *)
	(* Each algorithm should only be genated once.*)
	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.ALGORITHM(indx,inputs,outputs) &
	array_nth(algs,indx) => alg &
	Codegen.generate_algorithm(DAE.ALGORITHM(alg),1) 
	  => (Codegen.CFUNCTION(_,_,_,_,_,_,stmt_strs,_),_) &
	Util.string_delimit_list(stmt_strs,"\n") => res
	-------------------------
	build_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,algs,_),ass1,ass2,e) => res 
        
  rule	print "-build_equation failed\n" 
	--------------------------------
	build_equation(_,_,_,_,_) => "//build_equation failed\n" 
end

(** relation: build_residual_blocks
 **
 ** This relation generates code for blocks on residual form, i.e.
 ** g(\dot{x},x,y,t) = 0
 **)

 relation build_residual_blocks:(DAE.DAElist,DAELow.DAELow, 
				 int vector, (* ass1 *)
				 int vector, (* ass2 *)
				 int list list) (* blocks *)
	  => string list =

  axiom	build_residual_blocks(_,_,_,_,[]) => []
	 
  rule	(* For system of equations *) 
	 build_residual_system(dae,dlow,ass1,ass2,block) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res 
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as (_::_::_))::blocks) 
	  => eqn_str::res
	 
  rule	(* for single equations *)
	 build_residual_equation(dae,dlow,ass1,ass2,eqn) => eqn_str &
	 build_residual_blocks(dae,dlow,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_residual_blocks(dae,dlow,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_residual_blocks failed\n" 
	 -----------------
	 build_residual_blocks(_,_,_,_,_) => fail
 end

(** relation build_residual_system
 **
 ** A system of equations on residual form is still only an output of each
 ** residual equation. The numerical solver will solve the system.
**)

relation build_residual_system: (DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int list (* equation no. *)
				   ) => string =

  axiom	build_residual_system(_,_,_,_,[]) => ""

  rule	build_residual_equation(dae,dlow,ass1,ass2,eqn) => s1 &
	build_residual_system(dae,dlow,ass1,ass2,eqns) => s2 &
	string_append(s1,s2) => str
	---------------------------------------------
	build_residual_system(dae,dlow,ass1,ass2,eqn::eqns) => str
end


(** relation build_residual_equation 
 **
 ** This relation generates code on residual form for one equation.
 ** It is used both for state variables and algebraic variables.
 **)

 relation build_residual_equation:(DAE.DAElist,
				   DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int (* equation no. *)
				   ) => string =
	 
  rule  (* Do not output equations for discrete variables here *)
	 int_sub(e,1) => e' &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (DAELow.VAR(_,kind,_,_,_,_,_,_,_,_,_,_,_,flow)) &  
	 DAELow.is_discrete kind 
	 --------------------------------
	 build_residual_equation(_,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,_,_,_,_,_),_,ass2,e) => ""	
         
  rule  (* Solving for non-states *)
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow)) &  
	 DAELow.is_non_state kind => true &
	 (*print "Solving for non-states\n" &*)
	 let varexp = Exp.CREF(cr,Exp.REAL) &
	 Exp.solve(e1,e2,varexp) => expr &
         Exp.simplify(expr) => simplify_exp &
	 build_assignment(dae,cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string	
         
	 
  rule  (* Solving the state s, caluate residual form. *) 
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') 
	  => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_,dae_var_attr,comment,flow) &
	 int_string(indx) => indx_str &
	 let exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	 Exp.simplify(exp) => simplify_exp &
	 (* Use array named 'delta' for residuals *)
	 Util.string_append_list(["delta[",indx_str,"]"]) => cr_str &
	 let new_cr = Exp.CREF_IDENT(cr_str,[]) &
	 build_assignment(dae,new_cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => assigment_string 
	 
  rule	(* when-equations are not part of the residual equations *)
        int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.WHEN_EQUATION(e) 
	--------------------------------
	build_residual_equation(_,DAELow.DAELOW(_,_,eqns,_,_,_,_),_,_,e) => ""

  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_,dae_var_attr,comment,flow) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_residual_equation(dae,DAELow.DAELOW(DAELow.VARIABLES(_,_,vararr,_,_),_,eqns,_,_,_,_),ass1,ass2,e) => fail
         

  rule  print "-build_residual_equation failed\n" 
	--------------------------------
	build_residual_equation(_,_,_,_,_) 
	  => "//build_residual_equation failed\n" 
end

(** relation build_assignment 
 **
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)

relation build_assignment: (DAE.DAElist,
			    Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string) (* orig. name*) 
	  => string =

  rule  Exp.print_component_ref_str(cr) => cr_str &	
        print_exp_cpp_str(exp) => exp_str &
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
	-------------------------------------------------------------------------
	build_assignment(dae as DAE.DAE(elements),cr,exp as Exp.CALL(path,args,tuple as false,builtin),origname) => eqn_str


  rule  print "-simcodegen: build_assignment: Tuple return values from functions not implemented\n"
	--------------------------------------------------------------------------
	build_assignment(dae,cr,exp as Exp.CALL(path,args,tuple as true,builtin),origname) => fail
	  
  rule  Exp.print_component_ref_str(cr) => cr_str &
        print_exp_cpp_str(exp) => exp_str & 
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
        --------------------------------
	build_assignment(dae,cr,exp,origname) => eqn_str
        
  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(dae,cr,exp,origname) => fail
end


(** relation: print_exp_cpp_str
 **
 ** This relation prints a complete expression on a C/C++ format.
 **)

 relation print_exp_cpp_str : Exp.Exp => string =
         
  rule  print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s
         
 end

(** relation: lbinop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation lbinop_symbol : Exp.Operator => string =
  axiom	lbinop_symbol(Exp.AND) => " && "
  axiom	lbinop_symbol(Exp.OR) => " || "
end

(** relation: lunaryop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation lunaryop_symbol : Exp.Operator => string =
  axiom	lunaryop_symbol(Exp.NOT) => " !"
end

(** relation: relop_symbol
 **
 ** Helper relation to print_exp2_str
 **)

relation relop_symbol : Exp.Operator => string =
  axiom	relop_symbol(Exp.LESS(_))       => " < "
  axiom	relop_symbol(Exp.LESSEQ(_))     => " <= "
  axiom	relop_symbol(Exp.GREATER(_))    => " > "
  axiom	relop_symbol(Exp.GREATEREQ(_))  => " >= "
  axiom	relop_symbol(Exp.EQUAL(_))      => " == "
  axiom	relop_symbol(Exp.NEQUAL(_))     => " <> "
end


(** relation: print_exp2_str
 ** Helper relation to print_exp_str
 **)

 relation print_exp2_str : (Exp.Exp,int) => string =

  rule  print "# equation contain undefined symbols"
        --------------------------
        print_exp2_str(Exp.END,_) => fail
         
         
  rule  int_string(x) => s
	 ----------------------------
         print_exp2_str(Exp.ICONST(x),_) => s
         
  rule  real_string(x) => s
	 -----------------------------
         print_exp2_str(Exp.RCONST(x),_) => s

  rule  string_append ("\"", s) => s' &
	 string_append (s', "\"") => s''
         ---------------------------------
         print_exp2_str(Exp.SCONST(s),_) => s''
         
  axiom print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"


  rule	Exp.print_component_ref_str c => res
        --------------------------------
        print_exp2_str(Exp.CREF(c,_),_) => res

  rule  Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority(op) => pri2' &
         int_add(pri2',1) => pri2 & (* binary minus have higher priority than itself *)
         Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
         print_exp2_str (e1,pri3) => s2 & 
         print_exp2_str (e2,pri2) => s3 &
         Exp.print_rightpar_str (pri1,pri2) => s4 &
         string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	(* x^2 => x*x *)
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.ICONST(2)),pri1) => res
	 
  rule	(* x^2 => x*x *)
	 int_real(2) => two' &
	 real_eq(two,two) => true &
	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 Util.string_append_list([s1,s2, "*",s2,s4]) => res 
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), Exp.RCONST(two)),pri1) => res

  rule	Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
         string_append("pow(",s) => s' &
         string_append(s',",") => s'' &
         string_append(s'',s3) => s''' &
         string_append(s''',")") => res &
	 string_append (res, s4) => res'
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), e2),pri1) => res'

  rule	Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	 Exp.unaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ----------------------------
	 print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	 lbinop_symbol(op) => sym &
	 Exp.lbinop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ----------------------------------------------------------------
	 print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	 lunaryop_symbol(op) => sym &
 	 Exp.lunaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ---------------------------------------------------
	 print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	 relop_symbol(op) => sym &
 	 Exp.relop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str(e1,pri3) => s2 & 
	 print_exp2_str(e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -----------------------------------------------------------------
	 print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	 print_exp2_str(t,0) => thenstr &
	 print_exp2_str(f,0) => elsestr &
	 string_append ("(( ", ifstr) => s &
	 string_append (s, " ) ? ( ") => s' &
	 string_append (s', thenstr) => s'' &
	 string_append (s'', " ) : ( ") => s''' &
	 string_append (s''', elsestr) => s'''' &
	 string_append (s'''', " )) ") => slast 
	 ----------------------------
	 print_exp2_str(Exp.IFEXP(c,t,f),_) => slast
	 
	 (* abs using the fabs libc function *)
  rule	Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list(["fabs(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(Absyn.IDENT("abs"), args,_,builtin as true),_) => s

  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list([fs, "(", argstr, ")"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as true),_) => s

	 (* user defined Modelica functions, incl. external starts with an
	  ** underscore, to distringuish betweeen the lib function for external
	  ** functions and the wrapper function. *)
  rule	Absyn.path_string2(fcn,"_") => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 Util.string_append_list(["_",fs, "(", argstr, ").",fs,"_rettype_1"]) => s
	 ----------------------------------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,builtin as false),_) => s

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("{",s) => s' &
	 string_append (s',"}") => s''
	 -----------------------------
	 print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("(",s) => s' &
	 string_append (s',")") => s''
	 -----------------------------
	 print_exp2_str (Exp.TUPLE(es),_) => s''
	 
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	 string_append ("{{",s) => s' &
	 string_append (s',"}}") => s''
	 -----------------------------
	 print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (stop,pri3) => s3 &
 	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -------------------------------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (step,pri3) => s3 &
 	 print_exp2_str (stop,pri3) => s4 &
 	 Exp.print_rightpar_str (pri1,pri2) => s5 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', ":") => s''' &
	 string_append (s''', s4) => s'''' &
	 string_append (s'''', s5) => s'''''
	 -------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res &
	 string_append("-",res) => res2
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	 print_exp_cpp_str e => s & 
	 string_append ("(float)(", s) => s' &
	 string_append (s', ")") => s''
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	 print_exp_cpp_str e => s
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
         Exp.get_cref_from_exp(e) => cref_list &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
 	 Exp.print_rightpar_str (pri1,pri2) => s3 &
 	 int_string i => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, s3) => s' &
	 string_append (s', "[") => s'' &
	 string_append (s'', s4) => s''' &
	 string_append (s''', "]") => s''''
	 ---------------------------------------
	 print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	 print_exp_cpp_str dim => dimstr &
	 Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	 Util.string_append_list(["size(",crstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	 print_exp_cpp_str exp => expstr &
	 print_exp_cpp_str iterexp => iterstr &
	 Util.string_append_list(["<reduction>",
				  fs,"(",expstr," for ",
				  id," in ",iterstr,")"]) => str
	 -------------------------------------------------------
	 print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

 end

(** relation: cref_modelica_str
 **
 ** Converts Exp.ComponentRef, i.e. variables, to Modelica friendly variables.
 ** This means that dots are converted to underscore, etc.
 **)

relation cref_modelica_str : Exp.ComponentRef => string =

  rule  Util.string_replace_char(s,#".",#"_") => res' &
        Util.string_replace_char(res',#"[",#"_") => res'' &
        Util.string_replace_char(res'',#"]",#"_") => res''' 
        (* & Util.string_append_list(["_",res,"_"]) => res'*)
        ------------------------------
        cref_modelica_str(Exp.CREF_IDENT(s,_)) => res'''
        
  rule	cref_modelica_str(n) => ns &
(*  	string_append(s,"_") => s1 &  *)
	string_append(s(*s1*),ns) => ss
	-------------------------------------
	 cref_modelica_str(Exp.CREF_QUAL(s,_,n)) => ss
end


(** relation: get_called_functions
 **
 ** Goes through the DAELow structure, finds all function calls and returns 
 ** them in a list. Removes duplicates.
 **)

relation get_called_functions : (DAE.DAElist, DAELow.DAELow) => Absyn.Path list =

  rule	DAELow.get_all_exps dlow => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res
	-------------------------------------
	get_called_functions (dae, dlow) => res
	
end

(** relation: get_called_functions_in_functions
 **
 ** Goes through the given DAE, finds the given functions and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_functions : (Absyn.Path list, DAE.DAElist) => Absyn.Path list =

  rule	Util.list_map_1(paths, get_called_functions_in_function, dae) => pathslist &
	Util.list_flatten(pathslist) => res
	-------------------------------------
	get_called_functions_in_functions (paths,dae) => res
end

(** relation: get_called_functions_in_function 
 **
 ** Goes through the given DAE, finds the given function and collects the names
 ** of the functions called from within those functions
 **)
relation get_called_functions_in_function : (Absyn.Path, DAE.DAElist) => Absyn.Path list =

	(* Don't fail here, ceval will generate the function later *)
  rule	DAE.get_named_function(path, elements) => [] &
	Print.print_error_buf("Function not found: ") &
	Absyn.path_string path => pathstr &	
	Print.print_error_buf(pathstr) &
	Print.print_error_buf("\n")
	(*debug*) & Debug.fprint("info", "Function not found: ")
	(*debug*) & Debug.fprintln("info", pathstr)
	---------------------------------------------------
	get_called_functions_in_function (path,DAE.DAE(elements)) => []


  rule	DAE.get_named_function(path, elements) => funcelems &
	DAE.get_all_exps funcelems => explist &
	Exp.get_function_calls_list explist => fcallexps &
	Util.list_select(fcallexps, is_not_builtin_call) => fcallexps' &
	Util.list_map(fcallexps', get_call_path) => calledfuncs &
	remove_duplicate_paths calledfuncs => res1 &
	(*debug*) Debug.fprint("info", "Found called functions: ") &
	(*debug*) Util.list_map(res1, Absyn.path_string) => debugpathstrs &
	(*debug*) Util.string_delimit_list(debugpathstrs, ", ") => debugpathstr &
	(*debug*) Debug.fprintln("info", debugpathstr) &
	get_called_functions_in_functions (res1, dae) => res2 &
	list_append(res1,res2) => res	
	---------------------------------------------------
	get_called_functions_in_function (path, dae as DAE.DAE(elements)) => res

end


(** relation: is_not_builtin_call
 **
 ** return true if the given Exp.CALL is a call but not to a builtin function.
 ** checks the builtin flag in Exp.CALL
 **)
relation is_not_builtin_call : Exp.Exp => bool =

  rule	bool_not(builtin) => res
	------------------
	is_not_builtin_call Exp.CALL(_,_,_,builtin) => res

  axiom	is_not_builtin_call e => false

end

(** relation: get_call_path
 **
 ** Retrive the function name from a CALL expression.
 **)

relation get_call_path : Exp.Exp => Absyn.Path =

  axiom	get_call_path Exp.CALL(path,_,_,_) => path

end

(** relation: remove_duplicate_paths
 **
 ** Removed duplicate Paths in a list of Path.
**)

relation remove_duplicate_paths : Absyn.Path list => Absyn.Path list =

  axiom	remove_duplicate_paths [] => []


  rule	remove_path_from_list (rest, first) => restwithoutfirst &
	remove_duplicate_paths restwithoutfirst => recresult
	----------------------------------------------------
	remove_duplicate_paths first::rest => first::recresult


end

(** relation: remove_path_from_list
 **
 ** Helper relation to remove_duplicate_paths.
 **)

relation remove_path_from_list : (Absyn.Path list, Absyn.Path) => Absyn.Path list =

  axiom	remove_path_from_list ([],_) => []

  rule	ModUtil.path_equal (first, path) => true &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => res

  rule	ModUtil.path_equal (first, path) => false &
	remove_path_from_list (rest, path) => res
	-----------------------------------------
	remove_path_from_list (first::rest, path) => first::res


end

relation use_zerocrossing: () => bool =

  rule	RTOpts.debug_flag "noevents" => res &
	bool_not(res) => res'
	----------------------------------------
	use_zerocrossing () => res'

end




relation generate_equation_order:(int list list) 
	  => (int list) =

  axiom	generate_equation_order([]) => []

  rule	(* For system of equations skip these *)
	generate_equation_order(blocks) => res 
	-------------------------------------
        generate_equation_order((block as (_::_::_))::blocks) 
	  => (res)
	  
  rule	(* for single equations *)
	generate_equation_order(blocks) => res 
	-------------------------------------
	generate_equation_order((block as [eqn])::blocks) => eqn::res
	
  rule	print "-generate_equation_order failed\n" 
	-----------------
	generate_equation_order(_) => fail
end
