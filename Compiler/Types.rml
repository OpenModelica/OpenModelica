(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 Types.rml
 ** module:      Types
 ** description: Type system
 **
 ** RCS: $Id$
 **
 ** This file specifies the type system, as defined in the modelica
 ** specification. It contains an RML type called `Type' which 
 ** defines types. It also contains relations for
 ** determining subtyping etc.
 **
 ** There are a few known problems with this module.  It currently
 ** depends on `SCode.Attributes', which in turn depends on
 ** `Absyn.ArrayDim'.  However, the only things used from those
 ** modules are constants that could be moved to their own modules.
 **)

module Types :

  with "ClassInf.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "Values.rml"
  with "SCode.rml"

  (** - Identifiers *)
  type Ident = string

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Attributes		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Attributes = ATTR of bool	(* flow *)
			      * SCode.Accessibility
	  		      * SCode.Variability	(* parameter *)
			      * Absyn.Direction

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * 
				bool (* constant *)
		   | VALBOUND of Values.Value

  (** - Types *)
  type Type = (TType * Absyn.Path option (* classname *))

	(**
	 **  A Type is a tuple of a TType (containing the actual type) and a optional classname
	 **  for the class where the type originates from.
	 **)

  datatype TType = T_INTEGER of Var list
		| T_REAL of Var list
		| T_STRING of Var list
		| T_BOOL of Var list
		| T_ENUM 
		| T_ENUMERATION of string list * Var list
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State		  (* The type of. a class *)
			     * Var list
		| T_FUNCTION of FuncArg list 
			     * Type			  (* Only single-result *)
		| T_TUPLE of Type list			  (* For functions returning 
							   multiple values. *)
		| T_NOTYPE				  (* Used when type is not yet determined *)


  datatype ArrayDim = DIM of int option

  type FuncArg = Ident * Type


  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
  datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Type * (* type *)
				 bool (* if the type is a tuple, each element 
				          have a const flag. *)

(* Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Type * Const (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)

  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)


  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)


  (** - Modification datatype, was originally in Mod *)

  datatype EqMod = TYPED of Exp.Exp * Properties |
		   UNTYPED of Absyn.Exp
  datatype SubMod = NAMEMOD of Ident * Mod
		  | IDXMOD of int list * Mod
  and Mod = MOD of bool (* final *) * (SubMod list) * EqMod option
  	  | REDECL of bool (* final *) * (SCode.Element*Mod) list
	  | NOMOD


  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  relation lookup_component : (Type, Ident) => Var
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation make_array: (Type, Absyn.ArrayDim) => Type
  relation array_element_type : Type => Type
  relation print_type : Type => ()
  relation print_prop : Properties => ()
  relation print_prop_str: Properties => string 
  relation unparse_type : Type => string
  relation unparse_const : Const => string
  relation print_var : Var => ()
  relation print_binding : Binding => ()
  relation print_binding_str : Binding => string
  relation print_params : FuncArg list => () 
  relation print_farg: FuncArg => () 
  relation make_function_type : (Absyn.Path, Var list) => Type
  relation make_enumeration_type: (Absyn.Path, Var list) => Type 
  relation is_parameter: Var => ()
  relation contain_real: Type list => bool
  relation dimensions_known: Type => bool 
	 
  relation get_vars: (Var list, Var => () )  => Var list
  relation get_classname: (Type) => Absyn.Path
  relation get_type_name: Type => string
  relation is_array : Type => bool
  relation is_string : Type => bool
  relation is_array_or_string : Type => bool
  relation is_input_attr : Attributes => bool
  relation is_output_attr : Attributes => bool
  relation is_bidir_attr : Attributes => bool
  relation ndims : Type => int
  relation get_dimension_sizes: Type => int list
  relation type_of_value: (Values.Value) => Type

  relation values_to_mods: (Values.Value list,string list) => Mod
  relation values_to_vars:(Values.Value list,Exp.Ident list) => Var list
	  
  relation is_prop_any_const : Properties => bool
  relation is_prop_all_const : Properties => bool
  relation get_prop_type : Properties => Type
  relation is_prop_array : Properties => bool

  relation elab_type : Type => Exp.Type
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation match_type_list : (Exp.Exp, Type list, Type list) => (Exp.Exp, Type list) 
  relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list 
  relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) => Properties 

  relation flatten_array_type : Type => (Type, int list)

  relation flow_variables: (Var list, Exp.ComponentRef) => Exp.ComponentRef list

  relation get_all_exps : Type => Exp.Exp list

end


with "Dump.rml"
with "Debug.rml"
with "Print.rml"
with "Util.rml"
with "Static.rml"

relation is_array : Type => bool =

  axiom	is_array((T_ARRAY(_,_),_)) => true
  axiom	is_array((_,_)) => false

end

relation is_string : Type => bool =

  axiom	is_string ((T_STRING(_),_)) => true
  axiom	is_string ((_,_)) => false

end

relation is_array_or_string : Type => bool =

  rule	is_array ty => true
	-------------------
	is_array_or_string ty => true

  rule	is_string ty => true
	-------------------
	is_array_or_string ty => true

  rule -----------------	is_array_or_string _ => false

end

relation ndims : Type => int =

  rule	ndims t => n &
	int_add(n,1) => n'
	---
	ndims( (T_ARRAY(_,t),_) ) => n'

  axiom ndims( (_,_) ) => 0

end
relation dimensions_known: Type => bool =
	
  rule	get_dimension_sizes(tp) => []
	-----------------------
	dimensions_known(tp) => false

  rule	get_dimension_sizes(tp) => _
	-----------------------
	dimensions_known(tp) => true
end

relation get_dimension_sizes: Type => int list =

  rule	get_dimension_sizes(tp) => res
	----------------
	get_dimension_sizes((T_ARRAY(DIM(SOME(i)),tp),_)) => i::res

(*  rule	get_dimension_sizes(tp) => res
	------------------------------
	get_dimension_sizes((T_ARRAY(DIM(NONE),tp),_)) => -1::res *)

  axiom	get_dimension_sizes((_,_)) => []

end

(** relation: values_to_mods
 ** author: PA
 **
 ** This relation takes a list of values and convert into a Modification.
 **  Used for record construction evaluation. PersonRecord("name",45) has a value list 
 ** { "name",45 } that needs to be converted into a modifier for the record class
 **  PersonRecord ("name,45)
 **  FIXME: How about other value types, e.g. array, enum etc 
**)

relation values_to_mods: (Values.Value list,Ident list) => Mod =

  axiom	values_to_mods([],_) => MOD(false,[],NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.INTEGER(i)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.ICONST(i),PROP((T_INTEGER([]),NONE),false)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.REAL(r)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.RCONST(r),PROP((T_REAL([]),NONE),false)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.STRING(s)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.SCONST(s),PROP((T_STRING([]),NONE),false)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.BOOL(b)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.BCONST(b),PROP((T_BOOL([]),NONE),false)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_) &
	values_to_record_constructor_call(cname,vals) => rec_call &
	values_to_vars(vals,val_names) => varlst &
	Absyn.path_string(cname) => cname_str 
	----------------------------------------
	values_to_mods(Values.RECORD(cname,vals,val_names)::rest,id::ids)
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(rec_call,
							  PROP((T_COMPLEX(ClassInf.RECORD(cname_str),varlst),NONE),false)))))::res,NONE)

  rule	Debug.fprint("failtrace","-values_to_mods failed for value: ") &
	Values.val_string(v) => vs & 
	Debug.fprint("failtrace",vs) &
	Debug.fprint("failtrace","\n")
	--------------------------
	values_to_mods(v::_,_) => fail
end

(** relation: values_to_record_constructor_call
 ** 
 ** This relation transforms a list of values and an Absyn.Path to a function call
 ** to a record constructor.
 **)

relation values_to_record_constructor_call:(Absyn.Path, Values.Value list) 
	  => Exp.Exp =

  rule	Util.list_map(values,Static.value_exp) => expl 
	----------------------------------------------
	values_to_record_constructor_call(funcname,values) 
	  => Exp.CALL(funcname,expl,false,false)
end

(** relation values_to_vars
 ** 
 ** Translates a list of Values.Value to a Var list, using a list
 ** of identifiers as component names.
 ** Used e.g. when retrieving the type of a record value.
 **)

relation values_to_vars:(Values.Value list,Exp.Ident list) => Var list =
	
  axiom	values_to_vars([],[]) => []

  rule	type_of_value(v) => tp &
	values_to_vars(vs,ids) => rest
	------------------------
	values_to_vars(v::vs,id::ids) 
	  => VAR(id,ATTR(false,SCode.RW,SCode.VAR,Absyn.BIDIR),false,tp,UNBOUND)::rest

  rule	Debug.fprint("failtrace","-values_to_vars failed\n") 
	-------------------------
	values_to_vars(_,_) => fail
end
	
(** relation: type_of_value
 ** author: PA
 **
 ** Returns the type of a Values.Value.
 ** Some information is lost in the translation, like attributes
 ** of the builtin type.
 **)
relation type_of_value: (Values.Value) => Type =

  axiom	type_of_value(Values.INTEGER(_)) => ((T_INTEGER([]),NONE))
  axiom	type_of_value(Values.REAL(_)) => ((T_REAL([]),NONE))
  axiom	type_of_value(Values.STRING(_)) => ((T_STRING([]),NONE))
  axiom	type_of_value(Values.BOOL(_)) => ((T_BOOL([]),NONE))

  axiom	type_of_value (Values.ENUM(_)) => ((T_ENUM,NONE))

  rule	type_of_value(v) => tp &
	list_length(v::vs) => dim1 
	--------------------
	type_of_value(w as Values.ARRAY(v::vs)) => ((T_ARRAY(DIM(SOME(dim1)),tp),NONE))

  rule	Util.list_map(vs, type_of_value) => ts
	--------------------------------------
	type_of_value(w as Values.TUPLE(vs)) => ((T_TUPLE(ts),NONE))

  rule	values_to_vars (vl, ids) => vars &
	Absyn.path_string(cname) => cname_str
	---------------------------------------
	type_of_value Values.RECORD(cname,vl,ids) => ((T_COMPLEX(ClassInf.RECORD(cname_str),vars),NONE))

  rule	Debug.fprint("failtrace","-type_of_values failed: ") &
	Values.val_string v => vs &
	Debug.fprintln("failtrace", vs)
	----------------------------------------------------
	type_of_value(v) => fail

end


(** relation: basic_type
 **
 ** Test whether a type is one of the builtin types.
 **)

relation basic_type : Type => bool =

  axiom	basic_type( (T_INTEGER(_),_) ) => true
  axiom	basic_type( (T_REAL(_),_) ) => true
  axiom	basic_type( (T_STRING(_),_) ) => true
  axiom	basic_type( (T_BOOL(_),_) ) => true
  axiom	basic_type( (T_ENUM,_) ) => true
  axiom	basic_type( (T_ARRAY(_,_),_) ) => false
  axiom	basic_type( (T_COMPLEX(_,_),_) ) => false
  axiom	basic_type( (T_ENUMERATION(_,_),_) ) => false
end

(** relation: equivtypes
 **
 ** This is the type equivalence relation.  It is defined in terms of
 ** the subtype relation.  Two types are considered equivalent if they
 ** are subtypes of each other.
 **)

relation equivtypes : (Type, Type) => bool =

  rule	subtype(t1, t2) => true &
	subtype(t2, t1) => true
	-----------------------
	equivtypes(t1, t2) => true

	(* default *)
  axiom	equivtypes(t1, t2) => false

end

(** relation: subtype
 **
 ** Is the first type a subtype of the second type?  This relation
 ** specifies the rules for subtyping in Modelica.
 **)

relation subtype : (Type, Type) => bool =
	
  axiom	subtype ( (T_INTEGER(_),_),(T_INTEGER(_),_)) => true
  axiom	subtype ((T_REAL(_),_),(T_REAL(_),_))       => true
  axiom	subtype ((T_STRING(_),_),(T_STRING(_),_))   => true
  axiom	subtype ((T_BOOL(_),_),(T_BOOL(_),_))       => true
  axiom	subtype ((T_ENUM,_),(T_ENUM,_))	      => true

  rule	l2 = l1 &
	subtype((T_ENUMERATION(rest1,vl1),p1),(T_ENUMERATION(rest2,vl2),p2))=> res
	----------------------------------------------------------
	subtype ((T_ENUMERATION(l1::rest1,vl1),p1),(T_ENUMERATION(l2::rest2,vl2),p2))
	  => res

  axiom	subtype ((T_ENUMERATION([],_),_),(T_ENUMERATION(_,_),_))=> true
	
  rule	 subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(_,t1),_),(T_ARRAY(DIM(NONE),t2),_)) => true
	    
  rule  subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(DIM(NONE),t1),_),(T_ARRAY(_,t2),_)) => true
	    
  rule  i1 = i2 &
 	subtype (t1,t2) => true
	---------------------------------------------------------
	subtype((T_ARRAY(DIM(SOME(i1)),t1),_),(T_ARRAY(DIM(SOME(i2)),t2),_)) => true
	
  rule	subtype_varlist(els1, els2) => true
	-----------------------------------
	subtype((T_COMPLEX(st1,els1),_), (T_COMPLEX(st2,els2),_)) => true
        
	(* PR. Check of tuples, similar to complex. Just that
	     identifier name do not have to be checked. Only types are
	 checked. *)
  rule	subtype_typelist(type_list1,type_list2) => true
	-----------------------------------
	subtype((T_TUPLE(type_list1),_), (T_TUPLE(type_list2),_)) => true

  axiom subtype(t1,t2) => false

(* What? If not subtye should return false. Doesn't mean no matching rule

  rule	Debug.fprint ("tytr", "subtype: no matching subtype rule.\n") &
	Debug.fcall ("tytr", print_type, t1) &
	Debug.fprint ("tytr", " <> ") &
	Debug.fcall ("tytr", print_type, t2) &
	Debug.fprint ("tytr", "\n")
	-----------------------------------
	subtype(t1,t2) => false
*)

end


(** PR. relation: subtype_typelist
 **
 ** This relation checks if the both `Type' lists matches types, element
 ** by element.
 **)

relation subtype_typelist: (Type list,Type list) => bool =

  axiom	subtype_typelist ([], []) => true

  rule	subtype(t1,t2) => true &
	subtype_typelist(rest1,rest2) => true		
	-----------------------------
	subtype_typelist(t1::rest1,t2::rest2) => true

	(* default *)
  axiom	subtype_typelist(_,_) => false


end

(** relation: subtype_varlist
 **
 ** This relation checks if the `Var' list in the first list is a
 ** subset of the list in the second argument.  More precisely, it
 ** checks if, for each `Var' in the second list there is a `Var' in
 ** the first list with a type that is a subtype of the `Var' in the
 ** second list.
 **)

relation subtype_varlist : (Var list, Var list) => bool =

  axiom	subtype_varlist(_, []) => true

  rule	varlist_lookup(l,n) => VAR(_,_,_,t1,_) &
	subtype(t1,t2) => true &
	subtype_varlist(l,vs) => true
	-----------------------------
	subtype_varlist(l, VAR(n,_,_,t2,_)::vs) => true

	(* default *)
  axiom	subtype_varlist(_,_) => false

end

(** relation: varlist_lookup
 **
 ** Given a list of `Var' and a name, this relation finds any `Var'
 ** with the given name.
 **)

relation varlist_lookup : (Var list, Ident) => Var =

  rule	n = name
	--------
	varlist_lookup((v as VAR(n,_,_,_,_))::_, name) => v

  rule	varlist_lookup(vs, name) => v
	-----------------------------
	varlist_lookup(v::vs, name) => v

end

(** relation: lookup_component
 **
 ** This relation finds a subcomponent by name.
 **)

relation lookup_component : (Type, Ident) => Var =
	
  rule	basic_type(t) => true &
	lookup_in_builtin(t,n) => v
	-------------------------
	lookup_component(t,n) => v

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component((T_COMPLEX(st,cs),_), id) => v

  rule	lookup_component2(cs,id) => VAR(n,attr,prot,ty,bnd) &
	let ty' = ((T_ARRAY(dim,ty),NONE))
	-----------------------------
	lookup_component((T_ARRAY(dim,(T_COMPLEX(st,cs),_)),_), id) 
	  => VAR(n,attr,prot,ty',bnd)

  rule	(*Print.print_buf "- Looking up " &
	Print.print_buf id &
	Print.print_buf " in noncomplex type\n"*)
	-----------------------------------------
	lookup_component(_, id) => fail

end

(** relation: lookup_in_builtin
 **
 ** Since builtin types are not represented as T_COMPLEX, special care
 ** is needed to be able to lookup the attributes (`start' etc) in
 ** them.
 **
 ** This is not a complete solution.  The current way of mapping the
 ** both the Modelica type `Real' and the simple type `RealType' to
 ** `T_REAL' is a bit problematic, since it doesn't make a
 ** difference between `Real' and `RealType', which makes the
 ** translator accept things like `x.start.start.start'.
 **)

relation lookup_in_builtin : (Type,Ident) => Var =

	(* Real *)	
  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_REAL(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_INTEGER(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_STRING(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_BOOL(cs),_),id) => v

(*	
  axiom	lookup_in_builtin(T_REAL,"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"unit")
	  => VAR("unit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"displayUnit")
	  => VAR("displayUnit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, VALBOUND(Values.REAL(0.0)))

  axiom	lookup_in_builtin(T_REAL,"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_BOOL, UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_REAL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

  axiom	lookup_in_builtin((T_REAL(_),_),"nominal")
	  => VAR("nominal",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_REAL(_),_),"stateSelect")
	  => VAR("stateSelect",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUMERATION(["never","avoid","default","prefer","always"]),NONE),
		 VALBOUND(Values.ENUM("default")))
		 (* optimized away looking up the builtin enumeration type 'stateSelect' *)

	(* Integer *)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), VALBOUND(Values.INTEGER(0)))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* Boolean *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(false)))

  axiom	lookup_in_builtin((T_BOOL(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* String *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))
*)
	(* Enumeration ( type E in spec) *)
  axiom	lookup_in_builtin((T_ENUM,_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE),VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_ENUM,_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the first element of
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)

  axiom	lookup_in_builtin((T_ENUM,_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_ENUM,_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))		 
end

(** relation: lookup_component2
 **
 ** This relation finds a named `Var' in a list of `Var's, comparing
 ** the name against the second argument to this relation.
 **)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: make_array
 **  This relation makes an array type given a Type and an Absyn.ArrayDim
 **)
relation make_array: (Type, Absyn.ArrayDim) => Type =
  axiom	 make_array(t,[]) => t

  rule	list_length(l) => len
	--------------------
	make_array(t,l) => ((T_ARRAY(DIM(SOME(len)),t),NONE))
end

(** relation: lift_array
 **
 ** This relation turns a type into an array of that type.  If the
 ** type already is an array, aonther dimension is simply added.
 **)

relation lift_array : (Type,int option) => Type =

  rule	(*print("\nDebug: lifts the array.") 
*)	-------------------
	lift_array (ty,i) => ((T_ARRAY(DIM(i),ty),NONE))
(* PR  axiom	lift_array (ty,i) => T_ARRAY(DIM(i),ty) *)

end

(** relation: unlift_array
 **
 ** This relation turns an array of a type into that type.
 **)

relation unlift_array : Type => Type =

  axiom	unlift_array((T_ARRAY(DIM(_),ty),_)) => ty

end

(** relation: array_element_type
 **
 ** This relation turns an array into the element type
 ** of the array.
 **)

relation array_element_type : Type => Type =

  rule	array_element_type(ty) => ty'
	------------------------------
	array_element_type( (T_ARRAY(DIM(_),ty),_)) => ty'

  axiom	array_element_type t => t

end

(** relation: unparse_type
 **
 ** This relation prints a Modelica type as a piece of Modelica code.
**)
relation unparse_type: Type => string =

  axiom	unparse_type((T_INTEGER(_),_)) =>  "Integer"
  axiom	unparse_type((T_REAL(_),_)) =>  "Real"
  axiom	unparse_type((T_STRING(_),_)) =>  "String"
  axiom	unparse_type((T_BOOL(_),_)) =>  "Boolean"

  rule	Util.string_delimit_list(l,",") => s1 &
	Util.string_append_list(["enumeration(",s1,")"]) => str
	-----------------
	unparse_type((T_ENUMERATION(l,_),_)) =>  str

  rule  flatten_array_type t => (ty, dimlst) &
	Util.list_map(dimlst,int_string) => dimlststr &
	list_reverse(dimlststr) => dimlststr' &
	unparse_type ty => tys &
	Util.string_delimit_list(dimlststr',", ") => dims &
	Util.string_append_list([tys,"[",dims,"]"]) => res
	--------------------
	unparse_type(t as (T_ARRAY(_,_),_) ) => res

  rule	Util.list_map(vs,unparse_var) => vars &
	Util.string_append_list(vars) => vstr &
	Util.string_append_list(["record ",name,"\n",vstr,"end record;"]) => res
	---------------------------
	unparse_type((t as T_COMPLEX(ClassInf.RECORD(name),vs),_))=> res

  rule	ClassInf.get_state_name(ci_state) => res
	--------------------------------------
	unparse_type((T_COMPLEX(ci_state,vs),_)) => res

  rule  Util.list_map(params, unparse_param) => paramstrs &	
	Util.string_delimit_list(paramstrs, ", ") => paramstr &
	unparse_type restype => restypestr &
	Util.string_append_list(["/* function(", paramstr, ") => ", restypestr, "*/"]) => res 
	--------------------------------------
	unparse_type((T_FUNCTION(params,restype),_)) => res

  rule	Util.list_map(tys, unparse_type) => tystrs &
	Util.string_delimit_list(tystrs, ", ") => tystr &
	Util.string_append_list(["/* (", tystr, ") */"]) => res
	--------------------------------------------------
	unparse_type ((T_TUPLE(tys),_)) => res

  axiom	unparse_type ((T_NOTYPE,_)) => "/* #NOTYPE# */"	

  axiom	unparse_type(ty) => "/* unparse_type: not implemented yet */\n"  

end	

relation unparse_const : Const => string =

  rule	Util.bool_string b => bstr
	--------------------------
	unparse_const CONST(b) => bstr

  rule	Util.list_map(constlist, unparse_const) => strlist &
	Util.string_delimit_list(strlist, ", ") => res &
	Util.string_append_list(["(", res, ")"]) => res'
	----------------------------------------------
	unparse_const TUPLE_CONST(constlist) => res'

end

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `composite'.  The actual code is expluded from the report.
 **)

(*!ignorecode*)

relation print_type : Type => () =

  rule	Print.print_error_buf "Integer" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------
	print_type((T_INTEGER(vars),_))

  rule	Print.print_error_buf "Real" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	------------
	print_type((T_REAL(vars),_))

  rule	Print.print_error_buf "String"
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	--------------
	print_type((T_STRING(vars),_))

  rule	Print.print_error_buf "Boolean" 
	& Print.print_error_buf " ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------
	print_type((T_BOOL(vars),_))

  rule	Print.print_error_buf "EnumType" 
	---------------
	print_type((T_ENUM,_))

  rule	Print.print_error_buf "enumeration((" &
	Dump.print_list(l,print, ", ") &
	Print.print_error_buf ") "  
	& Print.print_error_buf ", ("
	& Dump.print_list(vars, print_var, ", ")
	& Print.print_error_buf ")" 
	---------------------
	print_type((T_ENUMERATION(l,vars),_))

  rule	Print.print_error_buf "composite(" &
	Print.print_error_buf ", (" &
	ClassInf.print_state(st) &
	Print.print_error_buf ", (" &
	Dump.print_list(vars, print_var, ", ") &
	Print.print_error_buf ")" 
	-----------------
	print_type((T_COMPLEX(st,vars),_))

  rule	Print.print_error_buf "array[" & print_arraydim dim & Print.print_error_buf "] of " &
	print_type t & Print.print_error_buf ")" 
	------------
	print_type((T_ARRAY(dim,t),_))

  rule	Print.print_error_buf "function(" & print_params params & Print.print_error_buf " => " &
	print_type restype &  Print.print_error_buf ")"
	------------------------------
	print_type((T_FUNCTION(params,restype),_))

  rule	Print.print_error_buf "(" & 
	Dump.print_list(tys, print_type, ", ") &
	Print.print_error_buf ")"  
	---------
	print_type((T_TUPLE(tys),_))

  rule	Print.print_error_buf "#NOTYPE#"
	----------------
	print_type((T_NOTYPE,_))

  rule	Print.print_error_buf "print_type failed!\n"
	---------------------------
	print_type( (_,_) )

end

relation print_arraydim: ArrayDim => () =

  rule	get_arraydim_str ad => s &
	Print.print_error_buf s
	-------
	print_arraydim ad

end


relation get_arraydim_str: ArrayDim => string =

  axiom	get_arraydim_str DIM(NONE) => ":"

  rule	int_string i => s
	---------------------------
	get_arraydim_str DIM(SOME(i)) => s

  axiom	get_arraydim_str _ =>  "#STRANGE#"

end


relation print_params : FuncArg list => () =

  axiom	print_params []

  rule	Print.print_error_buf n & Print.print_error_buf " :: " & print_type t
	-------------------------------------
	print_params [(n,t)]

  rule	Print.print_error_buf n & Print.print_error_buf " :: " & print_type t &
	Print.print_error_buf " * " & print_params params
	---------------------------------
	print_params ((n,t)::params)

end

(*!includecode*)

relation unparse_var: Var => string =

  rule	unparse_type typ => t &
	Util.string_append_list([t," ",n,";\n"]) => res
	----------------------------
	unparse_var VAR(n, attr, prot, typ, bind) => res
end

relation unparse_param: FuncArg => string =

  rule	unparse_type ty => tstr &
	Util.string_append_list([id, ":", tstr]) => res
	----------------------------
	unparse_param ((id, ty)) => res
end

(* LS *)
relation print_var : Var => () =

  rule	print_type typ & Print.print_error_buf " " &
	Print.print_error_buf n & Print.print_error_buf " " & 
	SCode.variability_string var => vs &
	Print.print_error_buf vs & Print.print_error_buf " " &
	print_binding bind 
	-------
	print_var VAR(n, ATTR(_,_,var,_), prot, typ, bind)

end

(* LS *)
relation print_binding : Binding => () =

  rule	Print.print_error_buf "UNBOUND"
	---------------
	print_binding UNBOUND

  rule	Print.print_error_buf "EQBOUND: " &
	Exp.print_exp exp &
	Dump.print_select (f, " true", " false")
	----------------------------------------
	print_binding EQBOUND (exp,f)

  rule	Print.print_error_buf "VALBOUND: " &
	Values.print_val v
	--------------------
	print_binding VALBOUND (v)

end

relation print_binding_str : Binding => string =

  axiom	print_binding_str UNBOUND => "UNBOUND" 

  rule	Exp.print_exp_str exp => str &
	Dump.select_string (f, " true", " false") => str2 &
	Util.string_append_list(["EQBOUND(", str, ", ",str2, ")"]) => res
	----------------------------------------
	print_binding_str EQBOUND (exp,f) => res

  rule	Values.unparse_values [v] => s &
	Util.string_append_list(["VALBOUND(",s,")"]) => res
	--------------------
	print_binding_str VALBOUND (v) => res

end

(* LS *)
relation make_function_type: (Absyn.Path, Var list) => Type =

  rule	get_input_vars vl => invl &
	get_output_vars vl => outvl &
	make_fargs_list invl => fargs &
	make_return_type outvl => rettype 

(*	& Debug.fprint ("ft", " <fargs: ") & 
	Debug.fprint_list ("ft", fargs, print_farg, ", ") &
	Debug.fprint ("ft", " >") &

	Debug.fprint ("ft", " <rettype: ") & 
	Debug.fcall ("ft", print_type, rettype) &
	Debug.fprint ("ft", " >")
*)
	---------------------------------
	make_function_type(p,vl) => ((T_FUNCTION(fargs, rettype),SOME(p)))

end

relation make_enumeration_type: (Absyn.Path, Var list) => Type =

  rule	make_enumeration_type(p,xs) => ((T_ENUMERATION(strs,[]),_))
	---------------------------------
	make_enumeration_type (p,VAR(name,_,_,_,_)::xs) 
	  => ((T_ENUMERATION(name::strs,[]),SOME(p)))

  axiom	make_enumeration_type(p,[]) => ((T_ENUMERATION([],[]),SOME(p)))
end

relation print_farg: FuncArg => () =

  rule	print_type ty & Print.print_error_buf " " & Print.print_error_buf n
	-----------------------------------
	print_farg ((n,ty))

end

(* LS *)
relation get_input_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(* LS *)
relation get_output_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end


relation get_classname: (Type) => Absyn.Path =

  axiom	get_classname((_,SOME(p))) => p

end

(* LS *)
relation get_vars: (Var list, Var => () )  => Var list =

  axiom	get_vars ([],_) => []

  rule	cond(v) &
	get_vars (vl, cond) => vl'
	-------------------
	get_vars (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_vars (vl, cond) => vl'
	--------------------------
	get_vars (v::vl, cond) => vl'

end	


(* LS *)
relation is_input_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_input_attr attr => true
	--------------------------
	is_input_var VAR(n, attr, false, ty, bnd)

end

relation is_output_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_output_attr attr => true
	---------------------------
	is_output_var VAR(n, attr, false, ty, bnd)

end

relation is_input_attr : Attributes => bool =

  axiom	is_input_attr ATTR(_,_,_,Absyn.INPUT) => true

end

relation is_output_attr : Attributes => bool =

  axiom	is_output_attr ATTR(_,_,_,Absyn.OUTPUT) => true

end

relation is_bidir_attr : Attributes => bool =

  axiom	is_bidir_attr ATTR(_,_,_,Absyn.BIDIR) => true

end

(* LS *)
relation make_fargs_list: Var list => FuncArg list =

  axiom	make_fargs_list [] => []

  rule	(*is_input_var v &*)
	make_fargs_list vl => fargl
	------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd) :: vl) => ((n,ty)::fargl)

  rule	Print.print_error_buf "#-- Not an input var:" & Print.print_error_buf n
	---------------------------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd)::vl) => fail

end

(* LS *)
relation make_return_type: Var list => Type =

  axiom	make_return_type [] => ((T_NOTYPE,NONE))

  rule	make_return_type_single var => ty
	---------------------------------
	make_return_type [var] => ty

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type vl => ((T_TUPLE(tys),NONE))

end

(* LS *)
relation make_return_type_single: Var => Type =

  axiom	make_return_type_single VAR(n,attr,pr,ty,bnd) => ty

end

(* LS *)
relation make_return_type_tuple: (Var list) => Type list =

  axiom	make_return_type_tuple [] => []

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type_tuple VAR(n,attr,pr,ty,bnd)::vl => ty::tys

end

(* LS *)
relation is_parameter: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(n, ATTR(fl, ac, SCode.PARAM, dir), false, ty, bnd)

end

(* Returns true if a buitlin type, or array-type is Real *)
relation contain_real: Type list => bool =

  rule	contain_real([tp]) => r1 &
	contain_real(xs) => r2 &
	bool_or(r1,r2) => res 
	---------------
	contain_real ((T_ARRAY(d,tp),_)::xs) => res 

  axiom	contain_real ((T_REAL(_),_)::_) => true

  rule	contain_real(xs) => res
	--------------
	contain_real(_::xs) => res

  axiom	contain_real(_)=> false
end

relation flatten_array_type : Type => (Type, int list) =

  rule	flatten_array_type ty => (ty', dimlist')
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(NONE),ty), _)) => (ty', dimlist')

  rule	flatten_array_type ty => (ty', dimlist) &
	list_append (dimlist,[dim]) => dimlist'
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(SOME(dim)), ty),_)) => (ty', dimlist')

  axiom	flatten_array_type ty => (ty, [])

end

relation get_type_name: Type => string =

  axiom	get_type_name((T_INTEGER(_),_))=> "Integer"
  axiom	get_type_name((T_REAL(_),_))	=> "Real"
  axiom	get_type_name((T_STRING(_),_))=> "String"
  axiom	get_type_name((T_BOOL(_),_))	=> "Boolean"

  rule	ClassInf.get_state_name st => n
	-------------------------------
	get_type_name((T_COMPLEX(st, _),_)) => n

  rule	flatten_array_type arrayty => (ty, dims) &
	Util.list_map(dims, int_string) => dimstrs &
	Util.string_delimit_list(dimstrs,", ") => dimstr &
	get_type_name ty => tystr &
	Util.string_append_list([tystr,"[",dimstr,"]"]) => str
	------------------------------------------------------
	get_type_name(arrayty as (T_ARRAY(_,_),_) ) => str

  axiom	get_type_name( (_,_)) => "Not nameable type or no type"


end

(** LS: If PROP_TUPLE, returns true if all of the flags are true **)
relation is_prop_all_const: Properties => bool =

  axiom	is_prop_all_const PROP(_,constant) => constant

  rule	is_prop_tuple_all_const constant => res
	-----------------------------------
	is_prop_all_const PROP_TUPLE(_,constant) => res

  rule	Debug.fprint("failtrace", "- is_prop_all_const failed: ") &
	print_prop_str prop => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	is_prop_all_const prop => fail
end

(** LS: If PROP_TUPLE, returns true if any of the flags are true **)
relation is_prop_any_const: Properties => bool =

  axiom	is_prop_any_const PROP(_,constant) => constant

  rule	is_prop_tuple_any_const constant => res
	-----------------------------------
	is_prop_any_const PROP_TUPLE(_,constant) => res

  rule	Debug.fprint("failtrace", "- is_prop_any_const failed: ") &
	print_prop_str prop => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	is_prop_any_const prop => fail
end

(** LS: **)
relation is_prop_tuple_any_const: Const => bool =

  axiom	is_prop_tuple_any_const CONST(f) => f

  rule	is_prop_tuple_any_const first => true
	---------------------------------
	is_prop_tuple_any_const TUPLE_CONST(first::rest) => true

  rule	is_prop_tuple_any_const first => false
	--------------------------------------------
	is_prop_tuple_any_const TUPLE_CONST(first::[]) => false

  rule	is_prop_tuple_any_const first => false &
	is_prop_tuple_any_const TUPLE_CONST(rest) => res
	--------------------------------------------
	is_prop_tuple_any_const TUPLE_CONST(first::rest) => res

  rule	Debug.fprint("failtrace", "- is_prop_tuple_any_const failed: ") &
	unparse_const const => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	is_prop_tuple_any_const const => fail
end

(** LS: **)
relation is_prop_tuple_all_const: Const => bool =

  axiom	is_prop_tuple_all_const CONST(f) => f

  rule	is_prop_tuple_all_const first => false
	---------------------------------
	is_prop_tuple_all_const TUPLE_CONST(first::rest) => false

  rule	is_prop_tuple_all_const first => true
	--------------------------------------------
	is_prop_tuple_all_const TUPLE_CONST(first::[]) => true

  rule	is_prop_tuple_all_const first => true &
	is_prop_tuple_all_const TUPLE_CONST(rest) => res
	--------------------------------------------
	is_prop_tuple_all_const TUPLE_CONST(first::rest) => res

  rule	Debug.fprint("failtrace", "- is_prop_tuple_all_const failed: ") &
	unparse_const const => str &
	Debug.fprintln("failtrace", str)
	---------------------------------------------------------------
	is_prop_tuple_all_const const => fail

end


relation is_prop_array : Properties => bool =

  rule	get_prop_type p => t &
	is_type_array t => b
	----------------------
	is_prop_array p => b

end

(** LS: **)
relation get_prop_type: Properties => Type = 

  axiom	get_prop_type PROP(ty,_) => ty
  axiom	get_prop_type PROP_TUPLE(ty,_) => ty

end

relation is_type_array : Type => bool =
	
	axiom is_type_array((T_ARRAY(_,_),_)) => true
	axiom is_type_array((_,_)) => false

end

relation elab_type : Type => Exp.Type =

  axiom	elab_type((T_INTEGER(_),_)) => Exp.INT
  axiom	elab_type((T_REAL(_),_)) => Exp.REAL
  axiom	elab_type((T_BOOL(_),_)) => Exp.BOOL
  axiom	elab_type((T_STRING(_),_)) => Exp.STRING
  axiom elab_type((T_ENUM,_)) => Exp.ENUM

  rule	array_element_type t => et &
	elab_type et => t'
	----------------
	elab_type(t as (T_ARRAY(_,_),_)) => t'

  axiom	elab_type((_,_)) => Exp.OTHER

end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	Debug.print "Debug: match prop." &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	Debug.print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end


(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =

  rule	subtype(e_type, expected_type) => true 
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e, e_type)

  rule	subtype(e_type, expected_type) => false &
	(*Debug.fprint("sei", "trying type convert\n") &*)
	type_convert(e, e_type, expected_type) => (e',e_type') 
	(*& Debug.fprint("sei", "Type convert succeded\n") *)
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e',e_type')
end

(** relation: match_type_list
 **
 ** This relation matches a list of types, with a list of other types.
 ** Type conversion is disredaded, but an expression is given (the rhs of a tuple assignment)
 ** if such conversions should be implemented
 **)

relation match_type_list : (Exp.Exp, Type list, Type list ) => (Exp.Exp, Type list) =

  axiom	match_type_list(e,[],[]) => (e,[])

  rule	match_type(e,t1,t2) => (e',tp) &
	match_type_list(e',ts1,ts2) => (e'',res) 
	--------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => (e',tp::res)

(*  rule	Debug.fprint("failtrace","- match_type_list failed\n") 
	-----------------------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => fail*)
end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =
	    
  rule	(* Array expressions *)
	int_eq (dim1, dim2) => true &
	type_convert_array (elist, ty1, ty2) => elist' &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	  => (Exp.ARRAY(at,a,elist'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Range expressions *)
	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(step,ty1,ty2) => (step',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,SOME(step),stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',SOME(step'),stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Range expressions *)
	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,NONE,stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',NONE,stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	(* Matrix expressions *)
	int_eq (dim1, dim2) => true &
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(SOME(dim2)), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))
	    
  rule	(* Matrix expressions *)
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(NONE), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))

  rule	(* Array expressions *)
	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(NONE), ty2),p2))

	    
  rule	(* Array expressions *)
	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(SOME(dim1)), ty2),p2))

  rule	(* Arbitrary expressions, 
	 * first dimension [dim1], 
	 * second dimension [dim2] *)
	int_eq(dim1,dim2) => true &
	type_convert (e, ty1, ty2) => (e',t') 
 	------------------------------------------
 	type_convert(e, 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
 	  => (e', (T_ARRAY(DIM(SOME(dim2)), t'),p2))

  rule	(* Arbitrary expressions, 
	 * first dimension [:], 
	 * second dimension [dim2] *)
	type_convert (e, ty1, ty2) => (e',t') 
 	------------------------------------------
 	type_convert(e, 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
 	  => (e', (T_ARRAY(DIM(NONE), t'),p2))

  rule	(* Arbitrary expressions 
	 * first dimension [:]
	 * second dimension [:]
	 *)
	type_convert (e, ty1, ty2) => (e',t') 
	--------------------
	type_convert(e,
		     (T_ARRAY(DIM(NONE), ty1),_), 
 		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (e', (T_ARRAY(DIM(NONE), t'),p2))
	    
  rule	(* Arbitrary expression 
	 * first dimension [dim1]
	 * second dimension [:]
	 *)
	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (e', (T_ARRAY(DIM(SOME(dim1)), t'),p2))

  rule	type_convert_list (elist, tys1, tys2) => (elist',tys')
	------------------------------------------
	type_convert(Exp.TUPLE(elist), 
		     (T_TUPLE(tys1),_), 
		     (T_TUPLE(tys2),p2))
	  => (Exp.TUPLE(elist'), (T_TUPLE(tys'),p2))

  axiom	type_convert(exp, 
	    (T_ENUM,_),
	    (T_ENUMERATION(l,v),p2))
	    => (exp, (T_ENUMERATION(l,v),p2))
	    
  axiom	type_convert(e, (T_INTEGER(v),_), (T_REAL(_),p)) 
	  => (Exp.CAST(Exp.REAL,e),(T_REAL(v),p))

(*  rule	Debug.fprint("tcvt","- type conversion failed: ") &
	Debug.fcall ("tcvt",print_type,t1) & 
	Debug.fprint("tcvt",", ") & 
	Debug.fcall ("tcvt",print_type,t2) &
	Debug.fprint("tcvt","\n")
	-------------------------------
	type_convert (_,t1,t2) => fail *)
end

relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list =

  axiom type_convert_array ([], _, _) => []

  rule	type_convert_array (rest, ty1, ty2) => rest' &
	type_convert (first, ty1, ty2) => (first',_)
	-------------------------------------------
	type_convert_array (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_error_buf "- type conversion of array failed exp=" &
	Exp.print_exp e &
	Print.print_error_buf "t1 = " &
	print_type t1 & 
	Print.print_error_buf " t2 = " &
	print_type t2 &
	Print.print_error_buf "\n" 
	-------------------------------
	type_convert_array (e::_,t1,t2) => fail *)

end

relation type_convert_matrix : ((Exp.Exp*bool) list list, Type, Type) => (Exp.Exp*bool) list list =

  axiom type_convert_matrix ([], _, _) => []

  rule	type_convert_matrix (rest, ty1, ty2) => rest' &
	type_convert_matrix_row(first,ty1,ty2) => first'
	-------------------------------------------
	type_convert_matrix (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_error_buf "- type conversion of matrix failed" &
	Print.print_error_buf "t1 = " &
	print_type t1 & 
	Print.print_error_buf " t2 = " &
	print_type t2 &
	Print.print_error_buf "\n" 
	-------------------------------
	type_convert_matrix (e::_,t1,t2) => fail *)

end

relation type_convert_matrix_row: ((Exp.Exp*bool) list , Type, Type) 
	    => ( Exp.Exp * bool) list =
  axiom type_convert_matrix_row ([],_,_) => []

  rule	type_convert_matrix_row(rest,t1,t2) => rest &
	type_convert(exp,t1,t2) => (exp',newt) &
	is_array t2 => a
	---------------------------------
	type_convert_matrix_row((exp,_)::rest,t1,t2 )=> ((exp',a)::rest)
end

relation type_convert_list : (Exp.Exp list, Type list, Type list) 
	  => (Exp.Exp list, Type list) =

  axiom type_convert_list ([], _, _) => ([],[])

  rule	type_convert_list (rest, ty1rest, ty2rest) => (rest',tyrest') &
	type_convert (first, ty1, ty2) => (first',ty')
	-------------------------------------------
	type_convert_list (first::rest, ty1::ty1rest, ty2::ty2rest) => (first'::rest',ty'::tyrest')

end

relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) 
	  => Properties =

  rule	match_with_promote(PROP(t1,c1),PROP(t2,c2),havereal) => PROP(t,c) &
	let dim = dim1
	-----
	match_with_promote(PROP((T_ARRAY(dim1,t1),_),c1),
			   PROP((T_ARRAY(dim2,t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(dim,t),p2),c)

  rule	is_array t1 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	---------------------------
	match_with_promote(PROP(t1,c1),
			   PROP((T_ARRAY(DIM(SOME(1)),t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(DIM(SOME(1)),t),p2),c)

  rule	is_array t2 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	-----
	match_with_promote(PROP((T_ARRAY(DIM(SOME(1)),t1),p),c1),
			   PROP(t2,c2), havereal)
	  => PROP( (T_ARRAY(DIM(SOME(1)),t),p) ,c)


  rule	is_array t1 => false &
	is_array t2 => false &	
	t1 = t2 &
	let t = t1 &
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP(t1,c1),PROP(t2,c2), false) => PROP(t,c)


  rule	(* Have real and both Real *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_REAL(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and first Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_REAL(v),p2),c2), true) 
	  => PROP((T_REAL(v),p2),c)

  rule	(* Have real and second Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_INTEGER(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and both Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_INTEGER(_),p2),c2), true) 
	  => PROP((T_REAL([]),p2),c)
end

relation print_prop_str: Properties => string =

  rule	unparse_type ty => ty_str &
	Util.if(const,"const","non_const")  => const_str &
	Util.string_append_list(["PROP(",ty_str,const_str,")"]) => res
	-------------------
	print_prop_str PROP(ty,const) => res

  rule	unparse_type ty => ty_str &
	unparse_const const => const_str &
	Util.string_append_list(["PROP_TUPLE(",ty_str, ", ", const_str, ")"]) => res
	---------------------------------
	print_prop_str PROP_TUPLE(ty,const) => res
end


relation print_prop : Properties => () =

  rule	print_prop_str p => str &
	Print.print_error_buf str 
	----------------
	print_prop (p) => ()
end


(** relation: flow_variables
 **
 ** This relation retrieves all variables names that are flow variables, and 
 ** prepends the prefix given as an 'Exp.ComponentRef'
**)

relation flow_variables: (Var list, Exp.ComponentRef) => Exp.ComponentRef list =

  axiom	flow_variables([],_) => []

  rule	Exp.join_crefs(cr,Exp.CREF_IDENT(id,[])) => cr' &
	flow_variables(vs,cr) => res
	-------------------------
	flow_variables(VAR(id,ATTR(true,_,_,_),_,_,_)::vs,cr) => cr'::res

  rule	flow_variables(vs,cr) => res
	-------------------------
	flow_variables(_::vs,cr) => res
end

(** relation: get_all_exps
 ** 
 ** This relation goes through the Type structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : Type => Exp.Exp list =

  rule	get_all_exps_tt ttype => exps
	-----------------------------
	get_all_exps ((ttype, pathopt)) => exps

end

(** relation: get_all_exps_tt
 ** 
 ** This relation goes through the TType structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps_tt : TType => Exp.Exp list =

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_INTEGER(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_REAL(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_STRING(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_BOOL(vars) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_ENUMERATION(strs, vars) => exps

  rule	get_all_exps ty => exps
	---------------------------------------------
	get_all_exps_tt T_ARRAY(dim, ty) => exps

  rule	get_all_exps_vars vars => exps
	---------------------------------------------
	get_all_exps_tt T_COMPLEX(cinf, vars) => exps

  rule	Util.list_map(fargs, get_funcarg_type) => tys &
	Util.list_map(tys, get_all_exps) => explists &
	get_all_exps ty => tyexps &
	Util.list_flatten(tyexps::explists) => exps
	-------------------------------------------
	get_all_exps_tt T_FUNCTION(fargs, ty) => exps

  rule	Util.list_map(tys, get_all_exps) => explist &
	Util.list_flatten(explist) => exps
	----------------------------------
	get_all_exps_tt T_TUPLE (tys) => exps

  rule	Debug.fprintln("failtrace", "-- get_all_exps_tt failed")
	--------------------------------------------------------
	get_all_exps_tt _ => fail

end

relation get_all_exps_vars : Var list => Exp.Exp list =

  rule	Util.list_map(vars, get_all_exps_var) => explist &
	Util.list_flatten(explist) => exps
	----------------------------------
	get_all_exps_vars vars => exps
	
end

relation get_all_exps_var : Var => Exp.Exp list =

  rule	get_all_exps ty => tyexps &
	get_all_exps_binding bnd => bndexp &
	list_append (tyexps,bndexp) => exps
	----------------------------
	get_all_exps_var VAR(id,attr,prot,ty,bnd) => exps
	
end


relation get_all_exps_binding : Binding => Exp.Exp list =

  axiom	get_all_exps_binding EQBOUND(exp,cnst) => [exp]

  axiom	get_all_exps_binding UNBOUND => []

  axiom	get_all_exps_binding VALBOUND(v) => []

  rule	Debug.fprintln("failtrace", "-- get_all_exps_binding failed")
	-------------------------------------------------------------
	get_all_exps_binding _ => fail

end


relation get_funcarg_type: FuncArg => Type =

  axiom	get_funcarg_type ((id,ty)) => ty

end
