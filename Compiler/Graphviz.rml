(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Graphviz.rml
 ** module:      Graphviz
 ** description: Graphviz is a tool for drawing graphs from a textual
 ** representation. This module generates the textual input to graphviz from a
 ** tree defined using the data structures defined here, e.g. Node for tree
 ** nodes. See http://www.research.att.com/sw/tools/graphviz/ .
 **
 ** Input: The tree constructed from data structures in Graphviz
 ** Output: Textual input to graphviz, written to stdout.
 **
 ** RCS: $Id$
 **
 **)


module Graphviz:

  type Type = string
  type Ident = string
  type Label = string

	(** A graphviz Node is a node of the graph. 
	 ** It has a type and attributes and children.
	 ** It can also have a list of labels, provided by the LNODE
	 ** constructor.
	 **)
  datatype Node = NODE of Type
                        * Attributes 
                        * Children
                | LNODE of Type
			* Label list
			* Attributes
			* Children


  type Children = Node list

  type Attributes = Attribute list

	(** an Attribute is a pair of name an value. *)
  datatype Attribute = ATTR of string (* name *) 
                             * string (* value *)

  relation dump : Node => ()

  val box : Attribute

end

val box = ATTR("shape","box")

(* Relations *)

(** relation: dump
 **
 ** Dumps a Graphviz Node on stdout.
 **)

relation dump : Node => () =
	
  rule	print "graph AST {\n" &
	dump_node node => nm &
	print "}\n"
	----------------
	dump node => ()

end


(** relation dump_node
 **
 ** Dumps a node to a string.
 **)

relation dump_node : Node => Ident =
	
  rule	nodename typ => nm &
	make_label [typ] => typlbl &
	list_append([ATTR("label", typlbl)], attr) => newattr &
	make_node(nm, newattr) => out &
	print out &
	dump_children(nm, children)
	---------------------------
	dump_node (NODE(typ, attr, children)) => nm


  rule	nodename typ => nm &
	list_append ([typ], lbl) => lbl' &
	make_label lbl' => lblstr &
	list_append([ATTR("label", lblstr)], attr) => newattr &
	make_node(nm, newattr) => out &
	print out &
	dump_children(nm, children)
	---------------------------
	dump_node (LNODE(typ, lbl, attr, children)) => nm

end

(** relation: make_label
 **
 ** Creates a label from a list of strings.
**)

relation make_label: string list => string =

  rule	make_label_req(sl) => s0 &
	string_append("\"",s0) => s1 &
	string_append(s1, "\"") => s2
	------------------------------
	make_label sl => s2

end

(** relation: make_label_req
 **
 ** Helper relation to make_label
 **)

relation make_label_req: string list => string =

  axiom	make_label_req [s] => s

  rule	string_append(s1,"\\n") => s &
	string_append(s,s2) => res
	-------------------
	make_label_req [s1,s2] => res

  rule	make_label_req rest => old &
	string_append(s1,"\\n") => s &
	string_append(s,old) => res
	-------------------
	make_label_req s1::rest => res

end

(** relation: dump_children
 **
 ** Helper relation to dump_node
 **)

relation dump_children : (Ident, Children) => () =

  axiom dump_children (_, []) => ()

  rule	dump_node node => nm &
	print_edge(nm, parent) &
	dump_children(parent, rest)
	---------------------------
	dump_children(parent, node::rest)
end


(** relation: nodename
 **
 ** Creates a unique node name, 
 ** changed use of str as part of nodename, since it may contain spaces
 *)
relation nodename : string => string =

  rule	tick => i & int_string i => is & string_append("GVNOD",is) => s
	-----------------------------------------------------------------
	nodename str => s
end


(** relation: print_edge
 **
 ** Prints an edge between two nodes.
 **)

relation print_edge : (Ident, Ident) => () =

  rule	make_edge(n1,n2) => str &
	print str & print ";\n"
	-----------------------
	print_edge(n1,n2)
end


(** relation: make_edge
 **
 ** Creates a string representing an edge between two nodes.
**)

relation make_edge : (Ident, Ident) => string =

  rule	string_append(n1, " -- ") => s &
	string_append(s, n2) => str
	---------------------------
	make_edge (n1, n2) => str

end


(** relation: make_node
 **
 ** Creates string from a node.
 **)

relation make_node : (Ident, Attributes) => string =

  rule	make_attr attr => s &
	string_append(nm, s) => s' &
	string_append(s', ";") => str
	-----------------------------
	make_node (nm, attr) => str

end

(** relation: make_attr
 **
 ** Creates a string from an Attribute list.
 **)

relation make_attr : Attribute list => string = 

  rule	make_attr_req l => res &
	string_append ("[", res) => s &
	string_append (s, "]") => str
	----------------------------
	make_attr l => str

end

(** relation: make_attr_req 
 **
 ** Helper relation to make_attr_req.
 **)

relation make_attr_req : Attribute list => string =

  rule	string_append(name,"=") => s &
	string_append(s, v) => str
	---------------------------
	make_attr_req [ATTR(name,v)] => str


  rule  make_attr_req(rest) => old &
	string_append(name,"=") => s &
	string_append(s,v) => s' &
	string_append(s',",") => s'' &
	string_append(s'', old) => str
	---------------------------
	make_attr_req(ATTR(name,v)::rest) => str

end
