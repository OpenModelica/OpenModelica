(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)

(**
 ** file:	 Algorithm.rml
 ** module:      Algorithm
 ** description: Algorithm datatypes
 **
 ** RCS: $Id$
 **
 ** This file contains data types and relations for managing
 ** algorithm sections. The algorithms in the AST are analyzed by the `Inst'
 ** module (Inst.rml) which uses this module to represent the algorithms. No
 ** processing of any kind, except for building the datastructure is 
 ** done in this module.
 ** 
 ** It is used primarily by Inst.rml which both provides its input data
 ** and uses its "output" data.
 ** 
 **)

module Algorithm:

  with "Exp.rml"
  with "Types.rml"
  with "SCode.rml"

  type Ident = string

  (** The `Algorithm' type corresponds to a whole algorithm secion. *)
  (** It is simple a list of algorithm statements. *)
  datatype Algorithm = ALGORITHM of Statement list


  (** There are four kinds of statements.  Assignments (`a := b;'),
   ** if statements (`if A then B; elseif C; else D;'), for loops
   ** (`for i in 1:10 loop ...; end for;') and when statements
   ** (`when E do S; end when;'). *)
  datatype Statement = ASSIGN of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | TUPLE_ASSIGN of Exp.Type * Exp.Exp list * Exp.Exp
		     | ASSIGN_ARR of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | IF of Exp.Exp * Statement list * Else
		     | FOR of Exp.Type * bool * Ident * Exp.Exp * Statement list
		     | WHILE of Exp.Exp * Statement list
		     | WHEN of Exp.Exp * Statement list
		     | ASSERT of Exp.Exp * Exp.Exp

  (** An if statements can one or more `elseif' branches and an
   ** optional `else' branch. *)
  datatype Else = NOELSE
		| ELSEIF of Exp.Exp * Statement list * Else
		| ELSE of Statement list

  relation make_assignment : (Exp.Exp, Types.Properties,
			      Exp.Exp, Types.Properties,
			      SCode.Accessibility) => Statement

  relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement 

  relation make_if : (Exp.Exp,
		      Types.Properties,
		      Statement list,
		      (Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Statement

  relation make_for : (Ident, Exp.Exp, Types.Properties,
		       Statement list) => Statement

  relation make_while : (Exp.Exp, Types.Properties,
			 Statement list) => Statement
	
  relation make_when_a : (Exp.Exp, Types.Properties,
			Statement list) => Statement

  relation make_assert: (Exp.Exp, Exp.Exp, Types.Properties, Types.Properties) 
	  => Statement

  relation get_all_exps : Algorithm => Exp.Exp list

end

with "Util.rml"
with "Print.rml"
with "Dump.rml"
with "Debug.rml"

(** relation: make_assignment
 **
 ** This relation creates an `ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **
 ** LS: Added call to get_prop_type and is_prop_any_const instead of
 ** having PROP in the rules. Otherwise rules must be repeated because of
 ** combinations with PROP_TUPLE
 **)
relation make_assignment : (Exp.Exp, Types.Properties,
			    Exp.Exp, Types.Properties,
			    SCode.Accessibility) => Statement =

  rule	Types.prop_any_const (lprop) => Types.C_CONST &
	Print.print_error_buf "# Trying to assign to constant component\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & Print.print_buf "\n"
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Types.prop_any_const (lprop) => Types.C_PARAM &
	Print.print_error_buf "# Trying to assign to parameter component\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & Print.print_buf "\n"
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Print.print_error_buf "# Can't assign to (readonly) " & Exp.print_exp e & Print.print_error_buf "\n"
	---------------------------------------------------------
	make_assignment(e,_,_,_, SCode.RO) => fail

	(* LS: Replaced "as Types.PROP(_,false)" from lhprop", by the first predicate *)
  rule	Types.prop_any_const (lhprop) => Types.C_VAR &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => false &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN(t,c,rhs')

  rule	Types.prop_any_const (lhprop) => Types.C_VAR &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => true &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN_ARR(t,c,rhs')

  rule	Types.get_prop_type lprop => lt &
	Types.get_prop_type rprop => rt &
	Types.equivtypes (lt,rt) => false &
	Print.print_error_buf "# Type mismatch in assignment\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & Print.print_buf "\n" &
	Print.print_error_buf "    " & Types.print_type lt &
 	Print.print_error_buf " := " & Types.print_type rt & Print.print_buf "\n"
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Print.print_buf "- Algorithm.make_assignment failed\n" &
	Print.print_buf "    " & Exp.print_exp lhs &
 	Print.print_buf " := " & Exp.print_exp rhs & Print.print_buf "\n" 
	---------------------------------------------
	make_assignment (lhs, lprop, rhs, rprop, _) => fail

end

(** relation: make_tuple_assignment
 **
 ** This relation creates an `TUPLE_ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **)
relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement =

  rule	Util.list_map(lprop, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_CONST &
	Print.print_error_buf "# Trying to assign to constant component in tuple assignment\n" &
	Print.print_error_buf "    " & 
	Dump.print_list(lhs, Exp.print_exp, ", ") &
 	Print.print_error_buf " := " & Exp.print_exp rhs &
	Print.print_error_buf "\n"
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

  rule	Util.list_map(lprop, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_PARAM &
	Print.print_error_buf "# Trying to assign to parameter component in tuple assignment\n" &
	Print.print_error_buf "    " & 
	Dump.print_list(lhs, Exp.print_exp, ", ") &
 	Print.print_error_buf " := " & Exp.print_exp rhs &
	Print.print_error_buf "\n"
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail


  rule	Util.list_map(lhprops, Types.prop_any_const) => bvals &
	Util.list_reduce(bvals,Types.const_or) => Types.C_VAR &
	Util.list_map(lhprops,Types.get_prop_type) => lhrtypes &
	Types.match_type_list(rhs,tpl,lhrtypes) => (rhs',_)
	(* Don't use the new rhs', since type conversions of several output args
	 are not clearly defined. *)
	----------------------------------------------
	make_tuple_assignment(expl, lhprops,
			rhs, Types.PROP_TUPLE((Types.T_TUPLE(tpl),_),Types.TUPLE_CONST(clist))) 
	  => TUPLE_ASSIGN(Exp.OTHER,expl,rhs)

  rule	(*Debug.fprint("failtrace", "- make_tuple_assignment failed\n")*)
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

end


(** relation: get_prop_exp_type
 **
 ** Returns the expression type for a given Properties by calling
 ** get_type_exp_type. Used by make_assignment.
 **)
relation get_prop_exp_type : Types.Properties => Exp.Type =
	
  rule	Types.get_prop_type p => ty &
	get_type_exp_type ty => t
	--------------------------
	get_prop_exp_type p => t

end

(** relation: get_type_exp_type
 **
 ** Returns the expression type for a given Type module type. Used only by
 ** get_prop_exp_type. 
 **)
relation get_type_exp_type : Types.Type => Exp.Type =

  axiom	get_type_exp_type((Types.T_INTEGER(_),_)) => Exp.INT
  axiom	get_type_exp_type((Types.T_REAL(_),_)) => Exp.REAL
  axiom	get_type_exp_type((Types.T_STRING(_),_)) => Exp.STRING
  axiom	get_type_exp_type((Types.T_BOOL(_),_)) => Exp.BOOL

  rule	get_type_exp_type t => t'
	------------------------
	get_type_exp_type((Types.T_ARRAY(_,t),_)) => t'

  axiom	get_type_exp_type( (_,_) ) => Exp.OTHER (*was fail but records must be handled somehow *)

end

(** relation: make_if
 **
 ** This relation creates an `IF' construct, checking that the types
 ** of the parts are correct. Else part is generated using the make_else
 ** relation.
 **)
relation make_if : (Exp.Exp,
		    Types.Properties,
		    Statement list,
		    (Exp.Exp * Types.Properties * Statement list) list,
		    Statement list) => Statement =

  rule	make_else(eib,fb) => else
	-------------------------
	make_if(e,Types.PROP((Types.T_BOOL(_),_),_),tb,eib,fb) => IF(e,tb,else)

  rule	Print.print_error_buf "# Type error in if conditional (" &
	Exp.print_exp e & Print.print_buf ")\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_if(e,Types.PROP(t,_),_,_,_) => fail

end

(** relation: make_else
 **
 ** 
 **)
relation make_else : ((Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Else =

	(** This removes empty else branches *)
  axiom	make_else ([],[]) => NOELSE

  axiom	make_else ([],fb) => ELSE(fb)

  rule	make_else (xs,fb) => else
	-------------------------
	make_else ((e,Types.PROP((Types.T_BOOL(_),_),_),b)::xs,fb)
	  => ELSEIF(e,b,else)
	
  rule	Print.print_error_buf "# Type error in elseif conditional (" &
	Exp.print_exp e & Print.print_error_buf ")\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_else((e,Types.PROP(t,_),_)::_,_) => fail

end

(** relation: make_for 
 **)
relation make_for : (Ident, Exp.Exp, Types.Properties,
		     Statement list) => Statement =

  rule	Types.is_array t => array &
	Types.elab_type t => et
	-----------------------
	make_for(i,e,Types.PROP((Types.T_ARRAY(_,t),_),_),stmts) => FOR(et,array,i,e,stmts)

  rule	Print.print_error_buf "# Type error in for conditional.\n" &
	Print.print_error_buf "    Expected array, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_for(_,_,Types.PROP(t,_),_) => fail

end

(** relation: make_while 
 **)
relation make_while : (Exp.Exp, Types.Properties,
		       Statement list) => Statement =

  axiom	make_while(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHILE(e,stmts)

  rule	Print.print_error_buf "# Type error in while conditional.\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_while(_,Types.PROP(t,_),_) => fail

end

(** relation: make_when_a
 **)
relation make_when_a : (Exp.Exp, Types.Properties,
		      Statement list) => Statement =

  axiom	make_when_a(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHEN(e,stmts)

  axiom	make_when_a(e,Types.PROP((Types.T_ARRAY(_,(Types.T_BOOL(_),_)),_),_),stmts) => WHEN(e,stmts)


  rule	Print.print_error_buf "# Type error in when conditional.\n" &
	Print.print_error_buf "    Expected Boolean scalar or vector, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_when_a(_,Types.PROP(t,_),_) => fail
end

(** relation: make_assert
 **
 ** Creates an assert statenebt from two expressions.
 **)
relation make_assert: (Exp.Exp, (* condition *)
		       Exp.Exp, (* message *)
		       Types.Properties, 
		       Types.Properties) 
	  => Statement =

  axiom	make_assert(cond, msg, Types.PROP((Types.T_BOOL(_),_),_),Types.PROP((Types.T_STRING(_),_),_)) 
	  => ASSERT(cond,msg)

	  (* RML does not handle the pattern below T_BOOL(_), hence we need to
	     implement this differently. *) 
	(*  rule	not let T_BOOL(_) = condt &  
	 Print.print_buf "# Type error in assert condition.\n" &
	 Print.print_buf " Expected Boolean, got " &
	 Types.print_type condt & Print.print_buf "\n"
	 --------------------------------------------
	 make_assert(_,_,Types.PROP(condt,_),_) => fail 
	 *)
end 

(** relation: get_all_exps
 ** 
 ** This relation goes through the Algorithm structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : Algorithm => Exp.Exp list =

  rule	get_all_exps_stmts stmts => exps
	-----------------------------------
	get_all_exps ALGORITHM(stmts) => exps

end

(** relation: get_all_exps_stmts
 ** 
 ** This relation takes a list of statements and returns all expressions
 ** in all statements.
 **)

relation get_all_exps_stmts : Statement list => Exp.Exp list=

  rule	Util.list_map(stmts, get_all_exps_stmt) => expslist &
	Util.list_flatten(expslist) => exps
	-----------------------------------
	get_all_exps_stmts stmts => exps
end


(** relation: get_all_exps_stmt
 **
 ** Returns all expressions in a statement.
 **)

relation get_all_exps_stmt : Statement => Exp.Exp list =

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN(expty, cr, exp) => [crexp,exp]

  rule	list_append(explist,[exp]) => exps
	---------------------------------
	get_all_exps_stmt TUPLE_ASSIGN(expty, explist, exp) => exps

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN_ARR(expty, cr, exp) => [crexp,exp]


  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append(exps1, elseexps) => exps
	------------------------------------
	get_all_exps_stmt IF(exp, stmts, else) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt FOR(expty, flag, id, exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHILE(exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHEN(exp, stmts) => exp::exps

  axiom	get_all_exps_stmt ASSERT(e1, e2) => [e1,e2]

  rule	Debug.fprintln("failtrace", "-- get_all_exps_stmt failed")
	----------------------------------------------------------
	get_all_exps_stmt _ => fail

end

(** relation: get_all_exps_else
 **
 ** Helper relation to get_all_exps_stmt.
 **)

relation get_all_exps_else : Else => Exp.Exp list =

  axiom	get_all_exps_else NOELSE => []

  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append (exps1,elseexps) => exps
	------------------------------------
	get_all_exps_else ELSEIF(exp,stmts,else) => exp::exps

  rule	get_all_exps_stmts stmts => exps	
	----------------------------------------
	get_all_exps_else ELSE(stmts) => exps

end

(** relation: cref_to_exp
 **
 ** Creates an expression from a componentref.
 ** The type of the expression will become Exp.OTHER.
 **)

relation cref_to_exp : Exp.ComponentRef => Exp.Exp =

  axiom	cref_to_exp cref => Exp.CREF(cref, Exp.OTHER)

end

