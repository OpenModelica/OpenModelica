(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 Derive.rml
 ** module:      Derive
 ** description: Differentiation of equations from DAELow
 **
 ** RCS: $Id$
 ** 
 ** This module is responsible for symbolic differentiation of equations and 
 ** expressions. Is is currently (2004-09-28) only used by the solve relation in 
 ** the exp module for solving equations.
 ** 
 ** The symbolic differentiation is used in the Newton-Raphson method and in
 ** index reduction.
 ** 
 ** 
 **)

module Derive:
  with "DAELow.rml"
  with "Exp.rml"
  relation differentiate_equation_time: (DAELow.Equation,
				    DAELow.Variables) (* all time varying variables *)
	  => DAELow.Equation
  relation differentiate_exp_time: (Exp.Exp, DAELow.Variables) => Exp.Exp
  relation differentiate_exp: (Exp.Exp, Exp.ComponentRef) => Exp.Exp
end


with "Absyn.rml" 
with "Util.rml"
with "Print.rml" 
with "Graphviz.rml" 

(** relation: differentiate_equation_time
 **
 ** Differentiates an equation with respect to the time variable.
 **)

relation differentiate_equation_time: (DAELow.Equation,
				  DAELow.Variables) (* time varying variables *)
	  => DAELow.Equation =

  rule	differentiate_exp_time(e1,timevars) => e1' &
	differentiate_exp_time(e2,timevars) => e2' &
	Exp.simplify(e1') => e1'' &
	Exp.simplify(e2') => e2'' 
	(*& Exp.simplify(e1'') => e1'' &
	Exp.simplify(e2'') => e2'' *)
	----------------------
	differentiate_equation_time(DAELow.EQUATION(e1,e2),timevars) 
	  => DAELow.EQUATION(e1'',e2'')


  rule	print "-differentiate_equation_time on algorithm not impl yet.\n" 
	-----------------------
	differentiate_equation_time(DAELow.ALGORITHM(_,_,_),_) => fail

  rule	print "-differentiate_equation_time faile\n" 
	-----------------------
	differentiate_equation_time(_,_) => fail
end

(** relation: differentiate_exp_time
 **
 ** This relation differentiates expressions with respect to the 'time' variable.
 ** All other variables that are varying over time are given as the second variable.
 ** For instance, given the model:
 ** model test 
 **   Real x,y; 
 **   parameter Real PI=3.14; 
 ** equation
 **   x+y=5*PI;	
 ** end test;
 ** gives
 ** differentiate_exp_time('x+y=5*PI', [x,y]) => der(x)+der(y)=0
 **)

relation differentiate_exp_time: (Exp.Exp,DAELow.Variables) => Exp.Exp =

  axiom	differentiate_exp_time(Exp.ICONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp_time(Exp.RCONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp_time(Exp.CREF(Exp.CREF_IDENT("time",[]),tp),_) 
	  => Exp.RCONST(1.0)
	  
  rule	DAELow.get_var(cr,timevars) => (_,_)
	--------------------------------
	differentiate_exp_time(e as Exp.CREF(cr,tp),timevars) 
	  => Exp.CALL(Absyn.IDENT("der"),[e],false,true)

  rule  (* der(sin(x)) = der(x)*cos(x) *)
	differentiate_exp_time(e,timevars) => e'
	--------------------------------
	differentiate_exp_time(Exp.CALL(Absyn.IDENT("sin"),[e],false,true),timevars) 
	  => Exp.BINARY(e',Exp.MUL(Exp.REAL),Exp.CALL(Absyn.IDENT("cos"),[e],false,true))

  rule	(* list_member(cr,timevars) => false *)
	--------------------------------
	differentiate_exp_time(e as Exp.CREF(cr,tp),timevars) 
	  => Exp.RCONST(0.0)
	
  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.ADD(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.ADD(tp),e2')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.SUB(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.SUB(tp),e2')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.MUL(tp),e2),tv) 
	  => (* f'g + fg' *)
	  Exp.BINARY(Exp.BINARY(e1,Exp.MUL(tp),e2'),
			Exp.ADD(tp),
			Exp.BINARY(e1',Exp.MUL(tp),e2))

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	-----------------------------
	differentiate_exp_time(Exp.BINARY(e1,Exp.DIV(tp),e2),tv) 
	 => (* (f'g - fg' ) / g^2 *)
	  Exp.BINARY(Exp.BINARY(Exp.BINARY(e1',Exp.MUL(tp),e2)
				   ,Exp.SUB(tp),
				   Exp.BINARY(e1,Exp.MUL(tp),e2')),
			Exp.DIV(tp),
			Exp.BINARY(e2,Exp.MUL(tp),e2))


  rule	differentiate_exp_time(e,tv) => e' 
	-----------------------------
	differentiate_exp_time(Exp.UNARY(op,e),tv) => Exp.UNARY(op,e')

  rule	(* The derivative of logic expressions are non-existent *)
	Print.print_error_buf "#Derivative of expression " &
	Exp.print_exp_str e => e_str & Print.print_error_buf e_str & 
	Print.print_error_buf " is non-existent\n" 
	-----------------------------
	differentiate_exp_time(e as Exp.LBINARY(e1,op,e2),tv) 
	  => fail
	
  rule	differentiate_exp_time(e,tv) => e'
	-----------------------------
	differentiate_exp_time(Exp.LUNARY(op,e),tv) => Exp.LUNARY(op,e')

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2'
	-------------------------
	differentiate_exp_time(Exp.RELATION(e1,rel,e2),tv) => Exp.RELATION(e1',rel,e2')
	
  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' &
	differentiate_exp_time(e3,tv) => e3'
	-------------------------
	differentiate_exp_time(Exp.IFEXP(e1,e2,e3),tv) => Exp.IFEXP(e1',e2',e3')

  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl' 
	-------------------------------------------------
	differentiate_exp_time(Exp.CALL(a as Absyn.IDENT("der"),expl,b,c),tv) 
	  => Exp.CALL(a,expl',b,c)



  rule	Absyn.path_string(a) => str &
	print "Error. differentiating of function (" & print str & 
	print ") not impl yet.\n" &
	Util.list_map_1(expl,differentiate_exp_time,tv) => expl' 
	-------------------------------------------------
	differentiate_exp_time(Exp.CALL(a,expl,b,c),tv) => Exp.CALL(a,expl',b,c)
	
  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl' 
	--------------------------------------------
	differentiate_exp_time(Exp.ARRAY(tp,b,expl),tv) => Exp.ARRAY(tp,b,expl')

  rule	Print.print_buf "differentiate_exp_time on MATRIX not impl.\n" &
	print "differentiate_exp_time on MATRIX not impl.\n"
	---------------------------------------
	differentiate_exp_time(e as Exp.MATRIX(_,_,_),_) => e
	
  rule	Util.list_map_1(expl,differentiate_exp_time,tv) => expl'
	-----------------------
	differentiate_exp_time(Exp.TUPLE(expl),tv) => Exp.TUPLE(expl')

  rule	differentiate_exp_time(e,tv) => e'
	-----------------------
	differentiate_exp_time(Exp.CAST(tp,e),tv) => Exp.CAST(tp,e')

  rule	differentiate_exp_time(e,tv) => e'
	----------------------------
	differentiate_exp_time(Exp.ASUB(e,i),tv) => Exp.ASUB(e,i)

  rule	differentiate_exp_time(e1,tv) => e1' &
	differentiate_exp_time(e2,tv) => e2' 
	------------------------------
	differentiate_exp_time(Exp.REDUCTION(a,e1,b,e2),tv) 
	  => Exp.REDUCTION(a,e1',b,e2')

  rule	Exp.print_exp_str e => str &
	print "-differentiate_exp_time on " & print str & print " failed\n" 
	--------------------
	differentiate_exp_time(e,tv) => fail
end

(** relation: differenatiate_exp
 **
 ** This relation differentiates expressions with respect to a given variable, given as second argument.
 ** For example.
 ** differentiate_exp('2*x*y+2*x+y',x) => 2*x+2
 **)
		 
relation differentiate_exp: (Exp.Exp, Exp.ComponentRef) => Exp.Exp =
        
  axiom	differentiate_exp(Exp.ICONST(_),_) => Exp.RCONST(0.0)
  axiom	differentiate_exp(Exp.RCONST(_),_) => Exp.RCONST(0.0)

  rule	(* D(x)/dx => 1 *)
	Exp.cref_equal (cr, crx) => true &
	int_real(1) => rval (* Since bug in RML makes 1.0 into 0.0 *)
	--------------------------------
	differentiate_exp(Exp.CREF(cr,_), crx) => Exp.RCONST(rval)
	  
  rule	(* D(c)/dx => 0 *)
 	Exp.cref_equal (cr, crx) => false
	--------------------------------
	differentiate_exp(e as Exp.CREF(cr,_), crx) => Exp.RCONST(0.0)
	
  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.ADD(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.ADD(tp),e2')

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.SUB(tp),e2),tv) 
	  => Exp.BINARY(e1',Exp.SUB(tp),e2')

  rule	(* a^x => ax^(a-1) *)
        Exp.cref_equal (cr, tv) => true &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one
	-----------------------------
	differentiate_exp(Exp.BINARY((e1 as Exp.CREF(cr,_)),Exp.POW(tp),e2),tv) 
	  => (* ax^(a-1) *)
	  Exp.BINARY(e2,
		     Exp.MUL(tp),
 		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))

  rule	(* e^x => x*der(e)*e^x-1 *)
	differentiate_exp(e1,tv) => d_e1 &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one & 
	let exp = Exp.BINARY(Exp.BINARY(d_e1,
				Exp.MUL(tp),
 				Exp.BINARY(e2,Exp.SUB(tp),Exp.RCONST(1.0))),
		     Exp.MUL(tp),
		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))
	-----------------------------
	differentiate_exp(Exp.BINARY((e1),Exp.POW(tp),e2),tv) 
	  => exp (* ax^(a-1) *)
	  

  rule	(* der(e)^x => x*der(e,2)*der(e)^(x-1)*)
        Exp.cref_equal (cr, tv) => true &
        Exp.exp_contains(e2,Exp.CREF(tv,tp)) => false &
        differentiate_exp(Exp.CREF(tv,tp),tv) => const_one
	-----------------------------
	differentiate_exp(Exp.BINARY((e1 as Exp.CALL(a as Absyn.IDENT("der"),[exp as Exp.CREF(cr,_)],b,c)),Exp.POW(tp),e2),tv) 
	  => (* ax^(a-1) *)
	  Exp.BINARY(Exp.BINARY(Exp.CALL(a,[exp,Exp.ICONST(2)],b,c),
				Exp.MUL(tp),
				e2),
		     Exp.MUL(tp),
 		     Exp.BINARY(e1,Exp.POW(tp),                 
			        Exp.BINARY(e2,Exp.SUB(tp),const_one)))


  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.MUL(tp),e2),tv) 
	  => (* f'g + fg' *)
	  Exp.BINARY(Exp.BINARY(e1,Exp.MUL(tp),e2'),
			Exp.ADD(tp),
			Exp.BINARY(e1',Exp.MUL(tp),e2))

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	-----------------------------
	differentiate_exp(Exp.BINARY(e1,Exp.DIV(tp),e2),tv) 
	 => (* (f'g - fg' ) / g^2 *)
	  Exp.BINARY(Exp.BINARY(Exp.BINARY(e1',Exp.MUL(tp),e2)
				   ,Exp.SUB(tp),
				   Exp.BINARY(e1,Exp.MUL(tp),e2')),
			Exp.DIV(tp),
			Exp.BINARY(e2,Exp.MUL(tp),e2))


  rule	differentiate_exp(e,tv) => e' 
	-----------------------------
	differentiate_exp(Exp.UNARY(op,e),tv) => Exp.UNARY(op,e')

  rule  Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("sin"),exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(Absyn.IDENT("cos"),[exp],b,c),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule  Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("cos"),exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.UNARY(Exp.UMINUS(Exp.REAL),Exp.CALL(Absyn.IDENT("sin"),[exp],b,c)),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule  (* exp(x) => x' * exp(x) *)
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("exp"),exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(Absyn.IDENT("exp"),exp::[],b,c),
                        Exp.MUL(Exp.REAL),
                        exp')
 
  rule  (* log(x) => x' * 1/x *)
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("log"),exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
                        Exp.MUL(Exp.REAL),
                        Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   exp))

  rule  (* log10(x) => x'*1/(x*log(10)) *)
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("log10"),exp::[],b,c),tv) 
	  => Exp.BINARY(exp',
                        Exp.MUL(Exp.REAL),
                        Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(exp,
                                              Exp.MUL(Exp.REAL),
                                              Exp.CALL(Absyn.IDENT("log"),[Exp.RCONST(10.0)],b,c))))


  rule  (* sqrt(x) => 1(2 * sqrt(x)) * der(x) *)
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("sqrt"),exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(Exp.RCONST(2.0),
                                              Exp.MUL(Exp.REAL),
                                              Exp.CALL(Absyn.IDENT("sqrt"),exp::[],b,c))),
                        Exp.MUL(Exp.REAL),
                        exp')
        

  rule  (* tan x => 1/((cos x)^2) *)
        Exp.exp_contains(exp,Exp.CREF(tv,Exp.REAL)) => true &
        differentiate_exp(exp,tv) => exp' 
        -------------------------------------------------
	differentiate_exp(Exp.CALL(Absyn.IDENT("tan"),exp::[],b,c),tv) 
	  => Exp.BINARY(Exp.BINARY(Exp.RCONST(1.0),
                                   Exp.DIV(Exp.REAL),
                                   Exp.BINARY(Exp.CALL(Absyn.IDENT("cos"),[exp],b,c),
                                              Exp.POW(Exp.REAL),
                                              Exp.RCONST(2.0))),
                        Exp.MUL(Exp.REAL),
                        exp')

  rule	(* The derivative of logic expressions are non-existent *)
	Print.print_error_buf "#Derivative of expression " &
	Exp.print_exp_str e => e_str & Print.print_error_buf e_str & 
	Print.print_error_buf " is non-existent\n" 
	-----------------------------
	differentiate_exp(e as Exp.LBINARY(e1,op,e2),tv) 
	  => fail
	
  rule	differentiate_exp(e,tv) => e'
	-----------------------------
	differentiate_exp(Exp.LUNARY(op,e),tv) => Exp.LUNARY(op,e')

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2'
	-------------------------
	differentiate_exp(Exp.RELATION(e1,rel,e2),tv) => Exp.RELATION(e1',rel,e2')
	
  rule	differentiate_exp(e2,tv) => e2' &
	differentiate_exp(e3,tv) => e3'
	-------------------------
	differentiate_exp(Exp.IFEXP(e1,e2,e3),tv) => Exp.IFEXP(e1,e2',e3')

	(* der(x) *)
  rule	Exp.cref_equal(cr,tv) => true
	-------------------------------------------------
	differentiate_exp(Exp.CALL(a as Absyn.IDENT("der"),[exp as Exp.CREF(cr,_)],b,c),tv) 
	  => Exp.CALL(a,[exp,Exp.ICONST(2)],b,c)

	(* der(abs(x)) = sign(x)*der(x) *)
  rule	differentiate_exp(exp,tv) => exp' 
	-------------------------------------------------
	differentiate_exp(Exp.CALL(a as Absyn.IDENT("abs"),[exp],b,c),tv) 
	  => Exp.BINARY(Exp.CALL(Absyn.IDENT("sign"),[exp'],false,true),
			Exp.MUL(Exp.REAL),
			exp')

  rule	Util.list_map_1(expl,differentiate_exp,tv) => expl' 
	--------------------------------------------
	differentiate_exp(Exp.ARRAY(tp,b,expl),tv) => Exp.ARRAY(tp,b,expl')
	
  rule	Util.list_map_1(expl,differentiate_exp,tv) => expl'
	-----------------------
	differentiate_exp(Exp.TUPLE(expl),tv) => Exp.TUPLE(expl')

  rule	differentiate_exp(e,tv) => e'
	-----------------------
	differentiate_exp(Exp.CAST(tp,e),tv) => Exp.CAST(tp,e')

  rule	differentiate_exp(e,tv) => e'
	----------------------------
	differentiate_exp(Exp.ASUB(e,i),tv) => Exp.ASUB(e,i)

  rule	differentiate_exp(e1,tv) => e1' &
	differentiate_exp(e2,tv) => e2' 
	------------------------------
	differentiate_exp(Exp.REDUCTION(a,e1,b,e2),tv) 
	  => Exp.REDUCTION(a,e1',b,e2')

  rule	(* If the expression does not contain the variable,
	 the derivative is zero. For efficiency reasons this rule
	 is last. Otherwise expressions is allways traversed twice 
	 when differentiating.*)
	Exp.exp_contains(e,Exp.CREF(cr,Exp.REAL)) => false
	--------------------------------
	differentiate_exp(e,cr) => Exp.RCONST(0.0)

  rule	print "differentiate_exp " &
	Exp.print_exp_str e => s & print s &
	Exp.print_component_ref_str cr => s2 & 
	print " w.r.t: " & print s2 & 
	print " failed\n" 
	------------------------
	differentiate_exp(e,cr) => fail
	
end



