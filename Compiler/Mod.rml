(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:        Mod.rml
 ** module:      Mod
 ** description: Modification handling
 **
 ** RCS: $Id$
 **
 ** Modifications are simply the same kind of modifications used in
 ** the `Absyn' module.
 **
 ** This type is very similar to `SCode.Mod'.  The main difference is
 ** that it uses `Exp.Exp' for the expressions.  Expressions stored
 ** here are prefixed and typechecked.
 **
 ** The datatype itself is moved to the Types module, in Types.rml, to prevent
 ** circular dependencies.
 **
 **)

module Mod:

  with "Absyn.rml"
  with "Env.rml"
  with "Exp.rml"
  with "Prefix.rml"
  with "SCode.rml"
  with "Types.rml"


  type Ident = string

  relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod, bool (*impl*)) => Types.Mod
  relation unelab_mod : (Types.Mod) => SCode.Mod
  relation update_mod: (Env.Env, Prefix.Prefix, Types.Mod, bool (*impl*)) => Types.Mod 
  relation elab_untyped_mod : (SCode.Mod,Env.Env, Prefix.Prefix) => Types.Mod

  relation lookup_comp_modification: (Types.Mod, Absyn.Ident) => Types.Mod
  relation lookup_idx_modification: (Types.Mod, int) => Types.Mod
  relation lookup_modification_p: (Types.Mod,Absyn.Path) => Types.Mod
  relation merge : (Types.Mod, Types.Mod,Env.Env, Prefix.Prefix) => Types.Mod
  relation mod_equation : Types.Mod => Types.EqMod option

  relation print_mod : Types.Mod => ()
  relation print_mod_str : Types.Mod => string 

end

with "Dump.rml"
with "Debug.rml"
with "Print.rml"
with "Inst.rml"
with "Static.rml"
with "Values.rml"
with "Util.rml"
with "Ceval.rml"

(** relation: elab_mod
 **
 ** This relation elaborates on the expressions in a modification and
 ** turns them into global expressions.  This is done because the
 ** expressions in modifications must be elaborated on in the context
 ** they are provided in, and not the context they are used in.
 **)
 
relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod, bool (*impl*)) => Types.Mod =

  axiom	elab_mod (_,_,SCode.NOMOD,impl) => Types.NOMOD

  rule	elab_submods (env,pre,subs,impl) => subs'
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,each,subs,NONE),impl)
	  => Types.MOD(final,each,subs',NONE)
	
  rule	elab_submods (env,pre,subs,impl) => subs' &
	Static.elab_exp(env,e,impl,NONE) => (e',prop,_) &
	elab_mod_value(env,e') => e_val &
	(* Bug: will cause elaboration of parameters without value to fail,
	 But this can be ok, since a modifier is present, giving it a value 
	 from outer modifications.. *)
	Prefix.prefix_exp(env,e',pre) => e''
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,each,subs,SOME(e)),impl)
	  => Types.MOD(final,each,subs',SOME(Types.TYPED(e'',e_val,prop)))

  rule	Inst.add_nomod(elist) => elist' 
	-------------------------------
	elab_mod (env, pre, m as SCode.REDECL(final, elist),impl) 
	  =>  Types.REDECL(final, elist')

  rule	Debug.fprint("failtrace", "#-- elab_mod failed\n")
	-------------------------------------------------
	elab_mod (_,pre,mod,impl) => fail 
end

(** relation: elab_mod_value
** author: PA
 **
 ** Helper relation to elab_mod. Builds values from modifier expressions
 ** if possible.
 ** Tries to Constant evaluate an expressions an create a Value option for it.
 **)

relation elab_mod_value: (Env.Env, Exp.Exp) => Values.Value option =

	(* If ceval fails, it should not print error messages. *)
  rule	Ceval.ceval(env,e,false,NONE,NONE,Ceval.NO_MSG) => (v,_) 
	-------------------------------------------
	elab_mod_value(env,e) => SOME(v)

  axiom	elab_mod_value(_,_) => NONE
end
 

(** relation: unelab_mod
 **
 ** Transforms Mod back to SCode.Mod, loosing type information.
 **)

relation unelab_mod: Types.Mod => SCode.Mod =
	
  axiom	unelab_mod (Types.NOMOD) => SCode.NOMOD
	
  rule	unelab_submods (subs) => subs'
	------------------------------------
	unelab_mod (m as Types.MOD(final,each,subs,NONE))
	  =>  SCode.MOD(final,each,subs',NONE)
	  
  rule	unelab_submods (subs) => subs' 
	------------------------------------
	unelab_mod (m as Types.MOD(final,each,subs,SOME(Types.UNTYPED(e))))
	  => SCode.MOD(final,each,subs',SOME(e))
	  
  rule	Exp.print_exp_str e => es &
	unelab_submods (subs) => subs' &
	Exp.unelab_exp(e) => e'
	------------------------------------
	unelab_mod (m as Types.MOD(final,each,subs,SOME(Types.TYPED(e,_,p))))
	  => SCode.MOD(final,each,subs',SOME(e'))
	  
  rule	Util.list_map(elist,Util.tuple2_1) => elist'
	--------------------------------------------
	unelab_mod (m as Types.REDECL(final, elist)) 
	  =>  SCode.REDECL(final, elist')
	  
  rule	Print.print_buf "#-- elab_untyped_mod failed:\n" &
	print "- unelab_mod failed\n" 
	----------
	unelab_mod (mod) => fail
end

(** relation: unelab_submods
 **
 ** Helper relation to unelab_mod.
 **)

relation unelab_submods : ( Types.SubMod list)
	  => SCode.SubMod list =
	  
  axiom	unelab_submods ([]) => []
	
  rule	unelab_submod (x) => x' &
	unelab_submods (xs) => xs' &
	list_append(x',xs') => res	    
	-----------------------------
	unelab_submods (x::xs) => res
end

(** relation: unelab_submod
 **
 ** This relation unelaborates on a submodification.
 **)
		 
relation unelab_submod : (Types.SubMod) => SCode.SubMod list =
	
  rule	unelab_mod (m) => m'
	--------------------------
	unelab_submod (Types.NAMEMOD(i,m)) => [SCode.NAMEMOD(i,m')]
	
  rule	unelab_subscript(ss) => ss' &
	unelab_mod(m) => m'
	---------------------------
	unelab_submod (Types.IDXMOD(ss,m)) => [SCode.IDXMOD(ss',m')]
end

relation unelab_subscript: (int list) => SCode.Subscript list =
		    
   axiom unelab_subscript ([]) => []

   rule	unelab_subscript(is) => xs 
	--------------------------
	unelab_subscript (i::is) => Absyn.SUBSCRIPT(Absyn.INTEGER(i))::xs	    
end
(** relation: update_mod
 **
 ** This relation updates and untyped modification to a typed one, by looking
 ** up the type of the modifier in the environment and update it.
 **)
relation update_mod: (Env.Env,Prefix.Prefix, Types.Mod, bool (*impl*)) => Types.Mod =

  axiom	update_mod(_,_,Types.NOMOD,impl) => Types.NOMOD
  axiom	update_mod(_,_,m as Types.REDECL(_,_),impl) => m

  rule	update_submods (env,pre,subs,impl) => subs' &
	Static.elab_exp(env,e,impl,NONE) => (e',prop,_)  &
	elab_mod_value(env,e') => e_val &
	Prefix.prefix_exp(env,e',pre) => e'' &
	Debug.fprint("updmod","Updated mod: ") &
	Debug.fcall("updmod",print_mod ,Types.MOD(f, each, subs', SOME(Types.TYPED(e'', NONE,prop)))) 
	-----------------
	update_mod(env, pre, m as Types.MOD(f, each, subs, SOME(Types.UNTYPED(e))),impl)
	  => Types.MOD(f, each, subs', SOME(Types.TYPED(e'',e_val, prop)))

  rule	update_submods (env, pre, subs,impl) => subs' 
	---------------------------------------
	update_mod(env, pre, Types.MOD(f, each, subs, SOME(Types.TYPED(e, e_val, p))),impl) 
	  => Types.MOD(f, each, subs', SOME(Types.TYPED(e,e_val, p)))

  rule	update_submods (env,pre,subs,impl) => subs' 	
	-------------------------
	update_mod(env, pre, Types.MOD(f, each, subs, NONE),impl) 
	  => Types.MOD(f,each,subs',NONE)

  rule	Print.print_buf "- update_mod failed\n mod:" &
	print_mod m & Print.print_buf "\n" 
	--------------
	update_mod(env,pre,m,impl) => fail
end

relation update_submods: (Env.Env, Prefix.Prefix, Types.SubMod list, bool (*impl*))
	=> Types.SubMod list =
  axiom	update_submods (_,_,[],impl) => []

  rule	update_submod (env,pre,x,impl) => x' &
	update_submods (env,pre,xs,impl) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	update_submods (env,pre,x::xs,impl) => res
end


relation update_submod : (Env.Env, Prefix.Prefix, Types.SubMod, bool (*impl*)) 
	  => Types.SubMod list =

  rule	update_mod (env,pre,m,impl) => m'
	--------------------------
	update_submod (env,pre,Types.NAMEMOD(i,m),impl) => [Types.NAMEMOD(i,m')]

  rule	(*Static.elab_subscripts (env,ss) => (ss',true) &*)
	update_mod (env,pre,m,impl) => m' &
	make_idxmods ([],m') => smods &
	Print.print_buf "#Error, not implemented updating of IDXMOD yet\n"
	(* Need to store untyped IDXMOD list in mods such that we can elab *)
	(* the index here *)
	---------------------------
	update_submod (env,pre,Types.IDXMOD(_,m),impl) => smods
end

(** relation elab_untyped_mod
 **
 ** This relation is used to convert SCode.Mod into Mod, without 
 ** adding correct type information. Instead, a undefined type will be 
 ** given to the modification. This is used when modifications of e.g. 
 ** elements in base classes used. For instance,
 ** model test extends A(x=y); end test; // both x and y are defined in A
 ** The modifier x=y must be merged with outer modifiers, thus it needs 
 ** to be converted to Mod.
 ** Notice that the correct type information must be updated later on.
 **)

relation elab_untyped_mod: (SCode.Mod,Env.Env,Prefix.Prefix) => Types.Mod =

  axiom	elab_untyped_mod (SCode.NOMOD,_,_) => Types.NOMOD

  rule	elab_untyped_submods (subs,env,pre) => subs'
	------------------------------------
	elab_untyped_mod (m as SCode.MOD(final,each,subs,NONE),env,pre)
	  => Types.MOD(final,each,subs',NONE)
	
  rule	elab_untyped_submods (subs,env,pre) => subs' 
	------------------------------------
	elab_untyped_mod (m as SCode.MOD(final,each,subs,SOME(e)),env,pre)
	  => Types.MOD(final,each,subs',SOME(Types.UNTYPED(e)))

  rule	Inst.add_nomod(elist) => elist'
	-----------------
	elab_untyped_mod (m as SCode.REDECL(final, elist),env,pre) 
	  =>  Types.REDECL(final, elist')

  rule	Print.print_buf "#-- elab_untyped_mod failed:\n" &
	SCode.print_mod mod &
	Print.print_buf "\n"
	----------
	elab_untyped_mod (mod,env,pre) => fail
end

(** relation: elab_submods
 **
 ** This relation helps `elab_mod' by recusively elaborating on a list
 ** of submodifications.
 **)

relation elab_submods : (Env.Env, Prefix.Prefix, SCode.SubMod list, bool (*impl*))
	  => Types.SubMod list =

  axiom	elab_submods (_,_,[],impl) => []

  rule	elab_submod (env,pre,x,impl) => x' &
	elab_submods (env,pre,xs,impl) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	elab_submods (env,pre,x::xs,impl) => res

end

(** relation: elab_submod
 **
 ** This relation elaborates on a submodification, turning an
 ** `SCode.SubMod' into one or more `Types.SubMod's.
 **)

relation elab_submod : (Env.Env, Prefix.Prefix, SCode.SubMod, bool (*impl*)) => Types.SubMod list =

  rule	elab_mod (env,pre,m,impl) => m'
	--------------------------
	elab_submod (env,pre,SCode.NAMEMOD(i,m),impl) => [Types.NAMEMOD(i,m')]

  rule	Static.elab_subscripts (env,ss,impl) => (ss',Types.C_CONST) &
	elab_mod (env,pre,m,impl) => m' &
	make_idxmods (ss',m') => smods
	---------------------------
	elab_submod (env,pre,SCode.IDXMOD(ss,m),impl) => smods

end

(** relation: elab_untyped_submods
 **
 ** This relation helps `elab_untyped_mod' by recusively elaborating on a list
 ** of submodifications.
 **)

relation elab_untyped_submods : (SCode.SubMod list,Env.Env,Prefix.Prefix)
	  => Types.SubMod list =

  axiom	elab_untyped_submods ([],_,_) => []

  rule	elab_untyped_submod (x,env,pre) => x' &
	elab_untyped_submods (xs,env,pre) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	elab_untyped_submods (x::xs,env,pre) => res
end

(** relation: elab_untyped_submod
 **
 ** This relation elaborates on a submodification, turning an
 ** `SCode.SubMod' into one or more `Types.SubMod's, wihtout type information.
 **)

relation elab_untyped_submod : (SCode.SubMod,Env.Env,Prefix.Prefix) 
	  => Types.SubMod list =

  rule	elab_untyped_mod (m,env,pre) => m'
	--------------------------
	elab_untyped_submod (SCode.NAMEMOD(i,m),env,pre) 
	  => [Types.NAMEMOD(i,m')]

  rule	elab_untyped_mod (m,env,pre) => m'
	---------------------------
	elab_untyped_submod (SCode.IDXMOD(subcr,m),env,pre)
	  => [Types.IDXMOD([-1],m')]
end

(** relation: make_idxmods
 **
 ** From a list of list of integers, this relation creates a list of
 ** sub-modifications of the `IDXMOD' variety.
 **)

relation make_idxmods : (Exp.Subscript list, Types.Mod) => Types.SubMod list =

  axiom	make_idxmods([Exp.INDEX(Exp.ICONST(x))],m) => [Types.IDXMOD([x],m)]

  rule	make_idxmods(xs, m) => mods &
	prefix_idxmods(mods, x) => mods'
	--------------------------------
	make_idxmods(Exp.INDEX(Exp.ICONST(x))::xs, m) => mods'

  rule	Print.print_buf "= expand_slice\n" &
	expand_slice(x, xs, 1, m) => mods
	---------------------------
	make_idxmods(Exp.SLICE(Exp.ARRAY(_,_,x))::xs, m) => mods

  rule	Print.print_buf "# Sorry, [:] slices are not handled in modifications\n"
	--------------------------------------------------------------
	make_idxmods(Exp.WHOLEDIM::xs, m) => fail
	
end

(** relation: prefix_idxmods
 **
 ** This relation adds a subscript to each `Types.IDXMOD' in a list of
 ** submodifications.
 **)

relation prefix_idxmods : (Types.SubMod list, int) => Types.SubMod list =

  axiom	prefix_idxmods([],_) => []

  rule	prefix_idxmods(mods, i) => mods'
	--------------------------------
	prefix_idxmods(Types.IDXMOD(l,m)::mods, i) => Types.IDXMOD(i::l,m)::mods'

end

(** relation: expand_slice
 **
 ** This relation goes through an array slice modification and creates
 ** an singly indexed modification for each index in the slice.  For
 ** example, `x[2:3] = y' is changed into `x[2] = y[1]' and
 ** `x[3] = y[2]'.
 **)

relation expand_slice : (Exp.Exp list, Exp.Subscript list, int, Types.Mod)
	  => Types.SubMod list =

  axiom	expand_slice([], _, _, _) => []

  axiom	expand_slice([], _, _, _) => []

  rule	Exp.simplify(Exp.ASUB(e,n)) => e' &
	Types.unlift_array(t) => t' &
	make_idxmods(Exp.INDEX(x)::ss,
		     Types.MOD(final,each, [],
			 SOME(Types.TYPED(e',e_val,Types.PROP(t',const))))) => mods1 &
	int_add(n, 1) => n' &
	expand_slice(xs, ss, n', m) => mods2 &
	list_append(mods1, mods2) => mods
	---------------------------------
	expand_slice(x::xs, ss, n,
		     m as Types.MOD(final,each, [],
			      SOME(Types.TYPED(e,e_val,Types.PROP(t,const))))) => mods

  rule	Print.print_error_buf "# Illegal modification (" & print_mod mod & Print.print_buf ")\n"
	--------------------------------
	expand_slice(_,_,_,mod) => fail

end

(** relation: expand_list
 **
 ** This utility relation takes a list of integer values and a list of
 ** list of integers, and for each integer in the first and each list
 ** in the second list creates a
 ** list with that integer as head and the second list as tail. All
 ** resulting lists are collected in a list and returned.
 **)

relation expand_list : (Values.Value list, int list list) => int list list =

  axiom	expand_list([],_) => []

  axiom	expand_list(_,[]) => []

  rule	expand_list(xx,ys) => l1 &
	expand_list(xs,yy) => l2 &
	list_append(l1,l2) => l
	-----------------------
	expand_list(xx as (Values.INTEGER(x)::xs),yy as (y::ys))
		    => ((x::y)::l)

end

(** relation: insert_submods
 **
 ** This relation repeatedly calls `insert_submod' to incrementally
 ** insert several sub-modifications.
 **)

relation insert_submods : (Types.SubMod list, Types.SubMod list, 
			   Env.Env, Prefix.Prefix) 
	  => Types.SubMod list =

  axiom	insert_submods ([],_,_,_) => []

  rule	insert_submod (x,y,env,pre) => x' &
	insert_submods (xs,y,env,pre) => xs' &
	list_append(x', xs') => l
	-------------------------
	insert_submods (x::xs,y,env,pre) => l

end

(** relation: insert_submod
 **
 ** This relation inserts a `SubMod' into a list of unique `SubMod's,
 ** while keeping the uniqueness, merging the submod if necessary.
 **)

relation insert_submod : (Types.SubMod, Types.SubMod list,
			  Env.Env, Prefix.Prefix) 
	  => Types.SubMod list =

  axiom	insert_submod (sub,[],_,_) => [sub]

  rule	n1 = n2 &
	merge (m1,m2,env,pre) => m
	----------------------
	insert_submod (Types.NAMEMOD(n1,m1),Types.NAMEMOD(n2,m2)::tail,env,pre)
	  => (Types.NAMEMOD(n1,m)::tail)

  rule	i1 = i2 &
	merge (m1,m2,env,pre) => m
	----------------------
	insert_submod (Types.IDXMOD(i1,m1),Types.IDXMOD(i2,m2)::tail,env,pre)
	  => (Types.IDXMOD(i1,m)::tail)

  axiom	insert_submod (sub1, sub2,_,_) => sub1::sub2

end

(**
 ** - Lookup
 **)

(** relation: lookup_modification_p
 ** 
 ** This relation extracts a modification from inside another
 ** modification, using a name to look up submodifications.
 **)

relation lookup_modification_p: (Types.Mod,Absyn.Path) => Types.Mod =

  rule	lookup_comp_modification (m,n) => mod
	--------------------------------
	lookup_modification_p (m,Absyn.IDENT(n)) => mod

  rule	lookup_comp_modification (m,n) => mod &
	lookup_modification_p (mod,p) => mod'
	-------------------------------------
	lookup_modification_p (m,Absyn.QUALIFIED(n,p)) => mod'

  rule	Print.print_buf "- lookup_modification_p failed\n" 
	-----------------------
	lookup_modification_p(_,_) => fail
end

(** relation: lookup_comp_modification
 **
 ** This relation is used to look up an identifier in a modification.
 **)

relation lookup_comp_modification: (Types.Mod, Absyn.Ident) => Types.Mod =

  axiom lookup_comp_modification(Types.NOMOD,_) => Types.NOMOD

  axiom	lookup_comp_modification(Types.REDECL(_,_),_) => Types.NOMOD

  rule  lookup_comp_modification2(subs,n) => mod
	-----------------------------------
	lookup_comp_modification(Types.MOD(_,_,subs,_),n) => mod
	
  rule	Print.print_buf "# Mod.lookup_comp_modification(" &
	print_mod mod & Print.print_buf "," & Print.print_buf i &
	Print.print_buf ") failed\n" &
	print "- lookup_comp_modification failed\n" 
	--------------------
	lookup_comp_modification(mod,i) => fail

end	

(** relation: lookup_comp_modification2
 ** 
 ** This relation is just a helper to `lookup_comp_modification'.
 **)

relation lookup_comp_modification2 : (Types.SubMod list,Absyn.Ident) => Types.Mod =

  axiom lookup_comp_modification2([],_) => Types.NOMOD

  rule  n = m
	--------------------------------------
	lookup_comp_modification2(Types.NAMEMOD(n,mod)::_,m) => mod
	
  rule  lookup_comp_modification2(xs,n) => mod
	---------------------------------
	lookup_comp_modification2(x::xs,n) => mod

  rule	Print.print_buf "- lookup_comp_modification2 failed\n"
	---------------------------------------
	lookup_comp_modification2 (_,_) => fail

end

(** relation: lookup_idx_modification
 **
 ** This relation extracts modifications to an array element, using an
 ** integer to index the modification.
 **)

relation lookup_idx_modification: (Types.Mod, int) => Types.Mod =

  axiom lookup_idx_modification(Types.NOMOD,_) => Types.NOMOD

  axiom	lookup_idx_modification(Types.REDECL(_,_),_) => Types.NOMOD

  rule  lookup_idx_modification2(subs,NONE,idx) => (mod',subs') &
	merge (Types.MOD(f,each,subs',NONE),mod',[],Prefix.NOPRE) => mod'' &

	index_eqmod (eq,[idx]) => eq' &
	merge (mod'',Types.MOD(f,each,[],eq'),[],Prefix.NOPRE) => mod'''
(*	& print "lookup_idx_modificaton input :" &
	print_mod_str inmod => s & print s & print "\n" 
	& print "lookup_idx_modificaton returns :" &
	print_mod_str mod''' => s & print s & print "\n" *)
	-----------------------------------
	lookup_idx_modification(inmod as Types.MOD(f,each,subs,eq),idx) => mod'''
	
  rule	Debug.fprint("failtrace","-lookup_idx_modification(") &
	print_mod_str mod => str &
	Debug.fprint("failtrace",str) &
	Debug.fprint("failtrace",", ") &
	int_string idx => s & 
	Debug.fprint("failtrace",s) &
	Debug.fprint("failtrace",") failed\n") 
	--------------------
	lookup_idx_modification(mod,idx) => fail

end	

(** relation: lookup_idx_modification2
 **
 ** This relation does part of the job for `lookup_idx_modification'.
 **)

relation lookup_idx_modification2 : (Types.SubMod list, Types.EqMod option, int)
	  => (Types.Mod, Types.SubMod list) =

  axiom lookup_idx_modification2([],_,_) => (Types.NOMOD, [])

	(* FIXME: Redeclaration *)

  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (Types.NOMOD,subs')
	--------------------------------------
	lookup_idx_modification2(Types.IDXMOD([x],mod)::subs,eq,y)
	  => (mod,subs')
	
  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(Types.IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',Types.IDXMOD(xs,mod)::subs')

  rule  not x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(Types.IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',subs')

  rule	lookup_idx_modification3(nmod,y) => nmod' &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(Types.NAMEMOD(name,nmod)::subs,eq,y)
	  => (mod',Types.NAMEMOD(name,nmod')::subs')

  rule  lookup_idx_modification2(xs,eq,idx) => (mod,xs') 
	---------------------------------
	lookup_idx_modification2(x::xs,eq,idx) => (mod,x::xs')

  rule	Print.print_buf "- lookup_idx_modification2 failed\n"
	---------------------------------------
	lookup_idx_modification2 (_,_,_) => fail

end

(** relation: lookup_idx_modification3
 **
 ** Helper relation to lookup_idx_modification2.
 ** when looking up index of a named mod, e.g. y={1,2,3}, it should
 ** subscript the expression {1,2,3} to corresponding index.
**)
relation lookup_idx_modification3: (Types.Mod, int (* indx *)) 
	  => Types.Mod =

  axiom lookup_idx_modification3(Types.NOMOD,_) => Types.NOMOD

  axiom	lookup_idx_modification3(Types.REDECL(_,_),_) => Types.NOMOD

  rule	index_eqmod (eq,[idx]) => eq' 
	-----------------------------------
	lookup_idx_modification3(Types.MOD(f,Absyn.NON_EACH,subs,eq),idx) 
	  => Types.MOD(f,Absyn.NON_EACH,subs,eq')

  axiom	lookup_idx_modification3(Types.MOD(f,Absyn.EACH,subs,eq),idx) 
	  => Types.MOD(f,Absyn.EACH,subs,eq)
end


(** relation: index_eqmod
 **
 ** If there is an equation modification, this relation can subscript
 ** it using the provided indexing expressions.  This is used when a
 ** modification equates an array variable with an array expression.
 ** This expression will be expanded to produce one equation
 ** expression per array component.
 **)

relation index_eqmod : (Types.EqMod option, int list) => Types.EqMod option =

  axiom	index_eqmod (NONE,_) => NONE

  axiom	index_eqmod (e,[]) => e

  rule	Types.unlift_array t => t' &
	Exp.simplify Exp.ASUB(e,x) => exp &
	Values.nth_arrayelt(e_val,x) => e_val' &
	index_eqmod (SOME(Types.TYPED(exp,SOME(e_val'),Types.PROP(t',c))),xs) => e
	------------------------------------------
	index_eqmod (SOME(Types.TYPED(e,SOME(e_val),Types.PROP(t,c))),x::xs) => e

  rule	Types.unlift_array t => t' &
	Exp.simplify Exp.ASUB(e,x) => exp &
	index_eqmod (SOME(Types.TYPED(exp,NONE,Types.PROP(t',c))),xs) => e
	------------------------------------------
	index_eqmod (SOME(Types.TYPED(e,NONE,Types.PROP(t,c))),x::xs) => e
end

(**
 **
 ** - Merging
 **
 ** The merge relation merges to modifications to one. The first
 ** argument is the "outer" modification that should take precedence over
 ** the "inner" modifications.
 **
 **)

(** relation: merge
 ** 
 ** This relation merges to modificiations into one.  The first
 ** modifications takes precedence over the second.
 **)

relation merge : (Types.Mod, Types.Mod,Env.Env,Prefix.Prefix) => Types.Mod =

  axiom merge(Types.NOMOD,Types.NOMOD,_,_) => Types.NOMOD

  axiom merge(Types.NOMOD,m,_,_) => m

  axiom merge(m,Types.NOMOD,_,_) => m

	(* redeclaring same component *)
  rule	id1 = id2 &
	elab_untyped_mod(m2,env,pre) => m1' &
	elab_untyped_mod(m2,env,pre) => m2' &
	merge(m1',m2',env,pre) => m'' 
	--------------------------------------
	merge(Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,m1,bc,comment),_)]),
	      Types.REDECL(f2,[(SCode.COMPONENT(id2,_,_,_,_,_,m2,bc2,comment2),_)])
			       ,env,pre) 
	  => Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,SCode.NOMOD,bc,comment),m'')])
	  
  axiom	merge(mod as Types.REDECL(f1,els as [(SCode.COMPONENT(id1,_,_,_,_,_,_,_,_),_)]),
	      mods as Types.MOD(_,_,subs,_),env,pre) 
	(*luc_pop : this shoud return the first mod because it have been merged in merge_subs*)
	=> mod

		  
  axiom	merge(Types.MOD(_,_,subs,_),
	      Types.REDECL(f1,els as [(SCode.COMPONENT(id1,_,_,_,_,_,_,_,_),_)]),
	      env,pre)
	  => Types.MOD(false,Absyn.NON_EACH,Types.NAMEMOD(id1,Types.REDECL(f1,els))::subs,
		       NONE)

	(* When modifiers are identical *)
  rule outer = inner
	-----------------------------------------
	merge(outer,inner,_,_) => outer

  rule  Print.print_buf "# trying to modify final element\n"
	------------------------------------------
	merge(_,m as Types.MOD(true,_,_,_),_,_) => fail

  rule  merge_subs(subs1, subs2, env, pre) => subs &
	merge_eq(ass1, ass2) => ass
	----------------------------
	merge(Types.MOD(final,each,subs1,ass1), Types.MOD(false,each2,subs2,ass2),env,pre)
	  => Types.MOD(final,each,subs,ass)

 axiom	merge(outer,inner,_,_) => outer

end

(** relation: merge_subs
 ** 
 ** This relation merges to list of `Types.SubMod's.
 **)

relation merge_subs : (Types.SubMod list, Types.SubMod list, Env.Env, Prefix.Prefix)
	  => Types.SubMod list =

  axiom merge_subs(s1,[],_,_) => s1

  rule  merge_subs2(s1,s,env,pre) => (s1',s') &
	merge_subs(s1',s2,env,pre) => ss
	------------------------
	merge_subs(s1,s::s2,env,pre) => s'::ss

end

(** relation: merge_subs2
 ** 
 ** This relation helps in the merging of two lists of `Types.SubMod's.  It
 ** compares one `Types.SubMod' against a list of other `Types.SubMod's, and if
 ** there is one with the same name,  it is kept and the one `Types.SubMod'
 ** given in the second argument is discarded.
 **)

relation merge_subs2 : (Types.SubMod list, Types.SubMod, Env.Env, Prefix.Prefix)
	  => (Types.SubMod list, Types.SubMod) =

  axiom merge_subs2([],m,_,_) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & merge(m1,m2,env,pre) => m
	---------------------------
	merge_subs2(Types.NAMEMOD(n1,m1)::ss, Types.NAMEMOD(n2,m2),env,pre)
	  => (ss, Types.NAMEMOD(n1,m))

  rule  i1 = i2 & merge(m1,m2,env,pre) => m
	---------------------------
	merge_subs2(Types.IDXMOD(i1,m1)::ss, Types.IDXMOD(i2,m2),env,pre) 
	  => (ss, Types.IDXMOD(i1,m))

  rule  merge_subs2(ss, s2,env,pre) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2,env,pre) => (s1::ss',s)

end

(** relation: merge_eq
 ** 
 ** The outer modification, given in the first argument, takes
 ** precedence over the inner modifications.
 **)

relation merge_eq : (Types.EqMod option, Types.EqMod option) => Types.EqMod option =

	(* Outer assignments take precedence *)

  axiom merge_eq(e as SOME(Types.TYPED(_,_,_)), _) => e
  axiom merge_eq(e as SOME(Types.UNTYPED(_)), _) => e
  axiom merge_eq(NONE,e) => e

end

(** relation: mod_equation
 ** 
 ** This relation simply extracts the equation part of a modification.
 **)

relation mod_equation : Types.Mod => Types.EqMod option =

  axiom mod_equation Types.NOMOD => NONE
  axiom mod_equation Types.REDECL(_,_) => NONE
  axiom mod_equation Types.MOD(_,_,_,e) => e

end

(** - Printing *)
(*!ignorecode*)

(** relation: print_mod
 **
 ** This relation prints a modification. It uses a few other relation
 ** to do its stuff.
 **
 ** The relations are excluded from the report for brevity.
 **)

relation print_mod_str : Types.Mod => string =

  axiom	print_mod_str(Types.NOMOD) => "()"

  rule  Print.print_buf "(redeclare(" &
	Util.list_map(elist,Util.tuple2_1)=> elist' &
	Util.if(final,"final","") => final_str &
	Util.list_map(elist',SCode.print_element_str) => str_lst &
	Util.string_delimit_list(str_lst,", ") => str &
	Print.print_buf "))" &
	Util.string_append_list(["(redeclare(",final_str,str,"))"]) => res
	------------------------------
	print_mod_str Types.REDECL(final,elist) => res
	
  rule	Util.if(final,"final","") => final_str &
	print_subs1_str subs => s1 &
	Util.string_delimit_list(s1,",") => s1' &
	print_eqmod_str eq => s2 &
	Util.string_append_list([final_str,s1',s2]) => str
	--------------
	print_mod_str Types.MOD(final, each, subs, eq) => str 
end

(** relation: print_mod
 **
 ** Print a modifier on the Print buffer.
 **)

relation print_mod : Types.Mod => () =

rule	print_mod_str(m) => str &
	Print.print_buf str 
	-------------------
	print_mod (m) => ()
end

(** relation: print_subs1_str
 **
 ** Helper relation to print_mod_str
 **)

relation print_subs1_str : Types.SubMod list => string list =

  axiom print_subs1_str [] => []

  rule	print_sub_str x => s1  & 
	print_subs1_str xs => res
	------------------------------------
	print_subs1_str x::xs => s1::res

end

(** relation: print_sub_str
 **
 ** Helper relation to print_subs1_str
 **)

relation print_sub_str : Types.SubMod => string =

  rule  print_mod_str mod => mod_str &
	string_append(n,mod_str) => res
	------------------
	print_sub_str Types.NAMEMOD(n,mod) => res

  rule  print_subscripts_str ss => str  & print_mod_str mod => mod_str &
	string_append(str,mod_str) => res
	-------------------------------
	print_sub_str Types.IDXMOD(ss,mod) => res

end

(** relation: print_subscripts_str
 **
 ** Helper relation to print_sub_str
 **)

relation print_subscripts_str : int list => string =

axiom	print_subscripts_str([]) => "[]"

  rule	Print.print_buf "[" &
	int_string x => s & 
	print_subscripts2_str xs => str  &
	Util.string_append_list(["[",s,str,"]"]) => res
	-----------------------------------------------------
	print_subscripts_str x::xs => res
end

(** relation: print_subscripts2_str
 **
 ** Helper relation to print_subscripts_str
 **)

relation print_subscripts2_str : int list => string =

  axiom	print_subscripts2_str([]) => ""

  rule	Print.print_buf "," & int_string x => s &
	print_subscripts2_str(xs) => str &
	Util.string_append_list([",",s,str]) => res
	-----------------------
	print_subscripts2_str x::xs => res
end

(** relation: print_eqmod_str
 ** 
 ** Helper relation to print_mod_str
 **)

relation print_eqmod_str : Types.EqMod option => string =

  axiom print_eqmod_str NONE => ""

  rule  Exp.print_exp_str e  => str &
	Types.print_prop_str prop => str2 &
	Values.val_string(e_val) => e_val_str &
	Util.string_append_list([" = (typed)",str, str2,", E_VALUE:",
				 e_val_str]) => res
	-----------------------------
	print_eqmod_str SOME(Types.TYPED(e,SOME(e_val),prop)) => res

  rule  Exp.print_exp_str e  => str &
	Types.print_prop_str prop => str2 &
	Util.string_append_list([" = (typed)",str, str2]) => res
	-----------------------------
	print_eqmod_str SOME(Types.TYPED(e,NONE,prop)) => res

  rule  Dump.print_exp_str e => str &
	string_append(" =(untyped) ",str) => res
	-----------------------------
	print_eqmod_str SOME(Types.UNTYPED(e)) => res

end
