(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)



(**
 ** file:	 Ceval.rml
 ** module:      Ceval
 ** description: Constant propagation of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module handles constant propagation (or evaluation)
 ** When elaborating expressions, in the Static module, expressions are checked to 
 ** find out its type. It also checks whether the expressions are constant and the relation 
 ** ceval in this module will then evaluate the expression to a constant value, defined
 ** in the Values module.
 **
 ** Input: 
 **	Env: Environment with bindings
 **	Exp: Expression to check for constant evaluation
 **	Bool flag determines whether the current instantiation is implicit
 **	InteractiveSymbolTable is optional, and used in interactive mode,
 **	e.g. from mosh
 **	
 ** Output:
 **	Value: The evaluated value
 **     InteractiveSymbolTable: Modified symbol table
 **     Subscript list : Evaluates subscripts and generates constant expressions. 
 **)
											   
 module Ceval :
  with "Env.rml"
  with "Exp.rml"
  with "Interactive.rml"
  with "Values.rml"
  with "DAELow.rml"
		
  datatype Msg = MSG	(* Give error message *)
	     | NO_MSG   (* Do not give error message *)								   


  (** Constant evaluation of expressions *)
  relation ceval : (Env.Env, Exp.Exp, bool (*implicit*) ,
		    Interactive.InteractiveSymbolTable option, 
		    int option, (* dimensions *) 
		    Msg)
	  => (Values.Value, Interactive.InteractiveSymbolTable option)
	    
  relation ceval_list : (Env.Env, Exp.Exp list, bool (*impl*),
			 Interactive.InteractiveSymbolTable option,
			 Msg) 
	  => Values.Value list
	    
  relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list, 
			       bool, (*impl*) 
			       Msg)
	  => Exp.Subscript list

  relation is_known_external_func:( string, string option) => ()   
          
  relation build_model:(Env.Env, 
		        Exp.Exp, (* component ref for model *)
		        Interactive.InteractiveSymbolTable,
                        Msg)
          => (string, (*classname*)
              string, (*method*)
              Interactive.InteractiveSymbolTable, 
              string) (*initfilename*) 
          
  relation translate_model: (Env.Env, 
			     Exp.ComponentRef, (* component ref for model *)
			     Interactive.InteractiveSymbolTable,
                             Msg,
                             Exp.Exp)
          
	  => (Values.Value, 
              Interactive.InteractiveSymbolTable,
              DAELow.DAELow,
              string list (*libs *)) 
	  

 end


with "SimCodegen.rml"
with "Static.rml"
with "Print.rml" 
with "Types.rml"
with "ModUtil.rml"
with "System.rml"
with "Absyn.rml"
with "SCode.rml"
with "Inst.rml"
with "Lookup.rml"
with "Dump.rml"
with "DAE.rml"
with "Debug.rml"
with "Util.rml"
with "ClassInf.rml"
with "RTOpts.rml"
with "Parser.rml"
with "Prefix.rml"
with "Codegen.rml"
with "ClassLoader.rml"
with "Derive.rml"
with "Connect.rml"
with "Error.rml"
with "ErrorExt.rml"
with "Settings.rml"


(** relation: ceval_builtin
 **
 ** Helper for ceval. Parts for builtin calls are moved here, for readability.
 ** See ceval for documentation.
 **
 ** inputs: (Env.Env, Exp.Exp, bool /* impl */,
			  Interactive.InteractiveSymbolTable option, 
			  int option,
			  Msg) 
 ** outputs: (Values.Value, Interactive.InteractiveSymbolTable option)
 ** 
 ** NOTE:    It's ok if ceval_builtin fails. Just means the call wasn't a builtin function 
 **)
relation ceval_builtin : (Env.Env, Exp.Exp, bool,
			  Interactive.InteractiveSymbolTable option, 
			  int option,
			  Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

  rule	(* Handle size separately *)
	ceval_builtin_size(env,exp,dim,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.SIZE(exp,SOME(dim)),impl,st,_,msg) => (v,st) 	

  rule	ceval_builtin_size_matrix(env,exp,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.SIZE(exp,NONE),impl,st,_,msg) => (v,st) 	

  rule	ceval_builtin_handler id => handler &
	handler(env,args,impl,st,msg) => (v,st)
	-----------------------------------------
	ceval_builtin (env,Exp.CALL(Absyn.IDENT(id),args,_,builtin (* buildin: as true *)),impl,st,_,msg) => (v,st)

  rule	ceval_list(env,expl,impl,st,msg) => vallst &
	ceval_call_function (env,e,vallst,msg) => newval
	-------------------------------------------------------
	ceval_builtin (env, e as Exp.CALL(funcpath,expl,_,builtin as true),impl,st as NONE,_,msg) => (newval,st)

end


(** relation: ceval_builtin_handler
 **
 ** This relation dispatches builtin functions and operators to a dedicated
 ** relation that evaluates that particular relation.
 ** It takes an identifier as input and returns a relation that evaluates that
 ** function or operator.
 **
 ** inputs: Absyn.Ident  /* operator/function name */
 ** outputs: ((Env.Env, 
		Exp.Exp list, 
		bool, 
		Interactive.InteractiveSymbolTable option,
		Msg) => (Values.Value, Interactive.InteractiveSymbolTable option))
 **
 ** NOTE:   size handled specially. see ceval_builtin:
            removed: axiom	ceval_builtin_handler "size" => ceval_builtin_size
 **)
 relation ceval_builtin_handler : Absyn.Ident  
	  =>  ((Env.Env, 
		Exp.Exp list, 
		bool, 
		Interactive.InteractiveSymbolTable option,
		Msg)
	       => (Values.Value, Interactive.InteractiveSymbolTable option)) =

  axiom ceval_builtin_handler "floor" => ceval_builtin_floor
  axiom ceval_builtin_handler "ceil" => ceval_builtin_ceil
  axiom ceval_builtin_handler "abs" => ceval_builtin_abs
  axiom ceval_builtin_handler "sqrt" => ceval_builtin_sqrt
  axiom ceval_builtin_handler "div" => ceval_builtin_div
  axiom ceval_builtin_handler "sin" => ceval_builtin_sin
  axiom ceval_builtin_handler "cos" => ceval_builtin_cos
  axiom ceval_builtin_handler "asin" => ceval_builtin_asin
  axiom ceval_builtin_handler "acos" => ceval_builtin_acos
  axiom ceval_builtin_handler "atan" => ceval_builtin_atan
  axiom ceval_builtin_handler "tan" => ceval_builtin_tan
  axiom ceval_builtin_handler "integer" => ceval_builtin_integer
  axiom ceval_builtin_handler "mod" => ceval_builtin_mod
  axiom	ceval_builtin_handler "max" => ceval_builtin_max
  axiom ceval_builtin_handler "min" => ceval_builtin_min 
  axiom ceval_builtin_handler "rem" => ceval_builtin_rem
  axiom	ceval_builtin_handler "diagonal" => ceval_builtin_diagonal
  axiom ceval_builtin_handler "transpose" => ceval_builtin_transpose	 
  axiom	ceval_builtin_handler "differentiate" => ceval_builtin_differentiate
  axiom	ceval_builtin_handler "simplify" => ceval_builtin_simplify
  axiom ceval_builtin_handler "sign" => ceval_builtin_sign
  axiom	ceval_builtin_handler "exp" => ceval_builtin_exp 
  axiom	ceval_builtin_handler "noEvent" => ceval_builtin_noevent
  axiom	ceval_builtin_handler "cardinality" => ceval_builtin_cardinality 
  axiom	ceval_builtin_handler "cat" => ceval_builtin_cat
  axiom ceval_builtin_handler "identity" => ceval_builtin_identity

  axiom ceval_builtin_handler "promote" => ceval_builtin_promote

  rule	Debug.fprint("ceval", "No ceval_builtin_handler found for: ") &
	Debug.fprintln("ceval", id)
	--------------------------
	ceval_builtin_handler id => fail

end


(** relation: ceval
 **
 ** This relation is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **
 ** The third argument indicates whether the evaluation is performed in the
 ** interactive environment (implicit instantiation), in which case function
 ** calls are evaluated.
 **
 ** The last argument is an optional dimension.
 ** 
 ** inputs: (Env.Env, Exp.Exp, bool /* impl */,
			Interactive.InteractiveSymbolTable option, 
			int option,
			Msg) 
 ** outputs: (Values.Value, Interactive.InteractiveSymbolTable option)
 **)
 relation ceval : (Env.Env, Exp.Exp, bool,
		   Interactive.InteractiveSymbolTable option, 
		   int option,
		   Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

  axiom	ceval (_,Exp.ICONST(x),_,st,_,_) => (Values.INTEGER(x),st)
  axiom	ceval (_,Exp.RCONST(x),_,st,_,_) => (Values.REAL(x),st)
  axiom ceval (_,Exp.SCONST(x),_,st,_,_) => (Values.STRING(x),st)
  axiom ceval (_,Exp.BCONST(x),_,st,_,_) => (Values.BOOL(x),st)
  axiom ceval (_,Exp.END,_,st,SOME(dim),_)  => (Values.INTEGER(dim), st)

  rule	Error.add_message(Error.END_ILLEGAL_USE_ERROR,[])
	 --------------------------------------
	 ceval (_,Exp.END,_,st,NONE,MSG) => fail

  axiom	ceval (_,Exp.END,_,st,NONE,NO_MSG) => fail
         
  rule	ceval_ast_exp(env,exp,impl,st,msg) => exp'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_exp(env,exp,impl,st,msg) => exp'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_elt(env,elt,impl,st,msg) => elt'
	 --------------------------------------
	 ceval (env,Exp.CODE(Absyn.C_ELEMENT(elt),_),impl,st,_,msg) 
	  => (Values.CODE(Absyn.C_ELEMENT(elt')),st)

  axiom	ceval(env, Exp.CODE(c,_),_,st,_,_) => (Values.CODE(c),st)

  rule	ceval_list (env,es,impl,st,msg) => es' &
	 list_length es' => l
	 ------------------------------
	 ceval (env,Exp.ARRAY(_,_,es),impl,st,_,msg) => (Values.ARRAY(es'),st)

  rule	ceval_matrixelt(env,expll,impl,msg) => elts
	 ------------------------------
	 ceval (env, Exp.MATRIX(_,_,expll),impl,st,_,msg) 
	  => (Values.ARRAY(elts),st)

  rule    (* When in interactive mode, always evalutate crefs, i.e non-implicit
	   * mode..*)
	 ceval_cref(env,c,false,msg) => v
	 ---------------------------
	 ceval (env,Exp.CREF(c,_),impl as false,SOME(st),_,msg) 
	  => (v,SOME(st)) 

  rule	ceval_cref (env,c,impl,msg) => v
	 ---------------------------
	 ceval (env,Exp.CREF(c,_),impl,st,_,msg) => (v,st) 

  rule	ceval_builtin (env, exp, impl, st, dim,msg) => (v, st')
	 ---------------------------------------------------
	 ceval (env,exp,impl,st,dim,msg) => (v,st') 	

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') & 
         int_real(lhv) => lhvr &
         int_real(rhv) => rhvr &
         real_pow(lhvr,rhvr) => resr &
         real_int(resr) => res 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.INT), rh),impl,st,dim,msg) 
	  => (Values.INTEGER(res),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') & 
         int_real(rhv) => rhvr &
         real_pow(lhv,rhvr) => resr
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') & 
         int_real(lhv) => lhvr &
         real_pow(lhvr,rhv) => resr 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')

  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') & 
 	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') & 
         real_pow(lhv,rhv) => resr 
	 ------------------------
 	 ceval (env, Exp.BINARY(lh, Exp.POW(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(resr),st'')

	 (* Call functions *) 
	 (* FIXME: functions are always generated. Put back the check
	  and write another rule for the false case that generates the function *)
  rule	ceval_list(env,expl,impl,st,msg) => vallst &
	 ceval_call_function (env,e,vallst,msg) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(funcpath,expl,_,builtin),impl,st,_,msg) 
	  => (newval,st)
	 
  axiom	ceval (env, e as Exp.CALL(_,_,_,_),impl as false,NONE,_,NO_MSG) => fail
	 	 
  rule	ceval_interactive_functions(env,e,st,msg) => (value,st)
	 -------------------------------------
	 ceval (env, e as Exp.CALL(_,_,_,_),impl as true, SOME(st),_,msg) 
	  => (value,SOME(st))
	 
  rule	(* Call of record constructors, etc., i.e. functions that can be 
	 constant propagated. *)
	 ceval_list(env,expl,impl,st,msg) => vallst &
	 ceval_function(env,func,vallst,impl,msg) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(func,expl,_,_),impl as true,st as SOME(_),_,msg) 
	  => (newval,st)
	   
  rule	(* Call externally implemented functions. *) 
	 Static.is_function_in_cflist(cflist,func) => true &
	 ceval_list(env,expl,impl,st,msg) => vallst &
	 ModUtil.path_string2(func,"_") => funcstr &
	 string_append(funcstr,"_in.txt") => infilename &
	 string_append(funcstr,"_out.txt") => outfilename &
	 Values.write_to_file_as_args(vallst,infilename)  &
	 System.execute_function(funcstr) &
	 System.read_values_from_file(outfilename) => newval
	 -------------------------------------------------------
	 ceval (env, e as Exp.CALL(func,expl,_,_),impl as true,st as SOME(Interactive.SYMBOLTABLE(p,_,_,_,cflist)),_,msg) => (newval,st)
	 
	 (** Strings **)
  rule  ceval (env, lh, impl,st, NONE,msg) => (Values.STRING(lhv),_) &
	ceval (env, rh, impl,st,NONE,msg) => (Values.STRING(rhv),_) &
	 string_append(lhv,rhv) => str
	 -----------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.STRING), rh),impl,st,_,msg)
	  => (Values.STRING(str),st)
	   
	   (**  Numerical *)
  rule	ceval (env, lh, impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env, rh, impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_add(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh),impl,st,dim,msg)
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.ARRAY(vlst1),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(vlst2),st'') &
	 Values.add_elementwise_arrayelt(vlst1, vlst2) => reslst
	 -------------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD_ARR(_),rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(vlst2),st'') &
	 Values.sub_elementwise_arrayelt(vlst1, vlst2) => reslst
	 -------------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB_ARR(_),rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	 
  rule	ceval (env,lh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.mult_scalar_arrayelt(sval,aval) => reslst
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_ARRAY(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.mult_scalar_arrayelt(sval,aval) => reslst
	 ------------------------------------------------
ceval (env, Exp.BINARY(lh, Exp.MUL_ARRAY_SCALAR(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (sval,st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(aval),st'') &
	 Values.div_arrayelt_scalar(sval,aval) => reslst
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.DIV_ARRAY_SCALAR(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(reslst),st'')
	   
  rule	ceval (env,rh,impl,st,dim,msg) => (Values.ARRAY(rhvals),st') &
	 ceval (env,lh,impl,st',dim,msg) => (Values.ARRAY(lhvals),st'') &
	 Values.mult_scalar_product(rhvals,lhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {{..}..{..}} * {...} *)
	 ceval (env,lh,impl,st,dim,msg) 
	  => (Values.ARRAY(lhvals as (elt1::_)),st') &
	 ceval (env,rh,impl,st',dim,msg) 
	  => (Values.ARRAY(rhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => false &
	 Values.mult_scalar_product(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {...} * {{..}..{..}} *)
	 ceval (env,rh,impl,st,dim,msg) 
	  => (Values.ARRAY(rhvals as (elt1::_)),st') &
	 ceval (env,lh,impl,st',dim,msg) 
	  => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => false &
	 Values.mult_scalar_product(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (res,st'')
	 
  rule	(* {{..}..{..}} * {{..}..{..}} *)
	 ceval (env,rh,impl,st,dim,msg) 
	  => (Values.ARRAY(rhvals as (elt1::_)),st') &
	   ceval (env,lh,impl,st',dim,msg) 
	  => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	 Values.is_array(elt1) => true &
	 Values.is_array(elt2) => true &
	 Values.mult_matrix(lhvals,rhvals) => res
	 ------------------------------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim,msg) 
	  => (Values.ARRAY(res),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_add(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh),impl,st,dim,msg) 
	  => (Values.INTEGER(sum),st'')

	   (**)
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_sub(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env, rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_sub(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh),impl,st,dim,msg)
	  => (Values.INTEGER(sum),st'') 

	   (**)
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_mul(lhv, rhv) => sum
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(sum),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 real_div(lhv, rhv) => div 
	 -------------------------
	 ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim,msg) 
	  => (Values.REAL(div),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.REAL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.REAL(rhv),st'') &
	 not real_div(lhv,rhv) => _ &
	 Exp.print_exp_str lh => lh_str &
	 Exp.print_exp_str rh => rh_str &
	 Error.add_message(Error.DIVISION_BY_ZERO,[lh_str,rh_str]) 
	 -------------------------
ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim,msg) 
	  => fail
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.INTEGER(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.INTEGER(rhv),st'') &
	 int_mul(lhv, rhv) => sum
	 ------------------------
	 ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh),impl,st,dim,msg)
	  => (Values.INTEGER(sum),st'')

	  (**)
	  (* unary minus of array*)
  rule	ceval (env,exp,impl,st,dim,msg) => (Values.ARRAY(arr),st') &
	Util.list_map(arr,Values.value_neg) => arr'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UMINUS_ARR(_), exp),impl,st,dim,msg)
	  => (Values.ARRAY(arr'),st')
	   
  rule	ceval (env,exp,impl,st,dim,msg) => (v,st') &
	 Values.value_neg (v) => v'
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UMINUS(_), exp),impl,st,dim,msg)
	  => (v',st')
	  
  rule	ceval (env,exp,impl,st,dim,msg) => (v,st') 
	 ---------------------
	 ceval (env, Exp.UNARY(Exp.UPLUS(_), exp),impl,st,dim,msg)
	  => (v,st')
	   
	   (**  Logical *)
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.BOOL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.BOOL(rhv),st'') &
	 bool_and(lhv, rhv) => x
	 ------------------------
	 ceval (env, Exp.LBINARY(lh, Exp.AND, rh),impl,st,dim,msg)
	  => (Values.BOOL(x),st'')
	   
  rule	ceval (env,lh,impl,st,dim,msg) => (Values.BOOL(lhv),st') &
	 ceval (env,rh,impl,st',dim,msg) => (Values.BOOL(rhv),st'') &
	 bool_or(lhv, rhv) => x
	 ------------------------
	 ceval (env, Exp.LBINARY(lh, Exp.OR, rh),impl,st,dim,msg)
	  => (Values.BOOL(x),st'')
	   
  rule	ceval (env,e,impl,st,dim,msg) => (Values.BOOL(b),st') &
	 bool_not(b) => b'
	 -----------------
	 ceval (env, Exp.LUNARY(Exp.NOT, e),impl,st,dim,msg) 
	  => (Values.BOOL(b'),st')
	 
	 (**  Relations *)
  rule	ceval (env,lhs,impl,st,dim,msg) => (lhs',st') &
	 ceval (env,rhs,impl,st',dim,msg) => (rhs',st'') &
	 ceval_relation (lhs',relop,rhs') => v
	 -------------------------------------
	 ceval (env, Exp.RELATION(lhs,relop,rhs),impl,st,dim,msg) 
	  => (v, st'')
	 
	 (**)
  rule	ceval (env,start,impl,st,dim,msg) => (Values.INTEGER(start'),st') &
	 ceval (env,stop,impl,st',dim,msg) => (Values.INTEGER(stop'),st'') &
	 ceval_range(start', 1, stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.INT,start, NONE, stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.INTEGER(start'),st') &
	 ceval (env,step,impl,st',dim,msg) => (Values.INTEGER(step'),st'') &
	 ceval (env,stop,impl,st'',dim,msg) => (Values.INTEGER(stop'),st''') &
	 ceval_range(start', step', stop') => arr 
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.INT,start, SOME(step), stop),impl,st,dim,msg)
	  => (Values.ARRAY(arr),st''')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.REAL(start'),st') &
	 ceval (env,stop,impl,st',dim,msg) => (Values.REAL(stop'),st'') &
	 real_sub(stop',start') => diff &
	 int_real 1 => step & (* bug in rml, 1.0 => 0.0 in cygwin  *)
	 ceval_range_real(start', step, stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.REAL,start, NONE, stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st'')
	   
  rule	ceval (env,start,impl,st,dim,msg) => (Values.REAL(start'),st') &
	 ceval (env,step,impl,st',dim,msg) => (Values.REAL(step'),st'') &
	 ceval (env,stop,impl,st'',dim,msg) => (Values.REAL(stop'),st''') &
	 ceval_range_real(start', step', stop') => arr
	 -------------------------------------------
	 ceval (env, Exp.RANGE(Exp.REAL,start, SOME(step), stop),impl,st,dim,msg) 
	  => (Values.ARRAY(arr),st''')
	   
  rule	ceval (env,e,impl,st,dim,msg) => (Values.INTEGER(i),st') &
	 int_real i => r
	 ---------------
	 ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim,msg) 
	  => (Values.REAL(r),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(ivals),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,ivals) => rvals
	 ----------------------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim,msg) 
	  => (Values.ARRAY(rvals),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT, Exp.REAL, vallst) => vallst'
	 --------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.ARRAY(Exp.INT,_,expl)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	 ---------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.RANGE(Exp.INT,_,_,_)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')
	 
  rule	ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vallst),st') &
	 Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	 ---------------------------------------
	 ceval (env, Exp.CAST(Exp.REAL,e as Exp.MATRIX(Exp.INT,_,_)),
		impl,st,dim,msg) 
	  => (Values.ARRAY(vallst'),st')
	 
  rule	(* Ifexp, true branch *)
	 ceval (env,b,impl,st,dim,msg) 
	  => (Values.BOOL(true),st') &
	 ceval (env,e1,impl,st',dim,msg) 
	  => (v,st'')
	 ------------------------------------
	 ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim,msg) 
	  => (v,st'')

  rule	(* Ifexp, false branch *)
	 ceval (env,b,impl,st,dim,msg) => (Values.BOOL(false),st') &
	 ceval (env,e2,impl,st',dim,msg) => (v,st'')
	 ------------------------------------
	 ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim,msg) 
	  => (v,st'')
	   
  rule	(* asub *)
	 ceval (env,e,impl,st,dim,msg) => (Values.ARRAY(vals),st') &
	 int_sub(indx,1) => indx' &
	 list_nth(vals,indx') => v
	 -----------------------
	 ceval (env, Exp.ASUB(e,indx),impl,st,dim,msg) => (v,st')
	 
        (* (v,st) *)
  rule	Print.print_buf "#-- ceval reduction\n"
	 ---------------------------------------
	 ceval (env, Exp.REDUCTION(p,exp,iter,iterexp),impl,st,dim,MSG)
	  => fail 
	   
        (* (v,st) *)
  axiom	ceval (env, Exp.REDUCTION(p,exp,iter,iterexp),impl,st,dim,NO_MSG)
	  => fail 


           (*   ceval can apparently fa-il and that is ok, catched by other rules...*)
  rule	Debug.fprint("failtrace", "- ceval failed: ")
	 & Exp.print_exp_str e => str 

	 & Debug.fprint("failtrace",str) 
	 & Debug.fprint("failtrace", "\n")
	 (*& Debug.fprint("failtrace", " Env:" )
	  & Debug.fcall("failtrace",Env.print_env, env) *)
	 -----------------------------------------------------
	 ceval (env,e,_,_,_,MSG) => fail
	 
end


(** relation: ceval_call_function
 **
 ** This relation evaluates CALL expressions, i.e. function calls.
 ** They are currently evaluated by generating code for the function and
 ** then write input to file and execute the generated code. Finally, the
 ** result is read back from file and returned.
 ** 
 ** inputs:(Env.Env, 
			Exp.Exp, /* the call expression*/
			Values.Value list, /* input parameter values*/
			Msg) /* Should error messages be printed. */
 ** outputs: Values.Value /* resulting value */
 **)
relation ceval_call_function : (Env.Env, 
				Exp.Exp, 
				Values.Value list, 
				Msg) 
				 => Values.Value =

	(* External functions that are "known" should be evaluated without
	 * compilation, e.g. all math functions *)
  rule	ceval_known_external_funcs(env,funcpath,vallst,msg) => newval
	-------------------------------------------------------
	ceval_call_function (env, e as Exp.CALL(funcpath,expl,_,builtin), 
			     vallst,msg) => newval

        (* Call functions in non-interactive mode. *) 
	(* FIXME: functions are always generated. Put back the check
	 and write another rule for the false case that generates the function *)
  rule	(* Static.is_function_in_cflist(cflist,funcpath) => true & *)
	ceval_generate_function(env, funcpath) &
	ModUtil.path_string2(funcpath,"_") => funcstr &
	string_append(funcstr,"_in.txt") => infilename &
	string_append(funcstr,"_out.txt") => outfilename &
	Values.write_to_file_as_args(vallst,infilename)  &
	System.execute_function(funcstr) &
	System.read_values_from_file(outfilename) => newval
	-------------------------------------------------------
	ceval_call_function (env, e as Exp.CALL(funcpath,expl,_,builtin), 
			     vallst,msg) => newval
	
  rule	Debug.fprint("failtrace", "- ceval_call_function failed: ")
	& Exp.print_exp_str e => str 
	& Debug.fprintln("failtrace",str)
	-----------------------------------------------------
	ceval_call_function (env,e,_,_) => fail
	
end


(** relation: ceval_known_external_funcs
 **
 ** Evaluates external functions that are known, e.g. all math functions.
 **)
relation ceval_known_external_funcs: (Env.Env, 
				      Absyn.Path, 
				      Values.Value list,
				      Msg) => Values.Value =

  rule	Lookup.lookup_class(env,funcpath,false) => (cdef,env') &
	let SCode.CLASS(fid,_,_,SCode.R_EXT_FUNCTION,SCode.PARTS(_,_,_,_,_,extdecl)) = cdef &
	let SOME(Absyn.EXTERNALDECL(id,lan,out,args,_)) = extdecl &
	is_known_external_func(fid,id) &
	ceval_known_external_funcs2(fid,id,vals,msg) => res
	-----------------------------
	ceval_known_external_funcs(env,funcpath,vals,msg) => res
end


(** relation is_known_external_func
 **
 ** Succeds if external function name is "known", i.e. no compilation
 ** required.
 **
 ** NOTE:    adrpo changed the inputs to not include SCode and Absyn in the
             public impots
 **
 ** inputs:  (SCode.Ident /* string */, Absyn.Ident option /* string option */) 
 ** outputs: ()
 **)
relation is_known_external_func:(string, string option) => () =

  axiom	is_known_external_func("acos",SOME("acos"))
  axiom	is_known_external_func("asin",SOME("asin"))
  axiom	is_known_external_func("atan",SOME("atan"))
  axiom	is_known_external_func("atan2",SOME("atan2"))
  axiom	is_known_external_func("cos",SOME("cos"))
  axiom	is_known_external_func("cosh",SOME("cosh"))
  axiom	is_known_external_func("exp",SOME("exp"))
  axiom	is_known_external_func("log",SOME("log"))
  axiom	is_known_external_func("log10",SOME("log10"))
  axiom	is_known_external_func("sin",SOME("sin"))
  axiom	is_known_external_func("sinh",SOME("sinh"))
  axiom	is_known_external_func("tan",SOME("tan"))
  axiom	is_known_external_func("tanh",SOME("tanh"))
end


(** relation: ceval_known_external_funcs2
 ** author: PA
 **
 ** Helper relation to ceval_known_external_funcs, does the evaluation.
 **)
relation ceval_known_external_funcs2: (SCode.Ident, 
				       Absyn.Ident option,
				       Values.Value list,
				       Msg) => Values.Value =

  rule	System.acos rv => rv' 
	--------------------------
	ceval_known_external_funcs2("acos",SOME("acos"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.asin rv => rv' 
	--------------------------
	ceval_known_external_funcs2("asin",SOME("asin"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.atan(rv) => rv' 
	--------------------------
	ceval_known_external_funcs2("atan",SOME("atan"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.atan2(rv1,rv2) => rv' 
	--------------------------
	ceval_known_external_funcs2("atan2",SOME("atan2"),[Values.REAL(rv1),
							   Values.REAL(rv2)
							   ],_) 
	  => Values.REAL(rv')

  rule	real_cos(rv) => rv'
	--------------------------
	ceval_known_external_funcs2("cos",SOME("cos"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.cosh(rv) => rv'
	--------------------------
	ceval_known_external_funcs2("cosh",SOME("cosh"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	real_exp(rv) => rv'
	--------------------------
	ceval_known_external_funcs2("exp",SOME("exp"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.log(rv) => rv' 
	--------------------------
	ceval_known_external_funcs2("log",SOME("log"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.log10(rv) => rv' 
	--------------------------
	ceval_known_external_funcs2("log10",SOME("log10"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	real_sin(rv) => rv'
	--------------------------
	ceval_known_external_funcs2("sin",SOME("sin"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.sinh(rv) => rv'
	--------------------------
	ceval_known_external_funcs2("sinh",SOME("sinh"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	real_sin rv => sv &
	real_cos rv => cv &
	real_div(sv,cv) => rv' 
	--------------------------
	ceval_known_external_funcs2("tan",SOME("tan"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')

  rule	System.tanh(rv) => rv' 
	--------------------------
	ceval_known_external_funcs2("tanh",SOME("tanh"),[Values.REAL(rv)],_) 
	  => Values.REAL(rv')
end       


(** relation: ceval_function 
 ** 
 ** For constant evaluation of functions returning a single value. For now only
 ** record constructors.
 ** 
 ** inputs: (Env.Env, Absyn.Path, Values.Value list, 
			  bool /*impl*/, Msg ) 
 ** outputs: Values.Value =
 **)
relation ceval_function: (Env.Env, Absyn.Path, Values.Value list, 
			  bool, Msg ) 
	  => Values.Value =

	  (* For record constructors *)
  rule	Lookup.lookup_record_constructor_class(env,funcname) => (_,_) &
	Lookup.lookup_class(env,funcname,false) => (c,env') &
	SCode.component_names(c) => compnames &
	Types.values_to_mods(vallst,compnames) => mod &
	Inst.inst_class(env',mod,Prefix.NOPRE,Connect.empty_set,c,[],impl,Inst.TOP_CALL)
	  => (dae,_,_,_,_) &
	DAE.dae_to_record_value(funcname,dae,impl) => value  
	----------------------
	ceval_function(env,funcname,vallst,impl,msg) => value

  rule	Debug.fprint("failtrace", "ceval_function: Don't know what to do. impl was always false before:")
	& Absyn.path_string funcname => s
	& Debug.fprintln("failtrace", s)
	----------------------------------------------------------------------
	ceval_function(env,funcname,vallst,impl as true,msg) => fail
end


(** relaton: ceval_ast_exp
 **
 ** Part of meta-programming using CODE.
 **
 ** This relation evaluates a piece of Expression AST, replacing Eval(variable)
 ** with the value of the variable, given that it is of type "Expression".
 ** 
 ** Example: y = Code(1 + x)
 **          2 + 5 * ( x + Eval(y) )  =>   2 + 5 * ( x + 1 + x )
 **
 ** inputs:  (Env.Env, Absyn.Exp, 
			  bool /* impl */, 
			  Interactive.InteractiveSymbolTable option,
			  Msg)
 ** outputs: Absyn.Exp 
 **)
 relation ceval_ast_exp: (Env.Env, Absyn.Exp, 
			  bool, 
			  Interactive.InteractiveSymbolTable option,
			  Msg)
	  => Absyn.Exp =

  axiom	ceval_ast_exp (_,e as Absyn.INTEGER(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.REAL(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.CREF(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.STRING(_),_,_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.BOOL(_),_,_,_) => e

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.BINARY(e1, op, e2),impl,st,msg) 
	  => Absyn.BINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st,msg) => e'
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.UNARY(op, e),impl,st,msg) 
	  => Absyn.UNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.LBINARY(e1, op, e2),impl,st,msg) 
	  => Absyn.LBINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st,msg) => e'
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.LUNARY(op, e),impl,st,msg) 
	  => Absyn.LUNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp (env,e2,impl,st,msg) => e2' 
	 ---------------------------------
	 ceval_ast_exp (env, Absyn.RELATION(e1, op, e2),impl,st,msg) 
	  => Absyn.RELATION(e1',op,e2')

  rule	ceval_ast_exp(env,cond,impl,st,msg)=> cond' &
	 ceval_ast_exp(env,then,impl,st,msg)=> then' &
	 ceval_ast_exp(env,else,impl,st,msg)=> else' &
	 ceval_ast_expexp_list(env,nest,impl,st,msg) =>  nest'
	 -----------------------------------------------
	 ceval_ast_exp (env, Absyn.IFEXP(cond,then,else,nest),impl,st,msg)
	  => Absyn.IFEXP(cond',then',else',nest')

  rule	Static.elab_exp(env,e,impl,st) => (e',_,_) &
	 ceval(env,e',impl,st,NONE,msg) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp)),_) 
	 ----------------------------------
	 ceval_ast_exp (env, 
		        Absyn.CALL(Absyn.CREF_IDENT("Eval",[]),
				   Absyn.FUNCTIONARGS([e],[])),impl,st
			,msg)
	  => exp
  axiom	ceval_ast_exp(env,e as Absyn.CALL(cr,fa),_,_,msg) => e

  rule	ceval_ast_exp_list(env,expl,impl,st,msg) => expl'
	 ---------------------------------------------
	 ceval_ast_exp(env,Absyn.ARRAY(expl),impl,st,msg) 
	  => Absyn.ARRAY(expl')

  rule	ceval_ast_exp_list_list(env,expl,impl,st,msg) => expl'
	 --------------------------------------------------
	 ceval_ast_exp(env,Absyn.MATRIX(expl),impl,st,msg) 
	  => Absyn.MATRIX(expl')
	   
  rule	ceval_ast_exp(env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp(env,e2,impl,st,msg) => e2' &
	 ceval_ast_exp(env,e3,impl,st,msg) => e3' 
	 ------------------------------------
	 ceval_ast_exp(env,Absyn.RANGE(e1,SOME(e2),e3),impl,st,msg) 
	  => Absyn.RANGE(e1',SOME(e2'),e3')

  rule	ceval_ast_exp(env,e1,impl,st,msg) => e1' &
	 ceval_ast_exp(env,e3,impl,st,msg) => e3'
	 ------------------------------------
	 ceval_ast_exp(env,Absyn.RANGE(e1,NONE,e3),impl,st,msg) 
	  => Absyn.RANGE(e1',NONE,e3')
           
  rule	ceval_ast_exp_list(env,expl,impl,st,msg) => expl'
	 ---------------------------------------------
	 ceval_ast_exp(env,Absyn.TUPLE(expl),impl,st,msg) 
	  => Absyn.TUPLE(expl')

  axiom	ceval_ast_exp(env,Absyn.END,_,_,msg) => Absyn.END

  axiom	ceval_ast_exp(env,e as Absyn.CODE(_),_,_,msg) => e
 end


(** relation: ceval_ast_exp_list
 ** 
 ** List version of ceval_ast_exp
 ** 
 ** inputs: (Env.Env, Absyn.Exp list, 
			 bool /* impl */ , Interactive.InteractiveSymbolTable option,
			 Msg) 
 ** outputs: (Absyn.Exp list)
 **)
relation ceval_ast_exp_list: (Env.Env, Absyn.Exp list, 
			      bool, Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Absyn.Exp list) =

  axiom	ceval_ast_exp_list (env, [],_,_,msg) => []

  rule	ceval_ast_exp(env,e,impl,st,msg) => e' &
	ceval_ast_exp_list(env,es,impl,st,msg) => res
	-----------------------------------------
	ceval_ast_exp_list(env,e::es,impl,st,msg) 
	  => e::res
end


(** relation: ceval_ast_exp_list_list
 ** 
 ** inputs: (Env.Env, Absyn.Exp list list, 
			 bool /* impl */, 
			 Interactive.InteractiveSymbolTable option,
			 Msg) 
 ** outputs: (Absyn.Exp list list)
 **)
relation ceval_ast_exp_list_list: (Env.Env, Absyn.Exp list list, 
			           bool, 
				   Interactive.InteractiveSymbolTable option,
				   Msg)
	  => (Absyn.Exp list list) =

  axiom	ceval_ast_exp_list_list(env, [], _,_,msg) => []

  rule	ceval_ast_exp_list(env,e,impl,st,msg) => e' &
	ceval_ast_exp_list_list(env,es,impl,st,msg) => res
	----------------------------------------------
	ceval_ast_exp_list_list(env,e::es,impl,st,msg) 
	  => e::res
end


(** relation: ceval_ast_expexp_list
 **
 ** For IFEXP
 **)
relation ceval_ast_expexp_list: (Env.Env, (Absyn.Exp*Absyn.Exp) list, 
				 bool, 
				 Interactive.InteractiveSymbolTable option,
				 Msg) 
	  => (Absyn.Exp*Absyn.Exp) list =

  axiom	ceval_ast_expexp_list(_,[],_,_,msg) => []

  rule	ceval_ast_exp(env,e1,impl,st,msg)=> e1' &
	ceval_ast_exp(env,e2,impl,st,msg)=> e2' &
	ceval_ast_expexp_list(env,xs,impl,st,msg) => res
	-------------------------------------
	ceval_ast_expexp_list(env,(e1,e2)::xs,impl,st,msg) 
	  => ((e1',e2')::res)
end


(** relation: ceval_ast_elt
 **
 ** Evaluates an ast constructor for Element nodes, e.g. 
 ** Code(parameter Real x=1;)
 **
 ** inputs:  (Env.Env, Absyn.Element, 
			 bool /* impl */, 
			 Interactive.InteractiveSymbolTable option,
			 Msg)
 ** outputs: (Absyn.Element)
 **)
relation ceval_ast_elt: (Env.Env, Absyn.Element, 
			 bool, 
			 Interactive.InteractiveSymbolTable option,
			 Msg)
	  => (Absyn.Element) =

  rule	ceval_ast_citems(env,citems,impl,st,msg) => citems'
	-----------------------------------------------
	ceval_ast_elt (env, 
	               Absyn.ELEMENT(f,r,io,id,
	                 Absyn.COMPONENTS(attr,tp,citems),
	                 info as Absyn.INFO(file,isReadOnly,sline,scolumn,eline,ecolumn),c),
		       impl,st,msg)
	  => (Absyn.ELEMENT(f,r,io,id,Absyn.COMPONENTS(attr,tp,citems'),info,c))
end


(** relation: ceval_ast_citems
 **
 ** Helper relation to ceval_ast_elt.
 **
 ** inputs: (Env.Env, Absyn.ComponentItem list, 
			 bool /* impl */, 
			 Interactive.InteractiveSymbolTable option,
			 Msg)
 ** outputs: Absyn.ComponentItem list
 **)
relation ceval_ast_citems: (Env.Env, Absyn.ComponentItem list, 
			    bool, 
			    Interactive.InteractiveSymbolTable option,
			    Msg)
	  => Absyn.ComponentItem list =

  axiom	ceval_ast_citems(_,[],_,_,msg) => []

  rule	ceval_ast_citems(env,xs,impl,st,msg) => res &
	ceval_ast_modopt(env,modopt,impl,st,msg) => modopt' &
	ceval_ast_arraydim(env,ad,impl,st,msg) => ad' 
	------------------------------------------------
	ceval_ast_citems (env,Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad,modopt),cond,cmt)::xs,
			  impl,st,msg)
	  => (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad',modopt'),cond,cmt)::res)

  	  (* If one component fails, the rest should still succeed *)
  rule	ceval_ast_citems(env,xs,impl,st,msg) => res 
	----------------------------------
	ceval_ast_citems(env,x::xs,impl,st,msg) => x::res
end


(** relation: ceval_ast_modopt
 **
 ** inputs:  (Env.Env, Absyn.Modification option,
			  bool /* impl */, Interactive.InteractiveSymbolTable option,
			  Msg)
 ** outputs: Absyn.Modification option
 **)
relation ceval_ast_modopt: (Env.Env, Absyn.Modification option,
			    bool, Interactive.InteractiveSymbolTable option,
			    Msg)
	  => Absyn.Modification option	=

  rule	ceval_ast_modification(env,mod,st,impl,msg) => res
	----------------------------------------------
	ceval_ast_modopt(env,SOME(mod),st,impl,msg) => SOME(res)

  axiom	ceval_ast_modopt(env,NONE,_,_,msg) => NONE
	
end


(** relation: ceval_ast_modification
 **
 ** This relation evaluates Eval(variable) inside an AST Modification  and replaces 
 ** the Eval operator with the value of the variable if it has a type "Expression"
 **
 ** inputs:  (Env.Env, Absyn.Modification, 
		      bool /* impl */, 
			  Interactive.InteractiveSymbolTable option,
			  Msg)
 ** outputs: (Absyn.Modification)
 **)
 relation ceval_ast_modification: (Env.Env, Absyn.Modification, 
				   bool, 
				   Interactive.InteractiveSymbolTable option,
				   Msg)
	  => (Absyn.Modification) =

  rule	ceval_ast_exp(env,e,impl,st,msg) => e' &
	 ceval_ast_eltargs(env,eltargs,impl,st,msg) => eltargs'
	 --------------------------------------------------
	 ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,SOME(e)),impl,st,msg)
	  => (Absyn.CLASSMOD(eltargs',SOME(e')))

  rule	ceval_ast_eltargs(env,eltargs,impl,st,msg) => eltargs'
	 --------------------------------------------------
	 ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,NONE),impl,st,msg)
	  => (Absyn.CLASSMOD(eltargs',NONE))
 end


(** relation: ceval_ast_eltargs
 **
 ** Helper relation to ceval_ast_modification.
 **)
 relation ceval_ast_eltargs: (Env.Env, Absyn.ElementArg list,
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg)
	  => (Absyn.ElementArg list) =

  axiom	ceval_ast_eltargs(env,[],_,_,msg) => []

  rule	ceval_ast_modification(env,mod,impl,st,msg) => mod' &
	 ceval_ast_eltargs(env,args,impl,st,msg) => res 
	 -----------------------------------------------
	 ceval_ast_eltargs(env,Absyn.MODIFICATION(b,e,cr,SOME(mod),stropt)::args,
			   impl,st,msg) 
	  => Absyn.MODIFICATION(b,e,cr,SOME(mod'),stropt)::res

	   (**TODO: look through redeclarations for Eval(var) as well **)
  rule	ceval_ast_eltargs(env,args,impl,st,msg) => res
	 ------------------------------------------
	 ceval_ast_eltargs(env,m::args,
			   impl,st,msg) 
	  => m::res
 end


(** relation: ceval_ast_arraydim
 **
 ** Helper relation to ceva_ast_citems
 **
 ** inputs:  (Env.Env, Absyn.ArrayDim, 
			  bool /* impl */, 
			  Interactive.InteractiveSymbolTable option,
			  Msg)
 ** outputs: (Absyn.ArrayDim) 
 **)
 relation ceval_ast_arraydim: (Env.Env, Absyn.ArrayDim, 
			       bool, 
			       Interactive.InteractiveSymbolTable option,
			       Msg)
	  => (Absyn.ArrayDim) =

  axiom	ceval_ast_arraydim (env,[],_,_,msg) => []

  rule	ceval_ast_arraydim(env,xs,impl,st,msg) => res
	 -----------------------------------------
	 ceval_ast_arraydim(env,Absyn.NOSUB::xs,impl,st,msg) 
	  => Absyn.NOSUB::res

  rule	ceval_ast_arraydim(env,xs,impl,st,msg) => res &
	 ceval_ast_exp(env,e,impl,st,msg) => e'
	 ----------------------------------
	 ceval_ast_arraydim(env,Absyn.SUBSCRIPT(e)::xs,impl,st,msg) 
	  => Absyn.SUBSCRIPT(e)::res
 end


(* relation ceval_interactive_functions
 **
 ** This relation evaluates the functions defined in the interactive 
 ** environment.
 **
 ** inputs:  (Env.Env, 
			  Exp.Exp, /* exp to evaluate */
			  Interactive.InteractiveSymbolTable,
			  Msg)
 ** outputs: (Values.Value, Interactive.InteractiveSymbolTable)
 *)
 relation ceval_interactive_functions: (Env.Env, 
					Exp.Exp, 
					Interactive.InteractiveSymbolTable,
					Msg)
	  => (Values.Value, Interactive.InteractiveSymbolTable) =

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	 Lookup.lookup_class(env,path,true) => (c, env) &
	 Env.get_env_path(env) => SOME(p1) &
	 ModUtil.path_string(p1) => s1 &
	 Print.print_buf "Found class " &
	 Print.print_buf s1 & Print.print_buf "\n\n" &
	 Print.get_string() => str
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("lookupClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Interactive.get_type_of_variable(varid, iv) => tp &
	 Types.unparse_type tp => str 
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("typeOf"),[Exp.CREF(Exp.CREF_IDENT(varid,_),_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

axiom	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clear"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),Interactive.empty_symboltable)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,ic,[],cf)
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearVariables"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,[],iv,cf)
	 -------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearCache"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf),msg) => (Values.BOOL(true),newst)

  rule	Dump.unparse_str(p(*,false*)) => str
	 -------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	 Interactive.get_pathed_class_in_program(path,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,false*)) => str
	 -------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',path) => (dae',env)  &
          DAE.transform_if_eq_to_expr(dae') => (dae as DAE.DAE(dael)) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	 DAELow.lower(dae,false (* no dummy state*)) => (daelow as DAELow.DAELOW(vars,_,eqnarr,_,_,ae,_,_)) &
	 DAELow.incidence_matrix(daelow) => m &
	 DAELow.transpose_matrix(m) => mt &
	 DAELow.calculate_jacobian(vars,eqnarr,ae,m,mt) => jac &
	 DAELow.dump_jacobian_str(jac) => res 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("jacobian"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(res),Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

  rule  translate_model(env,cr,st,msg,filenameprefix) => (ret_val,st',_,_)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateModel"),
                                                    [Exp.CREF(cr,_),filenameprefix],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (ret_val,st')(*(Values.STRING("The model have been translated"),st')*)

  rule  Settings.set_compile_command(cmd)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompileCommand"),
                                                    [Exp.SCONST(cmd)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.BOOL(true),st)
           
  rule  Settings.set_plot_command(cmd)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setPlotCommand"),
                                                    [Exp.SCONST(cmd)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.BOOL(true),st)
           
  rule  Settings.set_temp_directory_path(cmd)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setTempDirectoryPath"),
                                                    [Exp.SCONST(cmd)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.BOOL(true),st)
           
  rule  Settings.set_installation_directory_path(cmd)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setInstallationDirectoryPath"),
                                                    [Exp.SCONST(cmd)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.BOOL(true),st)
 
  rule  Settings.set_modelica_path(cmd)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setModelicaPath"),
                                                    [Exp.SCONST(cmd)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
          => (Values.BOOL(true),st)
 
  rule  build_model(env,exp,st',msg) => (executable,method_str,st,initfilename) 
         -------------------------------
	 ceval_interactive_functions (env, exp as Exp.CALL(Absyn.IDENT("buildModel"),
                                                           [Exp.CREF(cr,_),
                                                            starttime,
                                                            stoptime,
                                                            interval,
                                                            method,
                                                            filenameprefix],_,_),
                                      st' as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                                      msg) 

	  => (Values.ARRAY([Values.STRING(executable),
                            Values.STRING(initfilename)]),st)
           
  rule  (* failing build_model *)
         -------------------------------
	 ceval_interactive_functions (env, exp as Exp.CALL(Absyn.IDENT("buildModel"),
                                                           [Exp.CREF(cr,_),
                                                            starttime,
                                                            stoptime,
                                                            interval,
                                                            method,
                                                            filenameprefix],_,_),
                                      st' as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                                      msg) 

	  => (Values.ARRAY([Values.STRING(""),
                            Values.STRING("")]),st')
           

  rule  (* FIXME: Should ceval be called with impl=true here? *)
         (* Build and simulate model *)

         build_model(env,exp,st',msg) => (executable,method_str,st,_) &
         
         win_citation() => cit &
	 System.path_delimiter => pd &
	 string_append(executable,".exe") => executableSuffixedExe &
	 Util.string_append_list([cit,".", pd, executableSuffixedExe, cit, " -m ",
                                  method_str," >> output.log 2>&1"
                                  ]) => sim_call &
	 System.system_call(sim_call) => 0 &
         
         Util.string_append_list([executable,"_res.plt"]) => result_file &
         
	 let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING(result_file)],["resultFile"]) &
	 let simType = (Types.T_COMPLEX(ClassInf.RECORD("SimulationResult")
				        ,[Types.VAR("resultFile",
						    Types.ATTR(false, 
							       SCode.RO, 
							       SCode.VAR,
							       Absyn.BIDIR),
				                    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
					  ],NONE
				        ),NONE) &
	 Interactive.add_var_to_symboltable("currentSimulationResult",simValue,simType,st) 
	  => newst 
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, exp as Exp.CALL(Absyn.IDENT("simulate"),
                                                    [Exp.CREF(cr,_),
                                                     starttime,stoptime,interval,method,filenameprefix],_,_),
                                      st' as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,newst)
	   
  rule	
	 (* simulation fail for some other reason than OPENMODELICAHOME not being set.*)
	 Settings.get_installation_directory_path => omhome &
	 Util.string_append_list(["Simulation failed.\n"]) => res &
	 let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING(res)],["resultFile"])
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval,method,filenameprefix],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,st)

  rule	let simValue = Values.RECORD(Absyn.IDENT("SimulationResult"),[Values.STRING("Simulation Failed. Environment variable OPENMODELICAHOME not set.")],["resultFile"])
	 ------------------------------------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval,method,filenameprefix],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (simValue,st)

  rule	Exp.unelab_cref(cr) => cr' &
	 Interactive.exist_class(cr',p) => true &
	 Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	 Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	 DAE.dump_str (dae) => str 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

	   (* model does not exist *)
  rule	Exp.unelab_cref(cr) => cr' &
	 Interactive.exist_class(cr',p) => false 
	 ----------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("Unknown model.\n"),Interactive.SYMBOLTABLE(p,sp,ic,iv,cf))

  rule	Static.component_ref_to_path(cr) => path &
	 SCode.elaborate(p) => p' &
	 (* we do not want error msg twice.. *)
	 Print.get_error_string() => str &
	 not Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	 Print.clear_error_buf() &
	 Print.print_error_buf(str) &
	 Print.get_error_string() => str
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),Interactive.SYMBOLTABLE(p,sp,ic,iv,cf))

(*  relation ceval : (Env.Env, Exp.Exp, bool (implicit) ,
		    Interactive.InteractiveSymbolTable option, 
		    int option, ( dimensions )
		    Msg)
	  => (Values.Value, Interactive.InteractiveSymbolTable option)
*)
  rule	 ceval(env,size_expression,true,SOME(st),NONE,msg) => 
	    (size_value as Values.INTEGER(size),SOME(st)) &
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 System.pwd() => pwd &
	 System.path_delimiter => pd & 
	 Util.string_append_list([pwd,pd,filename]) => filename' &
	 System.read_ptolemyplot_dataset(filename',vars',size) => value
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,vars),size_expression],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (value,st)

  rule	Error.add_message(Error.SCRIPT_READ_SIM_RES_ERROR,[])
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,_),_],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => fail

  rule	System.pwd() => pwd &
	 System.path_delimiter => pd & 
	 Util.string_append_list([pwd,pd,filename]) => filename' &
	 System.read_ptolemyplot_dataset_size(filename') => value 
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResultSize"),[Exp.SCONST(filename)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (value,st)

  rule	Error.add_message(Error.SCRIPT_READ_SIM_RES_SIZE_ERROR,[])
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResultSize"),[Exp.SCONST(filename)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => fail

  rule	(* plot *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   System.read_ptolemyplot_dataset(filename,vars'',0) => value &
	 System.pwd() => pwd &
        win_citation() => cit &
	 Settings.get_installation_directory_path => omhome &
	 System.trim(omhome,"\"") => omhome' &
	 System.path_delimiter => pd &
	 Util.string_append_list([cit,omhome',pd,"bin",pd,"doPlot",cit]) => plotCmd &
	 Util.string_append_list([pwd,pd,"tmpPlot.plt"]) => tmpPlotFile &
	 Values.write_ptolemyplot_dataset(tmpPlotFile,value,vars'',"Plot by OpenModelica") 
	  => res &
	   Util.string_append_list([cit,plotCmd, " \"", tmpPlotFile,"\"",cit]) => call &			   
	 System.system_call(call) => _
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	(* Catch error reading simulation file. *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   not System.read_ptolemyplot_dataset(filename,vars'',0) => _ 
	 ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("Error reading the simulation result."),st)
	   
  rule	(* Catch error reading simulation file. *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 Util.list_union_elt("time",vars') => vars'' &
	 not ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,NO_MSG) 
	  => (_,_)
	   ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("No simulation result to plot."),st)

  axiom ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
 	  => (Values.STRING("Unknown error while plotting"),st)
	   
(* plotparametric *)
(* This rule represents the normal case when an array of at least two elements 
   is given as an argument *)
  rule	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 list_length(vars') => length &
	 int_gt(length,1) => true &
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   System.read_ptolemyplot_dataset(filename,vars',0) => value &
	 System.pwd() => pwd &
         win_citation() => cit &
	 Settings.get_installation_directory_path => omhome &
	 System.trim(omhome,"\"") => omhome' &
	 System.path_delimiter => pd &
	 Util.string_append_list([cit,omhome',pd,"bin",pd,"doPlot",cit]) => plotCmd &
	 Util.string_append_list([pwd,pd,"tmpPlot.plt"]) => tmpPlotFile &
	 Values.write_ptolemyplot_dataset(tmpPlotFile,value,vars',"Plot by OpenModelica") 
	  => res &
	   Util.string_append_list([cit,plotCmd, " \"", tmpPlotFile,"\"",cit]) => call &			   
	 System.system_call(call) => _
	 ------------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plotParametric"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	(* Catch error with less than two elements (=variables) in the array.
           This means we cannot plot var2 as a function of var1 as var2 is missing*)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 list_length(vars') => length &
	 int_lt(length,2) => true 
	 ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plotParametric"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("Error: Less than two variables given to plotParametric."),st)


  rule	(* Catch error reading simulation file.*)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 (*Util.list_union_elt("time",vars') => vars'' & *)
	 ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,msg) 
	  => (Values.RECORD(_,[Values.STRING(filename)],_),_) &
	   not System.read_ptolemyplot_dataset(filename,vars',0) => _ 
	 ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plotParametric"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("Error reading the simulation result."),st)
	   
  rule	(* Catch error reading simulation file. *)
	 Util.list_map(vars,Exp.print_exp_str) => vars' &
	 (*Util.list_union_elt("time",vars') => vars'' &*)
	 not ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE,NO_MSG) 
	  => (_,_)
	   ---------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plotParametric"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING("No simulation result to plot."),st)

  axiom ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plotParametric"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
 	  => (Values.STRING("Unknown error while plotting"),st)
	   
(*end plotparametric*)

  rule	System.time => t1 &
	 ceval(env,exp,true,SOME(st),NONE,msg) => (value,SOME(st')) &   
	 System.time => t2 &
	 real_sub(t2,t1) => time 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("timing"),[exp],_,_),st,msg) => (Values.REAL(time),st')

  rule	System.set_c_compiler(str)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompiler"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	System.set_c_flags(str)
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompilerFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	string_append("+d=",str) => str' &
	 RTOpts.args [str'] => args 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setDebugFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),st)

  rule	System.cd(str) => res &
	 int_eq (res,0) => true &
	 System.pwd => str' 
	 -------------------------
	    ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

	    (* no such directory *)
  rule	not System.directory_exist(str) => 0 &
	    Util.string_append_list(["Error, directory ", str, " does not exist,"]) => res
	    ----------------------
	    ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(res),st)

  rule	System.pwd() => str'
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

  rule	System.system_call(str) => res 
	 -------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("system"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.INTEGER(res),st)


  rule	System.read_file(str) => str'
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readFile"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str'),st)

  rule	Error.print_messages_str() => str
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getErrorString"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str),st)

(* New error message implementation *)
  rule	Error.print_messages_str() => str
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getMessagesString"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str),st)

  rule	Error.get_messages_str() => str
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getMessagesStringInternal"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.STRING(str),st)

  rule	System.read_file(str) => scriptstr &
	 Parser.parsestringexp(scriptstr) => (istmts,msg) &
	 msg = "Ok" &
	 Interactive.evaluate(istmts,st,true) => (res,newst) &
	 Util.string_append_list([res,"\ntrue"]) => res'
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(res'),newst)

  axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st,msg) 
	  => (Values.BOOL(false),st)


  rule	(* SCode.elaborate(p) => p' & *)
	 Static.component_ref_to_path(fcr) => path &
	 ceval_generate_function(env, path)
         (*	& Inst.instantiate_implicit(p') => d & *)
	 --------------------------------------
	 ceval_interactive_functions (env,
				      Exp.CALL(Absyn.IDENT("generateCode"),[funcref as Exp.CREF(fcr,_)],_,_),
				      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true), st)
	 (* add path to symboltable for compiled functions
	  Interactive.SYMBOLTABLE(p,sp,ic,iv,(path,t)::cf),
	  but where to get t? *)

  rule	Settings.get_modelica_path => mp &
	 Static.component_ref_to_path(cr) => path &
	 ClassLoader.load_class(path, mp) => pnew &
	 Interactive.update_program(pnew,p) => p' &
	 Print.get_string => str &
	 let newst = Interactive.SYMBOLTABLE(p', sp, [], iv, cf)
	 ------------------------------
         ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(true),newst)

	 
  rule	Static.component_ref_to_path(cr) => path &
	 ModUtil.path_string(path) => pathstr &

	Error.add_message(Error.LOAD_MODEL_ERROR,[pathstr])
	 ------------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(false),st)

	    (* loadModel failed *)
  axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) => (Values.BOOL(false),st)
 


  rule  (* System.regular_file_exist(name) => 0 & *)
(*          Parser.parse(name) => p1 & *)
         ClassLoader.load_file(name) => p1 &
         Interactive.update_program(p1,p) => newp 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),
                                                    [Exp.SCONST(name)],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(true),Interactive.SYMBOLTABLE(newp,sp,ic,iv,cf))
          (* (Values.BOOL(true),Interactive.SYMBOLTABLE(newp,sp,[],iv,cf)) *)

       (** it the rule above have failed then check if file exists **)
        (* without this omc crashes *)
  rule  System.regular_file_exist(name) => rest &
         int_gt(rest,0) => true
         ---------------------------------------------------
         ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(false),st)
           
				
  rule	(*not Parser.parse(name) => _*) 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg)
	  => (Values.BOOL(false),st)
           
  rule	Static.component_ref_to_path(cr) => classpath &
	 Interactive.get_pathed_class_in_program(classpath,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,true*)) => str &
	 System.write_file(filename,str) 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(filename),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  rule	(*Error writing to file *)
	 Static.component_ref_to_path(cr) => classpath &
	 Interactive.get_pathed_class_in_program(classpath,p) => class &
	 Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)(*,true*)) => str &
	 Error.add_message(Error.WRITING_FILE_ERROR, [name])
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)


  rule	Static.component_ref_to_path(cr) => classpath &
	Interactive.get_contained_class_and_file(classpath,p) => (p',filename) &
	Dump.unparse_str(p'(*,true*)) => str &
	System.write_file(filename,str) 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("save"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)

  axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("save"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)

  rule	Dump.unparse_str(p(*,true*)) => str &
	 System.write_file(filename,str) 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveAll"),[Exp.SCONST(filename)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(true),st)


  rule	(*Error writing to file *)
	 Static.component_ref_to_path(cr) => classpath &
	 Absyn.path_string(classpath) => cname &
	 Error.add_message(Error.LOOKUP_ERROR,[cname,"global"])
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.BOOL(false),st)

  rule	Settings.get_installation_directory_path => omhome &
	System.trim(omhome,"\"") => omhome' &
	win_citation() => cit &  
         System.path_delimiter => pd &
         Util.string_append_list([omhome',pd,"bin",pd,"omc_helptext.txt"]) => filename &
	 print filename & 
	 System.read_file(filename) => str 
	 --------------------------
	 ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("help"),[],_,_),
				      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),msg) 
	  => (Values.STRING(str),st)

  rule	get_builtin_attribute(classname,cref,"unit",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getUnit"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"quantity",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getQuantity"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"displayUnit",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getDisplayUnit"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"min",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMin"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"max",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMax"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"start",st) => (v, st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStart"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"fixed",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getFixed"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"nominal",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getNominal"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"stateSelect",st) => (v,st')
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStateSelect"),
						   [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				     st,msg)
	  => (v, st')

  rule	ceval(env,bool_exp,true,SOME(st),NONE,msg) 
	  => (v as Values.BOOL(bval),SOME(st')) &
	Interactive.add_var_to_symboltable("$echo",v,
					   (Types.T_BOOL([]),NONE),st')
	    => st''
	 ----------------------------------------------
	 ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("echo"),
						   [bool_exp], _, _),
				     st,msg)
	  => (v, st'')
 
end


(**relation generate_makefilename
 **
 **)
relation generate_makefilename:(string) => string =
        
  rule  Util.string_append_list([filenameprefix,".makefile"]) => makefilename 
        ----------------------------
        generate_makefilename(filenameprefix) => makefilename
        
end


(**relation translate_model
 **author: x02lucpo
 **
 **translates a model into cpp code and writes also a makefile 
 **
 ** inputs:  (Env.Env, 
			  Exp.ComponentRef, /* component ref for model */
			  Interactive.InteractiveSymbolTable,
              Msg,
              Exp.Exp)
 ** outputs:  (Values.Value, 
              Interactive.InteractiveSymbolTable,
              DAELow.DAELow,
              string list /*libs */)
 **)
 relation translate_model: (Env.Env, 
			    Exp.ComponentRef, 
			    Interactive.InteractiveSymbolTable,
                            Msg,
                            Exp.Exp)

	  => (Values.Value, 
              Interactive.InteractiveSymbolTable,
              DAELow.DAELow,
              string list) =
         
  rule  extract_file_prefix(env,fileprefix,st,msg) => filenameprefix &
         Static.component_ref_to_path(cr) => classname &
         SCode.elaborate(p) => p' &
         Inst.instantiate_class(p',classname) => (dae', env) &
         DAE.transform_if_eq_to_expr(dae') => (dae as DAE.DAE(dael)) &
         Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname,dael,env)) 
	  => ic' &
           DAELow.lower(dae,true) => dlow &
         Debug.fprint("bltdump","Lowered DAE:\n") &
         Debug.fcall("bltdump", DAELow.dump,dlow) &
         DAELow.incidence_matrix(dlow) => m &
	 DAELow.transpose_matrix(m) => mT &
	 DAELow.matching_algorithm(dlow,m,mT,
				   (DAELow.INDEX_REDUCTION,DAELow.EXACT,
				    DAELow.REMOVE_SIMPLE_EQN)) 
	  => (ass1,ass2,dlow',m,mT) &
           DAELow.strong_components(m,mT,ass1,ass2) => (comps) &
         DAELow.translate_dae (dlow') => indexed_dlow &
         DAELow.calculate_values(indexed_dlow) => indexed_dlow' &
	 Debug.fprint("bltdump","indexed DAE:\n") &
	 Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) &
	 Debug.fcall("bltdump", DAELow.dump_incidence_matrix_t, mT) &
	 Debug.fcall("bltdump", DAELow.dump,indexed_dlow') &
	 Debug.fcall("bltdump", DAELow.dump_matching, ass1) &
	 Absyn.path_string(classname) => cname_str &
	 Util.string_append_list([filenameprefix,".cpp"]) => filename &
	 Util.string_append_list([filenameprefix,"_functions.cpp"]) => funcfilename &
	 generate_makefilename(filenameprefix) => makefilename &
         SimCodegen.generate_functions(p',dae,indexed_dlow',classname,funcfilename) => libs &
	 SimCodegen.generate_simulation_code(dae,indexed_dlow',ass1,ass2,m,mT,comps,classname,filename,funcfilename) &
	 SimCodegen.generate_makefile(makefilename,filenameprefix,libs) 
         (*	Util.string_append_list(["make -f ",cname_str, ".makefile\n"]) => s_call &
          *)
         ---------------------------------------------
 	 translate_model (env, 
                          cr,
                          st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                          msg,
                          fileprefix) 
          => (Values.STRING("The model have been translated"),st,
              indexed_dlow', libs)
         
  rule  (*Print.print_error_buf("# translate_model failed\n")*)
         ---------------------------------------------
         translate_model (env, cr,
                          st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                          _,
                          _)
	  => fail

end


(** relation extract_file_prefix
 ** author: x02lucpo
 **
 ** extracts the file_prefix from Exp.Exp as string
 **)
relation extract_file_prefix:(Env.Env,
                              Exp.Exp,
			      Interactive.InteractiveSymbolTable,
                              Msg)
          => (string) =

  rule 	ceval(env,filenameprefix,true,SOME(st),NONE,msg) 
	  => (Values.STRING(prefix_str),SOME(st)) 
          ----------------------------------
        extract_file_prefix(env, 
                                      filenameprefix,
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                                      msg)
          => prefix_str
        
  rule  
        ----------------------------------
        extract_file_prefix(_,_,_,_) => fail
end


(**relation calculate_simulation_settings
 **author: x02lucpo
 **
 **calculates the start,end,interval,stepsize, method and init_file_name
 **
 ** inputs:  (Env.Env,Exp.Exp,
			  Interactive.InteractiveSymbolTable,
              Msg,
              string)
 ** outputs:  (string/* filename */,
              real, /* start time*/
              real, /* stop time */
              real, /* step size */
              string /* method*/) 
 **)
relation calculate_simulation_settings: (Env.Env,Exp.Exp,
					 Interactive.InteractiveSymbolTable,
                                         Msg,
                                         string)
          => (string,
              real, 
              real, 
              real, 
              string)  =

  rule  ceval(env,filenameprefix,true,SOME(st),NONE,msg) 
	  => (Values.STRING(prefix_str),SOME(st)) &
          ceval(env,starttime,true,SOME(st),NONE,msg) 
	  => (Values.REAL(starttime_r),SOME(st)) &
	   ceval(env,stoptime,true,SOME(st),NONE,msg) 
	  => (Values.REAL(stoptime_r),SOME(st)) &
	   ceval(env,interval,true,SOME(st),NONE,msg) 
	  => (Values.INTEGER(interval_i),SOME(st)) &
	   ceval(env,method,true,SOME(st),NONE,msg) 
	  => (Values.STRING(method_str),SOME(st)) &
	 int_real(interval_i) => interval_r &
	 Util.string_append_list([prefix_str,"_init.txt"]) => init_filename 
        ---------------------------------
        calculate_simulation_settings(env, 
                                      Exp.CALL(_,
                                               [Exp.CREF(cr,_),
                                                starttime,stoptime,interval,method,filenameprefix],_,_),
                                      st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                                      msg,
                                      cname_str)
          => (init_filename,starttime_r,stoptime_r,interval_r,method_str)

  rule  Print.print_error_buf("# calculate_simulation_settings failed\n")
        ----------------------------------
        calculate_simulation_settings(_,_,_,_,_) => fail

end


(**relation build_model
**author: x02lucpo
**
**translates and builds the model through the compiler script
**
** inputs: (Env.Env,  
		    Exp.Exp, /* component ref for model */
		    Interactive.InteractiveSymbolTable,
            Msg)
** outputs: (string, /*classname*/
             string, /*method*/
             Interactive.InteractiveSymbolTable, 
             string) /*initfilename*/
**)
relation build_model:(Env.Env,  
		      Exp.Exp, 
		      Interactive.InteractiveSymbolTable,
                      Msg)
          => (string, 
              string, 
              Interactive.InteractiveSymbolTable, 
              string) =

  rule   translate_model(env,cr,st',msg,fileprefix) => (ret_val, st,indexed_dlow',libs) &
        Static.component_ref_to_path(cr) => classname &
	Absyn.path_string(classname) => cname_str &
        
        Exp.unelab_cref(cr) => a_cref &
        change_to_file_dir(a_cref,p) &
        calculate_simulation_settings(env,exp,st,msg,cname_str) 
          => (init_filename,starttime_r,
              stoptime_r,interval_r,method_str) &
        
	SimCodegen.generate_init_data(indexed_dlow',classname,init_filename,
				      starttime_r,stoptime_r,interval_r) &
        extract_file_prefix(env,fileprefix,st,msg) => filenameprefix &
        generate_makefilename(filenameprefix) => makefilename &
        (*	Util.string_append_list(["make -f ",cname_str, ".makefile\n"]) => s_call &
         *)
        compile_model(filenameprefix,libs) 

        -------------------------------------------
        build_model(env,exp as Exp.CALL(Absyn.IDENT(_),
                                        [Exp.CREF(cr,_),
                                         starttime,stoptime,interval,method,fileprefix],_,_),
                    st' as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf),
                    msg) 
          => (filenameprefix,method_str,st,init_filename)

  rule (*Print.print_error_buf("# build_model failed\n")*)
        -----------------------------------------
        build_model(_,_,_,_) => fail
end


(** relation: change_to_file_dir
 ** author: x02lucpo
 **
 ** CHANges to the dir where class-file (.mo) is saved or 
 ** OPENMODELICAHOMe/work if not saved
 **
 ** inputs: (Absyn.ComponentRef, /* class */
			    Absyn.Program) 
 ** outputs: ()
 **)
relation change_to_file_dir:(Absyn.ComponentRef,
			    Absyn.Program) => () =

  rule  (* change to the saved files directory *)
        Absyn.cref_to_path(class) => p_class &
	Interactive.get_pathed_class_in_program(p_class,p) => cdef &
	Absyn.class_filename(cdef) => filename &
        System.path_delimiter() => pd &
        string_list(pd) => pd'::_ &
        Util.string_split_at_char(filename,pd') => filename' &
        Util.list_strip_last(filename') => dir &
        Util.string_delimit_list(dir,pd) => dir' &

        System.cd(dir') => 0
        ------------------------------
        change_to_file_dir(class,p) => ()


  rule  (*model no saved! change to OPENMODELICAHOME/work *)
        Settings.get_installation_directory_path => omhome &
	System.trim(omhome,"\"") => omhome' &
        System.path_delimiter() => pd &
        win_citation() => cit &
        Util.string_append_list([cit,omhome',pd,"work",cit]) => dir' &
        System.cd(dir') => 0
        -------------------------------
        change_to_file_dir(class,p) => ()

        (*this relation should never fail*)
  axiom change_to_file_dir(_,_) => ()

end


(** relation: compile_model
 ** author: PA, x02lucpo
 **
 ** Compiles a model given a file-prefix, helper relation to build_model.
 **)
relation compile_model: (string, string list) => () =
	 
  rule	Settings.get_compile_command => "" &
        System.path_delimiter => pd &
	Settings.get_installation_directory_path => omhome & 
	System.string_replace(omhome,"\"","") => omhome' &
        win_citation() => cit &
        System.pwd => cd_path &
        string_append(fileprefix,".libs") => libsfilename &
        Util.string_delimit_list(libs," ") => libs_str &
        System.write_file(libsfilename,libs_str) &
        Util.string_append_list([cit,omhome', pd, "bin", pd, "Compile",cit," ", 
                                 (*"\"",cd_path,"\""," ",*)
                                 fileprefix (*,  " "
				 ,libs_str*)
                                 ]) => s_call &
        (*> output.log 2>&1 = redirect stderr to stdout and put it in output.log *)
        print s_call & print "\n" &
	System.system_call(s_call) => 0 
	--------------------------
	compile_model(fileprefix, libs) => ()
	
  rule	Settings.get_compile_command => command &
        Util.is_empty_string(command) => false & (*needed when the above rule does not work*)
        System.pwd => cd_path &
        win_citation() => cit &
        Util.string_delimit_list(libs," ") => libs_str &
        string_append(fileprefix,".libs") => libsfilename &
        System.write_file(libsfilename,libs_str) &
        Util.string_append_list([command," ", 
                                 (*cit,cd_path,cit," ",*)
                                 fileprefix (*, " " ,
                                 libs_str *)
                                 ]) => s_call &
        (*> output.log 2>&1 = redirect stderr to stdout and put it in output.log *)
        print s_call & print "\n" &
        
	System.system_call(s_call) => 0 
	--------------------------
	compile_model(fileprefix,libs) => ()

	(* compilation failed\n *)
  rule  Util.string_append_list([fileprefix,".log"]) => filename &
        System.regular_file_exist(filename) => 0 &
        System.read_file(filename) => str &
	Error.add_message(Error.SIMULATOR_BUILD_ERROR,[str])
	--------------------------
	compile_model(fileprefix,libs) => fail
 
  rule  Print.print_error_buf ("#Error building simulation code.\n ") 
	--------------------------
	compile_model(fileprefix,libs) => fail
end


(** relation: win_citation
 ** author: PA
 **
 ** Returns a cition mark if platform is windows, otherwise empty string. Used
 ** by simulate to make whitespaces work in filepaths for WIN32
 **)
relation win_citation: () => string =

  rule	System.platform => "WIN32"
	-------------------
	win_citation () => "\""

  axiom	win_citation() => ""
end


(** relation: get_builtin_attribute
 **
 ** Retrieves a builtin attribute of a variable in a class by instantiating 
 ** the class and retrieving the attribute value from the flat variable.
 **)
relation get_builtin_attribute: (Exp.ComponentRef, Exp.ComponentRef, string,
				   Interactive.InteractiveSymbolTable) 
	  => (Values.Value, Interactive.InteractiveSymbolTable) =

  rule	(* Check cached instantiated class *)
	  Static.component_ref_to_path(classname) => classname' &
	  Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	  Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	  Lookup.lookup_var(env,cref') => (attr,ty,Types.EQBOUND(exp,_,_)) &
	  Exp.print_exp_str exp => str
	  --------------------------------
	  get_builtin_attribute(classname,cref,"stateSelect",
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(classname) => classname' &
	  SCode.elaborate(p) => p' &
	  Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	  Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	    Env.open_scope(env',encflag,SOME(n)) => env3 &
	  ClassInf.start(r,n) => ci_state &
	  Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, Connect.empty_set, ci_state, 
			     c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys,_) &
	    Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	  Lookup.lookup_var(env4,cref') => (attr,ty,Types.EQBOUND(exp,_,_)) &
	  Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' &
	  Exp.print_exp_str exp => str
	  --------------------------------
	  get_builtin_attribute(classname,cref,"stateSelect",
			        Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str), Interactive.SYMBOLTABLE(p,sp,ic',vars,cf))

  rule	Static.component_ref_to_path(classname) => classname' &
	  Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	  Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	  Lookup.lookup_var(env,cref') => (attr,ty,Types.VALBOUND(v)) 
	  -----------------------------------------------
	  get_builtin_attribute(classname,cref,attribute,
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, st)

  rule	Static.component_ref_to_path(classname) => classname' &
	  SCode.elaborate(p) => p' &
	  Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	  Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	    Env.open_scope(env',encflag,SOME(n)) => env3 &
	  ClassInf.start(r,n) => ci_state &
	  Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, 
			     Connect.empty_set, ci_state, 
			     c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys,_) &
	    Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	  Lookup.lookup_var(env4,cref') => (attr,ty,Types.VALBOUND(v)) &
	  Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' 
	  -----------------------------------------------
	  get_builtin_attribute(classname,cref,attribute,
			        st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, Interactive.SYMBOLTABLE(p,sp,ic',vars,cf)) 
  end 

(** relation: ceval_matrixelt
 **
 ** Evaluates the expression of a matrix constructor, e.g. [1,2;3,4]
 **
 ** signature: (Env.Env,
			  (Exp.Exp*bool) list list, /* matrix constr. elts*/
			  bool, /*impl*/ 
			  Msg) 
	  => Values.Value list
 **)
relation ceval_matrixelt:(Env.Env,
			  (Exp.Exp*bool) list list,
			  bool, 
			  Msg) 
	  => Values.Value list =
	  
  rule	ceval_matrixeltrow(env,expl,impl,msg) => v &
	ceval_matrixelt(env,expll,impl,msg) => vl
	---------------------------
	ceval_matrixelt(env,expl::expll,impl,msg) => v::vl
	
  axiom	ceval_matrixelt(_,[],_,msg) => []
end


(** relation: ceval_matrixeltrow
 **
 ** Helper relation to ceval_matrixelt
 **
 ** signature: (Env.Env, (Exp.Exp*bool) list, bool, /*impl*/ 
			     Msg) => Values.Value
 **)
relation ceval_matrixeltrow:(Env.Env, (Exp.Exp*bool) list, bool, 
			     Msg) => Values.Value =
	
  rule	ceval (env,e,impl,NONE,NONE,msg) => (res,_) &
	ceval_matrixeltrow(env,rest,impl,msg) => Values.ARRAY(resl)
	-------------------
	ceval_matrixeltrow(env, (e,_)::rest,impl,msg) => Values.ARRAY(res::resl)
	
  axiom	ceval_matrixeltrow(env,[],_,msg) => Values.ARRAY([])
	
end


(** relation: ceval_builtin_size
 **
 ** Evaluates the size operator.
 **)
relation ceval_builtin_size : (Env.Env, Exp.Exp, Exp.Exp, bool, 
			       Interactive.InteractiveSymbolTable option,
			       Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	    

  rule	(* If dimensions known, always ceval *)
	  Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	  Types.dimensions_known(tp) => true &
	  Types.get_dimension_sizes(tp) => sizelst &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dim),st') &
	  int_sub(dim,1) => dim' &
	  list_nth(sizelst,dim') => v
	  ------------------------------------
	  ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl,st,msg) 
	  => (Values.INTEGER(v),st')

  rule	(* If component not instantiated yet, recursive definition.
	 For example,
	 Real x[:](min=fill(1.0,size(x,1))) = {1.0} 
	 *
	 * When size(x,1) should be determined, x must be instantiated, but
	 * that is not done yet. Solution: Examine Element to find modifier 
	 * which will determine dimension size.
	 *)
	Inst.elab_component_arraydim_from_env(env,cr) => dims &
	ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	ceval_builtin_size_3(dims,dimv) => v2
	------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,msg) 
	  => (v2,st')

  rule	(* If dimensions not known and impl=true, just silently fail *)
	  Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	  Types.dimensions_known(tp) => false
	  ------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as true,st,msg) => fail

  rule	(* If dimensions not known and impl=false, error message *)
	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.dimensions_known(tp) => false &
	Exp.print_component_ref_str(cr) => cr_str &
	Exp.print_exp_str(dim) => dim_str &
	Util.string_append_list(["size(",cr_str,", ",dim_str,")"]) => size_str &
	Error.add_message(Error.DIMENSION_NOT_KNOWN,[size_str])
	------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,MSG) => fail

  rule	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.dimensions_known(tp) => false 
	------------------------
  	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl as false,st,NO_MSG) => fail

  rule	(*For crefs without value binding*) 
	Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND) &
	Exp.print_exp_str exp => expstr &
 	Error.add_message(Error.UNBOUND_VALUE,[expstr])
	------------------------------------
	ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as false,st,MSG) => fail

  rule	Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND) 
	----------------------------------
	ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as false,st,NO_MSG) => fail

  rule	(*For crefs without value binding. If impl=true just silently fail *) 
	  Lookup.lookup_var(env,cr) => (attr, tp, Types.UNBOUND)
	  ------------------------------------
	  ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl as true,st,msg) => fail

  rule	(*For crefs with value binding*) 
	  Lookup.lookup_var(env,cr) => (attr, tp, binding) &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	  ceval_cref_binding (env,cr,binding,impl,msg) => v &
	  ceval_builtin_size_2(v,dimv) => v2
	  ------------------------------------
	  ceval_builtin_size(env,exp as Exp.CREF(cr,crtp),dim,impl,st,msg) => (v2,st')

  rule	  (* Special case for array expressions with nonconstant values*)
	  (* For now: only arrays of scalar elements: TODO generalize to arbitrary
	   dimensions*)
	  Exp.typeof(e) => tp &
	  Exp.type_builtin(tp) => true &
 	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(1),st') &
	  list_length(e::es) => len
 	  ---------------------------------
 	  ceval_builtin_size(env,Exp.ARRAY(_,_,e::es),dim,impl,st,msg) => (Values.INTEGER(len),st')

  rule	(* try to ceval expression, for constant expressions *)
	  ceval(env,exp,impl,st,NONE,msg) => (v, st') &
	  ceval(env,dim,impl,st,NONE,msg) => (Values.INTEGER(dimv),st') &
	  ceval_builtin_size_2(v,dimv) => v2
	  ---------------------------------
	  ceval_builtin_size(env,exp,dim,impl,st,msg) => (v2,st')

  rule	Print.print_error_buf "#-- ceval_builtin_size failed: "  &
	  Exp.print_exp_str exp => expstr &
	  Print.print_error_buf expstr &
	  Print.print_error_buf "\n" 
	  ------------------------------------
	  ceval_builtin_size(env,exp,dim,impl,st,MSG) => fail
  end


(** relation: ceval_bultin_size_2
 ** 
 ** Helper relation to ceval_builtin_size
 **)
relation ceval_builtin_size_2 : (Values.Value, int) => (Values.Value) =
	
  rule	list_length(lst) => dim
	---------------------------------------
	ceval_builtin_size_2(Values.ARRAY(lst), 1) => Values.INTEGER(dim)
	
  rule	int_sub (ind, 1) => ind' &
	ceval_builtin_size_2 (l, ind') => dim
	--------------------------------------------------
	ceval_builtin_size_2 (Values.ARRAY(l::lst), ind) => dim
	
  rule	Debug.fprint("failtrace","- ceval_builtin_size_2 failed\n")
	-------------------------------------
	ceval_builtin_size_2(_,_) => fail
end


(** relation: ceval_builtin_size_3
 ** author: PA
 ** 
 ** Helper relation to ceval_builtin_size. Used when recursive definition
 ** (attribute modifiers using size) is used.
**)
relation ceval_builtin_size_3: (Inst.DimExp list, int ) => Values.Value =

  rule	n - 1 => n' &
	list_nth(dims,n') => Inst.DIMINT(v) 
	-------------------------
	ceval_builtin_size_3(dims,n) => Values.INTEGER(v)

  rule	n - 1 => n' &
	list_nth(dims,n') => Inst.DIMEXP(sub,eopt) &
	print "ceval_builtin_size_3 failed DIMEXP in dimesion\n"
	-------------------------
	ceval_builtin_size_3(dims,n) => fail

(*  rule	print "-ceval_builtin_size_3 failed\n"
	-------------------------
	ceval_builtin_size_3(dims,n) => fail*)
end


(** relation: ceval_builtin_abs
 ** author: LP
 ** 
 ** Evaluates the abs operator.
 **)
relation ceval_builtin_abs : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_abs(rv) => rv'
	--------------------------------------
	ceval_builtin_abs(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.INTEGER(iv),_) &
        int_abs(iv) => iv  
	--------------------------------------
	ceval_builtin_abs(env,[exp],impl,st,msg) => (Values.INTEGER(iv),st)
end


(** relation: ceval_builtin_sign
 ** author: PA
 ** 
 ** Evaluates the sign operator.
 **)
relation ceval_builtin_sign : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_gt(rv,0.0) => b1 &
	real_lt(rv,0.0) => b2 &
	real_eq(rv,0.0) => b3 &
	Util.list_select([(b1,1.0),(b2,-1.0),(b3,0.0)],Util.tuple2_1) 
	  => [(_,rv')]
	--------------------------------------
	ceval_builtin_sign(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.INTEGER(iv),_) &
        int_gt(iv,0) => b1 &
	int_lt(iv,0) => b2 &
	int_eq(iv,0) => b3 &
	Util.list_select([(b1,1),(b2,-1),(b3,0)],Util.tuple2_1) 
	  => [(_,iv')]
	--------------------------------------
	ceval_builtin_sign(env,[exp],impl,st,msg) => (Values.INTEGER(iv'),st)
end


(** relation: ceval_builtin_exp
 ** author: PA
 ** 
 ** Evaluates the exp function
 **)
relation ceval_builtin_exp : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
	real_exp(rv) => rv'
	--------------------------------------
	ceval_builtin_exp(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)

end


(** relation: ceval_builtin_noevent
 ** author: PA
 ** 
 ** Evaluates the noEvent operator. During constant evaluation events are not
 ** considered, so evaluation will simply remove the operator and evaluate the
 ** operand.
 **)
relation ceval_builtin_noevent : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule  ceval (env,exp,impl,st,NONE,msg) => (v,_) 
	--------------------------------------
	ceval_builtin_noevent(env,[exp],impl,st,msg) => (v,st)

end


(** relation: ceval_builtin_cardinality
 ** author: PA
 ** 
 ** Evaluates the cardinality operator. The cardinality of a connector 
 ** instance is its number of (inside and outside) connections, i.e. 
 ** number of occurences in connect equations.
 **)
relation ceval_builtin_cardinality : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule  ceval_cardinality(env,cr) => cnt
	--------------------------------------
	ceval_builtin_cardinality(env,[Exp.CREF(cr,_)],impl,st,msg) 
	  => (Values.INTEGER(cnt),st)
end


(** relation: ceval_cardinality 
 ** author: PA
 ** 
 ** counts the number of connect occurences of the component ref in 
 ** equations in current scope.
 **)
relation ceval_cardinality: (Env.Env, Exp.ComponentRef) => int =
	
  rule	Util.list_select_1(crs,cr,Exp.cref_contained_in) => cr_lst &
	list_length(cr_lst) => res
	--------------------------
	ceval_cardinality(Env.FRAME(_,_,_,_,_,crs,_)::_,cr) => res
end


(** relation: ceval_builtin_cat
 ** author: PA
 ** 
 ** Evaluates the cat operator, for matrix concatenation.
 **)
relation ceval_builtin_cat : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,dim,impl,st,NONE,msg) => (Values.INTEGER(dim_int),_) &
	ceval_list(env,matrices,impl,st,msg) => mat_lst &
	ceval_cat(mat_lst,dim_int) => v
	--------------------------------------
	ceval_builtin_cat(env,dim::matrices,impl,st,msg) 
	  => (v,st)
end


(** relation: ceval_builtin_identity
 ** author: PA
 ** 
 ** Evaluates the cat operator, for matrix concatenation.
 **)
relation ceval_builtin_identity : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,dim,impl,st,NONE,msg) => (Values.INTEGER(dim_int),_) &
	int_add(dim_int,1) => dim_int' &
	Util.list_fill(Exp.ICONST(1),dim_int) => expl &
	
	ceval_builtin_diagonal2(env,Exp.ARRAY(Exp.INT,true,expl),impl,st,dim_int',1, [],msg) 
	  => retExp 
	--------------------------------------
	ceval_builtin_identity(env,[dim],impl,st,msg) 
	  => (Values.ARRAY(retExp),st)
end

(** relation: ceval_builtin_promote
 ** author: PA
 ** 
 ** Evaluates the internal promote operator, for promotion of arrays
 **)
relation ceval_builtin_promote : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option, Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,arr,impl,st,NONE,msg) => (arr_val,_) &
	ceval (env,dim,impl,st,NONE,msg) => (Values.INTEGER(dim_val),_) &
	ceval_builtin_promote_2(arr_val,dim_val) => res
	--------------------------------------
	ceval_builtin_promote(env,[arr,dim],impl,st,msg) 
	  => (res,st)
end


(** relation: ceval_builtin_promote_2
 **
 ** Helper relation to ceval_builtin_promote
 **)
relation ceval_builtin_promote_2: (Values.Value, 
				   int)
	=> Values.Value =

  axiom	ceval_builtin_promote_2(v,0) => Values.ARRAY([v])

  rule	int_sub(n,1) => n' &
	Util.list_map_1(vs,ceval_builtin_promote_2,n') => vs'
	------------------------
        ceval_builtin_promote_2(Values.ARRAY(vs),n) => Values.ARRAY(vs')

end


(** relation: ceval_cat
 **
 ** evaluates the cat operator given a list of array values and a 
 ** concatenation dimension.
 **)
relation ceval_cat: (Values.Value list,
		     int)
		      => Values.Value =

  rule	cat_dimension(v_lst,dim) => v_lst' 
	---------------
	ceval_cat(v_lst,dim) => Values.ARRAY(v_lst')

end


(** relation: cat_dimension
 ** 
 ** Helper relation to ceval_cat, concatenates a list arrays as
 ** Values, given a dimension as integer.
 **)
relation cat_dimension: (Values.Value list, int) => Values.Value list =
	
	(* base case for first dimension *)
  rule	Util.list_map(vlst,Values.array_values) => vlst_lst &
	Util.list_flatten(vlst_lst) => v_lst'
	-------------------------------------
	cat_dimension(vlst,1) => v_lst'

	(* higher dimensions *)
  rule	Util.list_map(vlst,Values.array_values) => v_lst_lst &
	int_sub(dim,1) => dim' &
	cat_dimension_2(v_lst_lst,dim') => v_lst_lst' &
	Util.list_map(v_lst_lst',Values.make_array) => v_lst' &
	let Values.ARRAY(vlst2)::_ = v_lst' &
	list_length(vlst2) => len &
	ceval_builtin_transpose_2(v_lst',1,len) => v_lst'
	----------------------
	cat_dimension(vlst,dim)  => v_lst'
end


(** relation: cat_dimension_2
 ** author: PA
 **
 ** Helper relation to cat_dimension.
 **)
relation cat_dimension_2: (Values.Value list list, int) 
	  => Values.Value list list =

  rule	Util.list_first(lst) => l_lst &
	list_length(l_lst) => 1 &
	Util.list_map(lst,Util.list_first) => first_lst &
	cat_dimension(first_lst,dim) => first_lst' &
	Util.list_map(first_lst',Util.list_create) => first_lst''
	-----------------------------
	cat_dimension_2(lst ,dim) => first_lst''

  rule	Util.list_map(lst,Util.list_first) => first_lst &
	Util.list_map(lst,Util.list_rest) => rest & 
	cat_dimension(first_lst,dim) => first_lst' &
	cat_dimension_2(rest,dim) => rest' &
	Util.list_thread_map(rest',first_lst',Util.list_cons) => res
	-----------------------------
	cat_dimension_2(lst,dim) => res


end
	

(** relation: ceval_builtin_floor
 ** author: LP
 ** 
 ** evaluates the floor operator.
 **)
relation ceval_builtin_floor : (Env.Env, 
				Exp.Exp list, 
				bool, 
				Interactive.InteractiveSymbolTable option,
				Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' 
        --------------------------------------
        ceval_builtin_floor(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end


(** relation ceval_builtin_ceil
 ** author: LP
 ** 
 ** evaluates the ceil operator.
 **)
relation ceval_builtin_ceil : (Env.Env, 
			       Exp.Exp list, 
			       bool, 
			       Interactive.InteractiveSymbolTable option,
			       Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        real_int rv' => ri &
        int_real ri => rvt &
        real_eq(rvt,rv) => true 
        --------------------------------------
        ceval_builtin_ceil(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        real_int rv' => ri &
        int_add(ri,1) => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_ceil(env,[exp],impl,st,msg) => (Values.REAL(rv''),st)
end


(** relation: ceval_builtin_sqrt
 ** author: LP
 ** 
 ** Evaluates the builtin sqrt operator.
 **)
relation ceval_builtin_sqrt : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option,Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_lt (rv,0.0) => true &
	Error.add_message(Error.NEGATIVE_SQRT,[])
        --------------------------------------
        ceval_builtin_sqrt(env,[exp],impl,st,msg) => fail
        
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sqrt rv => rv' 
        --------------------------------------
        ceval_builtin_sqrt(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end


(** relation ceval_builtin_sin
 ** author: LP
 **
 ** Evaluates the builtin sin function.
 **)
relation ceval_builtin_sin : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sin rv => rv' 
	--------------------------------------
	ceval_builtin_sin(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end


(** relation ceval_builtin_cos
 ** author: LP
 **
 ** Evaluates the builtin cos function.
 **)	    
relation ceval_builtin_cos : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_cos rv => rv' 
	--------------------------------------
	ceval_builtin_cos(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
        
end


(** relation ceval_builtin_tan
 ** author: LP
 **
 ** Evaluates the builtin tan function.
 **)
relation ceval_builtin_tan : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
        
	  (** tan is not implemented in RML for some strange reason. *)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        real_sin rv => sv &
	real_cos rv => cv &
	real_div(sv,cv) => rv' 
	--------------------------------------
	ceval_builtin_tan(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end


(** relation ceval_builtin_asin
 ** author: PA
 **
 ** Evaluates the builtin asin function.
 **)
relation ceval_builtin_asin : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
          
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        System.asin rv => rv' 
	--------------------------------------
	ceval_builtin_asin(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
	
end


(** relation ceval_builtin_acos
 ** author: PA
 **
 ** Evaluates the builtin acos function.
 **)	    
relation ceval_builtin_acos : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
            
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
        System.acos rv => rv' 
	--------------------------------------
	ceval_builtin_acos(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
        
end


(** relation ceval_builtin_atan
 ** author: PA
 **
 ** Evaluates the builtin atan function.
 **)
relation ceval_builtin_atan : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
        
	  (** atan is not implemented in RML for some strange reason. *)
	
  rule	ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
	System.atan(rv) => rv' 
	--------------------------------------
	ceval_builtin_atan(env,[exp],impl,st,msg) => (Values.REAL(rv'),st)
end


(** relation ceval_builtin_div
 ** author: LP
 **
 ** Evaluates the builtin div operator.
 **)
relation ceval_builtin_div : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri &
        int_real ri => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rv''),st)
                 
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
	int_div(ri1,ri2) => ri' 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,msg) 
	  => (Values.INTEGER(ri'),st)
        
  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
	Exp.print_exp_str(exp1) => exp1_str &
	Exp.print_exp_str(exp2) => exp2_str & 
	Error.add_message(Error.DIVISION_BY_ZERO,[exp1_str,exp2_str]) 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,MSG) => fail
	
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
	Exp.print_exp_str(exp1) => lh_str &
	Exp.print_exp_str(exp2) => rh_str &
	Error.add_message(Error.DIVISION_BY_ZERO,[lh_str,rh_str]) 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_div(env,[exp1,exp2],impl,st,NO_MSG) => fail
end


(** relation ceval_builtin_mod
 ** author: LP
 **
 ** Evaluates the builtin mod operator.
 **)
relation ceval_builtin_mod : (Env.Env, Exp.Exp list, bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule  ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	int_real ri2 => rv2 &
	real_div(rv1,rv2) => rva &
	real_floor(rva) => rvb &
	real_mul(rvb,rv2) => rvc &
	real_sub(rv1,rvc) => rvd &
	real_int rvd => ri'
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,msg) => (Values.INTEGER(ri'),st)
        
  rule  ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
	Exp.print_exp_str(exp1) => lhs_str &
	Exp.print_exp_str(exp2) => rhs_str &
	Error.add_message(Error.MODULO_BY_ZERO,[lhs_str,rhs_str]) 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule  ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule  ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
	Exp.print_exp_str(exp1) => lhs_str &
	Exp.print_exp_str(exp2) => rhs_str &
	Error.add_message(Error.MODULO_BY_ZERO,[lhs_str,rhs_str]) 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule  ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_mod(env,[exp1,exp2],impl,st,NO_MSG) => fail
end


(** relation ceval_builtin_max
 ** author: LP
 **
 ** Evaluates the builtin max function.
 **)
relation ceval_builtin_max : (Env.Env, Exp.Exp list, bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule	ceval (env,arr,impl,st,NONE,msg) => (v,_) &
	ceval_builtin_max2(v) => (v')
        --------------------------------------
        ceval_builtin_max(env,[arr],impl,st,msg) => (v',st)

  rule	ceval (env,s1,impl,st,NONE,msg) => (Values.INTEGER(i1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.INTEGER(i2),_) &
	int_max(i1,i2) => i
        --------------------------------------
        ceval_builtin_max(env,[s1,s2],impl,st,msg) => (Values.INTEGER(i),st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.REAL(r1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.REAL(r2),_) &
	real_max(r1,r2) => r
        --------------------------------------
        ceval_builtin_max(env,[s1,s2],impl,st,msg) => (Values.REAL(r),st)

end


(** relation: ceval_builtin_max2
 **
 ** Helper relation to ceval_builtin_max.
 **)
relation ceval_builtin_max2 : (Values.Value) => (Values.Value) =

  rule	ceval_builtin_max2(v1)
	      => (Values.INTEGER(i1)) &
	ceval_builtin_max2(Values.ARRAY(vls)) 
	      => (Values.INTEGER(i2)) &
	int_max(i1,i2) => res
	---------------------
	ceval_builtin_max2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res))

  rule	ceval_builtin_max2(v1) => (Values.REAL(i1)) &
	ceval_builtin_max2(Values.ARRAY(vls)) => (Values.REAL(i2)) &
	real_max(i1,i2) => res
	---------------------
	ceval_builtin_max2(Values.ARRAY(v1::(vls as _::_)))
	  => (Values.REAL(res))

  rule	ceval_builtin_max2(vl) => (v)
	------------------
	ceval_builtin_max2(Values.ARRAY([vl]))
	  => (v)

  axiom	ceval_builtin_max2(Values.INTEGER(i))
	  => (Values.INTEGER(i))

  axiom	ceval_builtin_max2(Values.REAL(i))
	  => (Values.REAL(i))

  rule	print "ceval_builtin_max2 failed\n" 
	------------------------
	ceval_builtin_max2(_)=>fail
end


(** relation: ceval_builtin_min
 ** author: PA
 **
 ** Constant evaluation of builtin min function.
 **)
relation ceval_builtin_min : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	           
  rule  ceval (env,arr,impl,st,NONE,msg) => (v,_) &
	ceval_builtin_min2(v) => (v')
        --------------------------------------
        ceval_builtin_min(env,[arr],impl,st,msg) => (v',st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.INTEGER(i1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.INTEGER(i2),_) &
	int_min(i1,i2) => i
        --------------------------------------
        ceval_builtin_min(env,[s1,s2],impl,st,msg) => (Values.INTEGER(i),st)

  rule  ceval (env,s1,impl,st,NONE,msg) => (Values.REAL(r1),_) &
	ceval (env,s2,impl,st,NONE,msg) => (Values.REAL(r2),_) &
	real_min(r1,r2) => r
        --------------------------------------
        ceval_builtin_min(env,[s1,s2],impl,st,msg) => (Values.REAL(r),st)
end


(** relation: ceval_builtin_min2
 **
 ** Helper relation to ceval_builtin_min.
 **)
relation ceval_builtin_min2 : (Values.Value) => (Values.Value) =

  rule	ceval_builtin_min2(v1) => (Values.INTEGER(i1)) &
	ceval_builtin_min2(Values.ARRAY(vls)) 
	  => (Values.INTEGER(i2)) &
	int_min(i1,i2) => res
	---------------------
	ceval_builtin_min2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.INTEGER(res))

  rule	ceval_builtin_min2(v1) => (Values.REAL(i1)) &
	ceval_builtin_min2(Values.ARRAY(vls)) => (Values.REAL(i2)) &
	real_min(i1,i2) => res
	---------------------
	ceval_builtin_min2(Values.ARRAY(v1::(vls as _::_))) 
	  => (Values.REAL(res))

  rule	ceval_builtin_min2(vl) => (v)
	------------------
	ceval_builtin_min2(Values.ARRAY([vl]))
	  => (v)

  axiom	ceval_builtin_min2(Values.INTEGER(i))
	  => (Values.INTEGER(i))

  axiom	ceval_builtin_min2(Values.REAL(i))
	  => (Values.REAL(i))
end


(** relation ceval_builtin_differentiate
 ** author: LP
 ** 
 ** This relation differentiates an equation: x^2 + x => 2x + 1
 **)		 
 relation ceval_builtin_differentiate : (Env.Env, 
					 Exp.Exp list, 
					 bool, 
					 Interactive.InteractiveSymbolTable option,
					 Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
           
  rule   Derive.differentiate_exp(exp1,cr) => differentiated_exp &
         Exp.simplify(differentiated_exp) => differentiated_exp' &
         (* this is wrong... *)
          Exp.print_exp_str(differentiated_exp') => ret_val
         (* this should be used instead but unelab_exp must be able to unelaborate a complete exp 
           now it doesn't so the expression is returned as string*)
         (*Exp.unelab_exp(differentiated_exp') => absyn_exp *)
         ----------------------------------------------
         ceval_builtin_differentiate(env,[exp1,Exp.CREF(cr,_)],impl,st,msg) 
          => (Values.STRING(ret_val),st) 
           (*           =>  (Values.CODE(Absyn.C_EXPRESSION(absyn_exp)),st) *)

	 
  rule Print.print_buf "#Differentiation failed\n" 
	 ---------------------------------------------------------
	 ceval_builtin_differentiate (_,_,_,st,msg) => fail
 end


(* relation ceval_builtin_simplify
 ** author: LP
 **
 ** this relation simplifies an equation: x^2 + x => 2x + 1
 *)
 relation ceval_builtin_simplify : (Env.Env, 
				    Exp.Exp list, 
				    bool, 
				    Interactive.InteractiveSymbolTable option,
				    Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
           
         
           
  rule  Exp.simplify(exp1) => exp1' &
         Exp.print_exp_str(exp1') => ret_val
         (* this should be used instead but unelab_exp must be able to unelaborate a complete exp *)
         (*Exp.unelab_exp(simplifyd_exp') => absyn_exp *)
         ----------------------------------------------
         ceval_builtin_simplify(env,[exp1],impl,st,msg) 
          => (Values.STRING(ret_val),st) 
           (*           =>  (Values.CODE(Absyn.C_EXPRESSION(absyn_exp)),st) *)

	 
  rule Print.print_buf "#simplification failed\n" 
	 ---------------------------------------------------------
	 ceval_builtin_simplify (_,_,_,st,MSG) => fail
	 
         
 end


(** relation ceval_builtin_rem
 ** author: LP
 **
 ** Evaluates the builtin rem operator
 **)
relation ceval_builtin_rem : (Env.Env, 
			      Exp.Exp list, 
			      bool, 
			      Interactive.InteractiveSymbolTable option,
			      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	  
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_int(rva) => rvai & int_real(rvai) => rva' &
	real_mul(rva',rv2) => rvb &
	real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.REAL(rv2),_) &
	real_div(rv1,rv2) => rva &
	real_int(rva) => rvai & int_real(rvai) => rva' &
	real_mul(rva',rv2) => rvb &
	real_sub(rv1,rvb) => rvd
         --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	ceval (env,exp1,impl,st,NONE,msg) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	real_div(rv1,rv2) => rva &
	real_int(rva) => rvai & int_real(rvai) => rva' &
	real_mul(rva',rv2) => rvb &
	real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.REAL(rvd),st)
        
  rule	
	ceval (env,exp1,impl,st,NONE,msg) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE,msg) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	int_real ri2 => rv2 &
	real_div(rv1,rv2) => rva &
	real_int(rva) => rvai & int_real(rvai) => rva' &
	real_mul(rva',rv2) => rvb &
	real_sub(rv1,rvb) => rvd &
	real_int rvd => ri'
         --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,msg) => (Values.INTEGER(ri'),st)
        
  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
	Exp.print_exp_str(exp1) => exp1_str &
	Exp.print_exp_str(exp2) => exp2_str &
	Error.add_message(Error.REM_ARG_ZERO,[exp1_str,exp2_str]) 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,MSG) => fail
         
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,NO_MSG) => fail

  rule	ceval (env,exp2,impl,st,NONE,MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
	Exp.print_exp_str(exp1) => exp1_str &
	Exp.print_exp_str(exp2) => exp2_str &
	Error.add_message(Error.REM_ARG_ZERO,[exp1_str,exp2_str]) 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,MSG) => fail
        
  rule	ceval (env,exp2,impl,st,NONE,NO_MSG) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true 
        --------------------------------------
        ceval_builtin_rem(env,[exp1,exp2],impl,st,NO_MSG) => fail
end


(** relation ceval_builtin_integer
 ** author: LP
 **
 ** Evaluates the builtin integer operator
 **)
relation ceval_builtin_integer : (Env.Env, Exp.Exp list, bool, 
				  Interactive.InteractiveSymbolTable option,
				  Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	   
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.REAL(rv),_) &
         real_int rv => ri 
         --------------------------------------
         ceval_builtin_integer(env,[exp],impl,st,msg) 
	  => (Values.INTEGER(ri),st)
         
 end


(** relation: ceval_generate_function
 ** 
 **
 ** Generates code for a given function name.
 **)    
relation ceval_generate_function : (Env.Env, Absyn.Path) => () =
	
  rule	Debug.fprintln("ceval", "/*- ceval_generate_function starting*/") &
	ModUtil.path_string2 (path,"_") => pathstr &
	ceval_generate_function_str (path,env,[]) => (gencodestr,_) &
	string_append(pathstr,".c") => filename &
	Print.clear_buf &
        (*
	 string_append("CEVALGENFUNC_", pathstr) => defmacro &
	 Print.print_buf "#ifndef " & Print.print_buf defmacro & Print.print_buf "\n" &
	 Print.print_buf "#define " & Print.print_buf defmacro & Print.print_buf "\n" &
         *)
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf gencodestr &
	Print.print_buf "\nint main(int argc, char** argv)\n" &
	Print.print_buf "{\n\n  if (argc != 3)\n" &
	Print.print_buf "{\n      fprintf(stderr,\"# Incorrect number of arguments\\n\");\n" &
	Print.print_buf "return 1;\n    }\n" &
	Print.print_buf "_" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
        (*
	 Print.print_buf "#endif /*" & Print.print_buf defmacro & Print.print_buf "*/\n" & 
         *)
	Print.write_buf(filename)&
	System.compile_c_file(filename) 
	--------------------------------------
	ceval_generate_function (env, path)
	
	
  rule	Debug.fprint("failtrace","/*- ceval_generate_function failed*/\n")
	-------------------------------------
	ceval_generate_function(_,_) => fail
end


(** relation: ceval_generate_function_str
 **
 ** Generates a function with the given path, and all functions that are called
 **  within that function. The string list contains names of functions already
 ** generated, which won't be generated again 
 **)
relation ceval_generate_function_str : (Absyn.Path, 
					Env.Env, 
					Absyn.Path list) 
	  => (string, Absyn.Path list) =

	(* If getmember succeeds, path is in generated functions list, so do nothing *) 
  rule	Util.list_getmember_p(path, gflist, ModUtil.path_equal) => gfmember 
	--------------------------------------------------------------------
	ceval_generate_function_str (path, env, gflist) => ("",gflist)

	(* If getmember fails, path is not in generated functions list, hence
	 * generate it *) 
  rule	not Util.list_getmember_p(path, gflist, ModUtil.path_equal) => _ &
	Debug.fprintln("ceval", "/*- ceval_generate_function_str starting*/") &
	Lookup.lookup_class(env, path, false) => (cls, env') &
	Debug.fprintln("ceval", "/*- ceval_generate_function_str instantiating*/") &
	Inst.implicit_function_instantiation(env', Types.NOMOD, Prefix.NOPRE, 
					     Connect.empty_set, cls, [], false) => (env'',d) &
	Debug.fprint("ceval", "/*- ceval_generate_function_str getting functions: ") &
	SimCodegen.get_called_functions_in_function (path, DAE.DAE(d)) => calledfuncs &
	Util.list_map(calledfuncs, Absyn.path_string) => debugfuncs &
	Util.string_delimit_list(debugfuncs, ", ") => debugfuncsstr &
	Debug.fprint("ceval", debugfuncsstr) &
	Debug.fprintln("ceval", "*/") &
	ceval_generate_function_str_list (calledfuncs, env, gflist) => (calledfuncsstrs, gflist') &
	Debug.fprint("ceval", "/*- ceval_generate_function_str prefixing dae */") &
	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Print.clear_buf &
	Absyn.path_string path => funcname &
	Util.string_append_list(["/*---FUNC: ", funcname, " ---*/\n\n"]) => funccom &
	Print.print_buf funccom &
	Debug.fprintln("ceval", "/* - ceval_generate_function_str generating functions */") &
	Codegen.generate_functions(d') => libs &
	Print.get_string => thisfuncstr &
	Util.list_append_elt(thisfuncstr, calledfuncsstrs) => calledfuncsstrs' &
	Util.string_delimit_list(calledfuncsstrs', "\n\n") => resstr
	---------------------------------------------------------------------------
	ceval_generate_function_str (path, env, gflist) => (resstr, path::gflist)


  rule	Debug.fprint("failtrace","/*- ceval_generate_function_str failed*/\n")
	-------------------------------------
	ceval_generate_function_str(_,_,_) => fail

end


(** relation: ceval_generate_function_str_list
 **
 ** Generates code for several functions.
 **)
relation ceval_generate_function_str_list : (Absyn.Path list, 
					     Env.Env, 
					     Absyn.Path list) 
	  => (string list, Absyn.Path list) =

  axiom	ceval_generate_function_str_list ([],env,gflist) => ([], gflist)

  rule	ceval_generate_function_str (first,env,gflist) => (firststr,gflist') &
	ceval_generate_function_str_list (rest,env,gflist') => (reststr,gflist'')
	-------------------------------------------------------------------------
	ceval_generate_function_str_list (first::rest, env, gflist) => (firststr::reststr, gflist'')
end


(** relation ceval_builtin_diagonal
 **
 ** This relation generates a matrix[n,n] (A) of the vector {a,b,...,n}
 ** where the diagonal of A is the vector {a,b,...,n}
 ** ie A[1,1] == a, A[2,2] == b ...
 *)
relation ceval_builtin_diagonal : (Env.Env, 
				   Exp.Exp list, 
				   bool, 
				   Interactive.InteractiveSymbolTable option,
				   Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	   
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.ARRAY(rv2),_) &
	 list_length(rv2) => dimension &
	 
	 int_add(dimension,1) => correctDimension &
	 ceval_builtin_diagonal2(env,exp,impl,st,correctDimension,1, [],msg) =>
         retExp &
	 
   	 int_string dimension => dimensionString &
   	 Debug.fcall("ceval", Print.print_buf, "== dimensionString ") & 
   	 Debug.fcall("ceval", Print.print_buf, dimensionString) & 
   	 Debug.fcall("ceval", Print.print_buf, "\n")    	
	 --------------------------------------
	 ceval_builtin_diagonal(env,[exp],impl,st,msg) 
	  => (Values.ARRAY(retExp),st)
	 
	 
  rule  Print.print_error_buf "#Error, could not evaulate diagonal.\n"
	 ---------------------------------------------------------
	 ceval_builtin_diagonal (_,_,_,_,MSG) => fail
         
 end


(** relation: ceval_builtin_diagonal2
 ** 
 **  This is a help relation that is calling itself recursively to 
 **  generate the a nxn matrix with some special diagonal elements. 
 ** see ceval_builtin_diagonal 
 **
 ** signature : (Env.Env, 
				    Exp.Exp, 
				    bool, 
				    Interactive.InteractiveSymbolTable option, 
				    int, /* matrix dimension */
				    int,  /* row */
				    Values.Value list,
				    Msg) 
	  =>  Values.Value list 
 **)
relation ceval_builtin_diagonal2 : (Env.Env, 
				    Exp.Exp, 
				    bool, 
				    Interactive.InteractiveSymbolTable option, 
				    int, 
				    int,  
				    Values.Value list,
				    Msg) 
	  =>  Values.Value list =

  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.REAL(rv2),_) &

	int_sub(matrixDimension , 1) => correctDim &
	Util.list_fill(Values.REAL(0.0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.REAL(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow,[Values.ARRAY(listWithElement)],msg ) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  [], msg ) 
	  =>  retExp

        
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.REAL(rv2),_) &

	not matrixDimension = row &
	int_sub(matrixDimension, 1) => correctDim &
	Util.list_fill(Values.REAL(0.0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.REAL(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	list_append(listIN,[Values.ARRAY(listWithElement)]) => appendedList &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow, appendedList, msg) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  listIN, msg ) 
	  => retExp
	
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.INTEGER(rv2),_) &

	int_sub(matrixDimension , 1) => correctDim &
	Util.list_fill(Values.INTEGER(0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.INTEGER(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow,[Values.ARRAY(listWithElement)] ,msg) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  [],msg ) =>  retExp

        
  rule	ceval (env,Exp.ASUB(s1,row),impl,st,NONE,msg) => (Values.INTEGER(rv2),_) &

	not matrixDimension = row &
	int_sub(matrixDimension, 1) => correctDim &
	Util.list_fill(Values.INTEGER(0),correctDim) => zeroList &
	
	
	int_sub(row , 1) => correctPlace &
	Util.list_replaceat(Values.INTEGER(rv2), correctPlace, zeroList) => listWithElement &

	int_add(row,1) => newRow &
	list_append(listIN,[Values.ARRAY(listWithElement)]) => appendedList &
	ceval_builtin_diagonal2(env,s1,impl,st,matrixDimension,newRow, appendedList,msg ) => retExp
	--------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row,  listIN,msg ) => retExp

        
  rule	matrixDimension = row
        --------------------------------------------------
	ceval_builtin_diagonal2 (env,s1,impl,st,matrixDimension,row, listIN,msg) => listIN
	


  rule  print"#-- ceval_builtin_diagonal2: Couldn't elaborate ceval_builtin_diagonal2()\n" &
 	int_string row => RowString &
	int_string matrixDimension => matrixDimensionString
	---------------------------------------------------------
	ceval_builtin_diagonal2 (_,_,_,_,matrixDimension,row,list,MSG) => fail

end


(** relation ceval_builtin_transpose
 **
 ** This relation transposes the two first dimension of an array A.
 *)
relation ceval_builtin_transpose : (Env.Env, 
				   Exp.Exp list, 
				   bool, 
				   Interactive.InteractiveSymbolTable option,
				   Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =
	   
  rule  ceval (env,exp,impl,st,NONE,msg) => (Values.ARRAY(vlst),_) &
	let Values.ARRAY(vlst2)::_ = vlst &
	list_length(vlst2) => dim1 &
	ceval_builtin_transpose_2(vlst,1,dim1) => vlst' 
	 --------------------------------------
	 ceval_builtin_transpose(env,[exp],impl,st,msg) 
	  => (Values.ARRAY(vlst'),st)
	 
	 
  rule  Print.print_error_buf "#Error, could not evaulate transpose.\n"
	 ---------------------------------------------------------
	 ceval_builtin_transpose (_,_,_,_,MSG) => fail
         
 end

(** relation: ceval_builtin_transpose_2
 ** author: PA
 **
 ** Helper relation to ceval_builtin_transpose
 **
 ** signature: (Values.Value list, 
				    int /* index */,
				    int) /* dim1 */
	  => Values.Value list 
 **)
relation ceval_builtin_transpose_2: (Values.Value list, 
				    int,
				    int)
	  => Values.Value list =

  rule	int_le(indx,dim1) => true &
	Util.list_map_1(vlst,Values.nth_arrayelt,indx) => transposed_row &
	int_add(indx,1) => indx' &
	ceval_builtin_transpose_2(vlst,indx',dim1) => rest
	---------------------------
	ceval_builtin_transpose_2(vlst,indx,dim1) 
	  => Values.ARRAY(transposed_row)::rest

  axiom ceval_builtin_transpose_2(_,_,_) => []
end


(** relation: ceval_builtin_size_matrix
 **
 ** Helper relation for ceval_builtin_size, for size(A) where 
 ** A is a matrix.
 **)
relation ceval_builtin_size_matrix : (Env.Env, 
				      Exp.Exp, 
				      bool, 
				      Interactive.InteractiveSymbolTable option,
				      Msg) 
	  => (Values.Value, Interactive.InteractiveSymbolTable option) =

  rule	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,Exp.CREF(cr,tp),impl,st,msg) 
	  => (v,st)

  rule	ceval(env,exp,impl,st,NONE,msg) => (v,st') &
	Types.type_of_value(v) => tp &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,exp,impl,st,msg) 
	  => (v,st)
end


(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)
 relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	 -----------------------------------------
	 ceval_relation (v1, Exp.GREATER(t), v2) => v

	 (**  Integers *)
  rule	int_lt (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.LESS(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)
  rule	int_le (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.LESSEQ(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b) 
  rule	int_ge (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.GREATEREQ(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b) 

  rule	int_eq (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.EQUAL(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	 -------------------
	 ceval_relation (Values.INTEGER(i1),
			 Exp.NEQUAL(Exp.INT),
			 Values.INTEGER(i2)) => Values.BOOL(b)

	 (**  Reals *)
  rule	real_lt (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.LESS(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_le (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.LESSEQ(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ge (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.GREATEREQ(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.EQUAL(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	 -------------------
	 ceval_relation (Values.REAL(i1),
			 Exp.NEQUAL(Exp.REAL),
			 Values.REAL(i2)) => Values.BOOL(b)

	 (* Booleans *)
  rule	(* b1 != b2  == (b1 and not b2) or (not b1 and b2) *)
	 bool_not b1 => nb1 &
	 bool_not b2 => nb2 &
	 bool_and(b1,nb2) => ba &
	 bool_and(nb1,b2) => bb &
	 bool_or(ba,bb) => b
	 -------------------------------------
	 ceval_relation (Values.BOOL(b1),
		 	 Exp.NEQUAL(Exp.BOOL),
			 Values.BOOL(b2)) => Values.BOOL(b)
       
  rule	(* b1 == b2  ==> b1 and b2 or (not b1 and not b2) *)
 	 bool_not b1 => nb1 &
	 bool_not b2 => nb2 &
	 bool_and(b1,b2) => ba &
	 bool_and(nb1,nb2) => bb &
	 bool_or(ba,bb) => b
	 -------------------------------------
	 ceval_relation (Values.BOOL(b1),
		 	 Exp.EQUAL(Exp.BOOL),
			 Values.BOOL(b2)) => Values.BOOL(b)

  axiom	ceval_relation (Values.BOOL(false),
		 	 Exp.LESS(Exp.BOOL),
			 Values.BOOL(true)) => Values.BOOL(true)

  axiom	ceval_relation (Values.BOOL(_),
		 	 Exp.LESS(Exp.BOOL),
			 Values.BOOL(_)) => Values.BOOL(false)

  rule	Debug.fprint("failtrace", "- ceval_relation failed\n")
	 & print "-ceval_relation failed\n" 
	 ---------------------------------
	 ceval_relation (_,_,_) => fail
	 
end


(** relation: ceval_range
 **
 ** This re-lation evaluates a range expression.  It only handles integers.
 **)		 
relation ceval_range : (int, int, int) => Values.Value list =
	
  rule	(* e.g. 1:1 => {1} *)
	int_eq(start,stop) => true 
	------------------
	ceval_range(start,_,stop) => [Values.INTEGER(start)]
	
  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	int_gt(j,k) => b1 &
	int_gt(d,0) => b2 &
	bool_and(b1,b2) => c1 &
	int_lt(j,k) => b3 &
	int_lt(d,0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range(j,d,k) => []
	
  rule	ceval_range2(start,step,stop) => res
	-----------------------------------
	ceval_range (start, step, stop) => res
	
end


(** relation: ceval_range2
 **
 ** Helper relation to ceval_range.
 **)
relation ceval_range2: (int,int,int) => Values.Value list =
	
  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range2 (start,_,stop) => []	
	
  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range2 (next, step, stop) => l
	-----------------------------------
	ceval_range2 (start, step, stop) => Values.INTEGER(start)::l
end



(** relation: ceval_range_real
 **
 ** This relation evaluates a range expression.  It only handles reals
 **)		 
 relation ceval_range_real : (real, real, real) => Values.Value list =
	 
  rule	(* e.g. 1:1 => {1} *)
	 real_eq(start,stop) => true 
	 ------------------
	 ceval_range_real(start,_,stop) => [Values.REAL(start)]
	 
  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	 real_gt(j,k) => b1 &
	 real_gt(d,0.0) => b2 &
	 bool_and(b1,b2) => c1 &
	 real_lt(j,k) => b3 &
	 real_lt(d,0.0) => b4 &
	 bool_and(b3,b4) => c2 &
	 bool_or(c1,c1) => true
	 -----------------------------
	 ceval_range_real(j,d,k) => []
	 
  rule	ceval_range_real2(j,d,k)=> res
	 -----------------------------------
	 ceval_range_real (j,d,k) => res
  end


(** relation: ceval_range_real2
 **
 ** Helper relation to ceval_range_real.
 **)
relation ceval_range_real2 : (real, real, real) => Values.Value list =
	
  rule	real_gt(start,stop) => true
	  --------------------------
	  ceval_range_real2 (start,_,stop) => []

  rule	real_gt(start,stop) => false & (* redundant *)
	  real_add (start, step) => next &
	  ceval_range_real2 (next, step, stop) => l 	
	  -----------------------------------
	  ceval_range_real2 (start, step, stop) => Values.REAL(start)::l
  end


(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)
 relation ceval_list : (Env.Env, 
			Exp.Exp list, 
			bool, 
			Interactive.InteractiveSymbolTable option,
			Msg) 
	  => Values.Value list =

  axiom	ceval_list (env, [], _, _,msg) => []

  rule	ceval (env, exp,impl,st,NONE,msg) => (v,_)
	 ----------------------------
	 ceval_list (env, [exp],impl,st,msg) => [v]

  rule	ceval (env,exp,impl,st,NONE,msg) => (v,_) &
	 ceval_list (env, exps,impl,st,msg) => vs
	 ------------------------------
	 ceval_list (env, exp::exps,impl,st,msg) => v::vs

 end


(** relation: ceval_cref
 **
 ** Evaluates ComponentRef, i.e. variables, by looking up variables in the
 ** environment.
 **
 ** signature: (Env.Env, Exp.ComponentRef, bool, /*impl*/ Msg) 
	  => Values.Value
 **)
relation ceval_cref : (Env.Env, Exp.ComponentRef, bool, Msg) 
	  => Values.Value =

	  (* Search in env for binding. *)
  rule	Lookup.lookup_var (env, c) => (attr,ty,binding) &
	ceval_cref_binding (env,c,binding,impl,msg) => v
	-------------------------------------
	ceval_cref (env,c,impl,msg) => v 

  rule	not Lookup.lookup_var (env, c) => (_,_,_) &
	Env.print_env_path_str(env) => scope_str &
	Exp.print_component_ref_str c => str &
	Error.add_message(Error.LOOKUP_VARIABLE_ERROR,[str,scope_str])
	-------------------------------------
	ceval_cref (env,c,impl as false ,MSG) => fail

  rule	not Lookup.lookup_var (env, c) => (_,_,_) 
	-------------------------------------
	ceval_cref (env,c,impl as false ,NO_MSG) => fail

	 (* No binding found. *)
  rule	Exp.print_component_ref_str c => str &
	Env.print_env_path_str(env) => scope_str &
	Error.add_message(Error.NO_CONSTANT_BINDING,[str,scope_str])
	-------------------------------------
	ceval_cref (env,c,impl as false, MSG) => fail

(*  rule	print "ceval_cref failed\n" 
	---------------
	ceval_cref(_,_,_,_) => fail*)
	
end 


(** relation: ceval_cref_binding
 **
 ** Helper relation to ceval_cref. Evaluates varaibles by evaluating 
 ** their bindings.
 **
 ** signature: ceval_cref_binding : (Env.Env, Exp.ComponentRef,
			       Types.Binding, 
			       bool, /*impl*/
			       Msg) 
	  => Values.Value
 **)
relation ceval_cref_binding : (Env.Env, Exp.ComponentRef,
			       Types.Binding, 
			       bool,  
			       Msg) 
	  => Values.Value =
	  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr'(*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,v, sizelst,impl,msg) => res
	-----------------------------------------
	ceval_cref_binding (env,cr (*Exp.CREF_IDENT(id,subsc)*),Types.VALBOUND(v),impl,msg)
	  => res
	  
  rule	Print.print_buf "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND,impl as false,MSG) => fail
	
  rule	Debug.fprint("ceval", "#- ceval_cref__binding: Ignoring unbound when implicit")	
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND,impl as true,MSG) => fail
	
	(* REDUCTION bindings*)
  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	rfn = "array" &
	Debug.fprintln("ceval", "#-- ceval_cref_binding Array evaluation")
	---------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,_,Types.C_CONST),impl,MSG)
	  => fail
	  
	  (* REDUCTION bindings*)
  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	not rfn = "array" &
	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr' (*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value (env,subsc,v,sizelst,impl,msg) => res
	---------------------------
	ceval_cref_binding (env,cr(*Exp.CREF_IDENT(id,subsc)*),Types.EQBOUND(exp,_,Types.C_CONST),impl,msg)
	  => res

	(* arbitrary expressions, C_VAR, value exists. *)  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr'(*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,e_val,sizelst,impl,msg) => res 
	----------------------------------------------------------
	ceval_cref_binding (env,cr (*Exp.CREF_IDENT(id,subsc)*),Types.EQBOUND(exp,SOME(e_val),Types.C_VAR),impl,msg) 
	  => res

	(* arbitrary expressions, C_PARAM, value exists. *)  
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr'(*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,e_val,sizelst,impl,msg) => res 
	----------------------------------------------------------
	ceval_cref_binding (env,cr(*Exp.CREF_IDENT(id,subsc)*),Types.EQBOUND(exp,SOME(e_val),Types.C_PARAM),impl,msg) 
	  => res

	  (* arbitrary expressions. When binding has optional value. *)
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr'(*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value(env,subsc,v,sizelst,impl,msg) => res
	------------------------
	ceval_cref_binding (env,cr(*Exp.CREF_IDENT(id,subsc)*),Types.EQBOUND(exp,_,Types.C_CONST),impl,msg) 
	  => res

	  (* arbitrary expressions. When binding has optional value. *)
  rule	(* lookup without subscripts, so dimension sizes can be determined.*)
	Exp.cref_strip_last_subs(cr) => cr' & 
	Exp.cref_last_subs(cr) => subsc &
	Lookup.lookup_var(env,cr'(*Exp.CREF_IDENT(id,[])*))  => (_,tp,_) &
	Types.get_dimension_sizes(tp) => sizelst &

	ceval (env,exp,impl,NONE,NONE,msg) => (v,_) &
	ceval_subscript_value(env,subsc,v,sizelst,impl,msg) => res
	------------------------
	ceval_cref_binding (env,cr(*Exp.CREF_IDENT(id,subsc)*),Types.EQBOUND(exp,_,Types.C_PARAM),impl,msg) 
	  => res
	  
  rule	
	Debug.fprint("ceval", "#- ceval_cref__binding failed (nonconstant EQBOUND(") &
	Exp.print_exp_str exp => expstr &
	Debug.fprint("ceval", expstr) &
	Debug.fprintln("ceval", "))") 
	--------------------------------
	ceval_cref_binding (env,_,Types.EQBOUND(exp,_,Types.C_VAR),impl,MSG) => fail


  rule	Exp.print_component_ref_str e1  => s1 &
	Exp.print_exp_str exp => s2 &
	Util.string_append_list(["-ceval_cref_binding : ",s1," = ",s2," failed\n"]) => str &
	Debug.fprint("failtrace", str) 
	----------------------
	ceval_cref_binding(_,e1,Types.EQBOUND(exp,_,_),_,_) => fail
end


(** relation: ceval_subscript_value
 **
 ** Helper relation to ceval_cref_binding, applies subscrupts to array values
 ** to extract array elements.
 **
 ** signature: (Env.Env,
				 Exp.Subscript list, /* subscript to extract*/
				 Values.Value, 
				 int list, /* dimension sizes */
				 bool, /*impl*/
				 Msg) 
	  => Values.Value
 **)
relation ceval_subscript_value: (Env.Env,
				 Exp.Subscript list, 
				 Values.Value, 
				 int list, 
				 bool, 
				 Msg) 
	  => Values.Value =

  rule	ceval(env,exp,impl,NONE,SOME(dim),msg) => (Values.INTEGER(n),_) &
	int_sub(n,1) => n' &
	list_nth(lst,n') => subval &
	ceval_subscript_value(env,subs,subval,dims,impl,msg) => res
	---------------------------------------------
	ceval_subscript_value(env,Exp.INDEX(exp)::subs,Values.ARRAY(lst), dim::dims,impl,msg) 
	  => res
	  
  axiom	ceval_subscript_value(env,[],v,_,_,_) => v
	
  rule	Debug.fprint("failtrace","-ceval_subscript_value failed\n") 
	-----------------------
	ceval_subscript_value(_,_,_,_,_,_) => fail
end


(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **
 ** signature: (Env.Env, Exp.Subscript list, int list, 
			     bool, /*impl*/
			     Msg)
	  => Exp.Subscript list
 **)
relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list, 
			     bool,  
			     Msg)
	  => Exp.Subscript list =
	  
  axiom	ceval_subscripts (_,[],_,_,_) => []
	
  rule	ceval_subscript (env,sub,dim,impl,msg) => sub' &
	ceval_subscripts (env,subs,dims,impl,msg) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs,dim::dims,impl,msg) => (sub'::subs')
	
end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **
 ** signature: (Env.Env, Exp.Subscript, int, 
			    bool, /*impl*/ 
			    Msg) => Exp.Subscript
 **)
relation ceval_subscript : (Env.Env, Exp.Subscript, int, 
			    bool,  
			    Msg) => Exp.Subscript =
	
  axiom	ceval_subscript (env, Exp.WHOLEDIM,_,_,_) => Exp.WHOLEDIM
	
  rule	
	ceval (env, e1,impl,NONE,SOME(dim),msg) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1),dim,impl,msg) => Exp.INDEX(e1')
	
  rule	ceval (env, e1,impl,NONE,SOME(dim),msg) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1),dim,impl,msg) => Exp.SLICE(e1')
 end

