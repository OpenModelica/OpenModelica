(*
This file is part of OpenModelica.

Copyright (c) 1998-2005, Linköpings universitet, Department of
Computer and Information Science, PELAB

All rights reserved.

(The new BSD license, see also
http://www.opensource.org/licenses/bsd-license.php)


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in
  the documentation and/or other materials provided with the
  distribution.

* Neither the name of Linköpings universitet nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*)

(**
 ** file:	 DumpGraphviz.rml
 ** module:      DumpGraphviz
 ** description: Dumps the AST to a graph representation that can be read
 **		 by the graphviz tool.
 **
 ** RCS: $Id$
 **
 **)


module DumpGraphviz:

  with "Absyn.rml"
  with "Debug.rml"
  with "Graphviz.rml"

  type Ident = string
  type Node = Graphviz.Node

  (* Dump routines for debugging of AST *)
  relation dump: Absyn.Program => ()
end




with "ClassInf.rml"
with "Dump.rml"

(* Relations *)


(** relation: dump
 **
 ** Dumps a Program to a Graphviz graph.
 **)
relation dump : Absyn.Program => () =
	
  rule	(* print "> Beginning of rule dump\n" & *)
	build_graphviz(p) => r &
	Graphviz.dump(r)
	(* & print "> End of rule dump\n" *)
	----------------------
	dump p 
end

(** relation: build_graphviz
 **
 ** Build the graphviz graph for a Program.
 **)
relation build_graphviz : Absyn.Program => Node =

  rule	(* print "> Beginning of rule build_graphviz\n" & *)
	print_classes cs => nl
	(* & print "> End of rule build_graphviz\n" *)
	----------------------
	build_graphviz(Absyn.PROGRAM(cs,_)) => Graphviz.NODE("ROOT",[],nl)
end

(** relation: print_classes
 **
 ** Creates Nodes from a Class list.
 **)
relation print_classes : Absyn.Class list => Node list =

  axiom	print_classes [] => []

  rule	(* print "> Beginning of rule print_classes\n" & *)
	print_class c => node &
	print_classes cs => nl
	(* & print "> End of rule print_classes\n" *)
	-----------------------
	print_classes c::cs => node::nl

end

(** relation: print_class
 **
 ** Creates a Node for a Class.
 **)
relation print_class: Absyn.Class => Node =

  rule	(* print "> Beginning of rule print_class\n" & *)
	Absyn.restr_string r => rs &
	print_parts parts => nl
	(* & print "> End of rule print_class\n" *)
	-----------------------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,_),_)) => Graphviz.NODE(rs,[],nl)

end

(** relation: print_parts
 **
 ** Creates a Node list from a ClassPart list.
 **)
relation print_parts : Absyn.ClassPart list => Node list =

  axiom print_parts [] => []
	
  rule	print_class_part(c) => node &
	print_parts cs => nl
	-----------------------------
	print_parts c::cs => node::nl
end

(** relation: print_class_part
 ** 
 ** Creates a Node from A ClassPart.
 **)
relation print_class_part: Absyn.ClassPart => Node =

  rule	print_elementitems el => nl
	-----------------------
	print_class_part(Absyn.PUBLIC(el)) => Graphviz.NODE("PUBLIC",[],nl)


  rule	print_elementitems el => nl
	-----------------------
	print_class_part(Absyn.PROTECTED(el)) => Graphviz.NODE("PROTECTED",[],nl)


  rule	print_equations eqs => nl
	------------------------
	print_class_part(Absyn.EQUATIONS(eqs)) => Graphviz.NODE("EQUATIONS",[],nl)

  rule	print_algorithms eqs => nl
	------------------------
	print_class_part(Absyn.ALGORITHMS(eqs)) => Graphviz.NODE("ALGORITHMS",[],nl)

  rule	(* print "> Error in print_class_part\n" *)
	print ""
	---------------------------------
	print_class_part(_) => Graphviz.NODE("PART_ERROR",[],[])
end


(** relation: print_elementitems
 **
 ** Creates a Node list from ElementItem list.
 **)
relation print_elementitems: Absyn.ElementItem list => Node list =

  axiom	print_elementitems [] => []

  rule	print_elementitems el => nl
	-----------------------------
	print_elementitems (Absyn.ANNOTATIONITEM(_)::el) => nl

  rule	print_element e => node &
	print_elementitems el => nl
	--------------------------
	print_elementitems (Absyn.ELEMENTITEM(e)::el) => node::nl
end

(** relation: make_bool_attr
 **
 ** Create an Attribute from a bool value and a description string.
 **)
relation make_bool_attr: (string,bool) => Graphviz.Attribute =

  rule	Dump.select_string(flag,"true","false") => s
	---------------------------------------
	make_bool_attr (str,flag) => Graphviz.ATTR(str,s)

end

(** relation: make_leaf
 **
 ** Create a leaf Node from a string an a list of attributes.
 **)
relation make_leaf: (string, Graphviz.Attribute list) => Node =

  axiom	make_leaf (str, al) => Graphviz.NODE(str,al,[])

end

(** relation: print_element
 **
 ** Create a Node from an Element.
 **)
relation print_element: Absyn.Element => Node =

  rule	(* print "> Beginning of rule print_element\n" & *)
	make_bool_attr("final",final) => fa &
	print_elementspec spec => elsp
	(* & print "> End of rule print_element\n" *)
	------------------
	print_element (Absyn.ELEMENT(final,_,_,_,spec,_,_)) => Graphviz.NODE("ELEMENT",[fa],[elsp])

end

(** relation print_path
 **
 ** Create a Node from a Path.
 **)
relation print_path: Absyn.Path => Node =

  rule	Absyn.path_string p => s &
	make_leaf(s,[]) => pn
	--------------------
	print_path p => pn
end

(** relation: print_elementspec
 **
 ** Create a Node from an ElementSpec
 **)
relation print_elementspec: Absyn.ElementSpec => Node =

  rule	print_class cl => nl &
	make_bool_attr("replaceable",repl) => ra
	--------------------
	print_elementspec(Absyn.CLASSDEF(repl, cl)) => Graphviz.NODE("CLASSDEF",[ra],[])

  rule	print_path p => en
	---------------------------------
	print_elementspec(Absyn.EXTENDS(p, l)) => Graphviz.NODE("EXTENDS",[],[en])

  rule	print_path(p) => pn &
	print_components(cs) => cns
	--------------------------
	print_elementspec(Absyn.COMPONENTS(attr,p,cs)) => Graphviz.NODE("COMPONENTS",[],pn::cns)

  rule	print ""
	--------
	print_elementspec(_) => Graphviz.NODE("ELSPEC_ERROR",[],[])
end

(** relation: print_components
 **
 ** Create a Node list from a ComponentItem list.
 **)
relation print_components: Absyn.ComponentItem list => Node list =

  axiom	print_components [] => []

  rule	print_componentitem c => n &
	print_components cs => nl
	-------------------------
	print_components c::cs => n::nl

end


(** relation: print_componentitem
 **
 ** Create a Node from a ComponentItem.
 **)
relation print_componentitem: Absyn.ComponentItem => Node =

  rule	print "" &
	let nn = Graphviz.NODE(n,[],[]) 
	--------
	print_componentitem(Absyn.COMPONENTITEM(Absyn.COMPONENT(n,a,m),_,_)) => Graphviz.LNODE("COMPONENT",[n],[],[nn])
end

(** relation: print_equations
 ** 
 ** Create a Node list from an EquationItem list.
 **)
relation print_equations: Absyn.EquationItem list => Node list =

  axiom	print_equations [] => []

  rule	print_equation eq => node &
	print_equations el => nl
	--------------------------
	print_equations Absyn.EQUATIONITEM(eq,ann)::el => node::nl
	
end

(** relation: print_equation
 **
 **Create a Node from an Equation.
 **) 
relation print_equation: Absyn.Equation => Node =

  rule	Dump.print_exp_str e1 => s1 &
	Dump.print_exp_str e2 => s2 &
	string_append (s1, " = ") => s &
	string_append (s, s2) => s'
	---------------------------
	print_equation (Absyn.EQ_EQUALS(e1,e2)) => Graphviz.LNODE("EQ_EQUALS",[s'],[],[])

  rule	Dump.print_component_ref_str c1 => s1 &
	Dump.print_component_ref_str c2 => s2 &
	string_append ("connect(", s1) => s &
	string_append (s, s2) => s' &
	string_append (s', ")") => s''
	---------------------------
	print_equation (Absyn.EQ_CONNECT(c1,c2)) => Graphviz.LNODE("EQ_CONNECT",[s''],[],[])

  rule	print_equations eqs => eqn &
	Dump.print_exp_str e => es
	------------------------
	print_equation (Absyn.EQ_FOR(n,e,eqs)) => Graphviz.LNODE("EQ_FOR",[n,es],[],eqn)

  axiom	print_equation (_) => Graphviz.NODE("EQ_ERROR",[],[])

end

(** relation: print_algorithms
 **
 ** Create a Node list from an AlgorithmItem list.
 **)
relation print_algorithms: Absyn.AlgorithmItem list => Node list =

  axiom	print_algorithms [] => []

  rule	print_algorithmitem e => node &
	print_algorithms el => nl
	--------------------------
	print_algorithms e::el => node::nl
	
end

(** relation: print_algorithmitem
 **
 ** Create a Node from an AlgorithmItem.
 **)
relation print_algorithmitem: Absyn.AlgorithmItem => Node =
	
  rule	print_algorithm (alg) => node
	---------------------------------
	print_algorithmitem (Absyn.ALGORITHMITEM(alg,_)) => node

  axiom	print_algorithmitem (_) => Graphviz.NODE("ALG_ERROR",[],[])
end

(** relation: print_algorithm
 **
 ** Create a Node from an Algorithm.
 **)
relation print_algorithm: Absyn.Algorithm => Node =

  rule	print "" 
	------------------
	print_algorithm (Absyn.ALG_ASSIGN(cr,e)) => Graphviz.NODE("ALG_ASSIGN",[],[])

  rule	print ""
	--------
	print_algorithm (_) => Graphviz.NODE("ALG_ERROR",[],[])
end

(** relation: variability_symbol
 **
 ** Return Variability as a string.
 **)
relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => ""
  axiom	variability_symbol(Absyn.DISCRETE) => "DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "PARAM"
  axiom	variability_symbol(Absyn.CONST) => "CONST"

end

(** relation: direction_symbol
 **
 ** Return direction as a string.
 **)
relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => ""
  axiom	direction_symbol(Absyn.INPUT) => "INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "OUTPUT"

end

