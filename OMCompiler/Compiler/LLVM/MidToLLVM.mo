/*
 * This file is part of OpenModelica.
 *
 * Copyright (c) 1998-2018, Open Source Modelica Consortium (OSMC),
 * c/o Linköpings universitet, Department of Computer and Information Science,
 * SE-58183 Linköping, Sweden.
 *
 * All rights reserved.
 *
 * THIS PROGRAM IS PROVIDED UNDER THE TERMS OF GPL VERSION 3 LICENSE OR
 * THIS OSMC PUBLIC LICENSE (OSMC-PL) VERSION 1.2.
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THE OSMC PUBLIC LICENSE OR THE GPL VERSION 3,
 * ACCORDING TO RECIPIENTS CHOICE.
 *
 * The OpenModelica software and the Open Source Modelica
 * Consortium (OSMC) Public License (OSMC-PL) are obtained
 * from OSMC, either from the above address,
 * from the URLs: http://www.ida.liu.se/projects/OpenModelica or
 * http://www.openmodelica.org, and in the OpenModelica distribution.
 * GNU version 3 is obtained from: http://www.gnu.org/copyleft/gpl.html.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without
 * even the implied warranty of  MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE, EXCEPT AS EXPRESSLY SET FORTH
 * IN THE BY RECIPIENT SELECTED SUBSIDIARY LICENSE CONDITIONS OF OSMC-PL.
 *
 * See the full OSMC Public License conditions for more details.
 *
 */



encapsulated package MidToLLVM
" file:        MidToLLVM.mo
  package:     MidToLLVM
  description: Traverses MidCode and calls functions defined in EXT_LLVM
               this functions constructs an in memory representation of LLVM bitcode.
  author: @johti
"
import Absyn;
import AbsynUtil;
import Array;
import CodegenUtil.{underscorePath,dotPath};
import DAE;
import DAEUtil;
import EXT_LLVM;
import ExecStat.{execStat,execStatReset};
import Flags;
import MidCode;
import MidCodeUtil;
import MidToLLVMUtil;
import SimCode;
import SimCodeFunction;
import Tpl.{Text,textString}; //To convert underScorePath to strings.
import Util;
import DAEToMid;
protected
/*Integers to represent the different types generated by MidToLLVM.mo*/
constant Integer MODELICA_UNKNOWN = 0;
constant Integer MODELICA_INTEGER = 1;
constant Integer MODELICA_BOOLEAN = 2;
constant Integer MODELICA_REAL = 3;
constant Integer MODELICA_METATYPE = 4 "Strings and metatypes are treated the same.";
constant Integer MODELICA_TUPLE = 5 "Meta tuples and tuples are treated the same.";
constant Integer MODELICA_VOID = 6;
constant Integer MODELICA_INTEGER_PTR = 11;
constant Integer MODELICA_BOOLEAN_PTR = 22;
constant Integer MODELICA_REAL_PTR = 33;
constant Integer MODELICA_METATYPE_PTR = 44;
constant Integer MODELICA_TUPLE_PTR = 55;
public
function JIT
  input MidCode.Function functionToBeCalled;
  input list<Values.Value> valLst;
  output Values.Value newval;
 protected
  constant String FUNCTION_NAME = "omc_" + textString(underscorePath(Tpl.MEM_TEXT({},{}),functionToBeCalled.name));
  constant String VAL_LST = "valLst";
  constant String TOP_LEVEL_EXPRESSION = "top_level_expression";
  constant String THREAD_DATA = "threadData";
  Values.Value res "The resulting Values.Value";
  list<MidCode.Var> functionArgs "The actual function arguments deduced from functionArgsTS";
  list<String> valFuncArgs "Represents both Value.Values objects and typedescs";
  list<MidCode.Var> mmcVars "The variables that will be assigned by the mk-functions";
  list<MidCode.Var> valuePTRVars;
algorithm
  /* Generate top level entry. Two arguments, threadData and valLst*/
  EXT_LLVM.startFuncGen(TOP_LEVEL_EXPRESSION);
  EXT_LLVM.genFunctionArg(MODELICA_METATYPE,"valLst");
  if listLength(functionToBeCalled.outputs) >= 1 then
    EXT_LLVM.genFunctionType(MODELICA_METATYPE);
  else
    EXT_LLVM.genFunctionType(MODELICA_VOID);
  end if;
  genFunctionPrototype(TOP_LEVEL_EXPRESSION);
  EXT_LLVM.genFunctionBody(TOP_LEVEL_EXPRESSION);
  /*Create the variables to be sent to the function*/
  functionArgs := MidToLLVMUtil.valLstToMidVarLst(valLst);
  List.map_0(functionArgs,genAllocaLLVMInstForVar);
  /*Convert the values to a list of type_descs*/
  EXT_LLVM.genAllocaModelicaMetaTy(VAL_LST);
  EXT_LLVM.genCallArg(VAL_LST);
  EXT_LLVM.genCall(name="valueLst_to_type_descs"
                   ,functionTy=MODELICA_METATYPE
                   ,dest=VAL_LST
                   ,assignment=true,isVariadic=false);
  genReadCalls(functionArgs,VAL_LST);
  /*Allocate output variables and generate the call, do different things depending on how many retvals.*/
  List.map_0(functionToBeCalled.outputs, genAllocaLLVMInstForVar);
  /*Generate the call arg/args for the function that we are calling */
  EXT_LLVM.genAllocaModelicaMetaTy(THREAD_DATA);
  EXT_LLVM.storeThreadData_t();
  EXT_LLVM.genCallArg(THREAD_DATA);
  List.map_0(List.map(functionArgs,genVarName),EXT_LLVM.genCallArg);
  if listLength(functionToBeCalled.outputs) == 1 then
    EXT_LLVM.genCall(name=FUNCTION_NAME
                     ,dest=genVarName(listHead(functionToBeCalled.outputs))
                     ,functionTy=getTypeIdentifierForVar(listHead(functionToBeCalled.outputs))
                     ,assignment=true
                     ,isVariadic=false);
  elseif listLength(functionToBeCalled.outputs) > 1 then
    List.map_0(List.map(functionToBeCalled.outputs,getTypeIdentifierForVar),EXT_LLVM.createStructElement);
    EXT_LLVM.createStructSignature("outStruct_"+FUNCTION_NAME);
    EXT_LLVM.createStruct("outStruct_"+FUNCTION_NAME);
    EXT_LLVM.genCall(name=FUNCTION_NAME
                     ,dest="outStruct_"+FUNCTION_NAME
                     ,functionTy=MODELICA_TUPLE
                     ,assignment=true
                     ,isVariadic=false);
   storeValsFromStruct(List.map(functionToBeCalled.outputs,DAEToMid.varToOutVar),"outStruct_"+FUNCTION_NAME,0);
  else /*Void functions*/
    EXT_LLVM.genCall(name=FUNCTION_NAME
                     ,dest=""
                     ,functionTy=MODELICA_VOID
                     ,assignment=false
                     ,isVariadic=false);
  end if;
  /*Convert the result of the call to mmc and then to Value.Values*/
  mmcVars := list(MidCode.VAR("mmc_" + v.name, v.ty, v.volatile) for v in functionToBeCalled.outputs);
  List.map_0(List.map(mmcVars,genVarName),EXT_LLVM.genAllocaModelicaMetaTy);
  genmkCalls(functionToBeCalled.outputs,mmcVars);
  res := match mmcVars
    local
      MidCode.Var H;
    case {} /*Void functions*/
      algorithm
        EXT_LLVM.genReturnVoid();
        EXT_LLVM.finnishGen();
        runJit(AbsynUtil.pathString(functionToBeCalled.name),valLst);
      then Values.Value.NORETCALL(); //Silly to generate a Values..NORETCALL in llvm to much fuzz..., I do it here.
    case H :: {} //Functions returning a single value.
      algorithm
        genmmcToValueCall(H,"finalValuePTR");
        EXT_LLVM.genReturn(retVar="finalValuePTR");
        EXT_LLVM.finnishGen();
      then runJit(AbsynUtil.pathString(functionToBeCalled.name),valLst);
    case H :: _ //For functions returning tuples
      algorithm
        valuePTRVars := listReverse(MidCode.VAR("valuePTR"+v.name,v.ty,v.volatile) for v in mmcVars);
        genmmcToValueCalls(listReverse(mmcVars),valuePTRVars);
        genmmcToValueTuple("finalValuePTR",valuePTRVars);
        EXT_LLVM.genReturn(retVar="finalValuePTR");
        EXT_LLVM.finnishGen();
        then runJit(AbsynUtil.pathString(functionToBeCalled.name),valLst);
    else algorithm Error.addInternalError("Error running Jit\n", sourceInfo()); then fail();
  end match;
  /*Preprocess, return res.*/
  newval := match res
    local list<Values.Value> valueLst;
    case Values.Value.META_TUPLE(valueLst=valueLst) then Values.Value.TUPLE(valueLst);
    else res;
  end match;
end JIT;

function genReadCalls
  input list<MidCode.Var> functionArgs;
  input String valLst;
algorithm
  /*Generate read calls*/
  for v in functionArgs loop
    EXT_LLVM.genCallArgAddr(valLst);
    () := match v.ty
      case DAE.T_ARRAY(__) algorithm EXT_LLVM.genCallArg(genVarName(v)); then ();
      else algorithm EXT_LLVM.genCallArgAddr(genVarName(v)); then ();
    end match;
    EXT_LLVM.genCall(name=genReadCallStr(v),functionTy=MODELICA_VOID,dest=""
                     ,assignment=false,isVariadic=false);
  end for;
end genReadCalls;

function genReadCallStr
  "Generates a string desc of what read function that should be called given a DAE.Type"
  input MidCode.Var v;
  output String res;
algorithm
  res := match v.ty
    case DAE.T_INTEGER(__) then "read_modelica_integer";
    case DAE.T_BOOL(__) then "read_modelica_boolean";
    case DAE.T_REAL(__) then "read_modelica_real";
    case DAE.T_STRING(__) then "read_modelica_metatype";
    case DAE.T_METALIST(__) then "read_modelica_metatype";
    case DAE.T_ENUMERATION(__) then fail();
    case DAE.T_COMPLEX(__) then "read_modelica_complex";
    case DAE.T_METAUNIONTYPE(__) then "read_modelica_metatype";
    case DAE.T_METAARRAY(__) then "read_modelica_metatype";
    case DAE.T_METAOPTION(__) then "read_modelica_metatype";
    case DAE.T_METATUPLE(__) then "read_modelica_metatype";
    case DAE.T_ARRAY(__) then readArrayString(v.ty);
    case DAE.T_METARECORD(__) then "read_modelica_metatype";
    else algorithm Error.addInternalError("\n",sourceInfo()); then fail();
  end match;
end genReadCallStr;

function readArrayString
  "Generates the string for a read call related to arrays. Only handles real for now"
  input DAE.Type ty;
  output String res;
algorithm
  res := match DAEUtil.expTypeElementType(ty)
    case DAE.T_REAL(__) then "read_real_array";
    else fail(); //Extend with more types.
  end match;
end readArrayString;

//TODO: maybe move this stuff to DAEToMid?
//(Unsure what the correct engineering practice would be, still MidCode does handle this correct and separate), same structure is also used in SimCode.
function genRecordDecls
  "Only handles RECORD_DECL_DEF at the moment, they seem to be the ones that are interesting."
  input list<SimCodeFunction.RecordDeclaration> extraRecordDecls;
algorithm
  List.map_0(extraRecordDecls,genRecordDecl);
end genRecordDecls;

function genRecordDecl
  input SimCodeFunction.RecordDeclaration rDecl;
algorithm
  () :=
    match rDecl
      /*TODO: When exactly does this case occur? Written alot of tests have yet to see it.*/
      case SimCodeFunction.RECORD_DECL_FULL(__) then ();
      case SimCodeFunction.RECORD_DECL_DEF(__)
        algorithm
          genRecordDeclDef( textString(dotPath(Tpl.MEM_TEXT({},{}),rDecl.path))
                           ,textString(underscorePath(Tpl.MEM_TEXT({},{}),rDecl.path))
                           ,rDecl.fieldNames);
      then ();
    else fail();
    end match;
end genRecordDecl;

function genRecordDeclDef
  "Generates the LLVM IR for a genRecordDeclDef. This is generated
  to provide the correct LLVM-signature to correctly handle algebraic datatypes."
  input String origName "The dot path";
  input String encName "The underscore path";
  input list<String> fieldNames;
protected
  Integer numFields = listLength(fieldNames);
  String fieldsArray = encName+"__desc__fields"; //To keep naming conventions the same
algorithm
  /*First generate field e.g the char** (Similar to CodegenCFunctions line 476) */
  /*Decide if we should have fields or not.*/
  () := match numFields
    case 0
      algorithm
       EXT_LLVM.addToLLVMStrArray("no fields");
       EXT_LLVM.genCStrArray(fieldsArray,numFields);
       EXT_LLVM.genGvarCStr(origName); //dot path
       EXT_LLVM.genGvarCStr(encName); //underscore path
       /*Glue it together to  create the Struct.*/
       EXT_LLVM.genGlobalStructFieldConstant(encName); //The underscore path
       EXT_LLVM.genGlobalStructFieldConstant(origName); //The dot path
       EXT_LLVM.genGlobalStructFieldConstant(fieldsArray); //The field
       EXT_LLVM.genGlobalStructConstant("struct.record_description"/*Do not change this name (If so change generateIntial... in llvm_gen.hpp).*/,encName+"__desc");
    then();
    else
     algorithm
      /*Fill a ds in the C context with data for later C string array creation */
      List.map_0(fieldNames,EXT_LLVM.addToLLVMStrArray);
      /*Create an array of char*. fields_array*/
      EXT_LLVM.genCStrArray(fieldsArray,numFields);
      EXT_LLVM.genGvarCStr(origName); //dot path
      EXT_LLVM.genGvarCStr(encName); //underscore path
      /*Glue it together to  create the Struct.*/
      EXT_LLVM.genGlobalStructFieldConstant(encName); //The underscore path
      EXT_LLVM.genGlobalStructFieldConstant(origName); //The dot path
      EXT_LLVM.genGlobalStructFieldConstant(fieldsArray); //The field
      /*Create the struct, (llvm aggregate type) */
      EXT_LLVM.genGlobalStructConstant("struct.record_description"/*Do not change this name (If so change generateIntial... in llvm_gen.hpp).*/,encName+"__desc");
     then();
  end match;
end genRecordDeclDef;

function genProgram
  "Given a MidCodeProgram. Lower each function to a corresponding LLVM-IR function"
  input MidCode.Program p;
algorithm
  //Start codegen in runtime/llvm_gen.cpp
  EXT_LLVM.setOptSettings(not Flags.isSet(Flags.JIT_NO_OPT));
  List.map_0(p.functions,genDeclaration);
  List.map_0(p.functions,genFunction);
end genProgram;

protected

function runJit
  "Runs a compiled top level function returning a Value.Values"
  input String name "Name of the function the top level expr is calling.";
  input list<Values.Value> valLst "Values passed to the top level function";
  output Values.Value newVal "The computed return value";
  protected Integer I;
algorithm
  if Flags.isSet(Flags.JIT_DUMP_IR) then
    print("Dumping LLVM-IR\n");
    EXT_LLVM.dumpIR();
  end if;
  EXT_LLVM.jitCompile();
  execStat("Compilation for JIT:("+ name + ") JIT");
  if Flags.isSet(Flags.EXEC_STAT) then
    execStatReset();
    newVal := EXT_LLVM.runJIT(valLst);
    execStat("executeFunction("+ name + ") JIT");
  else
    newVal := EXT_LLVM.runJIT(valLst);
  end if;
end runJit;

function genmkCalls
  input list<MidCode.Var> outputVars;
  input list<MidCode.Var> inputVars;
algorithm
  if not listEmpty(outputVars) then
    genmkCall(listHead(outputVars),listHead(inputVars));
    genmkCalls(listRest(outputVars),listRest(inputVars));
  end if;
end genmkCalls;

function genmmcToValueCalls
  input list<MidCode.Var> mmcVars;
  input list<MidCode.Var> valuePTRVars;
algorithm
  if not listEmpty(valuePTRVars) then
    genmmcToValueCall(listHead(mmcVars),genVarName(List.first(valuePTRVars)));
    genmmcToValueCalls(listRest(mmcVars),listRest(valuePTRVars));
  end if;
end genmmcToValueCalls;

function genmkCall
 "Generates external calls to the mmc_mk* functions in simulationruntime.
   Result: mmcVar = mmc_mk*(inputVar)"
  input MidCode.Var inputVar;
  input MidCode.Var mmcVar;
algorithm
  () := match inputVar.ty
    case DAE.T_INTEGER(__)
      algorithm
        EXT_LLVM.genCallArg(inputVar.name); EXT_LLVM.genCall(name="mmc_mk_icon_wrapper",functionTy=MODELICA_METATYPE,dest=genVarName(mmcVar),assignment=true,isVariadic=false);
      then ();
    case DAE.T_BOOL(__)
      algorithm
        EXT_LLVM.genCallArg(inputVar.name); EXT_LLVM.genCall(name="mmc_mk_bcon_wrapper",functionTy=MODELICA_METATYPE,dest=genVarName(mmcVar),assignment=true,isVariadic=false);
      then ();
    case DAE.T_REAL(__)
      algorithm
         EXT_LLVM.genCallArg(inputVar.name); EXT_LLVM.genCall(name="mmc_mk_rcon",functionTy=MODELICA_METATYPE,dest=genVarName(mmcVar),assignment=true,isVariadic=false);
       then ();
    case DAE.T_STRING(__)
      algorithm
        EXT_LLVM.genStoreVarInst(genVarName(inputVar),genVarName(mmcVar));
       then ();
          /*TODO, add these if Martin deems it neccessary.. */
    case DAE.T_METALIST(__) algorithm EXT_LLVM.genStoreVarInst(genVarName(inputVar),genVarName(mmcVar)); then ();
    case DAE.T_ENUMERATION(__) then ();
    case DAE.T_COMPLEX(__) then ();
    case DAE.T_METAUNIONTYPE(__) then();
    case DAE.T_METAARRAY(__) algorithm EXT_LLVM.genStoreVarInst(genVarName(inputVar),genVarName(mmcVar)); then();
    case DAE.T_METAOPTION(__) then ();
    case DAE.T_METATUPLE(__) then ();
    case DAE.T_ARRAY(__) algorithm
      //We do nothing. We should already have a modelica_array, However we need to keep chaining the calls. LLVM will remove this during opt.
      EXT_LLVM.genStoreVarInst(genVarName(inputVar),genVarName(mmcVar));
    then();
    else algorithm print("UNKOWN TYPE IN GENMKCALLS" + anyString(inputVar.ty) + "\n"); then();
  end match;
end genmkCall;

function genmmcToValueCall
  "This function is used for all functions called from the top level that returns one element."
  input MidCode.Var var;
  input String resultVar;
algorithm
  //Create the pointer variable we want to assign the result to.
  EXT_LLVM.genAllocaModelicaMetaTy(resultVar);
  EXT_LLVM.genCallArg(genVarName(var));
  () := match var.ty
    case DAE.T_INTEGER(__)
      algorithm
        EXT_LLVM.genCall(name="mmc_icon_to_value_wrapper", functionTy=MODELICA_METATYPE, dest=resultVar, assignment=true,isVariadic=false);
      then ();
    case DAE.T_BOOL(__)
      algorithm
        EXT_LLVM.genCall(name="mmc_bcon_to_value_wrapper",functionTy=MODELICA_METATYPE,dest=resultVar,assignment=true,isVariadic=false);
      then ();
    case DAE.T_REAL(__)
      algorithm
        EXT_LLVM.genCall(name="mmc_rcon_to_value_wrapper",functionTy=MODELICA_METATYPE,dest=resultVar,assignment=true,isVariadic=false);
      then ();
    case DAE.T_STRING(__)
      algorithm
        EXT_LLVM.genCall(name="mmc_scon_to_value_wrapper",functionTy=MODELICA_METATYPE,dest=resultVar,assignment=true,isVariadic=false);
      then();
    case DAE.T_ENUMERATION(__) then ();
    case DAE.T_COMPLEX(__) then ();
    case DAE.T_METAUNIONTYPE(__) then();
    case DAE.T_METALIST(__)
      algorithm
        EXT_LLVM.genCall(name="mmc_lcon_to_value_wrapper",functionTy=MODELICA_METATYPE,dest=resultVar,assignment=true,isVariadic=false);
      then ();
    case DAE.T_METAARRAY(__) then (); //Metaarrays do not seem to be supported in the CevalContext.
    case DAE.T_ARRAY(__)
      algorithm
        EXT_LLVM.genCallArgConstInt(getTypeIdentifier(DAEUtil.expTypeElementType(var.ty)));
        EXT_LLVM.genCall(name="mmc_arrcon_to_value_wrapper",functionTy=MODELICA_METATYPE,dest=resultVar,assignment=true,isVariadic=false);
      then();
    case DAE.T_METAOPTION(__) then ();
    else algorithm print("Failed to elaborate" + anyString(var) + "\n"); then fail();
  end match;
end genmmcToValueCall;

function genmmcToValueTuple
  "If the function is supposed to return a tuple, this function is used instead."
  input String tuple "Name of the tuple to be created.";
  input list<MidCode.Var> valueArgs "All these objects now refer to a void*, handled by the symtab in the llvmContext.";
protected
  String valLst = "valueLst";
algorithm
  //Create the tuple variable
  EXT_LLVM.genAllocaModelicaMetaTy(tuple);
  //Create the pointer variable we want to assign the result to.
  genLst(valueArgs,valLst);
  EXT_LLVM.genCallArg(valLst);
  EXT_LLVM.genCall(name="mmc_mtcon_to_value", functionTy=MODELICA_METATYPE, dest=tuple, assignment=true,isVariadic=false);
end genmmcToValueTuple;

function genLst
  input list<MidCode.Var> lstToBeCreated;
  input String lst "This string refeers to a pointer to the valuelst.";
algorithm
  EXT_LLVM.genAllocaModelicaMetaTy(lst);
  EXT_LLVM.startGenLst();
  for value in lstToBeCreated loop
    EXT_LLVM.genMmcCons(value.name);
  end for;
  EXT_LLVM.genLst(lst);
end genLst;

function genDeclaration
  "Creates an in memory representation of a function declaration"
  input MidCode.Function func;
protected
  String name;
algorithm
  name := "omc_" + textString(underscorePath(Tpl.MEM_TEXT({},{}),func.name));
  EXT_LLVM.startFuncGen(name);
  genFunctionArgs(func.inputs);
  genFunctionType(func.outputs,name);
  genFunctionPrototype(name);
end genDeclaration;

function genFunction
  "Generates the LLVM instructions for a function"
  input MidCode.Function func "Function to be translated to LLVM IR.";
protected
    String name;
algorithm
  name := "omc_" + textString(underscorePath(Tpl.MEM_TEXT({},{}),func.name));
  EXT_LLVM.startFuncGen(name);
  EXT_LLVM.genFunctionType(MODELICA_METATYPE);
  EXT_LLVM.genFunctionBody(name);//Start creating the function body in memory
  genLocalDecls(func,func.locals, func.localBufs, func.localBufPtrs);
  List.map_0(func.outputs, genAllocaLLVMInstForVar);
  genEntry(func.entryId);
  genBlocks(func);
  genExit(func);
  EXT_LLVM.finnishGen();
end genFunction;

function addThreadData_t
"Adds a thread_data argument"
  input Integer ty;
  input String name;
algorithm
  EXT_LLVM.addThreadData_t(ty,name);
end addThreadData_t;

/*Creates a function args vector in the runtime */
function genFunctionArgs
  input list<MidCode.Var> inputs;
algorithm
  //TODO Thread_data_t is added separate at the moment. add a builtin bool here.
  addThreadData_t(MODELICA_METATYPE,"threadData");
  for inp in inputs loop
    EXT_LLVM.genFunctionArg(getTypeIdentifierForVar(inp)
                            ,genVarName(inp));
  end for;
end genFunctionArgs;

function genFunctionType
  input list<MidCode.Var> outputs;
  input String name;
algorithm
  () := match listLength(outputs)
    case 0 algorithm EXT_LLVM.genFunctionType(MODELICA_VOID); then();
    case 1 algorithm EXT_LLVM.genFunctionType(getTypeIdentifierForVar(listHead(outputs))); then();
    else /*MRV*/
      algorithm
        for o in outputs loop EXT_LLVM.createStructElement(getTypeIdentifierForVar(o)); end for;
        EXT_LLVM.createStructSignature("outStruct_"+name);
        /*MRV functions shall return tuples*/
        EXT_LLVM.genFunctionType(MODELICA_TUPLE,"outStruct_"+name);
      then ();
 end match;
end genFunctionType;

function genFunctionPrototype
  "Assembles the different pieces the calls to genFunctionArgs and genFunctionType created and
  sets the name this is done by delegation to EXT_LLVM."
  input String name;
algorithm
  EXT_LLVM.genFunctionPrototype(name);
end genFunctionPrototype;

function genLocalDecls
  "Allocates all local variables,bufs and bufptr."
  input MidCode.Function func;
  input list<MidCode.Var> locals;
  input list<MidCode.VarBuf> localBufs;
  input list<MidCode.VarBufPtr> localBufPtrs;
algorithm
  List.map_0(locals, genAllocaLLVMInstForVar);
  List.map_0(localBufs, genAllocaLLVMInstForVarBuf);
  List.map_0(localBufPtrs, genAllocaLLVMInstForVarBufPtr);
end genLocalDecls;

function genAllocaLLVMInstForVar
  "Generates a corresponding LLVM alloca instruction for a MidCode.Var."
  input MidCode.Var var;
protected
  DAE.Type ty;
  list<Integer> allocaArgs;
algorithm
  ty := var.ty;
  () := match ty
    case DAE.T_INTEGER(__) algorithm EXT_LLVM.genAllocaModelicaInt(genVarName(var), var.volatile); then();
    case DAE.T_REAL(__) algorithm EXT_LLVM.genAllocaModelicaReal(genVarName(var), var.volatile); then();
    case DAE.T_BOOL(__) algorithm EXT_LLVM.genAllocaModelicaBool(genVarName(var), var.volatile); then();
    case DAE.T_ARRAY(__)
      algorithm
          //Allocate the pointer to the base of the struct.
          allocaBaseArray(var);
      then();
    else algorithm EXT_LLVM.genAllocaModelicaMetaTy(genVarName(var)); then();
  end match;
end genAllocaLLVMInstForVar;

function allocaBaseArray
  input MidCode.Var var;
algorithm
  EXT_LLVM.genAllocaModelicaMetaTy(genVarName(var));
  EXT_LLVM.genCall(name="alloc_base_array_t",functionTy=MODELICA_METATYPE,dest=genVarName(var),assignment=true,isVariadic=false);
end allocaBaseArray;

function genAllocaLLVMInstForVarBuf
  input MidCode.VarBuf vBuf;
algorithm
  () := match vBuf
    local String name;
    case MidCode.VARBUF(name=name)
      algorithm
        /* jmp_buf allocated on the stack. */
        EXT_LLVM.genAllocaModelicaMetaTy(name);
        /*Assign a C jmp_buf to the pointer stored in the LLVM enviroment. */
        EXT_LLVM.genCall(name="alloc_get_jmp_buf",functionTy=MODELICA_METATYPE,dest=name,assignment=true,isVariadic=false);
      then();
    else fail();
  end match;
end genAllocaLLVMInstForVarBuf;

function genAllocaLLVMInstForVarBufPtr
  input MidCode.VarBufPtr vBufPtr;
algorithm
  () := match vBufPtr
    local String name;
    case MidCode.VARBUFPTR(name=name) algorithm EXT_LLVM.genAllocaModelicaMetaTy(name); then();
    else fail();
  end match;
end genAllocaLLVMInstForVarBufPtr;

function genStoreLLVMInst
  "Creates a store instruction for a variable to a destination variable"
  input MidCode.Var var "src";
  input String dest "dest";
algorithm
  EXT_LLVM.genStoreVarInst(var.name,dest);
end genStoreLLVMInst;

//This has to be done to start the first basic block of the function.
function genEntry
  input Integer entryId;
algorithm
  EXT_LLVM.genGoto(entryId);
end genEntry;

function genBlocks
  input MidCode.Function func;
algorithm
  List.map1_0(func.body,genBlock,func);
end genBlocks;

function genExit
"Generates the exit block from midcode in memory"
  input MidCode.Function func;
protected
  String retVar "The name of the return variable";
  Integer nOutputs;
algorithm
  nOutputs := listLength(func.outputs);
  /*Generat exit block.*/
  EXT_LLVM.genExit(func.exitId);
  () := match nOutputs
    case 0 algorithm EXT_LLVM.genReturnVoid(); then ();
    case 1 algorithm EXT_LLVM.genReturn(genVarName(listHead(func.outputs))); then();
    else algorithm handleMRV("outStruct_"+"omc_" + textString(underscorePath(Tpl.MEM_TEXT({},{}),func.name)),func.outputs); then ();
  end match;
end genExit;

function handleMRV
  "Writes the output variable to the return struct.
  Then creates a ret instruction with the retStruct."
  input String structName "The Name of the struct we are returning.";
  input list<MidCode.Var> outputs "output variables.";
protected
    Integer fieldPos = 0 "The location of the element in the struct,0,1,2,...length(outputs)";
algorithm
  EXT_LLVM.createStruct(structName);
  for ovar in outputs loop
    EXT_LLVM.storeValToStruct(genVarName(ovar),structName,/*The retStruct is always 1D.*/ 0,fieldPos);
    fieldPos := fieldPos + 1;
  end for;
  EXT_LLVM.genReturn(structName);
end handleMRV;

function genBlock
  "Sets the current active block in the llvm runtime for code insertion.
  Then generate the statments belonging to that block. The terminator of a basic block
  can be a statement (In LLVM) or it can be a set of basic blocks. this differs from the MidCode representation."
  input MidCode.Block blck;
  input MidCode.Function func;
algorithm
  EXT_LLVM.setNewActiveBlock(blck.id);
  List.map_0(blck.stmts,genStmt);
  genTerminator(func,blck.terminator);
end genBlock;

function genStmt
  "Generates LLVM IR for a MidCode statement. Currently Nothing is done
  for NOP instructions, LLVM IR does not provide a NOP instruction, thus nothing is done
  in EXT_LLVM.genNop() currently. (If it is needed some LLVM hack might suffice)"
  input MidCode.Stmt stmt;
algorithm
  () := match stmt
    local
      MidCode.RValue rvalue;
      MidCode.VAR pDest;
    case MidCode.NOP(__) algorithm EXT_LLVM.genNop(); then (); //TODO, is it neccessary to do anything here?
    case MidCode.ASSIGN(dest=MidCode.VAR(name=_,ty=_),src=rvalue) algorithm genLLVMInst(stmt.dest,rvalue); then ();
    case MidCode.ALLOCARRAY(__)
      algorithm
        EXT_LLVM.genCallArgAddr(genVarName(stmt.array));
        EXT_LLVM.genCallArg(genVarName(stmt.dimSize));
        List.mapMap_0(stmt.sizeOfDims,genVarName,EXT_LLVM.genCallArg);
        EXT_LLVM.genCall(name=stmt.func,functionTy=MODELICA_VOID,dest="",assignment=false,isVariadic=true);
      then();
    end match;
  end genStmt;

function genTerminator
  "Given a function and a terminator.
  Maps a MidCode terminator to a corresponding LLVM terminator, since calls are not terminators in LLVM IR
  a dummy goto terminator is generated after each call."
  input MidCode.Function func;
  input MidCode.Terminator term;
algorithm
  () := match term
    local
      Integer pLabel;
      MidCode.Var pCondition;
      Integer pOnTrue;
      Integer pOnFalse;
      list<tuple<Integer,Integer>> pCases;
      list<String> extCallArgs;
      DAE.Type ty;
      Integer c1 "1 Component in tuple";
      Integer c2 "2 Component in tuple";
    /* Look this up in DAEToMid to make sure that return is the last thing we do. Seems to be the case*/
    case MidCode.RETURN(__) algorithm EXT_LLVM.genGoto(func.exitId); then();
    case MidCode.GOTO(next=pLabel) algorithm EXT_LLVM.genGoto(pLabel); then();
    case MidCode.BRANCH(condition=pCondition,onTrue=pOnTrue,onFalse=pOnFalse)
      algorithm
        EXT_LLVM.genBranch(genVarName(pCondition),pOnTrue,pOnFalse);
      then ();
    /*Generates a switch statment, they occur when generating match-expressions. Observe that we need to build it in steps, several calls are made.*/
    case MidCode.SWITCH(condition=pCondition,cases=pCases)
      algorithm
        EXT_LLVM.genSwitch(genVarName(pCondition),listLength(pCases));
        for T in pCases loop
          (c1,c2) := T; //Must be a better way of doing this..
          EXT_LLVM.addCaseToSwitch(c1,c2);
        end for;
      then ();
    case MidCode.CALL(func=_,builtin=_,inputs=_,outputs=_,next=_,ty=ty)
      algorithm
        genCall(term,getTypeIdentifier(ty));
        //Dummy terminator to the next block.
        EXT_LLVM.genGoto(term.next);
    then();
    case MidCode.LONGJMP(__)
      algorithm
        EXT_LLVM.genCallArgMmcJumpr();
        EXT_LLVM.genCallArgConstInt(1);
        EXT_LLVM.genLongJmp();
        //Dummy terminator, it is needed for correct LLVM-IR (LLVM will remove it during opt).
        EXT_LLVM.genGoto(func.exitId);
      then();
    case MidCode.PUSHJMP(__)
      algorithm
        EXT_LLVM.genStoreFromMmcJumpr(term.old_buf.name);
        EXT_LLVM.genCallArg(term.new_buf.name); //Pass the adress.
        EXT_LLVM.genCall(name="set_mmc_jumper",functionTy=MODELICA_VOID,dest="",assignment=false,isVariadic=false);
        EXT_LLVM.genCallArg(term.new_buf.name);
        EXT_LLVM.genCall(name="setjmp",functionTy=MODELICA_VOID,dest="",assignment=false,isVariadic=false);
        EXT_LLVM.genGoto(term.next);
      then();
    case MidCode.POPJMP(__)
      algorithm
        EXT_LLVM.genCallArg(term.old_buf.name); //Pass the pointer.
        EXT_LLVM.genCall(name="set_mmc_jumper",functionTy=MODELICA_VOID,dest="",assignment=false,isVariadic=false);
        EXT_LLVM.genGoto(term.next);
      then();
    else algorithm Error.addInternalError("Unsuported terminator: " + anyString(term) + "\n",sourceInfo()); then fail();
  end match;
end genTerminator;

function genCall
  "Generates an llvm, call instruction, observe that a call is a terminator in MidCode, but not
   a terminator in LLVM IR. The arguments for this functions must have been created before this function is called."
  input MidCode.Terminator term "The call expression, a terminator in MidCode not a terminator in LLVM!";
  input Integer functionTy;
protected
  String dest "The destination variable, it get's assigned IFF there is an assignment call.";
  String functionName "The name of the function to be called";
  Boolean assignment "True if it is a non void function";
algorithm
  () := match term
    local
      Boolean builtin;
      Absyn.Path pPath;
    case MidCode.CALL(func=pPath,builtin=false,inputs=_,outputs=_,next=_,ty=_)
      algorithm
          functionName := "omc_" + textString(underscorePath(Tpl.MEM_TEXT({},{}),pPath));
          EXT_LLVM.genAllocaModelicaMetaTy("threadData");
          EXT_LLVM.genCallArg("threadData");
        then();
     case MidCode.CALL(func=pPath,builtin=true,inputs=_,outputs=_,next=_,ty=_)
       algorithm
         functionName := identBuiltinCall(pPath);
       then();
  end match;
  () := match term
    local
      Absyn.Path pPath;
      Boolean pBuiltin;
      DAE.Type pTy;
      Integer pNext;
      list<MidCode.OutVar> pOutputs;
      list<MidCode.Var> pInputs;
      Integer fieldPos = 0;
      case MidCode.CALL(func=pPath,builtin=pBuiltin,inputs=pInputs,outputs=pOutputs,next=pNext,ty=pTy)
        algorithm
          () := match pOutputs
            local
              MidCode.Var pVar;
            case MidCode.OUT_VAR(var=pVar) :: {} algorithm
                (dest,assignment) := (genVarName(pVar), true);
              then();
            case MidCode.OUT_VAR(var=pVar) :: _
              algorithm
                (dest,assignment) := ("outStruct_"+functionName,true);
                EXT_LLVM.createStruct(dest);
                then();
            case MidCode.OUT_WILD() :: _ algorithm (dest,assignment) := ("",false); then ();
            case {} algorithm (dest,assignment) := ("",false); then ();
          end match;
          //Load the rest of the arguments
          List.mapMap_0(pInputs,genVarName,EXT_LLVM.genCallArg);
          EXT_LLVM.genCall(functionName,functionTy,dest,assignment,isVariadic=false /*No variadic functions in Modelica.*/);
          /* Write to the return values from the struct */
          if listLength(pOutputs) > 1 then
            storeValsFromStruct(pOutputs,dest,0);
          end if;
      then ();
    else ();
  end match;
end genCall;

//TODO refactor, inefficient.
function storeValsFromStruct
  input list<MidCode.OutVar> oVars;
  input String dest;
  input Integer fieldPos;
protected
  MidCode.Var var;
algorithm
  () := match oVars
    case MidCode.OUT_VAR(var=var) :: _
      algorithm
        EXT_LLVM.storeValFromStruct(genVarName(var),dest,0,fieldPos);
        storeValsFromStruct(listRest(oVars),dest,fieldPos+1);
      then();
    else then();
  end match;
end storeValsFromStruct;

function genLLVMInst
  input MidCode.Var dest;
  input MidCode.RValue rValue;
algorithm
//print("LLVM INST:" + anyString(dest.ty) + "&:" + anyString(rValue) + "\n");
  () := match (dest,rValue)
    local
    String psrc_name;
    Boolean pBoolean;
    DAE.Type ty;
    Integer index;
    Integer pInteger;
    MidCode.BinaryOp pbinop;
    MidCode.UnaryOp pUnop;
    MidCode.Var pVarSrc;
    MidCode.Var plsrc;
    MidCode.Var prsrc;
    MidCode.Var src;
    Real pReal;
    String lsrc_name;
    String pString;
    String rsrc_name;
    String stringValue;
    list<MidCode.Var> elements;
  case (_,MidCode.DEREFERENCE(src=pVarSrc,ty=ty)) //Expand to function when more types are supported.
    algorithm
      EXT_LLVM.getDoubleFromPtr(genVarName(pVarSrc),genVarName(dest),0);
    then();
  case (MidCode.VAR(_,ty as DAE.T_ARRAY(__),_),MidCode.VARIABLE(src=pVarSrc as MidCode.VAR(ty=DAE.T_ARRAY(__))))
    algorithm
      EXT_LLVM.genCallArg(genVarName(pVarSrc));
      EXT_LLVM.genCallArgAddr(genVarName(dest));
      //The function should vary depending on the type.
      EXT_LLVM.genCall(name=genArrayCopyFunc(ty),functionTy=MODELICA_VOID,dest="",assignment=false,isVariadic=false);
    then();
  case (MidCode.VAR(_,DAE.T_ARRAY(__),_),MidCode.VARIABLE(pVarSrc as MidCode.VAR(name=psrc_name)))
    algorithm
      EXT_LLVM.storeDVarToPtr(genVarName(pVarSrc),genVarName(dest),0);
    then();
  case (_,MidCode.VARIABLE(src=pVarSrc as MidCode.VAR(name=psrc_name,ty=_)))
    algorithm
      genStoreLLVMInst(pVarSrc,genVarName(dest));
    then();
  case (_, MidCode.BINARYOP(op=pbinop
                            ,lsrc=plsrc as MidCode.VAR(name=lsrc_name,ty=DAE.T_STRING(__))
                            ,rsrc=prsrc as MidCode.VAR(name=rsrc_name,ty=DAE.T_STRING(__))))
    algorithm
      genBinaryOPLLVMInst(genVarName(dest),pbinop,plsrc,prsrc);
    then();
  case (_,MidCode.BINARYOP(op=MidCode.POW()
                           ,lsrc=MidCode.VAR(name=lsrc_name,ty=_)
                           ,rsrc=MidCode.VAR(name=rsrc_name,ty=_)))
    algorithm
      genLLVMPowInst(lsrc_name,rsrc_name,genVarName(dest));
    then();
  case (_,MidCode.BINARYOP(op=pbinop,lsrc=plsrc,rsrc=prsrc))
    algorithm
      genBinaryOPLLVMInst(genVarName(dest),pbinop,plsrc,prsrc);
    then();
  case (_,MidCode.UNARYOP(op=MidCode.BOX(),src=src))
    algorithm
      genmkCall(src,dest); //TODO maybe change the name of genmkCall...
    then();
  case (_,MidCode.UNARYOP(op=MidCode.UNBOX(),src=src))
    algorithm
      unboxVar(src,dest);
    then();
  case (_,MidCode.UNARYOP(op=pUnop,src=src))
    algorithm
      genUnaryOpLLVMInst(pUnop,src,dest);
    then();
  case (MidCode.VAR(_,DAE.T_INTEGER(__),_),MidCode.LITERALINTEGER(value=pInteger))
    algorithm
      EXT_LLVM.genStoreLiteralInt(pInteger,genVarName(dest));
    then();
  case (MidCode.VAR(_,DAE.T_BOOL(__),_),MidCode.LITERALBOOLEAN(value=pBoolean))
    algorithm
      EXT_LLVM.genStoreLiteralBoolean(pBoolean, genVarName(dest));
    then();
  case (MidCode.VAR(_,DAE.T_REAL(__),_),MidCode.LITERALREAL(value=pReal))
    algorithm
      EXT_LLVM.genStoreLiteralReal(pReal,genVarName(dest));
    then();
  case (MidCode.VAR(_,DAE.T_ARRAY(__),_),MidCode.LITERALREAL(value=pReal)) //Note that T_ARRAY at the left side is always a dereferenced array for now
    algorithm
      EXT_LLVM.storeDoubleToPtr(pReal,genVarName(dest),0);
    then();
  case (MidCode.VAR(_,DAE.T_STRING(__),_), MidCode.LITERALSTRING(value=stringValue))
    algorithm
      EXT_LLVM.genStringConstant(stringValue,genVarName(dest));
    then();
  case (_,MidCode.LITERALMETATYPE(elements=elements,ty=ty))
    algorithm
      genLiteralMetatype(elements,ty,dest);
    then ();
  case (_,MidCode.METAFIELD(src=src,index=index,ty=ty))
    algorithm
      EXT_LLVM.genCallArg(genVarName(src));
      EXT_LLVM.genCallArgConstInt(index+1);
      EXT_LLVM.genCall(name="get_metafield",functionTy=MODELICA_METATYPE,dest=genVarName(dest),assignment=true,isVariadic=false);
    then();
  case (_,MidCode.UNIONTYPEVARIANT(src=src))
    algorithm
      EXT_LLVM.genCallArg(genVarName(src));
      EXT_LLVM.genCall(name="get_uniontypevariant",functionTy=MODELICA_INTEGER,dest=genVarName(dest),assignment=true,isVariadic=false);
    then();
  case (_,MidCode.ISCONS(src=src))
    algorithm
      EXT_LLVM.genCallArg(genVarName(src));
      EXT_LLVM.genCall(name="isCons",functionTy=MODELICA_BOOLEAN,dest=genVarName(dest),assignment=true,isVariadic=false);
    then ();
  case (_,MidCode.ISSOME(src=src))
    algorithm
      EXT_LLVM.genCallArg(genVarName(src));
      EXT_LLVM.genCall(name="isSome",functionTy=MODELICA_BOOLEAN,dest=genVarName(dest),assignment=true,isVariadic=false);
    then();
  case (_,MidCode.LITERALARRAY(__))
    algorithm
      genLiteralArray(genVarName(dest),rValue.elements,rValue.ty,listLength(rValue.elements));
    then ();
  else algorithm Error.addInternalError("Unknown operation in genLLVMinst:" + anyString(rValue) + "\n",sourceInfo()); then fail();
  end match;
end genLLVMInst;

function genLiteralArray
  "Not fully implemented. Can be fixed easily though"
  input String dest;
  input list<MidCode.RValue> elements;
  input DAE.Type arrayType;
  input Integer siz;
algorithm
  () := match DAEToMid.getArrayType(arrayType)
    local
      Real realArr[siz];
      Integer ix = 1;
    case DAE.T_REAL(__)
      algorithm
      for e in elements loop
        realArr[ix] := MidCodeUtil.rValueToLiteralReal(e);
        ix := ix + 1;
      end for;
      EXT_LLVM.assignRealArr(realArr,dest);
    then();
    case _
      algorithm
      Error.addInternalError("Mapping unknown array type\n",sourceInfo()); then fail();
  end match;
end genLiteralArray;

function genLiteralMetatype
  input list<MidCode.Var> elements;
  input DAE.Type ty;
  input MidCode.Var dest;
protected
  Integer metaTypeSlots;
  Integer metaTypeCtor;
  Integer ix;
  list<String> elementArgs;
  String record_desc;
algorithm
  metaTypeCtor := genTypeCtorIndex(elements,ty);
  metaTypeSlots := listLength(elements);
  elementArgs := List.map(elements,genVarName);
  () := match ty
    case DAE.T_METARECORD()
      algorithm
        record_desc := textString(underscorePath(Tpl.MEM_TEXT({},{}),ty.path)) + "__desc";
        EXT_LLVM.genCallArgConstInt(metaTypeSlots+1);
        EXT_LLVM.genCallArgConstInt(metaTypeCtor);
        /*Add the record description*/
        EXT_LLVM.genCallArgAddr(record_desc);
        List.map_0(elementArgs,EXT_LLVM.genCallArg);
        EXT_LLVM.genCall(name="mmc_mk_box",functionTy=MODELICA_METATYPE,dest=genVarName(dest),assignment=true,isVariadic=true);
      then();
    case DAE.T_METAARRAY(__)
      algorithm
        EXT_LLVM.genCallArgConstInt(listLength(elementArgs));
        EXT_LLVM.genCallArgConstInt(0); //Write zeroes.
        EXT_LLVM.genCall(name="arrayCreate",functionTy=MODELICA_METATYPE,dest=genVarName(dest),assignment=true,isVariadic=false);//We now have an array, the dest variable is a pointer to it.
        //Add elements to said array.
      ix := 1;
      for e in elementArgs loop
        EXT_LLVM.genCallArg(genVarName(dest));
        EXT_LLVM.genCallArgConstInt(ix);
        EXT_LLVM.genCallArg(e);
        EXT_LLVM.genCall(name="arrayUpdate",functionTy=MODELICA_METATYPE,dest=genVarName(dest),assignment=true,isVariadic=false);
        ix := ix + 1;
      end for;
      then ();
    else
      algorithm
        EXT_LLVM.genCallArgConstInt(metaTypeSlots);
        EXT_LLVM.genCallArgConstInt(metaTypeCtor);
        List.map_0(elementArgs,EXT_LLVM.genCallArg);
        EXT_LLVM.genCall(name="mmc_mk_box",functionTy=MODELICA_METATYPE,dest=genVarName(dest),assignment=true,isVariadic=true);
      then();
  end match;
end genLiteralMetatype;

function genLLVMPowInst
  "Generates a llvm pow instruction for the left and
  the right variable. Note that the variables are already know so we know the signature "
  input String lhs;
  input String rhs;
  input String dest;
  algorithm
    EXT_LLVM.genPow(lhs,rhs,dest);
end genLLVMPowInst;

/*Instruction generation for unary operators */
function genUnaryOpLLVMInst
  "Wrapper function that in turn generate LLVM IR for
  the different unary operators present in MidCode."
  input MidCode.UnaryOp op;
  input MidCode.Var src;
  input MidCode.Var dest;
protected
  MidCode.Var originalVar;
  DAE.Type originalType;
algorithm
  () := match op
    case MidCode.MOVE(originalType=originalType) //This is neccessary since it seems DAEToMid mutates the variable during correct cast.
      algorithm
        originalVar := MidCode.Var.VAR(src.name, originalType, src.volatile);
        genMoveLLVMInst(originalVar,dest);
    then ();
    case MidCode.UMINUS() algorithm genUMinusLLVMInst(src,genVarName(dest)); then ();
    case MidCode.NOT() algorithm genNotLLVMInst(src,genVarName(dest)); then ();
    else algorithm Error.addInternalError("Unkown regular unaryop\n",sourceInfo()); then ();
  end match;
end genUnaryOpLLVMInst;

function genMoveLLVMInst
"Operation that occurs in the Midcode when casting between two types
  occurs, this function assumes that MidCode casts to the correct type
  cast to the same types are ignored. "
  input MidCode.Var src;
  input MidCode.Var dest;
protected
  Integer from;
  Integer to;
  Boolean NOP;
algorithm
  from := getTypeIdentifierForVar(src);
  to := getTypeIdentifierForVar(dest);
  if from == MODELICA_INTEGER and to == MODELICA_REAL then
    EXT_LLVM.genModelicaIntToModelicaReal(genVarName(src),genVarName(dest));
  elseif from == MODELICA_REAL and to == MODELICA_INTEGER then
    EXT_LLVM.genModelicaRealToModelicaInt(genVarName(src),genVarName(dest));
  elseif from == MODELICA_INTEGER and to == MODELICA_BOOLEAN then
    EXT_LLVM.genModelicaIntToModelicaBoolean(genVarName(src),genVarName(dest));
  elseif from == MODELICA_BOOLEAN and to == MODELICA_INTEGER then
    EXT_LLVM.genModelicaBooleanToModelicaInt(genVarName(src),genVarName(dest));
  elseif from == MODELICA_INTEGER and to == MODELICA_METATYPE then
    EXT_LLVM.genModelicaIntToModelicaMeta(genVarName(src),genVarName(dest));
  elseif from == MODELICA_METATYPE and to == MODELICA_INTEGER then
    EXT_LLVM.genModelicaMetaToModelicaInt(genVarName(src),genVarName(dest));
  elseif from == MODELICA_REAL and to == MODELICA_BOOLEAN then
    EXT_LLVM.genModelicaRealToModelicaBoolean(genVarName(src),genVarName(dest));
  elseif from == MODELICA_BOOLEAN and to == MODELICA_REAL then
    EXT_LLVM.genModelicaBooleanToModelicaReal(genVarName(src),genVarName(dest));
  elseif from == MODELICA_REAL and to == MODELICA_METATYPE then
    EXT_LLVM.genModelicaRealToModelicaMeta(genVarName(src),genVarName(dest));
  elseif from == MODELICA_METATYPE and to == MODELICA_REAL then
    EXT_LLVM.genModelicaMetaToModelicaReal(genVarName(src),genVarName(dest));
  elseif from == to then
    EXT_LLVM.genStoreVarInst(genVarName(src),genVarName(dest)); //This is only to keep the semantics the same.
  else
    Error.addInternalError("Cast from:" + anyString(from) + "to:" + anyString(to) + " not allowed\n",sourceInfo());
    fail();
  end if;
end genMoveLLVMInst;

function genUMinusLLVMInst
  "Generate a unnary minus instruction. Either for a modelica_integer or for a modelica_real"
  input MidCode.Var src;
  input String dest;
algorithm
  () := match src.ty
    case DAE.T_INTEGER(__) algorithm EXT_LLVM.genIUminus(genVarName(src),dest); then();
    case DAE.T_REAL(__) algorithm EXT_LLVM.genRUminus(genVarName(src),dest); then();
   else algorithm Error.addInternalError("Unary minus for uknown type:" + anyString(src) + "\n",sourceInfo()); then fail();
 end match;
end genUMinusLLVMInst;

function genNotLLVMInst
  "Generate a LLVM not instruction, can only occur for boolean types."
  input MidCode.Var src;
  input String dest;
algorithm
  EXT_LLVM.genNot(genVarName(src),dest);
end genNotLLVMInst;

function genBinaryOPLLVMInst
  "For basic operations, we must first decide if we are dealing with a Real or a Integer
   we only check the left hand side, it should be guaranteed by now that both sides are of the same type.
   for the moment only check basic types, Integer reals metatype and so on."
  input String dest_name; //Name of destination register or variable.
  input MidCode.BinaryOp op;
  input MidCode.Var lsrc;
  input MidCode.Var rsrc;
algorithm
  () := match getTypeIdentifierForVar(lsrc)
    case MODELICA_INTEGER algorithm genBinaryOPLLVMIInst(dest_name,op,lsrc,rsrc); then();
    case MODELICA_REAL algorithm genBinaryOPLLVMRInst(dest_name,op,lsrc,rsrc); then();
    case MODELICA_BOOLEAN algorithm genBinaryOPLLVMBInst(dest_name,op,lsrc,rsrc); then();
    case MODELICA_METATYPE algorithm genBinaryOPLLVMSInst(dest_name,op,lsrc,rsrc); then();
    else algorithm Error.addInternalError("Error BinaryOp:" + anyString(lsrc) + " and " + anyString(rsrc)  + "\n",sourceInfo()); then fail();
  end match;
end genBinaryOPLLVMInst;

function genBinaryOPLLVMSInst
   "Generates binaryop instruction for modelica_strings"
  input String dest_name;
  input MidCode.BinaryOp op;
  input MidCode.Var lsrc;
  input MidCode.Var rsrc;
algorithm
  () := match op
    case MidCode.ADD()
      algorithm
       EXT_LLVM.genCallArg(genVarName(lsrc));
       EXT_LLVM.genCallArg(genVarName(rsrc));
       EXT_LLVM.genCall(name="stringAppend",functionTy=MODELICA_METATYPE,dest=dest_name,assignment=true,isVariadic=false);
    then();
    case MidCode.EQUAL()
      algorithm
       EXT_LLVM.genCallArg(genVarName(lsrc));
       EXT_LLVM.genCallArg(genVarName(rsrc));
       EXT_LLVM.genCall(name="stringEqual",functionTy=MODELICA_BOOLEAN,dest=dest_name,assignment=true,isVariadic=false);
      then();
    else algorithm Error.addInternalError("Unsupported string operation\n",sourceInfo()); then();
  end match;
end genBinaryOPLLVMSInst;

/*For modelica boolean*/
function genBinaryOPLLVMBInst
  "Binary op for the different binary operations that exists for
  boolean types."
  input String dest_name;
  input MidCode.BinaryOp op;
  input MidCode.Var lsrc;
  input MidCode.Var rsrc;
algorithm
  ():=match op
      //Should support these atleast midcode does not seem to have the notion of and and or, supported in DAE?
    case MidCode.LESS() algorithm EXT_LLVM.genBLess(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.LESSEQ() algorithm EXT_LLVM.genBLessEq(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.GREATER() algorithm EXT_LLVM.genBGreater(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.GREATEREQ() algorithm EXT_LLVM.genBGreaterEq(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.EQUAL() algorithm EXT_LLVM.genBEqual(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.NEQUAL() algorithm EXT_LLVM.genBNequal(dest_name,lsrc.name,rsrc.name); then();
    else ();
  end match;
end genBinaryOPLLVMBInst;

/*For real types */
function genBinaryOPLLVMRInst
  "Generates LLVM binary op instructions for real types"
  input String dest_name;
  input MidCode.BinaryOp op;
  input MidCode.Var lsrc;
  input MidCode.Var rsrc;
algorithm
  ():=match op
    case MidCode.ADD() algorithm EXT_LLVM.genRAdd(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.SUB() algorithm EXT_LLVM.genRSub(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.MUL() algorithm EXT_LLVM.genRMul(dest_name,lsrc.name,rsrc.name);then();
    case MidCode.DIV() algorithm EXT_LLVM.genRDiv(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.LESS() algorithm EXT_LLVM.genRLess(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.LESSEQ() algorithm EXT_LLVM.genRLessEq(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.GREATER() algorithm EXT_LLVM.genRGreater(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.GREATEREQ() algorithm EXT_LLVM.genRGreaterEq(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.EQUAL() algorithm EXT_LLVM.genREqual(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.NEQUAL() algorithm EXT_LLVM.genRNequal(dest_name,lsrc.name,rsrc.name); then();
    else ();
  end match;
end genBinaryOPLLVMRInst;

function genBinaryOPLLVMIInst
  "Generates LLVM binary op instructions for integer types"
  input String dest_name;
  input MidCode.BinaryOp op;
  input MidCode.Var lsrc;
  input MidCode.Var rsrc;
algorithm
  () := match op
    case MidCode.ADD(__) algorithm EXT_LLVM.genIAdd(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.SUB(__) algorithm EXT_LLVM.genISub(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.MUL(__) algorithm EXT_LLVM.genIMul(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.DIV(__) algorithm EXT_LLVM.genIDiv(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.LESS(__) algorithm EXT_LLVM.genILess(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.LESSEQ(__) algorithm EXT_LLVM.genILessEq(dest_name,lsrc.name,rsrc.name); then();
    case MidCode.GREATER(__) algorithm EXT_LLVM.genIGreater(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.GREATEREQ(__) algorithm EXT_LLVM.genIGreaterEq(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.EQUAL(__) algorithm EXT_LLVM.genIEqual(dest_name,lsrc.name,rsrc.name); then ();
    case MidCode.NEQUAL(__) algorithm EXT_LLVM.genINequal(dest_name,lsrc.name,rsrc.name); then ();
    else ();
  end match;
end genBinaryOPLLVMIInst;

function getTypeIdentifierForVar
  input MidCode.Var var;
  output Integer typeDescInt;
algorithm
  typeDescInt := getTypeIdentifier(var.ty);
end getTypeIdentifierForVar;

function getTypeIdentifier
  "Given a DAE.Type returns an integer constant, the type identifier."
  input DAE.Type ty;
  output Integer tyDescInt;
algorithm
  tyDescInt := match ty
    case DAE.T_INTEGER(__) then MODELICA_INTEGER;
    case DAE.T_ENUMERATION(__) then MODELICA_INTEGER;
    case DAE.T_BOOL(__) then MODELICA_BOOLEAN;
    case DAE.T_REAL(__) then MODELICA_REAL;
    case DAE.T_METABOXED(__) then MODELICA_METATYPE;
    case DAE.T_METARECORD(__) then MODELICA_METATYPE;
    case DAE.T_METATYPE(__) then MODELICA_METATYPE;
    case DAE.T_METAOPTION(__) then MODELICA_METATYPE;
    case DAE.T_METAARRAY(__) then MODELICA_METATYPE;
    case DAE.T_METAUNIONTYPE(__) then MODELICA_METATYPE;
    case DAE.T_METALIST(__) then MODELICA_METATYPE;
    case DAE.T_STRING(__)   then MODELICA_METATYPE; //The same as far as LLVM is concerned.
    case DAE.T_ARRAY(__) then MODELICA_METATYPE;
    case DAE.T_UNKNOWN() then MODELICA_UNKNOWN;
    //TODO We treat tuple the same for now...
    case DAE.T_METATUPLE(__) then MODELICA_TUPLE;
    case DAE.T_TUPLE()  then MODELICA_TUPLE;
    case DAE.T_NORETCALL() then MODELICA_VOID;
    //The other seemed redudant to have.
    else algorithm Error.addInternalError("Unsupported identifier for:" + anyString(ty) + "\n",sourceInfo()); then 0;
end match;
end getTypeIdentifier;

function genVarName
  "Generates the variable name as a string."
  input MidCode.Var var;
  output String res;
  algorithm
  res := match var
    case MidCode.VAR(__) then var.name;
    else algorithm print("Empty varName\n"); then "";
  end match;
end genVarName;

//Stolen from Simon & Patrick
function identBuiltinCall
  input Absyn.Path path;
  output String name;
algorithm
  name := match path
    local Absyn.Path Ppath;
    case Absyn.IDENT(name="clock") then "mmc_clock";
    case Absyn.IDENT(name="anyString") then "mmc_anyString";
    case Absyn.IDENT(name="fail") then "MMC_THROW_INTERNAL";
    case Absyn.IDENT(name="intMod") then "modelica_mod_integer";
    case Ppath as Absyn.IDENT(__) then Ppath.name;
    else  algorithm Error.addInternalError("Called unsupported builtin function\n",sourceInfo()); then fail();
  end match;
end identBuiltinCall;

//Translated from Patrick & Simon.
function genTypeCtorIndex
  "Generate the c-tag that indicates which record of a uniontype we have."
  input list<MidCode.Var> elements;
  input DAE.Type ty;
  output Integer ctorIndex;
algorithm
  ctorIndex := match ty
    local Integer index;
    case DAE.T_METARECORD(index=index) then index + 3;
    case DAE.T_METAARRAY(__) then 2;
    case DAE.T_METATUPLE(__) then 0;
    case DAE.T_METAOPTION(__) then 1;
    case DAE.T_METALIST(__) then (if listLength(elements) then 1 else 0);
    case DAE.T_ARRAY(__) then 2;
    else algorithm Error.addInternalError("Ctag generation fail:" + anyString(ty) + "\n",sourceInfo()); then fail();
 end match;
end genTypeCtorIndex;

function unboxVar
  input MidCode.Var boxedVar;
  input MidCode.Var unboxedVar;
protected
  DAE.Type ty;
algorithm
  ty := MidCodeUtil.getVarTy(boxedVar);
  () := match ty
    local
      DAE.Type ty2;
    case DAE.T_METABOXED(ty=DAE.T_INTEGER(__))
      algorithm
        unboxAndAssign(boxedVar,unboxedVar,functionName="mmc_unbox_integer_no_inline",functionTy=MODELICA_INTEGER);
      then();
    case DAE.T_METABOXED(ty=DAE.T_ENUMERATION(__))
      algorithm
        unboxAndAssign(boxedVar,unboxedVar,functionName="mmc_unbox_integer_no_inline",functionTy=MODELICA_INTEGER);
      then();
    case DAE.T_METABOXED(ty=DAE.T_BOOL(__))
      algorithm
        unboxAndAssign(boxedVar,unboxedVar,"mmc_unbox_integer_no_inline",functionTy=MODELICA_BOOLEAN);
      then ();
    case DAE.T_METABOXED(ty=DAE.T_REAL(__))
      algorithm
        unboxAndAssign(boxedVar,unboxedVar,"mmc_unbox_real_no_inline",functionTy=MODELICA_REAL);
      then();
    case DAE.T_STRING(__)
      algorithm
        unboxAndAssign(boxedVar,unboxedVar,"mmc_unbox_string",functionTy=MODELICA_METATYPE);
      then();
    else algorithm Error.addInternalError("Boxing of unknown type...\n",sourceInfo()); then fail();
  end match;
end unboxVar;

function genArrayCopyFunc
  input DAE.Type arrayTy;
  output String func;
algorithm
  func := match listLength(MidCodeUtil.getDimensions(arrayTy))
    case 1 then "copy_real_array";
    case 2 then "copy_real_array_data";
    else algorithm Error.addInternalError("Attempted to generate array copy func for dims > 2\n", sourceInfo()); then fail();
  end match;
end genArrayCopyFunc;

function unboxAndAssign
  "Generates an external call to an mmc_unbox*  specified by functionName
   The result is assigned to the unboxedVar. Both should be present in the symbol table in the C context."
  input MidCode.Var boxedVar;
  input MidCode.Var unboxedVar;
  input String functionName;
  input Integer functionTy;
algorithm
  EXT_LLVM.genCallArg(genVarName(boxedVar));
  EXT_LLVM.genCall(functionName,functionTy,dest=genVarName(unboxedVar),assignment=true,isVariadic=false);
end unboxAndAssign;

annotation(__OpenModelica_Interface="backendInterface");
end MidToLLVM;
