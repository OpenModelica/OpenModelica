encapsulated package MidCodeDump
"
  file:        MidCodeDump.mo
  package:     MidCodeDump
  description: Generated by Susan.
"

public import Tpl;

public import MidCode;
public import System;
public import Absyn;
public import DAE;
public import ClassInf;
public import Util;
public import List;
public import DAEDump;
protected import DAEDumpTpl;

protected function lm_40
  input Tpl.Text in_txt;
  input list<MidCode.Function> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.Function> rest;
      MidCode.Function i_fn;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_fn :: rest )
      equation
        txt = dumpFunction(txt, i_fn);
        txt = Tpl.nextIter(txt);
        txt = lm_40(txt, rest);
      then txt;
  end match;
end lm_40;

public function dumpProgram
  input Tpl.Text in_txt;
  input MidCode.Program in_a_p;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_p)
    local
      Tpl.Text txt;
      list<MidCode.Function> i_functions;

    case ( txt,
           MidCode.PROGRAM(functions = i_functions) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("PROGRAM:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                     "\n",
                                                                     "\n"
                                                                 }, true)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_40(txt, i_functions);
        txt = Tpl.popIter(txt);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpProgram;

protected function lm_42
  input Tpl.Text in_txt;
  input list<MidCode.Var> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.Var> rest;
      MidCode.Var i_i;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_i :: rest )
      equation
        txt = dumpVarType(txt, i_i);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = dumpVarName(txt, i_i);
        txt = Tpl.nextIter(txt);
        txt = lm_42(txt, rest);
      then txt;
  end match;
end lm_42;

protected function smf_43
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
      then txt;
  end match;
end smf_43;

protected function lm_44
  input Tpl.Text in_txt;
  input list<MidCode.Var> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.Var> rest;
      MidCode.Var i_o;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_o :: rest )
      equation
        txt = dumpVarType(txt, i_o);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = dumpVarName(txt, i_o);
        txt = Tpl.nextIter(txt);
        txt = lm_44(txt, rest);
      then txt;
  end match;
end lm_44;

protected function smf_45
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
      then txt;
  end match;
end smf_45;

public function dumpFunction
  input Tpl.Text in_txt;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.Block> i_body;
      list<MidCode.VarBufPtr> i_localBufPtrs;
      list<MidCode.VarBuf> i_localBufs;
      list<MidCode.Var> i_locals;
      MidCode.Function i_fn;
      Absyn.Path i_name;
      list<MidCode.Var> i_outputs;
      list<MidCode.Var> i_inputs;
      Tpl.Text txt_3;
      list<MidCode.Var> ret_3;
      Tpl.Text l_outputArguments;
      Tpl.Text txt_1;
      Tpl.Text l_arguments;

    case ( txt,
           (i_fn as MidCode.FUNCTION(inputs = i_inputs, outputs = i_outputs, name = i_name, locals = i_locals, localBufs = i_localBufs, localBufPtrs = i_localBufPtrs, body = i_body)) )
      equation
        txt_1 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt_1 = lm_42(txt_1, i_inputs);
        txt_1 = Tpl.popIter(txt_1);
        l_arguments = smf_43(Tpl.emptyTxt, txt_1);
        ret_3 = List.restOrEmpty(i_outputs);
        txt_3 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt_3 = lm_44(txt_3, ret_3);
        txt_3 = Tpl.popIter(txt_3);
        l_outputArguments = smf_45(Tpl.emptyTxt, txt_3);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("FUNCTION "));
        txt = underscorePath(txt, i_name);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   INPUTS:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = Tpl.writeText(txt, l_arguments);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   OUTPUTS:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = Tpl.writeText(txt, l_outputArguments);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   LOCAL DECLARATIONS:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = dumpLocalDecls(txt, i_fn, i_locals, i_localBufs, i_localBufPtrs);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   ENTRY:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = dumpEntry(txt, i_fn);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   BASIC BLOCKS:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = dumpBlocks(txt, i_fn, i_body);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("   EXIT:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(5));
        txt = dumpExit(txt, i_fn);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpFunction;

protected function lm_47
  input Tpl.Text in_txt;
  input list<MidCode.Var> in_items;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.Var> rest;
      MidCode.Function a_fn;
      MidCode.Var i_local;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_local :: rest,
           a_fn )
      equation
        txt = dumpLocalDecl(txt, a_fn, i_local);
        txt = Tpl.nextIter(txt);
        txt = lm_47(txt, rest, a_fn);
      then txt;
  end match;
end lm_47;

protected function lm_48
  input Tpl.Text in_txt;
  input list<MidCode.VarBuf> in_items;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.VarBuf> rest;
      MidCode.Function a_fn;
      MidCode.VarBuf i_local;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_local :: rest,
           a_fn )
      equation
        txt = dumpLocalBufDecl(txt, a_fn, i_local);
        txt = Tpl.nextIter(txt);
        txt = lm_48(txt, rest, a_fn);
      then txt;
  end match;
end lm_48;

protected function lm_49
  input Tpl.Text in_txt;
  input list<MidCode.VarBufPtr> in_items;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.VarBufPtr> rest;
      MidCode.Function a_fn;
      MidCode.VarBufPtr i_local;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_local :: rest,
           a_fn )
      equation
        txt = dumpLocalBufPtrDecl(txt, a_fn, i_local);
        txt = Tpl.nextIter(txt);
        txt = lm_49(txt, rest, a_fn);
      then txt;
  end match;
end lm_49;

public function dumpLocalDecls
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input list<MidCode.Var> a_locals;
  input list<MidCode.VarBuf> a_localBufs;
  input list<MidCode.VarBufPtr> a_localBufPtrs;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_LINE("LOCALS:\n"));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_47(out_txt, a_locals, a_fn);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE("LOCAL_BUFS:\n"));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_48(out_txt, a_localBufs, a_fn);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.softNewLine(out_txt);
  out_txt := Tpl.popBlock(out_txt);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_LINE("LOCAL_BUF_PTRS:\n"));
  out_txt := Tpl.pushBlock(out_txt, Tpl.BT_INDENT(2));
  out_txt := Tpl.pushIter(out_txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_49(out_txt, a_localBufPtrs, a_fn);
  out_txt := Tpl.popIter(out_txt);
  out_txt := Tpl.popBlock(out_txt);
end dumpLocalDecls;

protected function fun_51
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;

    case ( txt,
           MidCode.VAR(volatile = true) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VOLATILE "));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end fun_51;

public function dumpLocalDecl
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input MidCode.Var a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_51(txt, a_var);
  out_txt := dumpVarType(out_txt, a_var);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(" "));
  out_txt := dumpVarName(out_txt, a_var);
  out_txt := Tpl.writeTok(out_txt, Tpl.ST_STRING(";"));
end dumpLocalDecl;

public function dumpLocalBufDecl
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input MidCode.VarBuf a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("VarBuf "));
  out_txt := dumpVarBufName(out_txt, a_var);
end dumpLocalBufDecl;

public function dumpLocalBufPtrDecl
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input MidCode.VarBufPtr a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("VarBufPtr "));
  out_txt := dumpVarBufPtrName(out_txt, a_var);
end dumpLocalBufPtrDecl;

public function dumpEntry
  input Tpl.Text in_txt;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_fn)
    local
      Tpl.Text txt;
      Integer i_entryId;

    case ( txt,
           MidCode.FUNCTION(entryId = i_entryId) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("ENTRY "));
        txt = dumpLabel(txt, i_entryId);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpEntry;

public function dumpExit
  input Tpl.Text in_txt;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_fn)
    local
      Tpl.Text txt;
      Integer i_exitId;

    case ( txt,
           MidCode.FUNCTION(exitId = i_exitId) )
      equation
        txt = dumpLabel(txt, i_exitId);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "%>\n",
                                    "RETURN"
                                }, false));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpExit;

protected function lm_57
  input Tpl.Text in_txt;
  input list<MidCode.Block> in_items;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.Block> rest;
      MidCode.Function a_fn;
      MidCode.Block i_block;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_block :: rest,
           a_fn )
      equation
        txt = dumpBlock(txt, a_fn, i_block);
        txt = Tpl.nextIter(txt);
        txt = lm_57(txt, rest, a_fn);
      then txt;
  end match;
end lm_57;

public function dumpBlocks
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input list<MidCode.Block> a_body;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
  out_txt := lm_57(out_txt, a_body, a_fn);
  out_txt := Tpl.popIter(out_txt);
end dumpBlocks;

protected function lm_59
  input Tpl.Text in_txt;
  input list<MidCode.Stmt> in_items;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items, in_a_fn)
    local
      Tpl.Text txt;
      list<MidCode.Stmt> rest;
      MidCode.Function a_fn;
      MidCode.Stmt i_stmt;

    case ( txt,
           {},
           _ )
      then txt;

    case ( txt,
           i_stmt :: rest,
           a_fn )
      equation
        txt = dumpStmt(txt, a_fn, i_stmt);
        txt = Tpl.nextIter(txt);
        txt = lm_59(txt, rest, a_fn);
      then txt;
  end match;
end lm_59;

protected function fun_60
  input Tpl.Text in_txt;
  input MidCode.Block in_a_block;
  input MidCode.Function in_a_fn;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_block, in_a_fn)
    local
      Tpl.Text txt;
      MidCode.Function a_fn;
      MidCode.Terminator i_terminator;
      list<MidCode.Stmt> i_stmts;
      Integer i_id;

    case ( txt,
           MidCode.BLOCK(id = i_id, stmts = i_stmts, terminator = i_terminator),
           a_fn )
      equation
        txt = dumpLabel(txt, i_id);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(":\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_59(txt, i_stmts, a_fn);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = dumpTerminator(txt, a_fn, i_terminator);
        txt = Tpl.popBlock(txt);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end fun_60;

public function dumpBlock
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input MidCode.Block a_block;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_60(txt, a_block, a_fn);
end dumpBlock;

public function dumpLabel
  input Tpl.Text txt;
  input Integer a_i;

  output Tpl.Text out_txt;
algorithm
  out_txt := Tpl.writeTok(txt, Tpl.ST_STRING("LABEL: "));
  out_txt := Tpl.writeStr(out_txt, intString(a_i));
end dumpLabel;

public function dumpVarName
  input Tpl.Text in_txt;
  input MidCode.Var in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_v)
    local
      Tpl.Text txt;
      String i_name;

    case ( txt,
           MidCode.VAR(name = i_name) )
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpVarName;

public function dumpVarBufName
  input Tpl.Text in_txt;
  input MidCode.VarBuf in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_v)
    local
      Tpl.Text txt;
      String i_name;

    case ( txt,
           MidCode.VARBUF(name = i_name) )
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpVarBufName;

public function dumpVarBufPtrName
  input Tpl.Text in_txt;
  input MidCode.VarBufPtr in_a_v;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_v)
    local
      Tpl.Text txt;
      String i_name;

    case ( txt,
           MidCode.VARBUFPTR(name = i_name) )
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end dumpVarBufPtrName;

protected function fun_66
  input Tpl.Text in_txt;
  input MidCode.Stmt in_a_stmt;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_stmt)
    local
      Tpl.Text txt;
      MidCode.RValue i_rvalue;
      String i_dest__name;

    case ( txt,
           MidCode.NOP() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NOP"));
      then txt;

    case ( txt,
           MidCode.ASSIGN(dest = MidCode.VAR(name = i_dest__name, ty = _), src = i_rvalue) )
      equation
        txt = Tpl.writeStr(txt, i_dest__name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
        txt = dumpRValue(txt, i_rvalue);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end fun_66;

public function dumpStmt
  input Tpl.Text txt;
  input MidCode.Function a_fn;
  input MidCode.Stmt a_stmt;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_66(txt, a_stmt);
end dumpStmt;

protected function fun_68
  input Tpl.Text in_txt;
  input Boolean in_a_value;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_value)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("1"));
      then txt;
  end match;
end fun_68;

protected function lm_69
  input Tpl.Text in_txt;
  input list<MidCode.Var> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.Var> rest;
      MidCode.Var i_element;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_element :: rest )
      equation
        txt = dumpVarName(txt, i_element);
        txt = Tpl.nextIter(txt);
        txt = lm_69(txt, rest);
      then txt;
  end match;
end lm_69;

protected function smf_70
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_70;

protected function smf_71
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_71;

protected function smf_72
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_72;

protected function smf_73
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_73;

protected function smf_74
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_74;

protected function smf_75
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_75;

protected function smf_76
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_76;

protected function fun_77
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input Tpl.Text in_a_elementargs;
  input Tpl.Text in_a_metatypeCtor;
  input Tpl.Text in_a_metatypeSlots;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_elementargs, in_a_metatypeCtor, in_a_metatypeSlots)
    local
      Tpl.Text txt;
      Tpl.Text a_elementargs;
      Tpl.Text a_metatypeCtor;
      Tpl.Text a_metatypeSlots;
      DAE.Type i_ty;
      Tpl.Text txt_2;
      Tpl.Text txt_1;
      Tpl.Text l_arguments;

    case ( txt,
           (i_ty as DAE.T_METARECORD(path = _)),
           a_elementargs,
           a_metatypeCtor,
           a_metatypeSlots )
      equation
        txt_1 = Tpl.writeText(Tpl.emptyTxt, a_metatypeSlots);
        txt_1 = Tpl.writeTok(txt_1, Tpl.ST_STRING("+1"));
        txt_2 = Tpl.writeTok(Tpl.emptyTxt, Tpl.ST_STRING("&"));
        txt_2 = dumpTypeUnderscorePath(txt_2, i_ty);
        txt_2 = Tpl.writeTok(txt_2, Tpl.ST_STRING("__desc"));
        l_arguments = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_arguments = smf_70(l_arguments, txt_1);
        l_arguments = smf_71(l_arguments, a_metatypeCtor);
        l_arguments = smf_72(l_arguments, txt_2);
        l_arguments = smf_73(l_arguments, a_elementargs);
        l_arguments = Tpl.popIter(l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("mmc_mk_box("));
        txt = Tpl.writeText(txt, l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           a_elementargs,
           a_metatypeCtor,
           a_metatypeSlots )
      equation
        l_arguments = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_arguments = smf_74(l_arguments, a_metatypeSlots);
        l_arguments = smf_75(l_arguments, a_metatypeCtor);
        l_arguments = smf_76(l_arguments, a_elementargs);
        l_arguments = Tpl.popIter(l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("mmc_mk_box("));
        txt = Tpl.writeText(txt, l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;
  end match;
end fun_77;

public function dumpRValue
  input Tpl.Text in_txt;
  input MidCode.RValue in_a_rvalue;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_rvalue)
    local
      Tpl.Text txt;
      Integer i_index;
      DAE.Type i_ty;
      list<MidCode.Var> i_elements;
      String i_value_3;
      Real i_value_2;
      Boolean i_value_1;
      Integer i_value;
      MidCode.UnaryOp i_op_1;
      MidCode.Var i_src;
      String i_rsrc__name;
      String i_lsrc__name;
      MidCode.Var i_rsrc;
      MidCode.Var i_lsrc;
      MidCode.BinaryOp i_op;
      String i_src__name;
      Integer ret_5;
      Tpl.Text l_elementargs;
      Tpl.Text l_metatypeCtor;
      Integer ret_2;
      Tpl.Text l_metatypeSlots;
      String ret_0;

    case ( txt,
           MidCode.VARIABLE(src = MidCode.VAR(name = i_src__name, ty = _)) )
      equation
        txt = Tpl.writeStr(txt, i_src__name);
      then txt;

    case ( txt,
           MidCode.BINARYOP(op = i_op, lsrc = (i_lsrc as MidCode.VAR(name = _, ty = DAE.T_STRING(varLst = _))), rsrc = (i_rsrc as MidCode.VAR(name = _, ty = DAE.T_STRING(varLst = _)))) )
      equation
        txt = dumpStringBinaryop(txt, i_op, i_lsrc, i_rsrc);
      then txt;

    case ( txt,
           MidCode.BINARYOP(op = MidCode.POW(), lsrc = MidCode.VAR(name = i_lsrc__name, ty = _), rsrc = MidCode.VAR(name = i_rsrc__name, ty = _)) )
      equation
        txt = Tpl.writeStr(txt, i_lsrc__name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ^ "));
        txt = Tpl.writeStr(txt, i_rsrc__name);
      then txt;

    case ( txt,
           MidCode.BINARYOP(op = i_op, lsrc = MidCode.VAR(name = i_lsrc__name, ty = _), rsrc = MidCode.VAR(name = i_rsrc__name, ty = _)) )
      equation
        txt = Tpl.writeStr(txt, i_lsrc__name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = binaryopToString(txt, i_op);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = Tpl.writeStr(txt, i_rsrc__name);
      then txt;

    case ( txt,
           MidCode.UNARYOP(op = MidCode.BOX(), src = i_src) )
      equation
        txt = varBox(txt, i_src);
      then txt;

    case ( txt,
           MidCode.UNARYOP(op = MidCode.UNBOX(), src = i_src) )
      equation
        txt = varUnbox(txt, i_src);
      then txt;

    case ( txt,
           MidCode.UNARYOP(op = i_op_1, src = i_src) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("("));
        txt = dumpVarType(txt, i_src);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") "));
        txt = unaryopToString(txt, i_op_1);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = dumpVarName(txt, i_src);
      then txt;

    case ( txt,
           MidCode.LITERALINTEGER(value = i_value) )
      equation
        txt = Tpl.writeStr(txt, intString(i_value));
      then txt;

    case ( txt,
           MidCode.LITERALBOOLEAN(value = i_value_1) )
      equation
        txt = fun_68(txt, i_value_1);
      then txt;

    case ( txt,
           MidCode.LITERALREAL(value = i_value_2) )
      equation
        txt = Tpl.writeStr(txt, realString(i_value_2));
      then txt;

    case ( txt,
           MidCode.LITERALSTRING(value = i_value_3) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("mmc_mk_scon(\""));
        ret_0 = Util.escapeModelicaStringToCString(i_value_3);
        txt = Tpl.writeStr(txt, ret_0);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("\")"));
      then txt;

    case ( txt,
           MidCode.LITERALMETATYPE(elements = i_elements, ty = i_ty) )
      equation
        ret_2 = listLength(i_elements);
        l_metatypeSlots = Tpl.writeStr(Tpl.emptyTxt, intString(ret_2));
        l_metatypeCtor = dumpTypeCtorIndex(Tpl.emptyTxt, i_elements, i_ty);
        l_elementargs = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_elementargs = lm_69(l_elementargs, i_elements);
        l_elementargs = Tpl.popIter(l_elementargs);
        txt = fun_77(txt, i_ty, l_elementargs, l_metatypeCtor, l_metatypeSlots);
      then txt;

    case ( txt,
           MidCode.METAFIELD(src = i_src, index = i_index, ty = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("MMC_FETCH(MMC_OFFSET(MMC_UNTAGPTR("));
        txt = dumpVarName(txt, i_src);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("),"));
        ret_5 = intAdd(i_index, 1);
        txt = Tpl.writeStr(txt, intString(ret_5));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("))"));
      then txt;

    case ( txt,
           MidCode.UNIONTYPEVARIANT(src = i_src) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(MMC_HDRCTOR(MMC_GETHDR("));
        txt = dumpVarName(txt, i_src);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")) - 3)"));
      then txt;

    case ( txt,
           MidCode.ISSOME(src = i_src) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(0==MMC_HDRSLOTS(MMC_GETHDR("));
        txt = dumpVarName(txt, i_src);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")) ? 0 : 1)"));
      then txt;

    case ( txt,
           MidCode.ISCONS(src = i_src) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("(MMC_GETHDR("));
        txt = dumpVarName(txt, i_src);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(") == MMC_CONSHDR)"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("notimplemented"));
      then txt;
  end match;
end dumpRValue;

public function binaryopToString
  input Tpl.Text in_txt;
  input MidCode.BinaryOp in_a_op;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_op)
    local
      Tpl.Text txt;

    case ( txt,
           MidCode.ADD() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("+"));
      then txt;

    case ( txt,
           MidCode.SUB() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
      then txt;

    case ( txt,
           MidCode.MUL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("*"));
      then txt;

    case ( txt,
           MidCode.DIV() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("/"));
      then txt;

    case ( txt,
           MidCode.LESS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<"));
      then txt;

    case ( txt,
           MidCode.LESSEQ() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("<="));
      then txt;

    case ( txt,
           MidCode.GREATER() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(">"));
      then txt;

    case ( txt,
           MidCode.GREATEREQ() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(">="));
      then txt;

    case ( txt,
           MidCode.EQUAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("=="));
      then txt;

    case ( txt,
           MidCode.NEQUAL() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!="));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("notimplemented"));
      then txt;
  end match;
end binaryopToString;

public function unaryopToString
  input Tpl.Text in_txt;
  input MidCode.UnaryOp in_a_op;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_op)
    local
      Tpl.Text txt;

    case ( txt,
           MidCode.MOVE() )
      then txt;

    case ( txt,
           MidCode.UMINUS() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("-"));
      then txt;

    case ( txt,
           MidCode.NOT() )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("!"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("notimplemented"));
      then txt;
  end match;
end unaryopToString;

public function dumpStringBinaryop
  input Tpl.Text in_txt;
  input MidCode.BinaryOp in_a_op;
  input MidCode.Var in_a_lsrc;
  input MidCode.Var in_a_rsrc;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_op, in_a_lsrc, in_a_rsrc)
    local
      Tpl.Text txt;
      MidCode.Var a_lsrc;
      MidCode.Var a_rsrc;

    case ( txt,
           MidCode.ADD(),
           a_lsrc,
           a_rsrc )
      equation
        txt = dumpVarName(txt, a_lsrc);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" + "));
        txt = dumpVarName(txt, a_rsrc);
      then txt;

    case ( txt,
           _,
           _,
           a_rsrc )
      equation
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("dumpVarName(lsrc)%> == "));
        txt = dumpVarName(txt, a_rsrc);
        txt = Tpl.popBlock(txt);
      then txt;
  end match;
end dumpStringBinaryop;

protected function lm_82
  input Tpl.Text in_txt;
  input list<tuple<Integer, Integer>> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<tuple<Integer, Integer>> rest;
      Integer i_to;
      Integer i_from;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           (i_from, i_to) :: rest )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("CASE "));
        txt = Tpl.writeStr(txt, intString(i_from));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(": "));
        txt = dumpLabel(txt, i_to);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(";"));
        txt = Tpl.nextIter(txt);
        txt = lm_82(txt, rest);
      then txt;
  end match;
end lm_82;

protected function fun_83
  input Tpl.Text in_txt;
  input list<MidCode.OutVar> in_a_outputs;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_outputs)
    local
      Tpl.Text txt;
      MidCode.Var i_var;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           MidCode.OUT_WILD() :: _ )
      then txt;

    case ( txt,
           MidCode.OUT_VAR(var = i_var) :: _ )
      equation
        txt = dumpVarName(txt, i_var);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" = "));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end fun_83;

protected function lm_84
  input Tpl.Text in_txt;
  input list<MidCode.Var> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.Var> rest;
      MidCode.Var i_i;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_i :: rest )
      equation
        txt = dumpVarName(txt, i_i);
        txt = Tpl.nextIter(txt);
        txt = lm_84(txt, rest);
      then txt;
  end match;
end lm_84;

protected function fun_85
  input Tpl.Text in_txt;
  input MidCode.OutVar in_a_o;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_o)
    local
      Tpl.Text txt;
      MidCode.Var i_var;

    case ( txt,
           MidCode.OUT_VAR(var = i_var) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("&"));
        txt = dumpVarName(txt, i_var);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("NULL"));
      then txt;
  end match;
end fun_85;

protected function lm_86
  input Tpl.Text in_txt;
  input list<MidCode.OutVar> in_items;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_items)
    local
      Tpl.Text txt;
      list<MidCode.OutVar> rest;
      MidCode.OutVar i_o;

    case ( txt,
           {} )
      then txt;

    case ( txt,
           i_o :: rest )
      equation
        txt = fun_85(txt, i_o);
        txt = Tpl.nextIter(txt);
        txt = lm_86(txt, rest);
      then txt;
  end match;
end lm_86;

protected function smf_87
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_87;

protected function smf_88
  input Tpl.Text in_txt;
  input Tpl.Text in_it;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_it)
    local
      Tpl.Text txt;
      Tpl.Text i_it;

    case ( txt,
           i_it )
      equation
        txt = Tpl.writeText(txt, i_it);
        txt = Tpl.nextIter(txt);
      then txt;
  end match;
end smf_88;

protected function fun_89
  input Tpl.Text in_txt;
  input Boolean in_a_builtin;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_builtin)
    local
      Tpl.Text txt;

    case ( txt,
           false )
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BUILTIN CALL:"));
      then txt;
  end match;
end fun_89;

protected function fun_90
  input Tpl.Text in_txt;
  input MidCode.Terminator in_a_terminator;
  input Integer in_a_exitId;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_terminator, in_a_exitId)
    local
      Tpl.Text txt;
      Integer a_exitId;
      MidCode.VarBufPtr i_old__buf;
      Absyn.Path i_func;
      Boolean i_builtin;
      list<MidCode.Var> i_inputs;
      list<MidCode.OutVar> i_outputs;
      list<tuple<Integer, Integer>> i_cases;
      Integer i_labelFalse;
      Integer i_labelTrue;
      MidCode.Var i_condition;
      Integer i_label;
      Tpl.Text txt_3;
      list<MidCode.OutVar> ret_3;
      Tpl.Text txt_2;
      Tpl.Text l_arguments;
      Tpl.Text l_returnAssignment;

    case ( txt,
           MidCode.RETURN(),
           a_exitId )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("RETURN:  "));
        txt = dumpLabel(txt, a_exitId);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.GOTO(next = i_label),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("GOTO:  "));
        txt = dumpLabel(txt, i_label);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.BRANCH(condition = i_condition, onTrue = i_labelTrue, onFalse = i_labelFalse),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("BRANCH: ("));
        txt = dumpVarName(txt, i_condition);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(")\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("onTrue "));
        txt = dumpLabel(txt, i_labelTrue);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("onFalse "));
        txt = dumpLabel(txt, i_labelFalse);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.SWITCH(condition = i_condition, cases = i_cases),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("SWITCH ("));
        txt = dumpVarName(txt, i_condition);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("):\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.pushIter(txt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_NEW_LINE()), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt = lm_82(txt, i_cases);
        txt = Tpl.popIter(txt);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.CALL(func = i_func, builtin = i_builtin, inputs = i_inputs, outputs = i_outputs, next = _),
           _ )
      equation
        l_returnAssignment = fun_83(Tpl.emptyTxt, i_outputs);
        txt_2 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt_2 = lm_84(txt_2, i_inputs);
        txt_2 = Tpl.popIter(txt_2);
        ret_3 = List.restOrEmpty(i_outputs);
        txt_3 = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING(", ")), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        txt_3 = lm_86(txt_3, ret_3);
        txt_3 = Tpl.popIter(txt_3);
        l_arguments = Tpl.pushIter(Tpl.emptyTxt, Tpl.ITER_OPTIONS(0, NONE(), SOME(Tpl.ST_STRING_LIST({
                                                                                      ",\n",
                                                                                      "    "
                                                                                  }, false)), 0, 0, Tpl.ST_NEW_LINE(), 0, Tpl.ST_NEW_LINE()));
        l_arguments = smf_87(l_arguments, txt_2);
        l_arguments = smf_88(l_arguments, txt_3);
        l_arguments = Tpl.popIter(l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("CALL:\n"));
        txt = fun_89(txt, i_builtin);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeText(txt, l_returnAssignment);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" "));
        txt = underscorePath(txt, i_func);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(" ("));
        txt = Tpl.writeText(txt, l_arguments);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE(")\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.LONGJMP(),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "LONGJMP()\n",
                                    "END OF BLOCK"
                                }, false));
      then txt;

    case ( txt,
           MidCode.PUSHJMP(old_buf = i_old__buf),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("PUSHJMP:\n"));
        txt = Tpl.pushBlock(txt, Tpl.BT_INDENT(2));
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("PUSH"));
        txt = dumpVarBufPtrName(txt, i_old__buf);
        txt = Tpl.softNewLine(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_LINE("SET_JMP(dumpVarBufName(new_buf))\n"));
        txt = Tpl.popBlock(txt);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("END OF BLOCK"));
      then txt;

    case ( txt,
           MidCode.POPJMP(old_buf = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING_LIST({
                                    "POPJMP:\n",
                                    "  POP(old_buf)\n",
                                    "END OF BLOCK"
                                }, false));
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("notimplemented"));
      then txt;
  end match;
end fun_90;

public function dumpTerminator
  input Tpl.Text in_txt;
  input MidCode.Function in_a_fn;
  input MidCode.Terminator in_a_terminator;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_fn, in_a_terminator)
    local
      Tpl.Text txt;
      MidCode.Terminator a_terminator;
      Integer i_exitId;

    case ( txt,
           MidCode.FUNCTION(locals = _, inputs = _, outputs = _, body = _, entryId = _, exitId = i_exitId),
           a_terminator )
      equation
        txt = fun_90(txt, a_terminator, i_exitId);
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end dumpTerminator;

protected function fun_92
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;
  input Tpl.Text in_a_attr;

  output Tpl.Text out_txt;
  output Tpl.Text out_a_attr;
algorithm
  (out_txt, out_a_attr) :=
  match(in_txt, in_a_var, in_a_attr)
    local
      Tpl.Text txt;
      Tpl.Text a_attr;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = _, ty = i_ty),
           a_attr )
      equation
        (txt, a_attr) = DAEDumpTpl.dumpType(txt, i_ty, a_attr);
      then (txt, a_attr);

    case ( txt,
           _,
           a_attr )
      then (txt, a_attr);
  end match;
end fun_92;

public function dumpVarType
  input Tpl.Text txt;
  input MidCode.Var a_var;

  output Tpl.Text out_txt;
protected
  Tpl.Text l_attr;
algorithm
  l_attr := Tpl.emptyTxt;
  (out_txt, l_attr) := fun_92(txt, a_var, l_attr);
end dumpVarType;

protected function fun_94
  input Tpl.Text in_txt;
  input Integer in_mArg;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_mArg)
    local
      Tpl.Text txt;

    case ( txt,
           0 )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0"));
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("1"));
      then txt;
  end match;
end fun_94;

protected function fun_95
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input list<MidCode.Var> in_a_elements;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_elements)
    local
      Tpl.Text txt;
      list<MidCode.Var> a_elements;
      Integer i_index;
      Integer ret_1;
      Integer ret_0;

    case ( txt,
           DAE.T_METARECORD(index = i_index),
           _ )
      equation
        ret_0 = intAdd(i_index, 3);
        txt = Tpl.writeStr(txt, intString(ret_0));
      then txt;

    case ( txt,
           DAE.T_METAARRAY(ty = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("2"));
      then txt;

    case ( txt,
           DAE.T_METATUPLE(types = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0"));
      then txt;

    case ( txt,
           DAE.T_METAOPTION(ty = _),
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("1"));
      then txt;

    case ( txt,
           DAE.T_METALIST(ty = _),
           a_elements )
      equation
        ret_1 = listLength(a_elements);
        txt = fun_94(txt, ret_1);
      then txt;

    case ( txt,
           _,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("0"));
      then txt;
  end match;
end fun_95;

public function dumpTypeCtorIndex
  input Tpl.Text txt;
  input list<MidCode.Var> a_elements;
  input DAE.Type a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt := fun_95(txt, a_ty, a_elements);
end dumpTypeCtorIndex;

public function dumpTypeUnderscorePath
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty)
    local
      Tpl.Text txt;
      Absyn.Path i_path;

    case ( txt,
           DAE.T_METARECORD(path = i_path) )
      equation
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = ClassInf.RECORD(path = i_path), varLst = _) )
      equation
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("error: dumpTypeUnderscorePath"));
      then txt;
  end match;
end dumpTypeUnderscorePath;

protected function fun_98
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty)
    local
      Tpl.Text txt;

    case ( txt,
           DAE.T_INTEGER(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VAR_BOX"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VAR_BOX"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VAR_BOX"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _) )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("VAR_BOX"));
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end fun_98;

public function varBoxType
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = _, ty = i_ty) )
      equation
        txt = fun_98(txt, i_ty);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varBoxType;

protected function fun_100
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input String in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_name)
    local
      Tpl.Text txt;
      String a_name;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_ENUMERATION_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_ENUMERATION_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_BOOL_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_REAL_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_STRING_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("T_COMPLEX_BOX("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           a_name )
      equation
        txt = Tpl.writeStr(txt, a_name);
      then txt;
  end match;
end fun_100;

public function varBox
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = i_name, ty = i_ty) )
      equation
        txt = fun_100(txt, i_ty, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varBox;

protected function fun_102
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input String in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_name)
    local
      Tpl.Text txt;
      String a_name;

    case ( txt,
           DAE.T_METABOXED(ty = DAE.T_INTEGER(varLst = _)),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METABOXED(ty = DAE.T_ENUMERATION(index = _)),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METABOXED(ty = DAE.T_BOOL(varLst = _)),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METABOXED(ty = DAE.T_REAL(varLst = _)),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("META_UNBOX_REAL("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("mmc_unbox_string("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           a_name )
      equation
        txt = Tpl.writeStr(txt, a_name);
      then txt;
  end match;
end fun_102;

public function varUnbox
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = i_name, ty = i_ty) )
      equation
        txt = fun_102(txt, i_ty, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varUnbox;

protected function fun_104
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input String in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_name)
    local
      Tpl.Text txt;
      String a_name;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNBOX_INTEGER("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNBOX_REAL("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("UNBOX_STRING("));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           a_name )
      equation
        txt = Tpl.writeStr(txt, a_name);
      then txt;
  end match;
end fun_104;

public function varUnbox2
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = i_name, ty = i_ty) )
      equation
        txt = fun_104(txt, i_ty, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varUnbox2;

protected function fun_106
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input String in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_name)
    local
      Tpl.Text txt;
      String a_name;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_integer(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_integer(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_real(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_string(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_integer(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAUNIONTYPE(paths = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METALIST(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAARRAY(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAOPTION(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METATUPLE(types = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("read_modelica_metatype(&inArgs, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end fun_106;

public function varModelicaRead
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = i_name, ty = i_ty) )
      equation
        txt = fun_106(txt, i_ty, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varModelicaRead;

protected function fun_108
  input Tpl.Text in_txt;
  input DAE.Type in_a_ty;
  input String in_a_name;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_ty, in_a_name)
    local
      Tpl.Text txt;
      String a_name;

    case ( txt,
           DAE.T_INTEGER(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_integer(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_BOOL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_integer(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_REAL(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_real(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_STRING(varLst = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_string(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_ENUMERATION(index = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_integer(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_COMPLEX(complexClassType = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAUNIONTYPE(paths = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METALIST(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAARRAY(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METAOPTION(ty = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           DAE.T_METATUPLE(types = _),
           a_name )
      equation
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("write_modelica_metatype(outVar, &"));
        txt = Tpl.writeStr(txt, a_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING(")"));
      then txt;

    case ( txt,
           _,
           _ )
      then txt;
  end match;
end fun_108;

public function varModelicaWrite
  input Tpl.Text in_txt;
  input MidCode.Var in_a_var;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_var)
    local
      Tpl.Text txt;
      String i_name;
      DAE.Type i_ty;

    case ( txt,
           MidCode.VAR(name = i_name, ty = i_ty) )
      equation
        txt = fun_108(txt, i_ty, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end varModelicaWrite;

public function identName
  input Tpl.Text in_txt;
  input Absyn.Path in_a_path;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_path)
    local
      Tpl.Text txt;
      String i_name;

    case ( txt,
           Absyn.IDENT(name = i_name) )
      equation
        txt = Tpl.writeStr(txt, i_name);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end identName;

public function replaceDotAndUnderscore
  input Tpl.Text in_txt;
  input String in_a_str;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_str)
    local
      Tpl.Text txt;
      String i_name;
      String ret_4;
      String ret_3;
      Tpl.Text l_str__underscores;
      String ret_1;
      Tpl.Text l_str__dots;

    case ( txt,
           i_name )
      equation
        ret_1 = System.stringReplace(i_name, ".", "_");
        l_str__dots = Tpl.writeStr(Tpl.emptyTxt, ret_1);
        ret_3 = System.stringReplace(Tpl.textString(l_str__dots), "_", "__");
        l_str__underscores = Tpl.writeStr(Tpl.emptyTxt, ret_3);
        ret_4 = System.unquoteIdentifier(Tpl.textString(l_str__underscores));
        txt = Tpl.writeStr(txt, ret_4);
      then txt;
  end match;
end replaceDotAndUnderscore;

public function underscorePath
  input Tpl.Text in_txt;
  input Absyn.Path in_a_path;

  output Tpl.Text out_txt;
algorithm
  out_txt :=
  match(in_txt, in_a_path)
    local
      Tpl.Text txt;
      String i_name_1;
      Absyn.Path i_path;
      Absyn.Ident i_name;

    case ( txt,
           Absyn.QUALIFIED(name = i_name, path = i_path) )
      equation
        txt = replaceDotAndUnderscore(txt, i_name);
        txt = Tpl.writeTok(txt, Tpl.ST_STRING("_"));
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           Absyn.IDENT(name = i_name_1) )
      equation
        txt = replaceDotAndUnderscore(txt, i_name_1);
      then txt;

    case ( txt,
           Absyn.FULLYQUALIFIED(path = i_path) )
      equation
        txt = underscorePath(txt, i_path);
      then txt;

    case ( txt,
           _ )
      then txt;
  end match;
end underscorePath;

annotation(__OpenModelica_Interface="backend");
end MidCodeDump;