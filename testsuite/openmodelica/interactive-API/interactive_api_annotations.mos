// name: Test Interactive API for Annotations for MSL 3.1
// keywords: Graphical API, annotations
// status: correct
// Subset of the Graphical API for annotations
//

setCommandLineOptions({"+d=showStatement"});
getAnnotationVersion();
setAnnotationVersion("3.x");
getAnnotationVersion();


loadModel(Modelica,{"3.1"}); getErrorString();
// delete Modelica.Fluid and Modelica.Media so we don't get the compiler into an infinite loop
// deleteClass(Modelica.Fluid); getErrorString();
// deleteClass(Modelica.Media); getErrorString();


// test the annotation getting from UsersGuide
getIconAnnotation(Modelica.UsersGuide);            getErrorString();
getDiagramAnnotation(Modelica.UsersGuide);         getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide);   getErrorString();

// test bug 1538
getComponentAnnotations(Modelica.Blocks.Sources.RealExpression); getErrorString();
getComponentAnnotations(Modelica.Blocks.Sources.IntegerExpression); getErrorString();
getComponentAnnotations(Modelica.Blocks.Sources.BooleanExpression); getErrorString();


// test getting of non-standard annotation
getNamedAnnotation(Modelica.UsersGuide, __Dymola_DocumentationClass); getErrorString();
// test getting of non-standard annotation
getNamedAnnotation(Modelica, __Dymola_DocumentationClass); getErrorString();

// If we set the annotations version to 3, then the OMC API getIconAnnotation don't returns the flat model for some components.
// I have tried it for Resistor, Conductor, EMF..........i am not sure how many more have this problem.
// Here is the output for 3 of them


getIconAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor);           getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor);        getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor);  getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Basic.Resistor);                     getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Basic.Resistor);                  getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.Resistor);            getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor);              getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor);           getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor);     getErrorString();

getIconAnnotation(Modelica.Electrical.Analog.Basic.EMF);                          getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Basic.EMF);                       getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.EMF);                 getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Basic.Conductor);                    getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Basic.Conductor);                 getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.Conductor);           getErrorString();

"I am using MSL31";
// One more thing, can someone tell me what is the output of getComponentAnnotations,

getIconAnnotation(Modelica.Electrical.Analog.Basic.Ground); getErrorString();
getComponentAnnotations(Modelica.Electrical.Analog.Basic.Ground); getErrorString();


// What does each parameter means? I have looked for it in the Modelica Specifications for 3.2 but couldn't find anything.
// One more thing i have noticed is, the default parameter values for the components are empty. Like,

getParameterNames(Modelica.Electrical.Analog.Basic.Resistor);                   getErrorString();
// R one doesn't have a default value!
getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "R");                getErrorString();
// the modification names
getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "R");        getErrorString();
// retrieve the start value
getComponentModifierValue(Modelica.Electrical.Analog.Basic.Resistor, R.start);  getErrorString();
// remove the component modifiers
removeComponentModifiers(Modelica.Electrical.Analog.Basic.Resistor, "R");         getErrorString();
// the modification names again, should be empty now
getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "R");        getErrorString();
getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "T_ref");            getErrorString();
getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "T_ref");    getErrorString();
getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "alpha");            getErrorString();
getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "alpha");    getErrorString();


// Also there are old bug report related to this issue: bug 1166 and 1160
// Best Regards Mohsen


// get documentation from package
getDocumentationAnnotation(Modelica.Mechanics.Rotational.Components); getErrorString();
// get documentation from model
getDocumentationAnnotation(Modelica.Mechanics.Rotational.Components.Intertia); getErrorString();
// get documentation from package
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic); getErrorString();
// get documentation from model
getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.EMF); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.StateGraph
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.StateGraph.UsersGuide.OverView); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.OverView); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.OverView); getErrorString();


getIconAnnotation(Modelica.StateGraph.UsersGuide.FirstExample); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.FirstExample); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.FirstExample); getErrorString();


getIconAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample); getErrorString();


getIconAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes); getErrorString();


getIconAnnotation(Modelica.StateGraph.UsersGuide.Literature); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.Literature); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.Literature); getErrorString();


getIconAnnotation(Modelica.StateGraph.UsersGuide.Contact); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.UsersGuide.Contact); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.Contact); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.FirstExample); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.ExecutionPaths); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.ExecutionPaths); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.ExecutionPaths); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.ShowExceptions); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.ShowExceptions); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.ShowExceptions); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.ControlledTanks); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.ControlledTanks); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.ControlledTanks); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.TankController); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.TankController); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.TankController); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.valve); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.valve); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.valve); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.Tank); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.Tank); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.Tank); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.Source); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.Source); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.Source); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1); getErrorString();


getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.PartialStep); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialStep); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialStep); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.PartialTransition); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialTransition); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialTransition); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon); getErrorString();


getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState); getErrorString();


getIconAnnotation(Modelica.StateGraph.StateGraphRoot); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.StateGraphRoot); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.StateGraphRoot); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.SetRealParameter); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.SetRealParameter); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.SetRealParameter); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.anyTrue); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.anyTrue); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.anyTrue); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.allTrue); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.allTrue); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.allTrue); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.RadioButton); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.RadioButton); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.RadioButton); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.NumericValue); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.NumericValue); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.NumericValue); getErrorString();


getIconAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp); getErrorString();
getDiagramAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp); getErrorString();
getDocumentationAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp); getErrorString();

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.SIunits
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits); getErrorString();
getDiagramAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits); getErrorString();


getIconAnnotation(Modelica.SIunits.UsersGuide.Conventions); getErrorString();
getDiagramAnnotation(Modelica.SIunits.UsersGuide.Conventions); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Conventions); getErrorString();


getIconAnnotation(Modelica.SIunits.UsersGuide.Literature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.UsersGuide.Literature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Literature); getErrorString();


getIconAnnotation(Modelica.SIunits.UsersGuide.Contact); getErrorString();
getDiagramAnnotation(Modelica.SIunits.UsersGuide.Contact); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Contact); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_degC); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_degC); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degC); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_degC); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_degC); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degC); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_degF); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_degF); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degF); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_degF); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_degF); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degF); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_degRk); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_degRk); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degRk); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_degRk); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_degRk); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degRk); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_deg); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_deg); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_deg); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_deg); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_deg); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_deg); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_rpm); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_rpm); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_rpm); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_rpm); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_rpm); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_rpm); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_kmh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_kmh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_kmh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_kmh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_kmh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_kmh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_day); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_day); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_day); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_day); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_day); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_day); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_hour); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_hour); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_hour); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_hour); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_hour); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_hour); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_minute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_minute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_minute); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_minute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_minute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_minute); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_litre); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_litre); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_litre); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_litre); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_litre); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_litre); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_kWh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_kWh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_kWh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_kWh); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_kWh); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_kWh); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_bar); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_bar); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_bar); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_bar); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_bar); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_bar); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_gps); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_gps); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_gps); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_gps); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_gps); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_gps); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.ConversionIcon); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.ConversionIcon); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.ConversionIcon); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.from_Hz); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.from_Hz); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.from_Hz); getErrorString();


getIconAnnotation(Modelica.SIunits.Conversions.to_Hz); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conversions.to_Hz); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conversions.to_Hz); getErrorString();


getIconAnnotation(Modelica.SIunits.Angle); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Angle); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Angle); getErrorString();


getIconAnnotation(Modelica.SIunits.SolidAngle); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SolidAngle); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SolidAngle); getErrorString();


getIconAnnotation(Modelica.SIunits.Length); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Length); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Length); getErrorString();


getIconAnnotation(Modelica.SIunits.PathLength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PathLength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PathLength); getErrorString();


getIconAnnotation(Modelica.SIunits.Position); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Position); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Position); getErrorString();


getIconAnnotation(Modelica.SIunits.Distance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Distance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Distance); getErrorString();


getIconAnnotation(Modelica.SIunits.Breadth); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Breadth); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Breadth); getErrorString();


getIconAnnotation(Modelica.SIunits.Height); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Height); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Height); getErrorString();


getIconAnnotation(Modelica.SIunits.Thickness); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Thickness); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Thickness); getErrorString();


getIconAnnotation(Modelica.SIunits.Radius); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Radius); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Radius); getErrorString();


getIconAnnotation(Modelica.SIunits.Diameter); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Diameter); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Diameter); getErrorString();


getIconAnnotation(Modelica.SIunits.Area); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Area); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Area); getErrorString();


getIconAnnotation(Modelica.SIunits.Volume); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Volume); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Volume); getErrorString();


getIconAnnotation(Modelica.SIunits.Time); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Time); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Time); getErrorString();


getIconAnnotation(Modelica.SIunits.Duration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Duration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Duration); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularVelocity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularVelocity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularVelocity); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularAcceleration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularAcceleration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularAcceleration); getErrorString();


getIconAnnotation(Modelica.SIunits.Velocity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Velocity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Velocity); getErrorString();


getIconAnnotation(Modelica.SIunits.Acceleration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Acceleration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Acceleration); getErrorString();


getIconAnnotation(Modelica.SIunits.Period); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Period); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Period); getErrorString();


getIconAnnotation(Modelica.SIunits.Frequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Frequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Frequency); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularFrequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularFrequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularFrequency); getErrorString();


getIconAnnotation(Modelica.SIunits.Wavelength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Wavelength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Wavelength); getErrorString();


getIconAnnotation(Modelica.SIunits.Wavelenght); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Wavelenght); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Wavelenght); getErrorString();


getIconAnnotation(Modelica.SIunits.WaveNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.WaveNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.WaveNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.CircularWaveNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CircularWaveNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CircularWaveNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.AmplitudeLevelDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AmplitudeLevelDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AmplitudeLevelDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.PowerLevelDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PowerLevelDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PowerLevelDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.DampingCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DampingCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DampingCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.LogarithmicDecrement); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LogarithmicDecrement); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LogarithmicDecrement); getErrorString();


getIconAnnotation(Modelica.SIunits.AttenuationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AttenuationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AttenuationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.PhaseCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PhaseCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PhaseCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.PropagationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PropagationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PropagationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.Damping); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Damping); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Damping); getErrorString();


getIconAnnotation(Modelica.SIunits.Mass); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Mass); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Mass); getErrorString();


getIconAnnotation(Modelica.SIunits.Density); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Density); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Density); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativeDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativeDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativeDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificVolume); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificVolume); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificVolume); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.SurfaceDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SurfaceDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SurfaceDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.Momentum); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Momentum); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Momentum); getErrorString();


getIconAnnotation(Modelica.SIunits.Impulse); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Impulse); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Impulse); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularMomentum); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularMomentum); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularMomentum); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularImpulse); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularImpulse); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularImpulse); getErrorString();


getIconAnnotation(Modelica.SIunits.MomentOfInertia); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MomentOfInertia); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MomentOfInertia); getErrorString();


getIconAnnotation(Modelica.SIunits.Inertia); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Inertia); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Inertia); getErrorString();


getIconAnnotation(Modelica.SIunits.Force); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Force); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Force); getErrorString();


getIconAnnotation(Modelica.SIunits.TranslationalSpringConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TranslationalSpringConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TranslationalSpringConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.TranslationalDampingConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TranslationalDampingConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TranslationalDampingConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.Weight); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Weight); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Weight); getErrorString();


getIconAnnotation(Modelica.SIunits.Torque); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Torque); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Torque); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricalTorqueConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricalTorqueConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricalTorqueConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.MomentOfForce); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MomentOfForce); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MomentOfForce); getErrorString();


getIconAnnotation(Modelica.SIunits.RotationalSpringConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RotationalSpringConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RotationalSpringConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.RotationalDampingConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RotationalDampingConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RotationalDampingConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.Pressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Pressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Pressure); getErrorString();


getIconAnnotation(Modelica.SIunits.AbsolutePressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AbsolutePressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AbsolutePressure); getErrorString();


getIconAnnotation(Modelica.SIunits.BulkModulus); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BulkModulus); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BulkModulus); getErrorString();


getIconAnnotation(Modelica.SIunits.Stress); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Stress); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Stress); getErrorString();


getIconAnnotation(Modelica.SIunits.NormalStress); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NormalStress); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NormalStress); getErrorString();


getIconAnnotation(Modelica.SIunits.ShearStress); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ShearStress); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ShearStress); getErrorString();


getIconAnnotation(Modelica.SIunits.Strain); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Strain); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Strain); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearStrain); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearStrain); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearStrain); getErrorString();


getIconAnnotation(Modelica.SIunits.ShearStrain); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ShearStrain); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ShearStrain); getErrorString();


getIconAnnotation(Modelica.SIunits.VolumeStrain); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VolumeStrain); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VolumeStrain); getErrorString();


getIconAnnotation(Modelica.SIunits.PoissonNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PoissonNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PoissonNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.ModulusOfElasticity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ModulusOfElasticity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ModulusOfElasticity); getErrorString();


getIconAnnotation(Modelica.SIunits.ShearModulus); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ShearModulus); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ShearModulus); getErrorString();


getIconAnnotation(Modelica.SIunits.SecondMomentOfArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SecondMomentOfArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SecondMomentOfArea); getErrorString();


getIconAnnotation(Modelica.SIunits.SecondPolarMomentOfArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SecondPolarMomentOfArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SecondPolarMomentOfArea); getErrorString();


getIconAnnotation(Modelica.SIunits.SectionModulus); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SectionModulus); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SectionModulus); getErrorString();


getIconAnnotation(Modelica.SIunits.CoefficientOfFriction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CoefficientOfFriction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CoefficientOfFriction); getErrorString();


getIconAnnotation(Modelica.SIunits.DynamicViscosity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DynamicViscosity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DynamicViscosity); getErrorString();


getIconAnnotation(Modelica.SIunits.KinematicViscosity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.KinematicViscosity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.KinematicViscosity); getErrorString();


getIconAnnotation(Modelica.SIunits.SurfaceTension); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SurfaceTension); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SurfaceTension); getErrorString();


getIconAnnotation(Modelica.SIunits.Work); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Work); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Work); getErrorString();


getIconAnnotation(Modelica.SIunits.Energy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Energy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Energy); getErrorString();


getIconAnnotation(Modelica.SIunits.EnergyDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnergyDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnergyDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.PotentialEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PotentialEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PotentialEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.KineticEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.KineticEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.KineticEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.Power); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Power); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Power); getErrorString();


getIconAnnotation(Modelica.SIunits.EnergyFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnergyFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnergyFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.EnthalpyFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnthalpyFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnthalpyFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.Efficiency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Efficiency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Efficiency); getErrorString();


getIconAnnotation(Modelica.SIunits.MassFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.VolumeFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VolumeFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VolumeFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.MomentumFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MomentumFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MomentumFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularMomentumFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularMomentumFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularMomentumFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermodynamicTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermodynamicTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermodynamicTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.Temp_K); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Temp_K); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Temp_K); getErrorString();


getIconAnnotation(Modelica.SIunits.Temperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Temperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Temperature); getErrorString();


getIconAnnotation(Modelica.SIunits.TemperatureDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TemperatureDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TemperatureDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.Temp_C); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Temp_C); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Temp_C); getErrorString();


getIconAnnotation(Modelica.SIunits.TemperatureSlope); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TemperatureSlope); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TemperatureSlope); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearTemperatureCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearTemperatureCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearTemperatureCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearExpansionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearExpansionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearExpansionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.CubicExpansionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CubicExpansionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CubicExpansionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativePressureCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativePressureCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativePressureCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.PressureCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PressureCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PressureCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.Compressibility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Compressibility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Compressibility); getErrorString();


getIconAnnotation(Modelica.SIunits.IsothermalCompressibility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IsothermalCompressibility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IsothermalCompressibility); getErrorString();


getIconAnnotation(Modelica.SIunits.IsentropicCompressibility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IsentropicCompressibility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IsentropicCompressibility); getErrorString();


getIconAnnotation(Modelica.SIunits.Heat); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Heat); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Heat); getErrorString();


getIconAnnotation(Modelica.SIunits.HeatFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HeatFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HeatFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.HeatFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HeatFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HeatFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.DensityOfHeatFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DensityOfHeatFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DensityOfHeatFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalConductivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalConductivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalConductivity); getErrorString();


getIconAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalInsulance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalInsulance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalInsulance); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalResistance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalResistance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalResistance); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalConductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalConductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalConductance); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalDiffusivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalDiffusivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusivity); getErrorString();


getIconAnnotation(Modelica.SIunits.HeatCapacity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HeatCapacity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HeatCapacity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificHeatCapacity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation); getErrorString();


getIconAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities); getErrorString();


getIconAnnotation(Modelica.SIunits.IsentropicExponent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IsentropicExponent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IsentropicExponent); getErrorString();


getIconAnnotation(Modelica.SIunits.Entropy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Entropy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Entropy); getErrorString();


getIconAnnotation(Modelica.SIunits.EntropyFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EntropyFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EntropyFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificEntropy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificEntropy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificEntropy); getErrorString();


getIconAnnotation(Modelica.SIunits.InternalEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.InternalEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.InternalEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.Enthalpy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Enthalpy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Enthalpy); getErrorString();


getIconAnnotation(Modelica.SIunits.HelmholtzFreeEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HelmholtzFreeEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HelmholtzFreeEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.GibbsFreeEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GibbsFreeEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GibbsFreeEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificInternalEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificInternalEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificInternalEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificEnthalpy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificEnthalpy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificEnthalpy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.MassieuFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassieuFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassieuFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.PlanckFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PlanckFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PlanckFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.DerDensityByEnthalpy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerDensityByEnthalpy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerDensityByEnthalpy); getErrorString();


getIconAnnotation(Modelica.SIunits.DerDensityByPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerDensityByPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerDensityByPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.DerDensityByTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerDensityByTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerDensityByTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.DerEnthalpyByPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerEnthalpyByPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerEnthalpyByPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.DerEnergyByDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerEnergyByDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerEnergyByDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.DerEnergyByPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DerEnergyByPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DerEnergyByPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricCurrent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricCurrent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricCurrent); getErrorString();


getIconAnnotation(Modelica.SIunits.Current); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Current); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Current); getErrorString();


getIconAnnotation(Modelica.SIunits.CurrentSlope); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CurrentSlope); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CurrentSlope); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricCharge); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricCharge); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricCharge); getErrorString();


getIconAnnotation(Modelica.SIunits.Charge); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Charge); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Charge); getErrorString();


getIconAnnotation(Modelica.SIunits.VolumeDensityOfCharge); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VolumeDensityOfCharge); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VolumeDensityOfCharge); getErrorString();


getIconAnnotation(Modelica.SIunits.SurfaceDensityOfCharge); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SurfaceDensityOfCharge); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SurfaceDensityOfCharge); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricFieldStrength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricFieldStrength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricFieldStrength); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricPotential); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricPotential); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricPotential); getErrorString();


getIconAnnotation(Modelica.SIunits.Voltage); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Voltage); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Voltage); getErrorString();


getIconAnnotation(Modelica.SIunits.PotentialDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PotentialDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PotentialDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectromotiveForce); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectromotiveForce); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectromotiveForce); getErrorString();


getIconAnnotation(Modelica.SIunits.VoltageSlope); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VoltageSlope); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VoltageSlope); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricFluxDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricFluxDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricFluxDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.Capacitance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Capacitance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Capacitance); getErrorString();


getIconAnnotation(Modelica.SIunits.Permittivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Permittivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Permittivity); getErrorString();


getIconAnnotation(Modelica.SIunits.PermittivityOfVacuum); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PermittivityOfVacuum); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PermittivityOfVacuum); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativePermittivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativePermittivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativePermittivity); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricSusceptibility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricSusceptibility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricSusceptibility); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricPolarization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricPolarization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricPolarization); getErrorString();


getIconAnnotation(Modelica.SIunits.Electrization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Electrization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Electrization); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricDipoleMoment); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricDipoleMoment); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricDipoleMoment); getErrorString();


getIconAnnotation(Modelica.SIunits.CurrentDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CurrentDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CurrentDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearCurrentDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearCurrentDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearCurrentDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticFieldStrength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticFieldStrength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticFieldStrength); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticPotential); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticPotential); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticPotential); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticPotentialDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticPotentialDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticPotentialDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.MagnetomotiveForce); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagnetomotiveForce); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagnetomotiveForce); getErrorString();


getIconAnnotation(Modelica.SIunits.CurrentLinkage); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CurrentLinkage); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CurrentLinkage); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticFluxDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticFluxDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticFluxDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticVectorPotential); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticVectorPotential); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticVectorPotential); getErrorString();


getIconAnnotation(Modelica.SIunits.Inductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Inductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Inductance); getErrorString();


getIconAnnotation(Modelica.SIunits.SelfInductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SelfInductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SelfInductance); getErrorString();


getIconAnnotation(Modelica.SIunits.MutualInductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MutualInductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MutualInductance); getErrorString();


getIconAnnotation(Modelica.SIunits.CouplingCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CouplingCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CouplingCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.LeakageCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LeakageCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LeakageCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.Permeability); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Permeability); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Permeability); getErrorString();


getIconAnnotation(Modelica.SIunits.PermeabilityOfVacuum); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PermeabilityOfVacuum); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PermeabilityOfVacuum); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativePermeability); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativePermeability); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativePermeability); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticSusceptibility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticSusceptibility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticSusceptibility); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectromagneticMoment); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectromagneticMoment); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectromagneticMoment); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticDipoleMoment); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticDipoleMoment); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticDipoleMoment); getErrorString();


getIconAnnotation(Modelica.SIunits.Magnetization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Magnetization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Magnetization); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticPolarization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticPolarization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticPolarization); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.PoyntingVector); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PoyntingVector); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PoyntingVector); getErrorString();


getIconAnnotation(Modelica.SIunits.Resistance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Resistance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Resistance); getErrorString();


getIconAnnotation(Modelica.SIunits.Resistivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Resistivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Resistivity); getErrorString();


getIconAnnotation(Modelica.SIunits.Conductivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conductivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conductivity); getErrorString();


getIconAnnotation(Modelica.SIunits.Reluctance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Reluctance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Reluctance); getErrorString();


getIconAnnotation(Modelica.SIunits.Permeance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Permeance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Permeance); getErrorString();


getIconAnnotation(Modelica.SIunits.PhaseDifference); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PhaseDifference); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PhaseDifference); getErrorString();


getIconAnnotation(Modelica.SIunits.Impedance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Impedance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Impedance); getErrorString();


getIconAnnotation(Modelica.SIunits.ModulusOfImpedance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ModulusOfImpedance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ModulusOfImpedance); getErrorString();


getIconAnnotation(Modelica.SIunits.Reactance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Reactance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Reactance); getErrorString();


getIconAnnotation(Modelica.SIunits.QualityFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.QualityFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.QualityFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.LossAngle); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LossAngle); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LossAngle); getErrorString();


getIconAnnotation(Modelica.SIunits.Conductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Conductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Conductance); getErrorString();


getIconAnnotation(Modelica.SIunits.Admittance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Admittance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Admittance); getErrorString();


getIconAnnotation(Modelica.SIunits.ModulusOfAdmittance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ModulusOfAdmittance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ModulusOfAdmittance); getErrorString();


getIconAnnotation(Modelica.SIunits.Susceptance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Susceptance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Susceptance); getErrorString();


getIconAnnotation(Modelica.SIunits.InstantaneousPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.InstantaneousPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.InstantaneousPower); getErrorString();


getIconAnnotation(Modelica.SIunits.ActivePower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ActivePower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ActivePower); getErrorString();


getIconAnnotation(Modelica.SIunits.ApparentPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ApparentPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ApparentPower); getErrorString();


getIconAnnotation(Modelica.SIunits.ReactivePower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReactivePower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReactivePower); getErrorString();


getIconAnnotation(Modelica.SIunits.PowerFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PowerFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PowerFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.Transconductance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Transconductance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Transconductance); getErrorString();


getIconAnnotation(Modelica.SIunits.InversePotential); getErrorString();
getDiagramAnnotation(Modelica.SIunits.InversePotential); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.InversePotential); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricalForceConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricalForceConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricalForceConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantEnergyDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantEnergyDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantEnergyDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantPower); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantIntensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantIntensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantIntensity); getErrorString();


getIconAnnotation(Modelica.SIunits.Radiance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Radiance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Radiance); getErrorString();


getIconAnnotation(Modelica.SIunits.RadiantExtiance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RadiantExtiance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RadiantExtiance); getErrorString();


getIconAnnotation(Modelica.SIunits.Irradiance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Irradiance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Irradiance); getErrorString();


getIconAnnotation(Modelica.SIunits.Emissivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Emissivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Emissivity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralEmissivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralEmissivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralEmissivity); getErrorString();


getIconAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity); getErrorString();


getIconAnnotation(Modelica.SIunits.LuminousIntensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LuminousIntensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LuminousIntensity); getErrorString();


getIconAnnotation(Modelica.SIunits.LuminousFlux); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LuminousFlux); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LuminousFlux); getErrorString();


getIconAnnotation(Modelica.SIunits.QuantityOfLight); getErrorString();
getDiagramAnnotation(Modelica.SIunits.QuantityOfLight); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.QuantityOfLight); getErrorString();


getIconAnnotation(Modelica.SIunits.Luminance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Luminance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Luminance); getErrorString();


getIconAnnotation(Modelica.SIunits.LuminousExitance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LuminousExitance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LuminousExitance); getErrorString();


getIconAnnotation(Modelica.SIunits.Illuminance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Illuminance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Illuminance); getErrorString();


getIconAnnotation(Modelica.SIunits.LightExposure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LightExposure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LightExposure); getErrorString();


getIconAnnotation(Modelica.SIunits.LuminousEfficacy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LuminousEfficacy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LuminousEfficacy); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralLuminousEfficacy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralLuminousEfficacy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralLuminousEfficacy); getErrorString();


getIconAnnotation(Modelica.SIunits.LuminousEfficiency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LuminousEfficiency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LuminousEfficiency); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralLuminousEfficiency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralLuminousEfficiency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralLuminousEfficiency); getErrorString();


getIconAnnotation(Modelica.SIunits.CIESpectralTristimulusValues); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CIESpectralTristimulusValues); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CIESpectralTristimulusValues); getErrorString();


getIconAnnotation(Modelica.SIunits.ChromaticityCoordinates); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ChromaticityCoordinates); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ChromaticityCoordinates); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralAbsorptionFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralAbsorptionFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralAbsorptionFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralReflectionFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralReflectionFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralReflectionFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralTransmissionFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralTransmissionFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralTransmissionFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralRadianceFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralRadianceFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralRadianceFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearAttenuationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearAttenuationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearAttenuationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.RefractiveIndex); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RefractiveIndex); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RefractiveIndex); getErrorString();


getIconAnnotation(Modelica.SIunits.StaticPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StaticPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StaticPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundParticleDisplacement); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundParticleDisplacement); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundParticleDisplacement); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundParticleVelocity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundParticleVelocity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundParticleVelocity); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundParticleAcceleration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundParticleAcceleration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundParticleAcceleration); getErrorString();


getIconAnnotation(Modelica.SIunits.VelocityOfSound); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VelocityOfSound); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VelocityOfSound); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundEnergyDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundEnergyDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundEnergyDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundPower); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundIntensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundIntensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundIntensity); getErrorString();


getIconAnnotation(Modelica.SIunits.AcousticImpedance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AcousticImpedance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AcousticImpedance); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificAcousticImpedance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificAcousticImpedance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificAcousticImpedance); getErrorString();


getIconAnnotation(Modelica.SIunits.MechanicalImpedance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MechanicalImpedance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MechanicalImpedance); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundPressureLevel); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundPressureLevel); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundPressureLevel); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundPowerLevel); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundPowerLevel); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundPowerLevel); getErrorString();


getIconAnnotation(Modelica.SIunits.DissipationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DissipationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DissipationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ReflectionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReflectionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReflectionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.TransmissionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TransmissionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TransmissionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.SoundReductionIndex); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SoundReductionIndex); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SoundReductionIndex); getErrorString();


getIconAnnotation(Modelica.SIunits.EquivalentAbsorptionArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EquivalentAbsorptionArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EquivalentAbsorptionArea); getErrorString();


getIconAnnotation(Modelica.SIunits.ReverberationTime); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReverberationTime); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReverberationTime); getErrorString();


getIconAnnotation(Modelica.SIunits.LoundnessLevel); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LoundnessLevel); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LoundnessLevel); getErrorString();


getIconAnnotation(Modelica.SIunits.Loundness); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Loundness); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Loundness); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativeAtomicMass); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativeAtomicMass); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativeAtomicMass); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativeMolecularMass); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativeMolecularMass); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativeMolecularMass); getErrorString();


getIconAnnotation(Modelica.SIunits.NumberOfMolecules); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NumberOfMolecules); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NumberOfMolecules); getErrorString();


getIconAnnotation(Modelica.SIunits.AmountOfSubstance); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AmountOfSubstance); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AmountOfSubstance); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarMass); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarMass); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarMass); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarVolume); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarVolume); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarVolume); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarInternalEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarInternalEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarInternalEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarHeatCapacity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarHeatCapacity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarHeatCapacity); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarEntropy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarEntropy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarEntropy); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarFlowRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarFlowRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarFlowRate); getErrorString();


getIconAnnotation(Modelica.SIunits.NumberDensityOfMolecules); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NumberDensityOfMolecules); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NumberDensityOfMolecules); getErrorString();


getIconAnnotation(Modelica.SIunits.MolecularConcentration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolecularConcentration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolecularConcentration); getErrorString();


getIconAnnotation(Modelica.SIunits.MassConcentration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassConcentration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassConcentration); getErrorString();


getIconAnnotation(Modelica.SIunits.MassFraction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassFraction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassFraction); getErrorString();


getIconAnnotation(Modelica.SIunits.Concentration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Concentration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Concentration); getErrorString();


getIconAnnotation(Modelica.SIunits.VolumeFraction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.VolumeFraction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.VolumeFraction); getErrorString();


getIconAnnotation(Modelica.SIunits.MoleFraction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MoleFraction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MoleFraction); getErrorString();


getIconAnnotation(Modelica.SIunits.ChemicalPotential); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ChemicalPotential); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ChemicalPotential); getErrorString();


getIconAnnotation(Modelica.SIunits.AbsoluteActivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AbsoluteActivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AbsoluteActivity); getErrorString();


getIconAnnotation(Modelica.SIunits.PartialPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PartialPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PartialPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.Fugacity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Fugacity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Fugacity); getErrorString();


getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivity); getErrorString();


getIconAnnotation(Modelica.SIunits.ActivityCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ActivityCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ActivityCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ActivityOfSolute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ActivityOfSolute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ActivityOfSolute); getErrorString();


getIconAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute); getErrorString();


getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute); getErrorString();


getIconAnnotation(Modelica.SIunits.ActivityOfSolvent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ActivityOfSolvent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ActivityOfSolvent); getErrorString();


getIconAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent); getErrorString();


getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent); getErrorString();


getIconAnnotation(Modelica.SIunits.OsmoticPressure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.OsmoticPressure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.OsmoticPressure); getErrorString();


getIconAnnotation(Modelica.SIunits.StoichiometricNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StoichiometricNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StoichiometricNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.Affinity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Affinity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Affinity); getErrorString();


getIconAnnotation(Modelica.SIunits.MassOfMolecule); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassOfMolecule); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassOfMolecule); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule); getErrorString();


getIconAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.CanonicalPartitionFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CanonicalPartitionFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CanonicalPartitionFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.MolecularPartitionFunction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolecularPartitionFunction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolecularPartitionFunction); getErrorString();


getIconAnnotation(Modelica.SIunits.StatisticalWeight); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StatisticalWeight); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StatisticalWeight); getErrorString();


getIconAnnotation(Modelica.SIunits.MeanFreePath); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MeanFreePath); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MeanFreePath); getErrorString();


getIconAnnotation(Modelica.SIunits.DiffusionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DiffusionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DiffusionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalDiffusionRatio); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionRatio); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionRatio); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalDiffusionFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ElementaryCharge); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElementaryCharge); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElementaryCharge); getErrorString();


getIconAnnotation(Modelica.SIunits.ChargeNumberOfIon); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ChargeNumberOfIon); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ChargeNumberOfIon); getErrorString();


getIconAnnotation(Modelica.SIunits.FaradayConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FaradayConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FaradayConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.IonicStrength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IonicStrength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IonicStrength); getErrorString();


getIconAnnotation(Modelica.SIunits.DegreeOfDissociation); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DegreeOfDissociation); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DegreeOfDissociation); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectrolyticConductivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectrolyticConductivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectrolyticConductivity); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarConductivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarConductivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarConductivity); getErrorString();


getIconAnnotation(Modelica.SIunits.TransportNumberOfIonic); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TransportNumberOfIonic); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TransportNumberOfIonic); getErrorString();


getIconAnnotation(Modelica.SIunits.ProtonNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ProtonNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ProtonNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.NucleonNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NucleonNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NucleonNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.AtomicMassConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AtomicMassConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AtomicMassConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.MassOfElectron); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassOfElectron); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassOfElectron); getErrorString();


getIconAnnotation(Modelica.SIunits.MassOfProton); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassOfProton); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassOfProton); getErrorString();


getIconAnnotation(Modelica.SIunits.MassOfNeutron); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassOfNeutron); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassOfNeutron); getErrorString();


getIconAnnotation(Modelica.SIunits.HartreeEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HartreeEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HartreeEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticMomentOfParticle); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticMomentOfParticle); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticMomentOfParticle); getErrorString();


getIconAnnotation(Modelica.SIunits.BohrMagneton); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BohrMagneton); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BohrMagneton); getErrorString();


getIconAnnotation(Modelica.SIunits.NuclearMagneton); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NuclearMagneton); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NuclearMagneton); getErrorString();


getIconAnnotation(Modelica.SIunits.GyromagneticCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GyromagneticCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GyromagneticCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.GFactorOfAtom); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GFactorOfAtom); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GFactorOfAtom); getErrorString();


getIconAnnotation(Modelica.SIunits.GFactorOfNucleus); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GFactorOfNucleus); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GFactorOfNucleus); getErrorString();


getIconAnnotation(Modelica.SIunits.LarmorAngularFrequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LarmorAngularFrequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LarmorAngularFrequency); getErrorString();


getIconAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency); getErrorString();


getIconAnnotation(Modelica.SIunits.CyclotronAngularFrequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CyclotronAngularFrequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CyclotronAngularFrequency); getErrorString();


getIconAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment); getErrorString();


getIconAnnotation(Modelica.SIunits.NuclearRadius); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NuclearRadius); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NuclearRadius); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectronRadius); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectronRadius); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectronRadius); getErrorString();


getIconAnnotation(Modelica.SIunits.ComptonWavelength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ComptonWavelength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ComptonWavelength); getErrorString();


getIconAnnotation(Modelica.SIunits.MassExcess); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassExcess); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassExcess); getErrorString();


getIconAnnotation(Modelica.SIunits.MassDefect); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassDefect); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassDefect); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativeMassExcess); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativeMassExcess); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativeMassExcess); getErrorString();


getIconAnnotation(Modelica.SIunits.RelativeMassDefect); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelativeMassDefect); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelativeMassDefect); getErrorString();


getIconAnnotation(Modelica.SIunits.PackingFraction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PackingFraction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PackingFraction); getErrorString();


getIconAnnotation(Modelica.SIunits.BindingFraction); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BindingFraction); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BindingFraction); getErrorString();


getIconAnnotation(Modelica.SIunits.MeanLife); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MeanLife); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MeanLife); getErrorString();


getIconAnnotation(Modelica.SIunits.LevelWidth); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LevelWidth); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LevelWidth); getErrorString();


getIconAnnotation(Modelica.SIunits.Activity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Activity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Activity); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificActivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificActivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificActivity); getErrorString();


getIconAnnotation(Modelica.SIunits.DecayConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DecayConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DecayConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.HalfLife); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HalfLife); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HalfLife); getErrorString();


getIconAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.BetaDisintegrationEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BetaDisintegrationEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BetaDisintegrationEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.ReactionEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReactionEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReactionEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.ResonanceEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ResonanceEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ResonanceEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.CrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.AngularCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AngularCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AngularCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralAngularCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralAngularCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralAngularCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.MacroscopicCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MacroscopicCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MacroscopicCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection); getErrorString();


getIconAnnotation(Modelica.SIunits.ParticleFluence); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ParticleFluence); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ParticleFluence); getErrorString();


getIconAnnotation(Modelica.SIunits.ParticleFluenceRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ParticleFluenceRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ParticleFluenceRate); getErrorString();


getIconAnnotation(Modelica.SIunits.EnergyFluence); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnergyFluence); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnergyFluence); getErrorString();


getIconAnnotation(Modelica.SIunits.EnergyFluenceRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnergyFluenceRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnergyFluenceRate); getErrorString();


getIconAnnotation(Modelica.SIunits.CurrentDensityOfParticles); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CurrentDensityOfParticles); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CurrentDensityOfParticles); getErrorString();


getIconAnnotation(Modelica.SIunits.MassAttenuationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassAttenuationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassAttenuationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.MolarAttenuationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MolarAttenuationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MolarAttenuationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.HalfThickness); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HalfThickness); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HalfThickness); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalLinearStoppingPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalLinearStoppingPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalLinearStoppingPower); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalAtomicStoppingPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalAtomicStoppingPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalAtomicStoppingPower); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalMassStoppingPower); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalMassStoppingPower); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalMassStoppingPower); getErrorString();


getIconAnnotation(Modelica.SIunits.MeanLinearRange); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MeanLinearRange); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MeanLinearRange); getErrorString();


getIconAnnotation(Modelica.SIunits.MeanMassRange); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MeanMassRange); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MeanMassRange); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearIonization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearIonization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearIonization); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalIonization); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalIonization); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalIonization); getErrorString();


getIconAnnotation(Modelica.SIunits.Mobility); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Mobility); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Mobility); getErrorString();


getIconAnnotation(Modelica.SIunits.IonNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IonNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IonNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.RecombinationCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RecombinationCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RecombinationCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronSpeed); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronSpeed); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronSpeed); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronFluenceRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronFluenceRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronFluenceRate); getErrorString();


getIconAnnotation(Modelica.SIunits.TotalNeutronSourceDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.TotalNeutronSourceDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.TotalNeutronSourceDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.SlowingDownDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SlowingDownDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SlowingDownDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.ResonanceEscapeProbability); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ResonanceEscapeProbability); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ResonanceEscapeProbability); getErrorString();


getIconAnnotation(Modelica.SIunits.Lethargy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Lethargy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Lethargy); getErrorString();


getIconAnnotation(Modelica.SIunits.SlowingDownArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SlowingDownArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SlowingDownArea); getErrorString();


getIconAnnotation(Modelica.SIunits.DiffusionArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DiffusionArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DiffusionArea); getErrorString();


getIconAnnotation(Modelica.SIunits.MigrationArea); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MigrationArea); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MigrationArea); getErrorString();


getIconAnnotation(Modelica.SIunits.SlowingDownLength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SlowingDownLength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SlowingDownLength); getErrorString();


getIconAnnotation(Modelica.SIunits.DiffusionLength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DiffusionLength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DiffusionLength); getErrorString();


getIconAnnotation(Modelica.SIunits.MigrationLength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MigrationLength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MigrationLength); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronYieldPerFission); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronYieldPerFission); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronYieldPerFission); getErrorString();


getIconAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption); getErrorString();


getIconAnnotation(Modelica.SIunits.FastFissionFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FastFissionFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FastFissionFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermalUtilizationFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermalUtilizationFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermalUtilizationFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.NonLeakageProbability); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NonLeakageProbability); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NonLeakageProbability); getErrorString();


getIconAnnotation(Modelica.SIunits.Reactivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Reactivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Reactivity); getErrorString();


getIconAnnotation(Modelica.SIunits.ReactorTimeConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReactorTimeConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReactorTimeConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.EnergyImparted); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EnergyImparted); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EnergyImparted); getErrorString();


getIconAnnotation(Modelica.SIunits.MeanEnergyImparted); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MeanEnergyImparted); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MeanEnergyImparted); getErrorString();


getIconAnnotation(Modelica.SIunits.SpecificEnergyImparted); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpecificEnergyImparted); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpecificEnergyImparted); getErrorString();


getIconAnnotation(Modelica.SIunits.AbsorbedDose); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AbsorbedDose); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AbsorbedDose); getErrorString();


getIconAnnotation(Modelica.SIunits.DoseEquivalent); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DoseEquivalent); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DoseEquivalent); getErrorString();


getIconAnnotation(Modelica.SIunits.AbsorbedDoseRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AbsorbedDoseRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AbsorbedDoseRate); getErrorString();


getIconAnnotation(Modelica.SIunits.LinearEnergyTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LinearEnergyTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LinearEnergyTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.Kerma); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Kerma); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Kerma); getErrorString();


getIconAnnotation(Modelica.SIunits.KermaRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.KermaRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.KermaRate); getErrorString();


getIconAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.Exposure); getErrorString();
getDiagramAnnotation(Modelica.SIunits.Exposure); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.Exposure); getErrorString();


getIconAnnotation(Modelica.SIunits.ExposureRate); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ExposureRate); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ExposureRate); getErrorString();


getIconAnnotation(Modelica.SIunits.ReynoldsNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ReynoldsNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ReynoldsNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.EulerNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EulerNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EulerNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.FroudeNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FroudeNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FroudeNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.GrashofNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GrashofNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GrashofNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.WeberNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.WeberNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.WeberNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.MachNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MachNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MachNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.KnudsenNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.KnudsenNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.KnudsenNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.StrouhalNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StrouhalNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StrouhalNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.FourierNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FourierNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FourierNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.PecletNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PecletNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PecletNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.RayleighNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RayleighNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RayleighNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.NusseltNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NusseltNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NusseltNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.BiotNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BiotNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BiotNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.StantonNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StantonNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StantonNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer); getErrorString();
getDiagramAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer); getErrorString();


getIconAnnotation(Modelica.SIunits.PrandtlNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PrandtlNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PrandtlNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.SchmidtNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SchmidtNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SchmidtNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.LewisNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LewisNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LewisNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.MagneticReynoldsNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MagneticReynoldsNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MagneticReynoldsNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.AlfvenNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AlfvenNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AlfvenNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.HartmannNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HartmannNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HartmannNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.CowlingNumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CowlingNumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CowlingNumber); getErrorString();


getIconAnnotation(Modelica.SIunits.BraggAngle); getErrorString();
getDiagramAnnotation(Modelica.SIunits.BraggAngle); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.BraggAngle); getErrorString();


getIconAnnotation(Modelica.SIunits.OrderOfReflexion); getErrorString();
getDiagramAnnotation(Modelica.SIunits.OrderOfReflexion); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.OrderOfReflexion); getErrorString();


getIconAnnotation(Modelica.SIunits.ShortRangeOrderParameter); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ShortRangeOrderParameter); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ShortRangeOrderParameter); getErrorString();


getIconAnnotation(Modelica.SIunits.LongRangeOrderParameter); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LongRangeOrderParameter); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LongRangeOrderParameter); getErrorString();


getIconAnnotation(Modelica.SIunits.DebyeWallerFactor); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DebyeWallerFactor); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DebyeWallerFactor); getErrorString();


getIconAnnotation(Modelica.SIunits.CircularWavenumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CircularWavenumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CircularWavenumber); getErrorString();


getIconAnnotation(Modelica.SIunits.FermiCircularWavenumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FermiCircularWavenumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FermiCircularWavenumber); getErrorString();


getIconAnnotation(Modelica.SIunits.DebyeCircularWavenumber); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DebyeCircularWavenumber); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DebyeCircularWavenumber); getErrorString();


getIconAnnotation(Modelica.SIunits.DebyeCircularFrequency); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DebyeCircularFrequency); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DebyeCircularFrequency); getErrorString();


getIconAnnotation(Modelica.SIunits.DebyeTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DebyeTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DebyeTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.SpectralConcentration); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SpectralConcentration); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SpectralConcentration); getErrorString();


getIconAnnotation(Modelica.SIunits.GrueneisenParameter); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GrueneisenParameter); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GrueneisenParameter); getErrorString();


getIconAnnotation(Modelica.SIunits.MadelungConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MadelungConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MadelungConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.DensityOfStates); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DensityOfStates); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DensityOfStates); getErrorString();


getIconAnnotation(Modelica.SIunits.ResidualResistivity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ResidualResistivity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ResidualResistivity); getErrorString();


getIconAnnotation(Modelica.SIunits.LorenzCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LorenzCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LorenzCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.HallCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HallCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HallCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ThermoelectromotiveForce); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThermoelectromotiveForce); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThermoelectromotiveForce); getErrorString();


getIconAnnotation(Modelica.SIunits.SeebeckCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.SeebeckCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.SeebeckCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.PeltierCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.PeltierCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.PeltierCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.ThomsonCoefficient); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ThomsonCoefficient); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ThomsonCoefficient); getErrorString();


getIconAnnotation(Modelica.SIunits.RichardsonConstant); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RichardsonConstant); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RichardsonConstant); getErrorString();


getIconAnnotation(Modelica.SIunits.FermiEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FermiEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FermiEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.GapEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.GapEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.GapEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.DonorIonizationEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DonorIonizationEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DonorIonizationEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.AcceptorIonizationEnergy); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AcceptorIonizationEnergy); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AcceptorIonizationEnergy); getErrorString();


getIconAnnotation(Modelica.SIunits.FermiTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FermiTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FermiTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.ElectronNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ElectronNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ElectronNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.HoleNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.HoleNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.HoleNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.IntrinsicNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.IntrinsicNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.IntrinsicNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.DonorNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.DonorNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.DonorNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.AcceptorNumberDensity); getErrorString();
getDiagramAnnotation(Modelica.SIunits.AcceptorNumberDensity); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.AcceptorNumberDensity); getErrorString();


getIconAnnotation(Modelica.SIunits.EffectiveMass); getErrorString();
getDiagramAnnotation(Modelica.SIunits.EffectiveMass); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.EffectiveMass); getErrorString();


getIconAnnotation(Modelica.SIunits.MobilityRatio); getErrorString();
getDiagramAnnotation(Modelica.SIunits.MobilityRatio); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.MobilityRatio); getErrorString();


getIconAnnotation(Modelica.SIunits.RelaxationTime); getErrorString();
getDiagramAnnotation(Modelica.SIunits.RelaxationTime); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.RelaxationTime); getErrorString();


getIconAnnotation(Modelica.SIunits.CarrierLifeTime); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CarrierLifeTime); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CarrierLifeTime); getErrorString();


getIconAnnotation(Modelica.SIunits.ExchangeIntegral); getErrorString();
getDiagramAnnotation(Modelica.SIunits.ExchangeIntegral); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.ExchangeIntegral); getErrorString();


getIconAnnotation(Modelica.SIunits.CurieTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CurieTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CurieTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.NeelTemperature); getErrorString();
getDiagramAnnotation(Modelica.SIunits.NeelTemperature); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.NeelTemperature); getErrorString();


getIconAnnotation(Modelica.SIunits.LondonPenetrationDepth); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LondonPenetrationDepth); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LondonPenetrationDepth); getErrorString();


getIconAnnotation(Modelica.SIunits.CoherenceLength); getErrorString();
getDiagramAnnotation(Modelica.SIunits.CoherenceLength); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.CoherenceLength); getErrorString();


getIconAnnotation(Modelica.SIunits.LandauGinzburgParameter); getErrorString();
getDiagramAnnotation(Modelica.SIunits.LandauGinzburgParameter); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.LandauGinzburgParameter); getErrorString();


getIconAnnotation(Modelica.SIunits.FluxiodQuantum); getErrorString();
getDiagramAnnotation(Modelica.SIunits.FluxiodQuantum); getErrorString();
getDocumentationAnnotation(Modelica.SIunits.FluxiodQuantum); getErrorString();

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Icons
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Icons.Example); getErrorString();
getDiagramAnnotation(Modelica.Icons.Example); getErrorString();
getDocumentationAnnotation(Modelica.Icons.Example); getErrorString();


getIconAnnotation(Modelica.Icons.Function); getErrorString();
getDiagramAnnotation(Modelica.Icons.Function); getErrorString();
getDocumentationAnnotation(Modelica.Icons.Function); getErrorString();


getIconAnnotation(Modelica.Icons.Record); getErrorString();
getDiagramAnnotation(Modelica.Icons.Record); getErrorString();
getDocumentationAnnotation(Modelica.Icons.Record); getErrorString();


getIconAnnotation(Modelica.Icons.TypeReal); getErrorString();
getDiagramAnnotation(Modelica.Icons.TypeReal); getErrorString();
getDocumentationAnnotation(Modelica.Icons.TypeReal); getErrorString();


getIconAnnotation(Modelica.Icons.TypeInteger); getErrorString();
getDiagramAnnotation(Modelica.Icons.TypeInteger); getErrorString();
getDocumentationAnnotation(Modelica.Icons.TypeInteger); getErrorString();


getIconAnnotation(Modelica.Icons.TypeBoolean); getErrorString();
getDiagramAnnotation(Modelica.Icons.TypeBoolean); getErrorString();
getDocumentationAnnotation(Modelica.Icons.TypeBoolean); getErrorString();


getIconAnnotation(Modelica.Icons.TypeString); getErrorString();
getDiagramAnnotation(Modelica.Icons.TypeString); getErrorString();
getDocumentationAnnotation(Modelica.Icons.TypeString); getErrorString();


getIconAnnotation(Modelica.Icons.TranslationalSensor); getErrorString();
getDiagramAnnotation(Modelica.Icons.TranslationalSensor); getErrorString();
getDocumentationAnnotation(Modelica.Icons.TranslationalSensor); getErrorString();


getIconAnnotation(Modelica.Icons.RotationalSensor); getErrorString();
getDiagramAnnotation(Modelica.Icons.RotationalSensor); getErrorString();
getDocumentationAnnotation(Modelica.Icons.RotationalSensor); getErrorString();


getIconAnnotation(Modelica.Icons.GearIcon); getErrorString();
getDiagramAnnotation(Modelica.Icons.GearIcon); getErrorString();
getDocumentationAnnotation(Modelica.Icons.GearIcon); getErrorString();


getIconAnnotation(Modelica.Icons.MotorIcon); getErrorString();
getDiagramAnnotation(Modelica.Icons.MotorIcon); getErrorString();
getDocumentationAnnotation(Modelica.Icons.MotorIcon); getErrorString();


getIconAnnotation(Modelica.Icons.ObsoleteModel); getErrorString();
getDiagramAnnotation(Modelica.Icons.ObsoleteModel); getErrorString();
getDocumentationAnnotation(Modelica.Icons.ObsoleteModel); getErrorString();

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Utilities
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes); getErrorString();
getDiagramAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes); getErrorString();


getIconAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes); getErrorString();
getDiagramAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes); getErrorString();


getIconAnnotation(Modelica.Utilities.UsersGuide.Contact); getErrorString();
getDiagramAnnotation(Modelica.Utilities.UsersGuide.Contact); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.UsersGuide.Contact); getErrorString();


getIconAnnotation(Modelica.Utilities.Examples.calculator); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Examples.calculator); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Examples.calculator); getErrorString();


getIconAnnotation(Modelica.Utilities.Examples.expression); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Examples.expression); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Examples.expression); getErrorString();


getIconAnnotation(Modelica.Utilities.Examples.readRealParameter); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Examples.readRealParameter); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Examples.readRealParameter); getErrorString();


getIconAnnotation(Modelica.Utilities.Examples.readRealParameterModel); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Examples.readRealParameterModel); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Examples.readRealParameterModel); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.list); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.list); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.list); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.copy); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.copy); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.copy); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.move); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.move); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.move); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.remove); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.remove); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.remove); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.removeFile); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.removeFile); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.removeFile); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.createDirectory); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.createDirectory); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.createDirectory); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.exist); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.exist); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.exist); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.assertNew); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.assertNew); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.assertNew); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.fullPathName); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.splitPathName); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.splitPathName); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.splitPathName); getErrorString();


getIconAnnotation(Modelica.Utilities.Files.temporaryFileName); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Files.temporaryFileName); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Files.temporaryFileName); getErrorString();


getIconAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.print); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.print); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.print); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.readFile); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.readFile); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.readFile); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.readLine); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.readLine); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.readLine); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.countLines); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.countLines); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.countLines); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.error); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.error); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.error); getErrorString();


getIconAnnotation(Modelica.Utilities.Streams.close); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Streams.close); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Streams.close); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.length); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.length); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.length); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.substring); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.substring); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.substring); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.repeat); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.repeat); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.repeat); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.compare); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.compare); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.compare); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.isEqual); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.isEqual); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.isEqual); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.count); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.count); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.count); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.find); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.find); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.find); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.findLast); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.findLast); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.findLast); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.replace); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.replace); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.replace); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.sort); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.sort); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.sort); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanToken); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanToken); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanToken); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanReal); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanReal); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanReal); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanInteger); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanInteger); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanInteger); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanBoolean); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanBoolean); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanBoolean); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanString); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanString); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanString); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanIdentifier); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanIdentifier); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanIdentifier); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanDelimiter); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanDelimiter); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanDelimiter); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.scanNoToken); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.scanNoToken); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.scanNoToken); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.syntaxError); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.syntaxError); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.syntaxError); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanReal); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanReal); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanReal); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanString); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanString); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanString); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace); getErrorString();


getIconAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments); getErrorString();


getIconAnnotation(Modelica.Utilities.System.getWorkDirectory); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.getWorkDirectory); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.getWorkDirectory); getErrorString();


getIconAnnotation(Modelica.Utilities.System.setWorkDirectory); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.setWorkDirectory); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.setWorkDirectory); getErrorString();


getIconAnnotation(Modelica.Utilities.System.getEnvironmentVariable); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.getEnvironmentVariable); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.getEnvironmentVariable); getErrorString();


getIconAnnotation(Modelica.Utilities.System.setEnvironmentVariable); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.setEnvironmentVariable); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.setEnvironmentVariable); getErrorString();


getIconAnnotation(Modelica.Utilities.System.command); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.command); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.command); getErrorString();


getIconAnnotation(Modelica.Utilities.System.exit); getErrorString();
getDiagramAnnotation(Modelica.Utilities.System.exit); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.System.exit); getErrorString();


getIconAnnotation(Modelica.Utilities.Types.Compare); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Types.Compare); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Types.Compare); getErrorString();


getIconAnnotation(Modelica.Utilities.Types.FileType); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Types.FileType); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Types.FileType); getErrorString();


getIconAnnotation(Modelica.Utilities.Types.TokenType); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Types.TokenType); getErrorString();
getDocumentationAnnotation(Modelica.Utilities.Types.TokenType); getErrorString();


getIconAnnotation(Modelica.Utilities.Types.TokenValue); getErrorString();
getDiagramAnnotation(Modelica.Utilities.Types.TokenValue); getErrorString();

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Thermal
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort); getErrorString();


getIconAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D); getErrorString();
getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D); getErrorString();
getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D); getErrorString();

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Mechanics
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.World); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.World); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.World); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum); getErrorString();

getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b); getErrorString();

getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic); getErrorString();

getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.Force); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Force); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.Force); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque); getErrorString();
getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque); getErrorString();
getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.ForceAndTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Spring); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Internal.BasicForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Internal.BasicTorque); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Orientation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Orientation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotationAngle); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotationAngle); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxy); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxy); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxz); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxz); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axis); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axis); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axis); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotationAngle); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotationAngle); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotationsAngles); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotationsAngles); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxz); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxz); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Interfaces.Frame); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.Frame); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearingAdaptor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialAbsoluteSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialRelativeSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialVisualizer); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Prismatic); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Revolute); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Cylindrical); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Universal); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Planar); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.GearConstraint); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheelSet); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSR); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSR); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSP); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRP); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativePosition); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeAngles); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeAngularVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutForceAndTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Power); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeBaseSensor); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeBaseSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsolutePosition); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsolutePosition); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsoluteAngularVelocity); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsoluteAngularVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativePosition); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativePosition); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativeAngularVelocity); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativeAngularVelocity); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformAbsoluteVector); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformAbsoluteVector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformRelativeVector); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformRelativeVector); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.ZeroForceAndTorque); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.ZeroForceAndTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceBaseSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicCutForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicCutTorque); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Axis); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Axis); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Color); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Color); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.SpecularCoefficient); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.SpecularCoefficient); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeType); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeType); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeExtra); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeExtra); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes); getErrorString();


getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Init); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Init); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.Init); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedShape); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedShape2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedFrame); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedArrow); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.SignalArrow); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Ground); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.DoubleArrow); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Internal.FixedLines); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Body); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BodyBox); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BodyCylinder); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.PointMass); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Mounting1D); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Rotor1D); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BevelGear1D); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.RollingWheel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Parts.RollingWheel); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Overview); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Overview); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.FlangeConnectors); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.FlangeConnectors); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SupportTorques); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SupportTorques); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SignConventions); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SignConventions); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.UserDefinedComponents); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.UserDefinedComponents); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.RequirementsForSimulationTool); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.RequirementsForSimulationTool); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Contact); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Contact); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.First); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.First); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.FirstGrounded); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.FirstGrounded); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.Friction); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.Friction); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.CoupledClutches); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.CoupledClutches); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo1); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo1); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo2); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.ElasticBearing); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.ElasticBearing); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.Backlash); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.Backlash); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Examples.RollingWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.RollingWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Inertia); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Disc); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.BearingFriction); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Brake); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Clutch); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.OneWayClutch); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealGear); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.LossyGear); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Gearbox); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealGearR2T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealRollingWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.InitializeFlange); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Position); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Speed); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Accelerate); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Move); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.LinearSpeedDependentTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.QuadraticSpeedDependentTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.ConstantTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.ConstantSpeed); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.TorqueStep); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.AngleSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.SpeedSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.AccSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelAngleSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelSpeedSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelAccSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.TorqueSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.PowerSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.InternalSupport); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliant); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliant); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTorque); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialAbsoluteSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialRelativeSensor); getErrorString();


getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialFriction); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialFriction); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.SignConvention); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.InitialConditions); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.InitialConditions); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.WhyArrows); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Accelerate); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Accelerate); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Damper); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Damper); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Oscillator); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Oscillator); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Sensors); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Sensors); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Friction); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.PreLoad); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.ElastoGap); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.ElastoGap); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Brake); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Brake); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.Fixed); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.SupportFriction); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.Brake); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Components.InitializeFlange); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Position); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Speed); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Accelerate); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Move); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Force); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Force2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.LinearSpeedDependentForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.QuadraticSpeedDependentForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ConstantForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ConstantSpeed); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ForceStep); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.PositionSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.SpeedSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.AccSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelPositionSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelSpeedSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelAccSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.ForceSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.PowerSensor); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.Translational.Interfaces.Support); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.InternalSupport); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialTwoFlanges); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialTwoFlanges); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRigid); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRigid); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliant); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryOneFlangeAndSupport2); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryTwoFlangesAndSupport2); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational); getErrorString();


getDocumentationAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialForce); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialAbsoluteSensor); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRelativeSensor); getErrorString();


getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialFriction); getErrorString();


getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialFriction); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Math
// ----------------------------------------------------------------
// ----------------------------------------------------------------


getIconAnnotation(Modelica.Math.Vectors.isEqual); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.isEqual); getErrorString();


getIconAnnotation(Modelica.Math.Vectors.norm); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.norm); getErrorString();


getIconAnnotation(Modelica.Math.Vectors.length); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.length); getErrorString();


getIconAnnotation(Modelica.Math.Vectors.normalize); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.normalize); getErrorString();


getIconAnnotation(Modelica.Math.Vectors.reverse); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.reverse); getErrorString();


getIconAnnotation(Modelica.Math.Vectors.sort); getErrorString();


getDiagramAnnotation(Modelica.Math.Vectors.sort); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.isEqual); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.isEqual); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.norm); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.norm); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.sort); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.sort); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.solve); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.solve); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.solve2); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.solve2); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.leastSquares); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.leastSquares); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.equalityLeastSquares); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.equalityLeastSquares); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LU); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LU); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LU); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LU_solve); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LU_solve); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LU_solve2); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LU_solve2); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.QR); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.QR); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.eigenValues); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.eigenValues); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.eigenValueMatrix); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.eigenValueMatrix); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.singularValues); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.singularValues); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.det); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.det); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.inv); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.inv); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.rank); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.rank); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.balance); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.balance); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.exp); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.exp); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.integralExp); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.integralExp); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.integralExpT); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.integralExpT); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeev); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeev); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeev); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgegv); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgegv); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgegv); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesv); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesv); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesv); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetri); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetri); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetri); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf); getErrorString();


getIconAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr); getErrorString();


getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr); getErrorString();


getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr); getErrorString();


getIconAnnotation(Modelica.Math.sin); getErrorString();


getDiagramAnnotation(Modelica.Math.sin); getErrorString();


getDocumentationAnnotation(Modelica.Math.sin); getErrorString();


getIconAnnotation(Modelica.Math.cos); getErrorString();


getDiagramAnnotation(Modelica.Math.cos); getErrorString();


getDocumentationAnnotation(Modelica.Math.cos); getErrorString();


getIconAnnotation(Modelica.Math.tan); getErrorString();


getDiagramAnnotation(Modelica.Math.tan); getErrorString();


getDocumentationAnnotation(Modelica.Math.tan); getErrorString();


getIconAnnotation(Modelica.Math.asin); getErrorString();


getDiagramAnnotation(Modelica.Math.asin); getErrorString();


getDocumentationAnnotation(Modelica.Math.asin); getErrorString();


getIconAnnotation(Modelica.Math.acos); getErrorString();


getDiagramAnnotation(Modelica.Math.acos); getErrorString();


getDocumentationAnnotation(Modelica.Math.acos); getErrorString();


getIconAnnotation(Modelica.Math.atan); getErrorString();


getDiagramAnnotation(Modelica.Math.atan); getErrorString();


getDocumentationAnnotation(Modelica.Math.atan); getErrorString();


getIconAnnotation(Modelica.Math.atan2); getErrorString();


getDiagramAnnotation(Modelica.Math.atan2); getErrorString();


getDocumentationAnnotation(Modelica.Math.atan2); getErrorString();


getIconAnnotation(Modelica.Math.sinh); getErrorString();


getDiagramAnnotation(Modelica.Math.sinh); getErrorString();


getDocumentationAnnotation(Modelica.Math.sinh); getErrorString();


getIconAnnotation(Modelica.Math.cosh); getErrorString();


getDiagramAnnotation(Modelica.Math.cosh); getErrorString();


getDocumentationAnnotation(Modelica.Math.cosh); getErrorString();


getIconAnnotation(Modelica.Math.tanh); getErrorString();


getDiagramAnnotation(Modelica.Math.tanh); getErrorString();


getDocumentationAnnotation(Modelica.Math.tanh); getErrorString();


getIconAnnotation(Modelica.Math.exp); getErrorString();


getDiagramAnnotation(Modelica.Math.exp); getErrorString();


getDocumentationAnnotation(Modelica.Math.exp); getErrorString();


getIconAnnotation(Modelica.Math.log); getErrorString();


getDiagramAnnotation(Modelica.Math.log); getErrorString();


getDocumentationAnnotation(Modelica.Math.log); getErrorString();


getIconAnnotation(Modelica.Math.log10); getErrorString();


getDiagramAnnotation(Modelica.Math.log10); getErrorString();


getDocumentationAnnotation(Modelica.Math.log10); getErrorString();


getIconAnnotation(Modelica.Math.tempInterpol1); getErrorString();


getDiagramAnnotation(Modelica.Math.tempInterpol1); getErrorString();


getIconAnnotation(Modelica.Math.tempInterpol2); getErrorString();


getDiagramAnnotation(Modelica.Math.tempInterpol2); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Magnetic
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.FluxTubeConcept); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.FluxTubeConcept); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.ReluctanceForceCalculation); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.ReluctanceForceCalculation); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Literature); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Literature); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Contact); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Contact); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SaturatedInductor); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceCurrentBehaviour); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceStrokeBehaviour); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceStrokeBehaviour); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ArmatureStroke); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.Components.PermeanceActuator); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.Components.ConstantActuator); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonQuasiStationary); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonQuasiStationary); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonPullInStroke); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonPullInStroke); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.Components.SimpleSolenoid); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.Components.AdvancedSolenoid); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.Utilities.CoilDesign); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.ConstantReluctance); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.LeakageWithCoefficient); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.EddyCurrent); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.HollowCylinderAxialFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.HollowCylinderRadialFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.Cuboid); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderAxialFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderAxialFlux); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderRadialFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderRadialFlux); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidParallelFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidParallelFlux); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidOrthogonalFlux); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidOrthogonalFlux); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.LeakageAroundPoles); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.LeakageAroundPoles); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterCylinder); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterCylinder); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowCylinder); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowCylinder); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfCylinder); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfCylinder); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfHollowCylinder); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfHollowCylinder); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterSphere); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterSphere); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowSphere); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowSphere); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfSphere); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfSphere); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfHollowSphere); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfHollowSphere); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.CoaxCylindersEndFaces); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.CoaxCylindersEndFaces); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.BaseData); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.BaseData); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMnPb28); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMnPb28); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.mu_rApprox); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.mu_rApprox); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.BaseData); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.BaseData); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.NdFeB); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.NdFeB); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.Sm2Co17); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.Sm2Co17); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.SmCo5); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.SmCo5); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticNdFeB); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticNdFeB); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticSmCo); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticSmCo); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.HardFerrite); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.HardFerrite); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticHardFerrite); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticHardFerrite); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.MagneticPort); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.MagneticPort); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PositiveMagneticPort); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.NegativeMagneticPort); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPortsElementary); getErrorString();


getIconAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPorts); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPorts); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialFixedShape); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialForce); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialLeakage); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.ConstantMagneticPotentialDifference); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.SignalMagneticPotentialDifference); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.SignalMagneticFlux); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticPotentialDifferenceSensor); getErrorString();


getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticFluxSensor); getErrorString();


getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticFluxSensor); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Electrical
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Electrical.Analog.Examples.Utilities.RealSwitch); getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Examples.AmplifierWithOpAmpDetailed); getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.AmplifierWithOpAmpDetailed); getErrorString();

getIconAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes); getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes); getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes); getErrorString();

getIconAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors); getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors); getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors); getErrorString();

getIconAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers); getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers); getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers); getErrorString();

getIconAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc); getErrorString();
getDiagramAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc); getErrorString();
getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingMOSInverter); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingNPN_OrGate); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingRectifier); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingResistor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Examples.OvervoltageProtection); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.Rectifier); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.ShowSaturatingInductor); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.ShowVariableResistor); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Examples.SwitchWithArc); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Examples.ThyristorBehaviourTest); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Basic.M_Transformer); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Basic.M_Transformer); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Interfaces.TwoPin); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Interfaces.OnePort); getErrorString();


getIconAnnotation(Modelica.Electrical.Analog.Interfaces.TwoPort); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.VoltageSource); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.CurrentSource); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Lines.M_OLine); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Analog.Sensors.PowerSensor); getErrorString();


getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.ReleaseNotes); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.ReleaseNotes); getErrorString();


getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.Literature); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.Literature); getErrorString();


getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.Contact); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.Contact); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Multiplexer); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.FlipFlop); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.HalfAdder); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.FullAdder); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Adder4); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Counter3); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Counter); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.MUX4); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.RS); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.RSFF); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.DFF); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.JKFF); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.HalfAdder); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.FullAdder); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.Adder); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.Counter3); getErrorString();


getIconAnnotation(Modelica.Electrical.Digital.Interfaces.Logic); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.Logic); getErrorString();


getDocumentationAnnotation(Modelica.Electrical.Digital.Interfaces.Logic); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.DigitalSignal); getErrorString();


getDocumentationAnnotation(Modelica.Electrical.Digital.Interfaces.DigitalOutput); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.SISO); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.MISO); getErrorString();


getIconAnnotation(Modelica.Electrical.Digital.Delay.DelayParams); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Delay.DelayParams); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Delay.TransportDelay); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Delay.InertialDelay); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Delay.InertialDelaySensitive); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Not); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.And); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Nand); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Or); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Nor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Xor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Xnor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.InvGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.AndGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.NandGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.OrGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.NorGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.XorGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.XnorGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Gates.BufGate); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Set); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Step); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Table); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Pulse); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Clock); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToXO1); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToXO1Z); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToUX01); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.BooleanToLogic); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToBoolean); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.RealToLogic); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToReal); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_DOL); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_YD); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMS_Start); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Inverter); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Inverter); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.SMR_Inverter); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMR_Inverter); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.SMPM_Inverter); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMPM_Inverter); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMEE_Generator); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.DCPM_Start); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCPM_Start); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.DCEE_Start); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCEE_Start); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.DCSE_Start); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCSE_Start); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.TransformerTestbench); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.TransformerTestbench); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.Rectifier6pulse); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.Rectifier6pulse); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.Rectifier12pulse); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.Rectifier12pulse); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SlipRing); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_PermanentMagnet); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ElectricalExcited); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ReluctanceRotor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_PermanentMagnet); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_ElectricalExcited); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_SeriesExcited); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy00); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy00); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy02); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy02); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy04); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy04); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy06); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy06); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy08); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy08); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy10); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy10); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd01); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd01); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd03); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd03); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd05); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd05); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd07); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd07); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd09); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd09); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd11); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd11); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz01); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz01); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz03); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz03); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz05); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz05); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz07); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz07); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz09); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz09); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz11); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz11); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy01); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy01); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy03); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy03); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy05); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy05); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy07); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy07); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy09); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy09); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy11); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy11); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd00); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd00); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd02); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd02); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd04); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd04); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd06); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd06); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd08); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd08); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd10); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd10); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz00); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz00); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz02); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz02); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz04); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz04); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz06); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz06); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz08); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz08); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz10); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz10); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialAirGap); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapS); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapR); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.DamperCage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.ElectricalExcitation); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PermanentMagnet); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialAirGapDC); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapDC); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.BasicTransformer); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialCore); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.IdealCore); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.IdealCore); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.VoltageQuasiRMSSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.CurrentQuasiRMSSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.ElectricalPowerSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.MechanicalPowerSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.RotorDisplacementAngle); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Components.Rotator); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.FromSpacePhasor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.Rotator); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.ToPolar); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.FromPolar); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromSpacePhasor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromSpacePhasor); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.Rotator); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.Rotator); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToPolar); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToPolar); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromPolar); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromPolar); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicMachine); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicInductionMachine); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicDCMachine); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.VfController); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.SwitchYD); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.TerminalBox); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.SwitchedRheostat); getErrorString();


getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.SwitchedRheostat); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.RampedRheostat); getErrorString();


getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.RampedRheostat); getErrorString();


getIconAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData); getErrorString();


getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData); getErrorString();


getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYY); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYY); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYD); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYD); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.Rectifier); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.Rectifier); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Star); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Delta); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.PlugToPin_p); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.PlugToPin_n); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Resistor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Conductor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Capacitor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Inductor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.SaturatingInductor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Transformer); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableResistor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableConductor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableCapacitor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableInductor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealThyristor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealGTOThyristor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealCommutingSwitch); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealIntermediateSwitch); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealDiode); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealTransformer); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.Idle); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.Short); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealOpeningSwitch); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealClosingSwitch); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.OpenerWithArc); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.CloserWithArc); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.Plug); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.ConditionalHeatPort); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPlug); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPlug); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.OnePort); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.OnePort); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.FourPlug); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.FourPlug); getErrorString();


getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPort); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPort); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.PotentialSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.VoltageSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.CurrentSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.PowerSensor); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SignalVoltage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.ConstantVoltage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SineVoltage); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SignalCurrent); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.ConstantCurrent); getErrorString();


getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SineCurrent); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.Blocks
// ----------------------------------------------------------------
// ----------------------------------------------------------------

getIconAnnotation(Modelica.Blocks.Examples.PID_Controller); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.PID_Controller); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.PID_Controller); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.InverseModel); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.InverseModel); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.InverseModel); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.ShowLogicalSources); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.ShowLogicalSources); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.ShowLogicalSources); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.LogicalNetwork1); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.LogicalNetwork1); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.LogicalNetwork1); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus); getErrorString();


getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part); getErrorString();


getIconAnnotation(Modelica.Blocks.Continuous.PID); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Continuous.PID); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Continuous.PID); getErrorString();


getIconAnnotation(Modelica.Blocks.Continuous.LimPID); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Continuous.LimPID); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Continuous.LimPID); getErrorString();


getIconAnnotation(Modelica.Blocks.Continuous.Der); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Continuous.Der); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Continuous.Der); getErrorString();


getIconAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold); getErrorString();


getIconAnnotation(Modelica.Blocks.Discrete.FirstOrderHold); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Discrete.FirstOrderHold); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Discrete.FirstOrderHold); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.BlockIcon); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.BlockIcon); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.BlockIcon); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.SO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.SO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.MO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.MO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SISO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.SISO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.SISO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SI2SO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.SI2SO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.SI2SO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SIMO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.SIMO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.SIMO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MISO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.MISO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.MISO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MIMO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.MIMO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.MIMO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MIMOs); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.MIMOs); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.MIMOs); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MI2MO); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.MI2MO); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.MI2MO); getErrorString();

getIconAnnotation(Modelica.Blocks.Interfaces.SignalSource); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Interfaces.SignalSource); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Interfaces.SignalSource); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SVcontrol); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MVcontrol); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteBlockIcon); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteBlock); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteBlock); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteSISO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteSISO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMOs); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMOs); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SVdiscrete); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MVdiscrete); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanBlockIcon); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.BooleanSISO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanSISO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.BooleanMIMOs); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanMIMOs); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.MI2BooleanMOs); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.MI2BooleanMOs); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.SI2BooleanSO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.SI2BooleanSO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanSignalSource); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerBlockIcon); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.IntegerMO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerMO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSignalSource); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSignalSource); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSIBooleanSO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSIBooleanSO); getErrorString();


getIconAnnotation(Modelica.Blocks.Interfaces.IntegerMIBooleanMOs); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerMIBooleanMOs); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanBlockIcon); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSISO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI2SO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI3SO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSO); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanThresholdComparison); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanComparison); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendReal); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendBoolean); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendInteger); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveReal); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveBoolean); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveInteger); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Interfaces.PartialConversionBlock); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.And); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Or); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Xor); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Nor); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Nand); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Not); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Pre); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Edge); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.FallingEdge); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Change); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.GreaterThreshold); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.GreaterEqualThreshold); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.LessThreshold); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.LessEqualThreshold); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Greater); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.GreaterEqual); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Less); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.LessEqual); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.ZeroCrossing); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.LogicalSwitch); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.Switch); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.OnOffController); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Logical.TerminateSimulation); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degC); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degC); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degF); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degF); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degRk); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degRk); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_deg); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_deg); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_rpm); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_rpm); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_kmh); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_kmh); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_day); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_day); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_hour); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_hour); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_minute); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_minute); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_litre); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_litre); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_kWh); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_kWh); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_bar); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_bar); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_gps); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_gps); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.InverseBlockConstraints); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.RealToInteger); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.IntegerToReal); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.BooleanToReal); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.BooleanToInteger); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.RealToBoolean); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.IntegerToBoolean); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.RectangularToPolar); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.PolarToRectangular); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.Max); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.Min); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.Edge); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.BooleanChange); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Math.IntegerChange); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Routing.Replicator); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Routing.RealPassThrough); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Routing.IntegerPassThrough); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Routing.BooleanPassThrough); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Sources.RealExpression); getErrorString();


getIconAnnotation(Modelica.Blocks.Sources.IntegerExpression); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Sources.IntegerExpression); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Sources.IntegerExpression); getErrorString();

getIconAnnotation(Modelica.Blocks.Sources.BooleanExpression); getErrorString();
getDiagramAnnotation(Modelica.Blocks.Sources.BooleanExpression); getErrorString();
getDocumentationAnnotation(Modelica.Blocks.Sources.BooleanExpression); getErrorString();


getIconAnnotation(Modelica.Blocks.Types.Smoothness); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Types.Smoothness); getErrorString();


getDocumentationAnnotation(Modelica.Blocks.Types.Smoothness); getErrorString();


getIconAnnotation(Modelica.Blocks.Types.Extrapolation); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Types.Extrapolation); getErrorString();


getDocumentationAnnotation(Modelica.Blocks.Types.Extrapolation); getErrorString();


getIconAnnotation(Modelica.Blocks.Types.Init); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Types.Init); getErrorString();


getDocumentationAnnotation(Modelica.Blocks.Types.Init); getErrorString();


getIconAnnotation(Modelica.Blocks.Types.InitPID); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Types.InitPID); getErrorString();


getDocumentationAnnotation(Modelica.Blocks.Types.InitPID); getErrorString();


getIconAnnotation(Modelica.Blocks.Types.SimpleController); getErrorString();


getDiagramAnnotation(Modelica.Blocks.Types.SimpleController); getErrorString();


getDocumentationAnnotation(Modelica.Blocks.Types.SimpleController); getErrorString();


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// Modelica.UserGuide
// ----------------------------------------------------------------
// ----------------------------------------------------------------


getIconAnnotation(Modelica.UsersGuide.Overview); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.Overview); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.Overview); getErrorString();

getIconAnnotation(Modelica.UsersGuide.Connectors); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.Connectors); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.Connectors); getErrorString();

getIconAnnotation(Modelica.UsersGuide.Conventions); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.Conventions); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.Conventions); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ParameterDefaults); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ParameterDefaults); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ParameterDefaults); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4); getErrorString();

getIconAnnotation(Modelica.UsersGuide.ModelicaLicense2); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.ModelicaLicense2); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.ModelicaLicense2); getErrorString();

getIconAnnotation(Modelica.UsersGuide.Contact); getErrorString();
getDiagramAnnotation(Modelica.UsersGuide.Contact); getErrorString();
getDocumentationAnnotation(Modelica.UsersGuide.Contact); getErrorString();


// Result:
// {true}
// Evaluating: getAnnotationVersion()
// "3.x"
// Evaluating: setAnnotationVersion("3.x")
// true
// Evaluating: getAnnotationVersion()
// "3.x"
// Evaluating: loadModel(Modelica, {"3.1"})
// true
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide)
// {"<html>
// <p>
// Package <b>Modelica</b> is a <b>standardized</b> and <b>pre-defined</b> package
// that is developed together with the Modelica language from the
// Modelica Association, see
// <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a>.
// It is also called <b>Modelica Standard Library</b>.
// It provides constants, types, connectors, partial models and model
// components in various disciplines.
// </p>
// <p>
// This is a short <b>User's Guide</b> for
// the overall library. Some of the main sublibraries have their own
// User's Guides that can be accessed by the following links:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Digital.UsersGuide\">Digital</a>
//    </td>
//    <td valign=\"top\">Library for digital electrical components based on the VHDL standard
//    (2-,3-,4-,9-valued logic)</td>
// </tr>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Magnetic.FluxTubes.UsersGuide\">FluxTubes</a>
//     </td>
//    <td valign=\"top\">Library for modelling of electromagnetic devices with lumped magnetic networks</td>
// </tr>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody</a>
//     </td>
//    <td valign=\"top\">Library to model 3-dimensional mechanical systems</td>
// </tr>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.Rotational.UsersGuide\">Rotational</a>
//     </td>
//    <td valign=\"top\">Library to model 1-dimensional mechanical systems</td>
// </tr>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Fluid.UsersGuide\">Fluid</a></td>
//     <td valign=\"top\">Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description</td>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Media.UsersGuide\">Media</a>
//     </td>
//    <td valign=\"top\">Library of media property models</td>
// </tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.SIunits.UsersGuide\">SIunits</a> </td>
//    <td valign=\"top\">Library of type definitions based on SI units according to ISO 31-1992</td>
// </tr>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.StateGraph.UsersGuide\">StateGraph</a>
//     </td>
//    <td valign=\"top\">Library to model discrete event and reactive systems by hierarchical state machines</td>
// </tr>
//
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Utilities.UsersGuide\">Utilities</a>
//     </td>
//    <td valign=\"top\">Library of utility functions especially for scripting (Files, Streams, Strings, System)</td>
// </tr>
// </table>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentAnnotations(Modelica.Blocks.Sources.RealExpression)
// {{Dialog("General","Time varying output signal",true,-,false,-,-,-,-,"",false), Placement(true,-,-,100.0,-10.0,120.0,10.0,0.0,-,-,-,-,-,-,)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentAnnotations(Modelica.Blocks.Sources.IntegerExpression)
// {{Dialog("General","Time varying output signal",true,-,false,-,-,-,-,"",false), Placement(true,-,-,100.0,-10.0,120.0,10.0,0.0,-,-,-,-,-,-,)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentAnnotations(Modelica.Blocks.Sources.BooleanExpression)
// {{Dialog("General","Time varying output signal",true,-,false,-,-,-,-,"",false), Placement(true,-,-,100.0,-10.0,120.0,10.0,0.0,-,-,-,-,-,-,)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getNamedAnnotation(Modelica.UsersGuide, __Dymola_DocumentationClass)
// {true}
// Evaluating: getErrorString()
// ""
// Evaluating: getNamedAnnotation(Modelica, __Dymola_DocumentationClass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-60, -15}, {-30, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, -15}, {0, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, -15}, {30, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{30, -15}, {60, 15}}, 0, 360), Rectangle(true, {0.0, 0.0}, 0, {255, 255, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, -20}, {62, 0}}, 0), Line(true, {0.0, 0.0}, 0, {{60, 0}, {90, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {-60, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Sphere, 0.25, BorderPattern.None, {{-60, -10}, {60, -20}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-148, -50}, {152, -80}}, "Lnom=%Lnom", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-148, 91}, {152, 51}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-60, -15}, {-30, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, -15}, {0, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, -15}, {30, 15}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{30, -15}, {60, 15}}, 0, 360), Rectangle(true, {0.0, 0.0}, 0, {255, 255, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, -20}, {62, 0}}, 0), Line(true, {0.0, 0.0}, 0, {{60, 0}, {96, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-96, 0}, {-60, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Sphere, 0.25, BorderPattern.None, {{-60, -10}, {60, -20}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.SaturatingInductor)
// {"<HTML>
// <p>
// This model approximates the behaviour of an inductor with the influence of saturation,
// i.e. the value of the inductance depends on the current flowing through the inductor.
// The inductance decreases as current increases.<br>
// The parameters are:
// <ul>
// <li>Inom...nominal current</li>
// <li>Lnom...nominal inductance at nominal current</li>
// <li>Lzer...inductance near current = 0; Lzer has to be greater than Lnom</li>
// <li>Linf...inductance at large currents; Linf has to be less than Lnom</li>
// </ul>
// </p>
// </HTML>
// ","<html>
// <dl>
// <p>
//   <dt><b>Main Author:</b></dt>
//   <dd>
//   <a href=\"http://www.haumer.at/\">Anton Haumer</a><br>
//   Technical Consulting & Electrical Engineering<br>
//   A-3423 St.Andrae-Woerdern<br>Austria<br>
//   email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
//   </dd>
// </p>
// <p>
//   <dt><b>Release Notes:</b></dt>
//   <dd>
//   <ul>
//   <li> May 27, 2004: Implemented by Anton Haumer</li>
//   </ul>
//   </dd>
// </dl>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.Resistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {-70, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {90, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-144, -40}, {142, -72}}, "R=%R", 0, TextAlignment.Center), Line(false, {0.0, 0.0}, 0, {{0, -100}, {0, -30}}, {127, 0, 0}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-152, 87}, {148, 47}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.Resistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0), Line(true, {0.0, 0.0}, 0, {{-96, 0}, {-70, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {96, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.Resistor)
// {"<HTML>
// <P>
// The linear resistor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i*R = v</i>.
// The Resistance <i>R</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// ","<html>
// <ul>
// <li><i> August 07, 2009   </i>
//        by Anton Haumer<br> temperature dependency of resistance added<br>
//        </li>
// <li><i> March 11, 2009   </i>
//        by Christoph Clauss<br> conditional heat port added<br>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {-70, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {90, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0), Line(true, {0.0, 0.0}, 0, {{-52, -50}, {48, 50}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{40, 52}, {50, 42}, {54, 56}, {40, 52}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, -100}, {0, -30}}, {127, 0, 0}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-156, 109}, {144, 69}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-110, 20}, {-85, 20}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {160, 160, 164}, {160, 160, 164}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-95, 23}, {-85, 20}, {-95, 17}, {-95, 23}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{90, 20}, {115, 20}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-125, 0}, {-115, 0}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-120, -5}, {-120, 5}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {160, 160, 164}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-110, 25}, {-90, 45}}, "i", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {160, 160, 164}, {160, 160, 164}, LinePattern.Solid, FillPattern.Solid, 0.25, {{105, 23}, {115, 20}, {105, 17}, {105, 23}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{115, 0}, {125, 0}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {160, 160, 164}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{90, 45}, {110, 25}}, "i", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.HeatingResistor)
// {"<HTML>
// <p>This is a model for an electrical resistor where the generated heat
// is dissipated to the environment via connector <b>heatPort</b> and where
// the resistance R is temperature dependent according to the following
// equation:</p>
// <pre>    R = R_ref*(1 + alpha*(heatPort.T - T_ref))
// </pre>
// <p><b>alpha</b> is the <b>temperature coefficient of resistance</b>, which
// is often abbreviated as <b>TCR</b>. In resistor catalogues, it is usually
// defined as <b>X [ppm/K]</b> (parts per million, similarly to per centage)
// meaning <b>X*1.e-6 [1/K]</b>. Resistors are available for 1 .. 7000 ppm/K,
// i.e., alpha = 1e-6 .. 7e-3 1/K;</p>
//
// <p>
// Via parameter <b>useHeatPort</b> the heatPort connector can be enabled and disabled
// (default = enabled). If it is disabled, the generated heat is transported implicitly
// to an internal temperature source with a fixed temperature of T_ref.<br>
// If the heatPort connector is enabled, it must be connected.
// </p>
//
// </HTML>
// ","<html>
// <ul>
// <li><i> August 07, 2009   </i>
//        by Anton Haumer<br> temperature dependency of resistance added<br>
//        </li>
// <li><i> March 11, 2009   </i>
//        by Christoph Clauss<br> conditional heat port added<br>
//        </li>
// <li><i> 2002   </i>
//        by Anton Haumer<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.EMF)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-85, 10}, {-36, -10}}, 0), Line(true, {0.0, 0.0}, 0, {{0, 90}, {0, 40}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{35, 10}, {100, -10}}, 0), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-40, 40}, {40, -40}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, -90}, {0, -40}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, -50}, {199, -90}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {160, 160, 164}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, 80}, {189, 46}}, "k=%k", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, -30}, {-40, -30}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-100, -50}, {-80, -30}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, -50}, {-60, -30}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-60, -50}, {-40, -30}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-70, -30}, {-70, -10}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.EMF)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Polygon(true, {0.0, 0.0}, 0, {160, 160, 164}, {160, 160, 164}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-17, 95}, {-20, 85}, {-23, 95}, {-17, 95}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-20, 110}, {-20, 85}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {160, 160, 164}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, 110}, {-30, 90}}, "i", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{9, 75}, {19, 75}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-20, -110}, {-20, -85}}, {160, 160, 164}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {160, 160, 164}, {160, 160, 164}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-17, -100}, {-20, -110}, {-23, -100}, {-17, -100}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {160, 160, 164}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, -110}, {-30, -90}}, "i", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{8, -79}, {18, -79}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{14, 80}, {14, 70}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.EMF)
// {"<html>
// <p>EMF transforms electrical energy into rotational mechanical energy. It is used as basic building block of an electrical motor. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection. </p>
// </html>","<html>
// <ul>
// <li><i> 1998   </i>
//        by Martin Otter<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.Conductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {-70, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {90, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.None, FillPattern.None, 0.25, {{-136, -42}, {142, -74}}, "G=%G", 0, TextAlignment.Center), Line(false, {0.0, 0.0}, 0, {{0, -100}, {0, -30}}, {127, 0, 0}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-152, 87}, {148, 47}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-144, -40}, {142, -72}}, "G=%G", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.Conductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-96, 0}, {-70, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {96, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-70, 30}, {70, -30}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.Conductor)
// {"<HTML>
// <P>
// The linear conductor connects the branch voltage <i>v</i> with the
// branch current <i>i</i> by <i>i = v*G</i>.
// The Conductance <i>G</i> is allowed to be positive, zero, or negative.
// </P>
// </HTML>
// ","<html>
// <ul>
// <li><i> August 07, 2009   </i>
//        by Anton Haumer<br> temperature dependency of conductance added<br>
//        </li>
// <li><i> March 11, 2009   </i>
//        by Christoph Clauss<br> conditional heat port added<br>
//        </li>
// <li><i> 1998   </i>
//        by Christoph Clauss<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: "I am using MSL31"
// "I am using MSL31"
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.Ground)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-60, 50}, {60, 50}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-40, 30}, {40, 30}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-20, 10}, {20, 10}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 90}, {0, 50}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-144, -19}, {156, -59}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentAnnotations(Modelica.Electrical.Analog.Basic.Ground)
// {{Placement(true,0.0,100.0,10.0,-10.0,-10.0,10.0,270.0,-,-,-,-,-,-,)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getParameterNames(Modelica.Electrical.Analog.Basic.Resistor)
// {"R","T_ref","alpha"}
// Evaluating: getErrorString()
// ""
// Evaluating: getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "R")
// ""
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "R")
// {"start"}
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentModifierValue(Modelica.Electrical.Analog.Basic.Resistor, R.start)
// "1"
// Evaluating: getErrorString()
// ""
// Evaluating: removeComponentModifiers(Modelica.Electrical.Analog.Basic.Resistor, "R")
// true
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "R")
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "T_ref")
// "300.15"
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "T_ref")
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getParameterValue(Modelica.Electrical.Analog.Basic.Resistor, "alpha")
// "0"
// Evaluating: getErrorString()
// ""
// Evaluating: getComponentModifierNames(Modelica.Electrical.Analog.Basic.Resistor, "alpha")
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Rotational.Components)
// {"<html>
// <p>
// This package contains basic components 1D mechanical rotational drive trains.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Rotational.Components.Intertia)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic)
// {"<HTML>
// <p>
// This package contains basic analog electrical components.
// </p>
//
// </HTML>
// ","<html>
// <dl>
// <dt>
// <b>Main Authors:</b>
// <dd>
// Christoph Clau&szlig;
//     &lt;<a href=\"mailto:Christoph.Clauss@eas.iis.fraunhofer.de\">Christoph.Clauss@eas.iis.fraunhofer.de</a>&gt;<br>
//     Andr&eacute; Schneider
//     &lt;<a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>&gt;<br>
//     Fraunhofer Institute for Integrated Circuits<br>
//     Design Automation Department<br>
//     Zeunerstra&szlig;e 38<br>
//     D-01069 Dresden<br>
// <p>
// </dl>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Basic.EMF)
// {"<html>
// <p>EMF transforms electrical energy into rotational mechanical energy. It is used as basic building block of an electrical motor. The mechanical connector flange can be connected to elements of the Modelica.Mechanics.Rotational library. flange.tau is the cut-torque, flange.phi is the angle at the rotational connection. </p>
// </html>","<html>
// <ul>
// <li><i> 1998   </i>
//        by Martin Otter<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.OverView)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.OverView)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.OverView)
// {"<html>
// <p>
// In this section, an overview of the most important features
// of this library is given.
// </p>
// <h4><font color=\"#008000\">Steps and Transitions</font></h4>
// <p>
// A <b>StateGraph</b> is an enhanced finite state machine.
// It is based on the JGraphChart method and
// takes advantage of Modelica features for
// the \"action\" language. JGraphChart is a further development of
// Grafcet to include elements of StateCharts that are not present
// in Grafcet/Sequential Function Charts. Therefore, the StateGraph
// library has a similar modeling power as StateCharts but avoids
// some deficiences of StateCharts.
// </p>
// <p>
// The basic elements of StateGraphs are <b>steps</b> and <b>transitions</b>:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/StepAndTransition1.png\">
// </p>
// <p>
// <b>Steps</b> represent the possible states a StateGraph can have.
// If a step is active the Boolean variable <b>active</b> of
// the step is <b>true</b>. If it is deactivated,
// <b>active</b> = <b>false</b>. At the initial time, all \"usual\"
// steps are deactivated. The <b>InitialStep</b> objects are steps
// that are activated at the initial time. They are characterized
// by a double box (see figure above).
// </p>
// <p>
// <b>Transitions</b> are used to change the state of a StateGraph.
// When the step connected to the input of a transition is active,
// the step connected to the output of this transition is deactivated
// and the transition condition becomes true, then the
// transition fires. This means that the step connected to the input to the
// transition is deactivated and the step connected to the output
// of the transition is activated.
// </p>
// <p>
// The transition <b>condition</b> is defined via the parameter menu
// of the transition object. Clicking on object \"transition1\" in
// the above figure, results in the following menu:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/StepAndTransition2.png\">
// </p>
// <p>
// In the input field \"<b>condition</b>\", any type of time varying
// Boolean expression can be given (in Modelica notation, this is
// a modification of the time varying variable <b>condition</b>).
// Whenever this condition is true, the transition can fire.
// Additionally, it is possible to activate a timer, via
// <b>enableTimer</b> (see menu above) and provide a
// <b>waitTime</b>. In this case the firing of the transition
// is delayed according to the provided waitTime. The transition
// condition and the waitTime are displayed in the transition icon.
// </p>
// <p>
// In the above example, the simulation starts at <b>initialStep</b>.
// After 1 second, <b>transition1</b> fires and <b>step1</b> becomes
// active. After another second <b>transition2</b> fires and
// <b>initialStep</b> becomes again active. After a further
// second <b>step1</b> becomes again active, and so on.
// </p>
// <p>
// In JGrafcharts, Grafcet and Sequential Function Charts, the
// network of steps and transitions is drawn from top to bottom.
// In StateGraphs, no particular direction is defined, since
// steps and transitions are blocks with input and output connectors
// that can be arbitrarily placed and connected. Usually, it is
// most practical to define the network from left to right,
// as in the example above, since then it is easy to read the
// labels on the icons.
// </p>
// <h4><font color=\"#008000\">Conditions and Actions</font></h4>
// <p>
// With the block <b>TransitionWithSignal</b>, the firing condition
// can be provided as Boolean input signal, instead as entry in the
// menu of the transition. An example is given in the next
// figure:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/StepAndTransition3.png\">
// </p>
// <p>
// Component \"step\" is an instance of \"StepWithSignal\" that is
// a usual step where the active flag is available as Boolean
// output signal. To this output, component \"Timer\" from
// library \"Modelica.Blocks.Logical\" is connected. It measures the
// time from the time instant where the Boolean input (i.e., the
// active flag of the step) became true upto the current
// time instant. The timer is connected to a comparison
// component. The output is true, once the timer reaches
// 1 second. This signal is used as condition input of the
// transition. As a result, \"transition2\" fires, once step
// \"step\" has been active for 1 second.
// Of course, any other
// Modelica block with a Boolean output signal can be
// connected to the condition input of such a transition block
// as well.
// </p>
// <p>
// Conditions of a transition can either be computed by
// a network of logical blocks from the Logical library as
// in the figure above, or via the \"SetBoolean\" component
// any type of logical expression can be defined in textual
// form, as shown in the next figure:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/StepAndTransition4.png\">
// </p>
// <p>
// With the block \"<b>SetBoolean</b>\", a time varying expression
// can be provided as modification to the output signal <b>y</b>
// (see block with icon text \"timer.y > 1\" in the figure above).
// The output signal can be in turn connected to the condition
// input of a TransitionWithSignal block.
// </p>
// <p>
// The \"<b>SetBoolean</b>\" block can also be used to
// compute a Boolean signal depending on the active step.
// In the figure above, the output of the block with the
// icon text \"step.active\" is
// true, when \"step\" is active, otherwise it is false
// (note, the icon text of \"SetBoolean\" displays the modification
// of the output signal \"y\").
// This signal can then be used to compute desired <b>actions</b>
// in the physical systems model. For example, if a <b>valve</b>
// shall be open, when the StateGraph is in \"step1\" or
// in \"step4\", a \"SetBoolean\" block may be connected to the
// valve model using the following condition:
// </p>
// <pre>
//     valve = step1.active <b>or</b> step2.active
// </pre>
// <p>
// Via the Modelica operators <b>edge</b>(..) and <b>change</b>(..),
// conditions depending on rising and falling edges of
// Boolean expressions can be used when needed.
// </p>
// <p>
// In JGrafcharts, Grafcet, Sequential Function Charts and StateCharts,
// <b>actions</b> are formulated <b>within a step</b>. Such actions are
// distinguished as <b>entry</b>, <b>normal</b>, <b>exit</b> and
// <b>abort</b> actions. For example, a valve might be opened by
// an entry action of a step and might be closed by an exit
// action of the same step. In StateGraphs, this is (fortunately)
// <b>not possible</b>
// due to Modelicas \"single assignment rule\" that requires that every
// variable is defined by exactly one equation. Instead, the
// approach explained above is used. For example, via the
// \"SetBoolean\" component, the valve variable is set to true
// when the StateGraph is in particular steps.
// </p>
// <p>
// This feature of a StateGraph is <b>very useful</b>, since it allows
// a Modelica translator to <b>guarantee</b> that a given StateGraph
// has always <b>deterministic</b> behaviour without conflicts.
// In the other methodologies this is much more cumbersome. For example,
// if two steps are executed in parallel and both step actions
// modify the same variable, the result is either non-deterministic
// or non-obvious rules have to be defined which action
// takes priority. In a StateGraph, such a situation is detected by
// the translator resulting in an error, since there are two equations
// to compute one variable. Additional benefits of the StateGraph
// approach are:
// </p>
// <ul>
// <li> A JGrafchart or a StateChart need to potentially access
//      variables in a step that are defined in
//      higher hierarchical levels of a model. Therefore, mostly <b>global
//      variables</b> are used in the whole network, even if the
//      network is structured hierarchically. In StateGraphs this
//      is not necessary, since the physical systems outside
//      of a StateGraph might access the step or transition state
//      via a hierarchical name. This means that <b>no global variables</b>
//      are needed, because the local variables in the StateGraph
//      are accessed from local variables outside of the StateGraph.
//      </li>
// <li> It is simpler for a user to understand the information that
//      is provided in the non-graphical definition, since every
//      variable is defined at exactly one place. In the other
//      methodologies, the setting and re-setting of the same
//      variable is cluttered within the whole network.
//     </li>
// </ul>
// <p>
// To emphasize this important difference between these methodologies,
// consider the case that a state machine has the following
// hierarchy:
// </p>
// <pre>
//    stateMachine.superstate1.superstate2.step1
// </pre>
// <p>
// Within \"step1\" a StateChart would, e.g., access variable
// \"stateMachine.openValve\", say as \"entry action: openValve = true\".
// This typical usage has the severe drawback that it is not possible
// to use the hierarchical state \"superstate1\" as component in another
// context, because \"step1\" references a particular name outside of this
// component.
// </p>
// <p>
// In a StateGraph, there would be typically a \"SetBoolean\" component
// in the \"stateMachine\" component stating:
// </p>
// <pre>
//     openValve = superstate1.superstate2.step1.active;
// </pre>
// <p>
// As a result, the \"superstate1\" component can be used in
// another context, because it does not depend on the environment
// where it is used.
// </p>
// <h4><font color=\"#008000\">Execution Model</font></h4>
// <p>
// The execution model of a StateGraph follows from its
// Modelica implementation: Given the states of all steps, i.e.,
// whether a step is active or not active, the equations of all
// steps, transitions, transition conditions, actions etc. are
// sorted resulting in an execution sequence to compute
// essentially the new values of the steps. If conflicts occur,
// e.g., if there are more equations as variables, of if there
// are algebraic loops between Boolean variables, an exception
// is raised. Once all equations have been processed, the
// <b>active</b> variable of all steps are updated to the newly
// calculated values. Afterwards, the equations are again
// evaluated. The iteration stops, once no step changes
// its state anymore, i.e., once no transition fires anymore.
// Then, simulation continuous until a new event is triggered,
// (when a relation changes its value).
// </p>
// <p>
// With the Modelica \"sampled(..)\" operator, a StateGraph might also
// be executed within a discrete controller that is called
// at regular time instants. In a future version of the StateGraph
// library, this might be more directly supported.
// </p>
// <h4><font color=\"#008000\">Parallel and Alternative Execution</font></h4>
// <p>
// Parallel activities can be defined by
// component <b>Parallel</b> and alternative activities
// can be defined by component <b>Alternative</b>.
// An example for both components is given in the next figure.
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/Parallel1.png\">
// </p>
// <p>
// Here, the branch from \"step2\" to \"step5\" is executed in parallel
// to \"step1\". A transition connected to the output of a parallel
// branch component can only fire if the final steps
// in all parallel branches are active simultaneously.
// The figure above is a screen-shot from the animation of the
// StateGraph: Whenever a step is active or a transition can fire,
// the corresponding component is marked in <b>green</b> color.
// </p>
// <p>
// The three branches within \"step2\" to \"step5\" are
// executed alternatively, depending which transition condition
// of \"transition3\", \"transition4\", \"transition4a\" fires first.
// Since all three transitions fire after 1 second, they are all
// candidates for the active branch. If two or more transitions
// would fire at the same time instant, a priority selection
// is made: The alternative and parallel components have a
// vector of connectors. Every branch has to be connected to
// exactly one entry of the connector vector. The entry with
// the lowest number has the highest priority.
// </p>
// <p>
// Parallel, Alternative and Step components have vectors of
// connectors. The dimensions of these vectors are set in the
// corresponding parameter menu. E.g. in a \"Parallel\" component:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/Parallel2.png\">
// </p>
// <p>
// Currently in Dymola the following menu pops up, when a branch
// is connected to a vector of components in order to define
// the vector index to which the component shall be connected:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/Parallel3.png\">
// </p>
// <h4><font color=\"#008000\">CompositeSteps, Suspend and Resume Port</font></h4>
// <p>
// A StateGraph can be hierarchically structured by using a <b>CompositeStep</b>.
// This is a component that inherits from <b>PartialCompositeStep</b>.
// An example is given in the next figure (from Examples.ControlledTanks):
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/UsersGuide/CompositeStep1.png\">
// </p>
// <p>
// The CompositeStep component contains a local StateGraph that is
// entered by one or more input transitions and that is left
// by one or more output transitions. Also, other needed signals
// may enter a CompositeStep. The CompositeStep has similiar properties
// as a \"usual\" step: The CompositeStep is <b>active</b> once at least
// one step within the CompositeStep is active. Variable <b>active</b>
// defines the state of the CompositeStep.
// </p>
// <p>
// Additionally, a CompositeStep has a <b>suspend</b> port. Whenever the
// transition connected to this port fires, the CompositeStep is left
// at once. When leaving the CompositeStep via the suspend port, the internal
// state of the CompositeStep is saved, i.e., the active flags of all
// steps within the CompositeStep. The CompositeStep might be entered via
// its <b>resume</b> port. In this case the internal state from the
// suspend transition is reconstructed and the CompositeStep continues
// the execution that it had before the suspend transition fired
// (this corresponds to the history ports of StateCharts or JGrafCharts).
// </p>
// <p>
// A CompositeStep may contain other CompositeSteps. At every level,
// a CompositeStep and all of its content can be left via its suspend ports
// (actually, there
// is a vector of suspend connectors, i.e., a CompositeStep might
// be aborted due to different transitions).
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.FirstExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.FirstExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.FirstExample)
// {"<html>
// <p>
// A first example will be given here (not yet done).
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.ApplicationExample)
// {"<html>
// <p>
// In this section a more realistic, still simple, application example
// is given, to demonstrate various features of the StateGraph library.
// This example shows the control of a two tank system from the master thesis
// of Isolde Dressler
// (<a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">see literature</a>).
// </p>
// <p>
// In the following figure the top level of the model is shown.
// This model is available as StateGraph.Examples.ControlledTanks.
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/Examples/ControlledTanks1.png\">
// </p>
// <p>
// In the right part of the figure, two tanks are shown. At the top part,
// a large fluid source is present from which fluid can be filled in
// <b>tank1</b> when <b>valve1</b> is open. Tank1 can be emptied via
// <b>valve2</b> that is located in the bottom of tank2 and
// fills a second <b>tank2</b> which in turn is emptied via
// <b>valve3</b>. The actual levels of the tanks are measured
// and are provided as signals <b>level1</b> and <b>level2</b>
// to the <b>tankController</b>.
// </p>
// <p>
// The <b>tankController</b> is controlled by three buttons,
// <b>start</b>, <b>stop</b> and <b>shut</b> (for shutdown)
// that are mutually exclusive. This means that whenever one button is
// pressed (i.e., its state is <b>true</b>) then the other two
// buttons are not pressed (i.e., their states are <b>false</b>).
// When button <b>start</b> is pressed, the \"normal\" operation
// to fill and to empty the two tanks is processed:
// </p>
// <ol>
// <li> Valve 1 is opened and tank 1 is filled.</li>
// <li> When tank 1 reaches its fill level limit,
//      valve 1 is closed. </li>
// <li> After a waiting time, valve 2 is
//      opened and the fluid flows from tank 1 into tank 2.</li>
// <li> When tank 1 is empty, valve 2 is closed. </li>
// <li> After a waiting time, valve 3 is opened and
//      the fluid flows out of tank 2</li>
// <li> When tank 2 is empty, valve 3 is closed</liI>
// </ol>
// <p>
// The above \"normal\" process can be influenced by the following
// buttons:
// </p>
// <ul>
// <li> Button <b>start</b> starts the above process.
//      When this button is pressed after a \"stop\" or
//      \"shut\" operation, the process operation continues.
//      </li>.
// <li> Button <b>stop</b> stops the above process by
//      closing all valves. Then, the controller waits for
//      further input (either \"start\" or \"shut\" operation).</li>
// <li> Button <b>shut</b> is used to shutdown the process,
//      by emptying at once both tanks. When this is achieved,
//      the process goes back to its start configuration.
//      Clicking on \"start\", restarts the process.</li>
// </ul>
// <p>
// The implementation of the <b>tankController</b> is shown in
// the next figure:
// </p>
// <p align=\"center\">
// <img src=\"../Images/StateGraph/Examples/ControlledTanks2.png\">
// </p>
// <p>
// When the \"<b>start</b>\" button is pressed, the stateGraph is
// within the CompositeStep \"<b>makeProduct</b>\". During normal
// operation this CompositeStep is only left, once tank2 is empty.
// Afterwards, the CompositeStep is at once re-entered.
// </p>
// <p>
// When the \"<b>stop</b>\" button is pressed, the \"makeProduct\"
// CompositeStep is at once terminated via the \"<b>suspend</b>\" port
// and the stateGraph waits in step \"<b>s2</b>\" for further
// commands. When the \"<b>start</b>\" button is pressed, the CompositeStep
// is re-entered via its <b>resume</b> port and the \"normal\"
// operation continues at the state where it was aborted by the
// suspend transition. If the \"<b>shut</b>\" button is pressed,
// the stateGraph waits in the \"<b>emptyTanks</b>\" step, until
// both tanks are empty and then waits at the initial step
// \"<b>s1</b>\" for further input.
// </p>
// <p>
// The opening and closing of valves is <b>not</b> directly
// defined in the stateGraph. Instead via the \"<b>setValveX</b>\"
// components, the Boolean state of the valves are computed.
// For example, the output y of \"setValve2\" is computed as:
// </p>
// <pre>
//   y = makeProduct.fillTank2.active or emptyTanks.active
// </pre>
// <p>
// i.e., valve2 is open, when step \"makeProduct.fillTank2 or when
// step \"emptyTanks\" is active. Otherwise, valve2 is closed.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.ReleaseNotes)
// {"<html>
// <h4>Version 0.87, 2004-06-23</h4>
// <ul>
// <li> Included in Modelica standard library 2.0 Beta 1 with the new block connectors.
//      Changed all the references to the block connectors and the Logical library
//      correspondingly.</li>
// </ul>
// <h4>Version 0.86, 2004-06-20</h4>
// <ul>
// <li> New components \"Alternative\" and \"Parallel\" for alternative and
//      parallel execution paths.</li>
// <li> A step has now a vector of input and output connectors in order
//      that multiple connections to and from a step are possible</li>
// <li> Removed components \"AlternativeSplit\", \"AlternativeJoin\",
//      \"ParallelSplit\" and \"ParallelJoin\" since the newly introduced
//      components (\"Alternative\", \"Parallel\", vector connectors of steps)
//      have the same modeling power but are safer and more convenient.</li>
// <li> Removed the timer in a step (attach instead Logical.Timer to
//      the \"active\" port of a \"StepWithSignal\" component). Note, that in
//      most cases it is more convenient and more efficient to use the
//      built-in timer of a transition.</li>
// <li> Component \"StepInitial\" renamed to \"InitialStep\".</li>
// <li> New component \"Timer\" within sublibrary Logical.</li>
// <li> Updated and improved documentation of the library.</li>
// </ul>
// <h4>Version 0.85, 2004-06-17</h4>
// <ul>
// <li> Renamed \"MacroStep\" to \"CompositeStep\" and the ports of the MacroStep
//      from \"abort\" to \"suspend\" and \"histoy\" to \"resume\".</li>
// <li> Nested \"CompositeStep\" components are supported, based on the
//      experimental feature of nested inner/outer components
//      introduced by Dymola. This means that CompositeSteps can
//      be suspended and resumed at every level.</li>
// <li> New example \"Examples.ShowExceptions\" to demonstrate the new
//      feature of nested CompositeSteps.</li>
// <li> New package \"Logical\". It contains all components of
//      ModelicaAdditions.Blocks.Logical, but with new block connectors
//      and nicer icons. Additionally, logical blocks are also added.</li>
// <li> Improved icons for several components of the StateGraph library.</li>
// </ul>
// <h4>Version 0.83, 2004-05-21</h4>
// <ul>
// <li> The \"abort\" and \"history\" connectors are no longer visible in the
//      diagram layer of a CompositeStep since it is not allowed to connect
//      to them in a CompositeStep.</li>
// <li> Made the diagram/icon size of a CompositeStep smaller (from 200/-200 to
//      150/-150).</li>
// <li> Improved icons for \"SetBoolean/SetInteger/SetReal\" components.</li>
// <li> Renamed \"ParameterReal\" to \"SetRealParameter\".</li>
// </ul>
// <h4>Version 0.82, 2004-05-18</h4>
// <p>
// Implemented a first version that is provided to other people.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.Literature)
// {"<html>
// <p>
// The StateGraph library is based on the following references:
// </p>
// <dl>
// <dt>Arzen K.-E. (2004):</dt>
// <dd> <b>JGrafchart User Manual. Version 1.5</b>.
//      Department of Automatic Control, Lund Institute of Technology,
//      Lund, Sweden, Feb. 13<br>&nbsp;</dd>
// <dt>Dressler I. (2004):</dt>
// <dd> <b>Code Generation From JGrafchart to Modelica</b>.
//      Master thesis, supervisor: Karl-Erik Arzen,
//      Department of Automatic Control, Lund Institute of Technology,
//      Lund, Sweden, March 30<br>&nbsp;</dd>
// <dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
// <dd> <b>Object-Oriented and Hybrid Modeling in Modelica</b>.
//      Journal Europeen des systemes automatises (JESA),
//      Volume 35 - n. 1.<br>&nbsp;</dd>
// <dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
// <dd> <b>Modeling Petri Nets as Local Constraint Equations for
//      Hybrid Systems using Modelica</b>.
//      SCSC'98, Reno, Nevada, USA,
//      Society for Computer Simulation International, pp. 314-319.
//      </dd>
// </dl>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.UsersGuide.Contact)
// {"<html>
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> The development of this library was strongly motivated by the
//      master thesis of Isolde Dressler
//      (<a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">see literature</a>),
//      in which
//      a compiler from JGrafChart to Modelica was designed and
//      implemented. This project was supervised by Karl-Erik Arzen
//      from Departement of Automatic Control, Lund Institut of
//      Technology, Lund, Sweden.</li>
// <li> This library profits also from the experience gained
//      in the focused research program (Schwerpunktprogramm)
//      \"Continuous-Discrete Dynamic Systems\" (KONDISK), sponsored by the
//      Deutsche Forschungsgemeinschaft under grants OT174/1-2 and EN152/22-2.
//      This support is most gratefully acknowledged.
//  </li>
// <li> The implementation of the basic components of this library by describing
//      finite state machines with equations is based on
//      (Elmqvist, Mattsson and Otter, 2001),
//      which in turn uses ideas from (Mosterman, Otter and Elmqvist, 1998),
//      see <a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">literature</a></li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.FirstExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant2)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.FirstExample_Variant3)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.ExecutionPaths)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.ExecutionPaths)
// {-160.0,-160.0,160.0,160.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.ExecutionPaths)
// {"<HTML>
// <p>
// This is an example to demonstrate in which way <b>parallel</b> activities
// can be modelled by a StateGraph. When transition1 fires
// (after 1 second), two branches are executed in parallel.
// After 6 seconds the two branches are synchronized in order to arrive
// at step6.
// </p>
// <p>
// Before simulating the model, try to figure out whether which branch
// of the alternative sequence is executed. Note, that alternatives
// have priorities according to the port index (alternative.split[1]
// has a higher priority to fire as alternative.split[2]).
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.ShowCompositeStep)
// {"<HTML>
// <p>
// This is the same example as \"ExecutionPaths\". The only difference
// is that the alternative paths are included in a \"CompositeStep\".
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.ShowExceptions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.ShowExceptions)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.ShowExceptions)
// {"<HTML>
// <p>
// CompositeStep \"compositeStep\" is a hierarchical StateGraph consisting of
// two other subgraphs. Whenever component \"compositeStep\" is suspended,
// all steps with in \"compositeStep\" are deactivated. By entering \"compositeStep\"
// via its \"resume\" port, all steps within \"compositeStep\" are activated
// according to their setting before leaving the \"compositeStep\" via its
// \"suspend\" port.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.ControlledTanks)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.ControlledTanks)
// {-100.0,-100.0,100.0,100.0,true,0.1,0.5,0.5}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.ControlledTanks)
// {"<html>
// <p>
// With this example the controller of a tank filling/emptying system
// is demonstrated. This example is from Dressler (2004),
// see <a href=\"Modelica://Modelica.StateGraph.UsersGuide.Literature\">Literature</a>.
// The basic operation is to fill and empty the two tanks:
// </p>
// <ol>
// <li> Valve 1 is opened and tank 1 is filled.</li>
// <li> When tank 1 reaches its fill level limit,
//      valve 1 is closed. </li>
// <li> After a waiting time, valve 2 is
//      opened and the fluid flows from tank 1 into tank 2.</li>
// <li> When tank 1 is empty, valve 2 is closed. </li>
// <li> After a waiting time, valve 3 is opened and
//      the fluid flows out of tank 2</li>
// <li> When tank 3 is empty, valve 3 is closed</liI>
// </ol>
// <p>
// The above \"normal\" process can be influenced by three
// buttons:
// </p>
// <ul>
// <li> Button <b>start</b> starts the above process.
//      When this button is pressed after a \"stop\" or
//      \"shut\" operation, the process operation continues.
//      </li>.
// <li> Button <b>stop</b> stops the above process by
//      closing all valves. Then, the controller waits for
//      further input (either \"start\" or \"shut\" operation).</li>
// <li> Button <b>shut</b> is used to shutdown the process,
//      by emptying at once both tanks. When this is achieved,
//      the process goes back to its start configuration.
//      Clicking on \"start\", restarts the process.</li>
// </ul>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.TankController)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 68}, {-32, 54}}, "start", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 6}, {-32, -8}}, "stop", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, -54}, {-32, -68}}, "shut", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, -82}, {-18, -96}}, "level1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{24, -84}, {96, -98}}, "level2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{31, 68}, {99, 54}}, "valve1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{33, 9}, {101, -5}}, "valve2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{34, -53}, {102, -67}}, "valve3", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.TankController)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.TankController)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct)
// {-150.0,-150.0,150.0,150.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.MakeProduct)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, {{-100, -100}, {0, 100}, {100, -100}, {-100, -100}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.inflow1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, {{-100, -100}, {0, 100}, {100, -100}, {-100, -100}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.inflow2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, {{-100, 100}, {0, -100}, {100, 100}, {-100, 100}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.outflow1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, {{-100, 100}, {0, -100}, {100, 100}, {-100, 100}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.outflow2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.valve)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{20, 20}, {20, 20}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-131, 125}, {136, 67}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 0}, {0, -60}}, {255, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.valve)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{0, -60}, {0, 0}}, {255, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.valve)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.Tank)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-122, -82}, {88, -42}}, "%name", 0, TextAlignment.Center), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, BorderPattern.None, {{-60, 60}, {80, -40}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {191, 0, 95}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.5, BorderPattern.None, {{-60, -40}, {-60, -40}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.Tank)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.Tank)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.Source)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.5, BorderPattern.None, {{-80, 40}, {80, -40}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-144, 54}, {152, 114}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.Source)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.Source)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep)
// {-150.0,-150.0,150.0,150.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1)
// {-150.0,-150.0,150.0,150.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2)
// {-150.0,-150.0,150.0,150.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Examples.Utilities.CompositeStep2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_in)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepStatePort_out)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.PartialStep)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialStep)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialStep)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.PartialTransition)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialTransition)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialTransition)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{160, 110}, {-160, 150}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.PartialStateGraphIcon)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Interfaces.CompositeStepState)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.StateGraphRoot)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, 110}, {200, 150}}, "%name", 0, TextAlignment.Center), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-92, 78}, {96, 34}}, "root", 0, TextAlignment.Center), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-82, -6}, {-44, -40}}, 0), Line(true, {0.0, 0.0}, 0, {{0, 10}, {0, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{48, -6}, {86, -40}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-12, -16}, {0, -22}, {-12, -28}, {-12, -16}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-44, -22}, {-12, -22}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{36, -16}, {48, -22}, {36, -28}, {36, -16}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, -22}, {36, -22}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.StateGraphRoot)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.StateGraphRoot)
// {"<html>
// <p>
// On the highest level of a StateGraph, an instance of StateGraphRoot
// has to be present. If it is not within in a model, it is automatically
// included by a Modelica translator due to an appropriate annotation.
// Practically, this means that it need not be present in a
// StateGraph model.
// </p>
// <p>
// The StateGraphRoot object is needed, since all Step objects have
// an \"outer\" reference to communicate with the \"nearest\" CompositeStep
// (which inherits from PartialCompositeStep), especially to abort
// a CompositeStep via the \"suspend\" port. Even if no \"CompositeStep\" is present,
// on highest level a corresponding \"inner\" definition is needed
// and is provided by the StateGraphRoot object.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.SetRealParameter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {245, 245, 245}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.Raised, {{-100, 40}, {100, -40}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 90}, {150, 50}}, "%name =", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, 15}, {96, -15}}, "%value", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.SetRealParameter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.SetRealParameter)
// {"<html>
// <p>
// This is an <b>experimental component</b> to define a
// <b>Real parameter</b>
// in the <b>diagram layer</b>. The idea is to drag the icon from the
// package browser into the diagram layer. Then a window pops
// up in which the properties of this parameter can be defined
// (such as the default value). The name and default value of the
// parameter are displayed in the icon of this component. Whenever
// clicking on it, the dialog to change parameter settings pops-up.
// </p>
// <p>
// In Dymola, the described property is not fully available.
// Currently, when dragging this component in the diagram layer,
// a dialog pops up in which the properties of the parameter
// can be defined. However, afterwards, the parameter is not
// visible in the diagram layer. Making it visible requires to
// go into the text layer and add an annotation with the
// component size, resulting for example in:
// </p>
// <pre>
//   <b>parameter</b> StateGraph.SetRealParameter name = 2
//                        <b>annotation</b>(extent=[-10,-10; 10,10]);
// </pre>
// <p>
// This change makes the parameter icon visible in the
// diagram layer. However, clicking on this icon has no
// effect. Changing parameter properties, such as the default
// value, still requires to go in to the text layer.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.anyTrue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.anyTrue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.anyTrue)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.allTrue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.allTrue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.allTrue)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.RadioButton)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {128, 128, 128}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.5, BorderPattern.None, {{-100, -100}, {100, 100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-80, -40}, {80, 40}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.RadioButton)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.RadioButton)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.NumericValue)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {236, 233, 216}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.Raised, {{100, 50}, {-100, -50}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-90, -46}, {90, 34}}, " ", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.NumericValue)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.NumericValue)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {235, 235, 235}, LinePattern.None, FillPattern.Sphere, 0.25, {{-100, -100}, {100, 100}}, 0, 360), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 110}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.StateGraph.Temporary.IndicatorLamp)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.UsersGuide.HowToUseSIunits)
// {"<html>
// <p>
// When implementing a Modelica model, every variable needs to
// be declared. Physical variables should be declared with a unit.
// The basic approach in Modelica is that the unit attribute of
// a variable is the <b>unit</b> in which the <b>equations</b> are <b>written</b>,
// for example:
// </p>
//
// <pre>   <b>model</b> MassOnGround
//      <b>parameter</b> Real m(quantity=\"Mass\", unit=\"kg\") \"Mass\";
//      <b>parameter</b> Real f(quantity=\"Force\", unit=\"N\") \"Driving force\";
//      Real s(unit=\"m\") \"Position of mass\";
//      Real v(unit=\"m/s\") \"Velocity of mass\";
//    <b>equation</b>
//      <b>der</b>(s) = v;
//      m*<b>der</b>(v) = f;
//    <b>end</b> MassOnGround;
// </pre>
//
// <p>
// This means that the equations in the equation section are only correct
// for the specified units. A different issue is the user interface, i.e.,
// in which unit the variable is presented to the user in graphical
// user interfaces, both for input (e.g., parameter menu), as well as
// for output (e.g., in the plot window). Preferably, the Modelica tool
// should provide a list of units from which the user can select, e.g.,
// \"m\", \"cm\", \"km\", \"inch\" for quantity \"Length\". When storing the value in
// the model as a Modelica modifier, it has to be converted to the unit defined
// in the declaration. Additionally, the unit used in the graphical
// user interface has to be stored. In order to have a standardized way
// of doing this, Modelica provides the following three attributs
// for a variable of type Real:
// </p>
//
// <ul>
// <li><b>quantity</b> to define the physical quantity (e.g. \"Length\", or \"Energy\").</li>
// <li><b>unit</b> to define the unit that has to be used
//     in order that the equations are correct (e.g. \"N.m\").</li>
// <li><b>displayUnit</b> to define the unit used in the graphical
//     user interface as default display unit for input and/or output.</li>
// </ul>
//
// <p>
// Note, a unit, such as \"N.m\", is not sufficient to define uniquely the
// physical quantity, since, e.g., \"N.m\" might be either \"torque\" or
// \"energy\". The \"quantity\" attribute might therefore be used by a tool
// to select the corresponding menu from which the user can select
// a unit for the corresponding variable.
// </p>
//
// <p>
// For example, after providing a value for \"m\" and \"f\" in a parameter
// menu of an instance of MassOnGround, a tool might generate the following code:
// </p>
//
// <pre>
//    MassOnGround myObject(m(displayUnit=\"g\")=2, f=3);
// </pre>
//
// <p>
// The meaning is that in the equations a value of \"2\" is used
// and that in the graphical user interface a value of \"2000\" should be used,
// together with the unit \"g\" from the unit set \"Mass\" (= the quantity name).
// Note, according to the Modelica specification
// a tool might ignore the \"displayUnit\" attribute.
// </p>
//
// <p>
// In order to help the Modelica model developer, the Modelica.SIunits
// library provides about 450 predefined type names,
// together with values for the attributes <b>quantity</b>, <b>unit</b> and sometimes
// <b>displayUnit</b> and <b>min</b>. The unit is always selected as SI-unit according to the
// ISO standard. The type and the quantity names are the
// quantity names used in the ISO standard. \"quantity\" and \"unit\" are defined
// as \"<b>final</b>\" in order that they cannot be modified. Attributes \"displayUnit\"
// and \"min\" can, however, be changed in a model via a modification. The example above,
// might therefore be alternatively also defined as:
// </p>
//
// <pre>   <b>model</b> MassOnGround
//      <b>parameter</b> Modelica.SIunits.Mass  m \"Mass\";
//      <b>parameter</b> Modelica.SIunits.Force f \"Driving force\";
//      ...
//    <b>end</b> MassOnGround;
// </pre>
//
// <p>
// or in a short hand notation as
// </p>
//
// <pre>
//    <b>model</b> MassOnGround
//      <b>import</b> SI = Modelica.SIunits;
//      <b>parameter</b> SI.Mass  m \"Mass\";
//      <b>parameter</b> SI.Force f \"Driving force\";
//      ...
//    <b>end</b> MassOnGround;
// </pre>
//
// <p>
// For some often
// used Non SI-units (like hour), some additional type definitions are
// present as Modelica.SIunits.Conversions.NonSIunits. If this is not sufficient,
// the user has to define its own types or use the attributes directly
// in the declaration as in the example at the beginning.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.UsersGuide.Conventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.UsersGuide.Conventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Conventions)
// {"<html>
// <p>The following conventions are used in package SIunits:</p>
// <ul>
// <li>Modelica quantity names are defined according to the recommendations
//     of ISO 31. Some of these name are rather long, such as
//     \"ThermodynamicTemperature\". Shorter alias names are defined, e.g.,
//     \"type Temp_K = ThermodynamicTemperature;\".</li>
// <li>Modelica units are defined according to the SI base units without
//     multiples (only exception \"kg\").</li>
// <li>For some quantities, more convenient units for an engineer are
//     defined as \"displayUnit\", i.e., the default unit for display
//     purposes (e.g., displayUnit=\"deg\" for quantity=\"Angle\").</li>
// <li>The type name is identical to the quantity name, following
//     the convention of type names.</li>
// <li>All quantity and unit attributes are defined as final in order
//     that they cannot be redefined to another value.</li>
// <li>Similiar quantities, such as \"Length, Breadth, Height, Thickness,
//     Radius\" are defined as the same quantity (here: \"Length\").</li>
// <li>The ordering of the type declarations in this package follows ISO 31:
// <pre>
//   Chapter  1: <b>Space and Time</b>
//   Chapter  2: <b>Periodic and Related Phenomena</b>
//   Chapter  3: <b>Mechanics</b>
//   Chapter  4: <b>Heat</b>
//   Chapter  5: <b>Electricity and Magnetism</b>
//   Chapter  6: <b>Light and Related Electro-Magnetic Radiations</b>
//   Chapter  7: <b>Acoustics</b>
//   Chapter  8: <b>Physical Chemistry</b>
//   Chapter  9: <b>Atomic and Nuclear Physics</b>
//   Chapter 10: <b>Nuclear Reactions and Ionizing Radiations</b>
//   Chapter 11: (not defined in ISO 31-1992)
//   Chapter 12: <b>Characteristic Numbers</b>
//   Chapter 13: <b>Solid State Physics</b>
// </pre>
// </li>
// <li>Conversion functions between SI and non-SI units are available in subpackage
//     <b>Conversions</b>.</li>
// </ul>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Literature)
// {"<html>
// <p> This package is based on the following references
// </p>
//
// <dl>
// <dt>ISO 31-1992:</dt>
// <dd> <b>General principles concerning
//     quantities, units and symbols</b>.<br>&nbsp;</dd>
//
// <dt>ISO 1000-1992:</dt>
// <dd> <b>SI units and recommendations for the use
//     of their multiples and of certain other units</b>.<br>&nbsp;</dd>
//
// <dt>Cardarelli F.:</dt>
// <dd> <b>Scientific Unit Conversion - A Practical
//      Guide to Metrication</b>. Springer 1997.</dd>
// </dl>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.UsersGuide.Contact)
// {"<html>
// <dl>
// <dt><b>Main Author:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
//
//
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> Astrid Jaschinski, Hubertus Tummescheit and Christian Schweiger
//      contributed to the implementation of this package.</li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degC)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degF)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Temperature_degRk)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Angle_deg)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm)
// {"<html>
// <p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Velocity_kmh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_day)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_hour)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Time_minute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Volume_litre)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Energy_kWh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.Pressure_bar)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.NonSIunits.MassFlowRate_gps)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_degC)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "K", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "C", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degC)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_degC)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "C", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "K", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degC)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_degF)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "K", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "F", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degF)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_degF)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "F", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "K", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degF)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_degRk)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "K", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "Rk", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_degRk)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_degRk)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "Rk", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "K", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_degRk)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_deg)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "rad", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "deg", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_deg)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_deg)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "deg", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "rad", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_deg)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_rpm)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "rad/s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "1/min", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_rpm)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_rpm)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "1/min", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "rad/s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_rpm)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_kmh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "m/s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "km/h", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_kmh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_kmh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "km/h", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "m/s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_kmh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_day)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "day", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_day)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_day)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "day", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_day)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_hour)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "hour", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_hour)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_hour)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "hour", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_hour)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_minute)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "minute", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_minute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_minute)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "minute", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_minute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_litre)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "m3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "litre", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_litre)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_litre)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "litre", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "m3", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_litre)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_kWh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "J", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "kWh", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_kWh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_kWh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "kWh", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "J", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_kWh)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_bar)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "Pa", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "bar", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_bar)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_bar)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "bar", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "Pa", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_bar)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_gps)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "kg/s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "g/s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_gps)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_gps)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "g/s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "kg/s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_gps)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.ConversionIcon)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {191, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {30, 0}}, {191, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {191, 0, 0}, {191, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {30, 20}, {30, -20}, {90, 0}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-115, 155}, {115, 105}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.ConversionIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.ConversionIcon)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.from_Hz)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "Hz", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "1/s", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.from_Hz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.from_Hz)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conversions.to_Hz)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, 100}, {-100, 20}}, "1/s", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{100, -20}, {20, -100}}, "Hz", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conversions.to_Hz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conversions.to_Hz)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Angle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Angle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Angle)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SolidAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SolidAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SolidAngle)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Length)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PathLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PathLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PathLength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Position)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Position)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Position)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Distance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Distance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Distance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Breadth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Breadth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Breadth)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Height)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Height)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Height)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Thickness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Thickness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Thickness)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Radius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Radius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Radius)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Diameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Diameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Diameter)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Area)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Area)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Area)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Volume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Volume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Volume)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Time)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Time)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Time)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Duration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Duration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Duration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularVelocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularVelocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularVelocity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularAcceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularAcceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularAcceleration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Velocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Velocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Velocity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Acceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Acceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Acceleration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Period)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Period)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Period)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Frequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Frequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Frequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularFrequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Wavelength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Wavelength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Wavelength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Wavelenght)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Wavelenght)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Wavelenght)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.WaveNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.WaveNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.WaveNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CircularWaveNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CircularWaveNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CircularWaveNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AmplitudeLevelDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AmplitudeLevelDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AmplitudeLevelDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PowerLevelDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PowerLevelDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PowerLevelDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DampingCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DampingCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DampingCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LogarithmicDecrement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LogarithmicDecrement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LogarithmicDecrement)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AttenuationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PhaseCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PhaseCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PhaseCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PropagationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PropagationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PropagationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Damping)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Damping)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Damping)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Mass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Mass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Mass)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Density)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Density)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Density)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativeDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativeDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativeDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificVolume)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SurfaceDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SurfaceDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SurfaceDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Momentum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Momentum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Momentum)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Impulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Impulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Impulse)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularMomentum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularMomentum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularMomentum)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularImpulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularImpulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularImpulse)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MomentOfInertia)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MomentOfInertia)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MomentOfInertia)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Inertia)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Inertia)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Inertia)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Force)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Force)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Force)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TranslationalSpringConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TranslationalSpringConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TranslationalSpringConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TranslationalDampingConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TranslationalDampingConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TranslationalDampingConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Weight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Weight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Weight)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Torque)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Torque)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Torque)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricalTorqueConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricalTorqueConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricalTorqueConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MomentOfForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MomentOfForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MomentOfForce)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RotationalSpringConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RotationalSpringConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RotationalSpringConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RotationalDampingConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RotationalDampingConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RotationalDampingConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Pressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Pressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Pressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AbsolutePressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AbsolutePressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AbsolutePressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BulkModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BulkModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BulkModulus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Stress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Stress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Stress)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NormalStress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NormalStress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NormalStress)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ShearStress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ShearStress)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ShearStress)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Strain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Strain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Strain)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearStrain)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ShearStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ShearStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ShearStrain)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VolumeStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VolumeStrain)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VolumeStrain)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PoissonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PoissonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PoissonNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ModulusOfElasticity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ModulusOfElasticity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ModulusOfElasticity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ShearModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ShearModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ShearModulus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SecondMomentOfArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SecondMomentOfArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SecondMomentOfArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SecondPolarMomentOfArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SecondPolarMomentOfArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SecondPolarMomentOfArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SectionModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SectionModulus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SectionModulus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CoefficientOfFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CoefficientOfFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CoefficientOfFriction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DynamicViscosity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DynamicViscosity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DynamicViscosity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.KinematicViscosity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.KinematicViscosity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.KinematicViscosity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SurfaceTension)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SurfaceTension)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SurfaceTension)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Work)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Work)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Work)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Energy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Energy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Energy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnergyDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PotentialEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PotentialEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PotentialEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.KineticEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.KineticEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.KineticEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Power)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Power)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Power)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnergyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnergyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnergyFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnthalpyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnthalpyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnthalpyFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Efficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Efficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Efficiency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VolumeFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VolumeFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VolumeFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MomentumFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MomentumFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MomentumFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularMomentumFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularMomentumFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularMomentumFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermodynamicTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermodynamicTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermodynamicTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Temp_K)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Temp_K)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Temp_K)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Temperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Temperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Temperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TemperatureDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TemperatureDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TemperatureDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Temp_C)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Temp_C)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Temp_C)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TemperatureSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TemperatureSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TemperatureSlope)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearTemperatureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearTemperatureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearTemperatureCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.QuadraticTemperatureCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearExpansionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearExpansionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearExpansionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CubicExpansionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CubicExpansionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CubicExpansionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativePressureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativePressureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativePressureCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PressureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PressureCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PressureCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Compressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Compressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Compressibility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IsothermalCompressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IsothermalCompressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IsothermalCompressibility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IsentropicCompressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IsentropicCompressibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IsentropicCompressibility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Heat)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Heat)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Heat)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HeatFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HeatFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HeatFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HeatFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HeatFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HeatFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DensityOfHeatFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DensityOfHeatFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DensityOfHeatFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalConductivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CoefficientOfHeatTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SurfaceCoefficientOfHeatTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalInsulance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalInsulance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalInsulance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalResistance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalResistance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalResistance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalConductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalConductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalConductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalDiffusivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalDiffusivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HeatCapacity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificHeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtConstantVolume)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificHeatCapacityAtSaturation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RatioOfSpecificHeatCapacities)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IsentropicExponent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IsentropicExponent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IsentropicExponent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Entropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Entropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Entropy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EntropyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EntropyFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EntropyFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificEntropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificEntropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificEntropy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.InternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.InternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.InternalEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Enthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Enthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Enthalpy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HelmholtzFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HelmholtzFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HelmholtzFreeEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GibbsFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GibbsFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GibbsFreeEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificInternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificInternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificInternalEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificEnthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificEnthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificEnthalpy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificHelmholtzFreeEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificGibbsFreeEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassieuFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassieuFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassieuFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PlanckFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PlanckFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PlanckFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerDensityByEnthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerDensityByEnthalpy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerDensityByEnthalpy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerDensityByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerDensityByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerDensityByPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerDensityByTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerDensityByTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerDensityByTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerEnthalpyByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerEnthalpyByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerEnthalpyByPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerEnergyByDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerEnergyByDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerEnergyByDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DerEnergyByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DerEnergyByPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DerEnergyByPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricCurrent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricCurrent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricCurrent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Current)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Current)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Current)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CurrentSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CurrentSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CurrentSlope)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricCharge)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Charge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Charge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Charge)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VolumeDensityOfCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VolumeDensityOfCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VolumeDensityOfCharge)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SurfaceDensityOfCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SurfaceDensityOfCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SurfaceDensityOfCharge)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricFieldStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricFieldStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricFieldStrength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricPotential)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Voltage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Voltage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Voltage)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PotentialDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PotentialDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PotentialDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectromotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectromotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectromotiveForce)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VoltageSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VoltageSlope)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VoltageSlope)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricFluxDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricFluxDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricFluxDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Capacitance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Capacitance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Capacitance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Permittivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Permittivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Permittivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PermittivityOfVacuum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PermittivityOfVacuum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PermittivityOfVacuum)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativePermittivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativePermittivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativePermittivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricSusceptibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricSusceptibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricSusceptibility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricPolarization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricPolarization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricPolarization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Electrization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Electrization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Electrization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricDipoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricDipoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricDipoleMoment)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CurrentDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CurrentDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CurrentDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearCurrentDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearCurrentDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearCurrentDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticFieldStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticFieldStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticFieldStrength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticPotential)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticPotentialDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticPotentialDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticPotentialDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagnetomotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagnetomotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagnetomotiveForce)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CurrentLinkage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CurrentLinkage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CurrentLinkage)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticFluxDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticFluxDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticFluxDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticVectorPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticVectorPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticVectorPotential)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Inductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Inductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Inductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SelfInductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SelfInductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SelfInductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MutualInductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MutualInductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MutualInductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CouplingCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CouplingCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CouplingCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LeakageCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LeakageCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LeakageCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Permeability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Permeability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Permeability)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PermeabilityOfVacuum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PermeabilityOfVacuum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PermeabilityOfVacuum)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativePermeability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativePermeability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativePermeability)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticSusceptibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticSusceptibility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticSusceptibility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectromagneticMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectromagneticMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectromagneticMoment)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticDipoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticDipoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticDipoleMoment)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Magnetization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Magnetization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Magnetization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticPolarization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticPolarization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticPolarization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectromagneticEnergyDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PoyntingVector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PoyntingVector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PoyntingVector)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Resistance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Resistance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Resistance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Resistivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Resistivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Resistivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conductivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Reluctance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Reluctance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Reluctance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Permeance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Permeance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Permeance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PhaseDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PhaseDifference)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PhaseDifference)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Impedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Impedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Impedance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ModulusOfImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ModulusOfImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ModulusOfImpedance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Reactance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Reactance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Reactance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.QualityFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.QualityFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.QualityFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LossAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LossAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LossAngle)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Conductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Conductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Conductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Admittance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Admittance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Admittance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ModulusOfAdmittance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ModulusOfAdmittance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ModulusOfAdmittance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Susceptance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Susceptance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Susceptance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.InstantaneousPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.InstantaneousPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.InstantaneousPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ActivePower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ActivePower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ActivePower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ApparentPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ApparentPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ApparentPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReactivePower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReactivePower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReactivePower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PowerFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PowerFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PowerFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Transconductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Transconductance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Transconductance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.InversePotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.InversePotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.InversePotential)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricalForceConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricalForceConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricalForceConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantEnergyDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralRadiantEnergyDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantEnergyFluenceRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantIntensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Radiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Radiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Radiance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RadiantExtiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RadiantExtiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RadiantExtiance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Irradiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Irradiance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Irradiance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Emissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Emissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Emissivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralEmissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralEmissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralEmissivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DirectionalSpectralEmissivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LuminousIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LuminousIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LuminousIntensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LuminousFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LuminousFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LuminousFlux)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.QuantityOfLight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.QuantityOfLight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.QuantityOfLight)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Luminance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Luminance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Luminance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LuminousExitance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LuminousExitance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LuminousExitance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Illuminance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Illuminance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Illuminance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LightExposure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LightExposure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LightExposure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LuminousEfficacy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LuminousEfficacy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LuminousEfficacy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralLuminousEfficacy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralLuminousEfficacy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralLuminousEfficacy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LuminousEfficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LuminousEfficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LuminousEfficiency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralLuminousEfficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralLuminousEfficiency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralLuminousEfficiency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CIESpectralTristimulusValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CIESpectralTristimulusValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CIESpectralTristimulusValues)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ChromaticityCoordinates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ChromaticityCoordinates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ChromaticityCoordinates)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralAbsorptionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralAbsorptionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralAbsorptionFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralReflectionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralReflectionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralReflectionFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralTransmissionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralTransmissionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralTransmissionFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralRadianceFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralRadianceFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralRadianceFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearAttenuationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearAbsorptionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarAbsorptionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RefractiveIndex)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RefractiveIndex)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RefractiveIndex)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StaticPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StaticPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StaticPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundParticleDisplacement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundParticleDisplacement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundParticleDisplacement)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundParticleVelocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundParticleVelocity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundParticleVelocity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundParticleAcceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundParticleAcceleration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundParticleAcceleration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VelocityOfSound)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VelocityOfSound)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VelocityOfSound)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundEnergyDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundEnergyDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundIntensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundIntensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AcousticImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AcousticImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AcousticImpedance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificAcousticImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificAcousticImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificAcousticImpedance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MechanicalImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MechanicalImpedance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MechanicalImpedance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundPressureLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundPressureLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundPressureLevel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundPowerLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundPowerLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundPowerLevel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DissipationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DissipationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DissipationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReflectionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReflectionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReflectionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TransmissionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TransmissionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TransmissionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AcousticAbsorptionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SoundReductionIndex)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SoundReductionIndex)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SoundReductionIndex)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EquivalentAbsorptionArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EquivalentAbsorptionArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EquivalentAbsorptionArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReverberationTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReverberationTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReverberationTime)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LoundnessLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LoundnessLevel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LoundnessLevel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Loundness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Loundness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Loundness)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativeAtomicMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativeAtomicMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativeAtomicMass)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativeMolecularMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativeMolecularMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativeMolecularMass)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NumberOfMolecules)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NumberOfMolecules)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NumberOfMolecules)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AmountOfSubstance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AmountOfSubstance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AmountOfSubstance)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarMass)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarVolume)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarVolume)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarInternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarInternalEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarInternalEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarHeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarHeatCapacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarHeatCapacity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarEntropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarEntropy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarEntropy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarFlowRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarFlowRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NumberDensityOfMolecules)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NumberDensityOfMolecules)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NumberDensityOfMolecules)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolecularConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolecularConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolecularConcentration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassConcentration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassFraction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Concentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Concentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Concentration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.VolumeFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.VolumeFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.VolumeFraction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MoleFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MoleFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MoleFraction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ChemicalPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ChemicalPotential)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ChemicalPotential)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AbsoluteActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AbsoluteActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AbsoluteActivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PartialPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PartialPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PartialPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Fugacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Fugacity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Fugacity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ActivityCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ActivityCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ActivityCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ActivityOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ActivityOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ActivityOfSolute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ActivityCoefficientOfSolute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolute)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ActivityOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ActivityOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ActivityOfSolvent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.OsmoticCoefficientOfSolvent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StandardAbsoluteActivityOfSolvent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.OsmoticPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.OsmoticPressure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.OsmoticPressure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StoichiometricNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StoichiometricNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StoichiometricNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Affinity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Affinity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Affinity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassOfMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassOfMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassOfMolecule)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricDipoleMomentOfMolecule)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectricPolarizabilityOfAMolecule)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MicrocanonicalPartitionFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CanonicalPartitionFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GrandCanonicalPartitionFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolecularPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolecularPartitionFunction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolecularPartitionFunction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StatisticalWeight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StatisticalWeight)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StatisticalWeight)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MeanFreePath)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MeanFreePath)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MeanFreePath)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DiffusionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DiffusionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DiffusionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalDiffusionRatio)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionRatio)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionRatio)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalDiffusionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalDiffusionCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElementaryCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElementaryCharge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElementaryCharge)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ChargeNumberOfIon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ChargeNumberOfIon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ChargeNumberOfIon)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FaradayConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FaradayConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FaradayConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IonicStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IonicStrength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IonicStrength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DegreeOfDissociation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DegreeOfDissociation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DegreeOfDissociation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectrolyticConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectrolyticConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectrolyticConductivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarConductivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarConductivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TransportNumberOfIonic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TransportNumberOfIonic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TransportNumberOfIonic)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ProtonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ProtonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ProtonNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NucleonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NucleonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NucleonNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AtomicMassConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AtomicMassConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AtomicMassConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassOfElectron)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassOfElectron)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassOfElectron)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassOfProton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassOfProton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassOfProton)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassOfNeutron)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassOfNeutron)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassOfNeutron)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HartreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HartreeEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HartreeEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticMomentOfParticle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticMomentOfParticle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticMomentOfParticle)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BohrMagneton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BohrMagneton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BohrMagneton)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NuclearMagneton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NuclearMagneton)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NuclearMagneton)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GyromagneticCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GyromagneticCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GyromagneticCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GFactorOfAtom)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GFactorOfAtom)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GFactorOfAtom)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GFactorOfNucleus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GFactorOfNucleus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GFactorOfNucleus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LarmorAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LarmorAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LarmorAngularFrequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NuclearPrecessionAngularFrequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CyclotronAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CyclotronAngularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CyclotronAngularFrequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NuclearQuadrupoleMoment)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NuclearRadius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NuclearRadius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NuclearRadius)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectronRadius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectronRadius)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectronRadius)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ComptonWavelength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ComptonWavelength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ComptonWavelength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassExcess)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassExcess)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassExcess)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassDefect)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassDefect)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassDefect)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativeMassExcess)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativeMassExcess)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativeMassExcess)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelativeMassDefect)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelativeMassDefect)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelativeMassDefect)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PackingFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PackingFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PackingFraction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BindingFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BindingFraction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BindingFraction)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MeanLife)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MeanLife)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MeanLife)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LevelWidth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LevelWidth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LevelWidth)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Activity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Activity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Activity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificActivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificActivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DecayConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DecayConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DecayConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HalfLife)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HalfLife)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HalfLife)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AlphaDisintegrationEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MaximumBetaParticleEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BetaDisintegrationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BetaDisintegrationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BetaDisintegrationEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReactionEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReactionEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReactionEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ResonanceEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ResonanceEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ResonanceEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AngularCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AngularCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AngularCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralAngularCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralAngularCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralAngularCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MacroscopicCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MacroscopicCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MacroscopicCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalMacroscopicCrossSection)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ParticleFluence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ParticleFluence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ParticleFluence)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ParticleFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ParticleFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ParticleFluenceRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnergyFluence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnergyFluence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnergyFluence)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnergyFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnergyFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnergyFluenceRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CurrentDensityOfParticles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CurrentDensityOfParticles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CurrentDensityOfParticles)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassAttenuationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MolarAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MolarAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MolarAttenuationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AtomicAttenuationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HalfThickness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HalfThickness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HalfThickness)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalLinearStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalLinearStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalLinearStoppingPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalAtomicStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalAtomicStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalAtomicStoppingPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalMassStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalMassStoppingPower)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalMassStoppingPower)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MeanLinearRange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MeanLinearRange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MeanLinearRange)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MeanMassRange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MeanMassRange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MeanMassRange)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearIonization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearIonization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearIonization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalIonization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalIonization)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalIonization)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Mobility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Mobility)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Mobility)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IonNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IonNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IonNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RecombinationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RecombinationCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RecombinationCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronSpeed)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronSpeed)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronSpeed)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronFluenceRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronFluenceRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.TotalNeutronSourceDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.TotalNeutronSourceDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.TotalNeutronSourceDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SlowingDownDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SlowingDownDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SlowingDownDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ResonanceEscapeProbability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ResonanceEscapeProbability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ResonanceEscapeProbability)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Lethargy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Lethargy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Lethargy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SlowingDownArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SlowingDownArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SlowingDownArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DiffusionArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DiffusionArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DiffusionArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MigrationArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MigrationArea)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MigrationArea)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SlowingDownLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SlowingDownLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SlowingDownLength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DiffusionLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DiffusionLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DiffusionLength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MigrationLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MigrationLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MigrationLength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronYieldPerFission)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronYieldPerFission)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronYieldPerFission)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeutronYieldPerAbsorption)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FastFissionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FastFissionFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FastFissionFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermalUtilizationFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermalUtilizationFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermalUtilizationFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NonLeakageProbability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NonLeakageProbability)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NonLeakageProbability)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Reactivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Reactivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Reactivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReactorTimeConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReactorTimeConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReactorTimeConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EnergyImparted)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MeanEnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MeanEnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MeanEnergyImparted)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpecificEnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpecificEnergyImparted)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpecificEnergyImparted)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AbsorbedDose)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AbsorbedDose)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AbsorbedDose)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DoseEquivalent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DoseEquivalent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DoseEquivalent)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AbsorbedDoseRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AbsorbedDoseRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AbsorbedDoseRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LinearEnergyTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LinearEnergyTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LinearEnergyTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Kerma)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Kerma)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Kerma)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.KermaRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.KermaRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.KermaRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MassEnergyTransferCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.Exposure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.Exposure)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.Exposure)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ExposureRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ExposureRate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ExposureRate)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ReynoldsNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ReynoldsNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ReynoldsNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EulerNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EulerNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EulerNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FroudeNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FroudeNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FroudeNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GrashofNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GrashofNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GrashofNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.WeberNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.WeberNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.WeberNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MachNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MachNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MachNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.KnudsenNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.KnudsenNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.KnudsenNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StrouhalNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StrouhalNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StrouhalNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FourierNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FourierNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FourierNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PecletNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PecletNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PecletNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RayleighNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RayleighNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RayleighNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NusseltNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NusseltNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NusseltNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BiotNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BiotNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BiotNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StantonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StantonNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StantonNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FourierNumberOfMassTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PecletNumberOfMassTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GrashofNumberOfMassTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NusseltNumberOfMassTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.StantonNumberOfMassTransfer)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PrandtlNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PrandtlNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PrandtlNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SchmidtNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SchmidtNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SchmidtNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LewisNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LewisNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LewisNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MagneticReynoldsNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MagneticReynoldsNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MagneticReynoldsNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AlfvenNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AlfvenNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AlfvenNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HartmannNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HartmannNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HartmannNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CowlingNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CowlingNumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CowlingNumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.BraggAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.BraggAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.BraggAngle)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.OrderOfReflexion)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.OrderOfReflexion)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.OrderOfReflexion)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ShortRangeOrderParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ShortRangeOrderParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ShortRangeOrderParameter)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LongRangeOrderParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LongRangeOrderParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LongRangeOrderParameter)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DebyeWallerFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DebyeWallerFactor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DebyeWallerFactor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CircularWavenumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FermiCircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FermiCircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FermiCircularWavenumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DebyeCircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DebyeCircularWavenumber)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DebyeCircularWavenumber)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DebyeCircularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DebyeCircularFrequency)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DebyeCircularFrequency)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DebyeTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DebyeTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DebyeTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SpectralConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SpectralConcentration)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SpectralConcentration)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GrueneisenParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GrueneisenParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GrueneisenParameter)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MadelungConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MadelungConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MadelungConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DensityOfStates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DensityOfStates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DensityOfStates)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ResidualResistivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ResidualResistivity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ResidualResistivity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LorenzCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LorenzCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LorenzCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HallCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HallCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HallCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThermoelectromotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThermoelectromotiveForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThermoelectromotiveForce)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.SeebeckCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.SeebeckCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.SeebeckCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.PeltierCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.PeltierCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.PeltierCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ThomsonCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ThomsonCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ThomsonCoefficient)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RichardsonConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RichardsonConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RichardsonConstant)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FermiEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FermiEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FermiEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.GapEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.GapEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.GapEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DonorIonizationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DonorIonizationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DonorIonizationEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AcceptorIonizationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AcceptorIonizationEnergy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AcceptorIonizationEnergy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FermiTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FermiTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FermiTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ElectronNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ElectronNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ElectronNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.HoleNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.HoleNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.HoleNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.IntrinsicNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.IntrinsicNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.IntrinsicNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.DonorNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.DonorNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.DonorNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.AcceptorNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.AcceptorNumberDensity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.AcceptorNumberDensity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.EffectiveMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.EffectiveMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.EffectiveMass)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.MobilityRatio)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.MobilityRatio)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.MobilityRatio)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.RelaxationTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.RelaxationTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.RelaxationTime)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CarrierLifeTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CarrierLifeTime)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CarrierLifeTime)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.ExchangeIntegral)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.ExchangeIntegral)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.ExchangeIntegral)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CurieTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CurieTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CurieTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.NeelTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.NeelTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.NeelTemperature)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LondonPenetrationDepth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LondonPenetrationDepth)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LondonPenetrationDepth)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.CoherenceLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.CoherenceLength)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.CoherenceLength)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.LandauGinzburgParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.LandauGinzburgParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.LandauGinzburgParameter)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.SIunits.FluxiodQuantum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.SIunits.FluxiodQuantum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.SIunits.FluxiodQuantum)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.Example)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, -100}, {80, 50}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 50}, {-80, 70}, {100, 70}, {80, 50}, {-100, 50}}, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 70}, {100, -80}, {80, -100}, {80, 50}, {100, 70}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, 3}, {77, -49}}, "Example", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-120, 132}, {120, 73}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.Example)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.Example)
// {"<html>
// <p>
// This icon is designed for an <b>Example package</b>,
// i.e. a package containing executable demo models.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.Function)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-140, 162}, {136, 102}}, "%name", 0, TextAlignment.Center), Ellipse(true, {0.0, 0.0}, 0, {255, 127, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {100, -100}}, 0, 360), Text(true, {0.0, 0.0}, 0, {255, 127, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 100}, {100, -100}}, "f", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.Function)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.Function)
// {"<html>
// <p>
// This icon is designed for a <b>function</b>
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.Record)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 127}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 50}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-127, 115}, {127, 55}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, -50}, {100, -50}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-100, 0}, {100, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 50}, {0, -100}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.Record)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.Record)
// {"<html>
// <p>
// This icon is designed for a <b>record</b>
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.TypeReal)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {181, 181, 181}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, 94}, {94, -94}}, "R", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.TypeReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.TypeReal)
// {"<html>
// <p>
// This icon is designed for a <b>Real</b> type.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.TypeInteger)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {181, 181, 181}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, 94}, {94, -94}}, "I", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.TypeInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.TypeInteger)
// {"<html>
// <p>
// This icon is designed for an <b>Integer</b> type.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.TypeBoolean)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {181, 181, 181}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, 94}, {94, -94}}, "B", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.TypeBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.TypeBoolean)
// {"<html>
// <p>
// This icon is designed for a <b>Boolean</b> type.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.TypeString)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {181, 181, 181}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, 94}, {94, -94}}, "S", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.TypeString)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.TypeString)
// {"<html>
// <p>
// This icon is designed for a <b>String</b> type.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.TranslationalSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-70, -60}, {70, 20}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{0, -40}, {-10, -16}, {10, -16}, {0, -40}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 0}, {0, -16}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-70, 0}, {0, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-50, -40}, {-50, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-30, -40}, {-30, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-10, -40}, {-10, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{10, -40}, {10, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{30, -40}, {30, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{50, -40}, {50, -60}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.TranslationalSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.TranslationalSensor)
// {"<html>
// <p>
// This icon is designed for a <b>translational sensor</b> model.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.RotationalSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-70, 70}, {70, -70}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, 70}, {0, 40}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{22.9, 32.8}, {40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-22.9, 32.8}, {-40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{37.6, 13.7}, {65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-37.6, 13.7}, {-65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, 0.0}, {9.02, 28.6}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-0.48, 31.6}, {18.0, 26.0}, {18.0, 57.2}, {-0.48, 31.6}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-5, 5}, {5, -5}}, 0, 360)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.RotationalSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.RotationalSensor)
// {"<html>
// <p>
// This icon is designed for a <b>rotational sensor</b> model.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.GearIcon)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-90, 10}, {-60, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {128, 128, 128}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, {{-60, 10}, {-60, 20}, {-40, 40}, {-40, -40}, {-60, -20}, {-60, 10}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-40, 60}, {40, -60}}, 0), Polygon(true, {0.0, 0.0}, 0, {128, 128, 128}, {128, 128, 128}, LinePattern.Solid, FillPattern.Solid, 0.25, {{60, 20}, {40, 40}, {40, -40}, {60, -20}, {60, 20}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{60, 10}, {90, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, -90}, {-50, -90}, {-20, -30}, {20, -30}, {48, -90}, {60, -90}, {60, -100}, {-60, -100}, {-60, -90}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.GearIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.GearIcon)
// {"<html>
// <p>
// This icon is designed for a <b>gearbox</b> model.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.MotorIcon)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 0, 0}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-100, 50}, {30, -50}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, -90}, {-90, -90}, {-60, -20}, {-10, -20}, {20, -90}, {30, -90}, {30, -100}, {-100, -100}, {-100, -90}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{30, 10}, {90, -10}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.MotorIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.MotorIcon)
// {"<html>
// <p>
// This icon is designed for an <b>electrical motor</b> model.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Icons.ObsoleteModel)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Dash, FillPattern.None, 0.5, BorderPattern.None, {{-102, 102}, {102, -102}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Icons.ObsoleteModel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Icons.ObsoleteModel)
// {"<html>
// <p>
// This partial model is intended to provide a <u>default icon
// for an obsolete model</u> that will be removed from the
// corresponding library in a future release.
// <p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.UsersGuide.ImplementationNotes)
// {"<html>
// <p>
// Below the major design decisions of this library are summarized.
// <p>
// <ul>
// <li> <b>C-Function Interface</b><br>
//      This library contains several interfaces to C-functions in order
//      to operate with the environment. As will become clear, it is usally
//      required that a Modelica tool vendor provides an implementation
//      of these C-functions that are suited for his environment.
//      In directory \"Modelica.Utilities\\C-Sources\" a reference implementation
//      is given for Microsoft Windows Systems and for POSIX environments.
//      The files \"ModelicaInternal.c\" and \"ModelicaStrings.c\" can be
//      used as a basis for the integration in the vendors environment.<br>&nbsp;</li>
// <li> <b>Character Encoding</b><br>
//      The representation of characters is different in operating systems.
//      The more modern ones (e.g. Windows-NT) use an early variant of
//      Unicode (16 bit per character)
//      other (e.g. Windows-ME) use 8-bit encoding. Also 32 bit per character
//      and multi-byte representations are in use. This is important, since e.g.,
//      Japanese Modelica users need Unicode representation. The design in this
//      library is done in such a way that a basic set of calls to the operating
//      system hides the actual character representation. This means, that all
//      functions of this package can be used independent from the underlying
//      character representation.<br>
//      The C-interface of the Modelica language provides only an 8-bit
//      character encoding passing mechanism of strings. As a result, the
//      reference implementation in \"Modelica.Utilities\\C-Source\" needs to
//      be adapted to the character representation supported in the
//      Modelica vendor environment.<br>&nbsp;</li>
// <li> <b>Internal String Representation</b><br>
//      The design of this package was made in order that string handling
//      is convenient. This is in contrast to, e.g., the C-language, where
//      string handling is inconvenient, cumbersome and error prone, but on the
//      other hand is in some sense \"efficient\".
//      The standard reference implementation in \"Modelica.Utilities\\C-Source\"
//      is based on the standard C definition of a string, i.e., a pointer to
//      a sequence of characters, ended with a null terminating character.
//      In order that the string handling in this package is convenient,
//      some assumptions have been made, especially, that the access to
//      a substring is efficient (O(1) access instead of O(n) as in standard C).
//      This allows to hide string pointer arithmetic from the user.
//      In such a case, a similiar efficiency as in C can be expected for
//      most high level operations, such as find, sort, replace.
//      The \"efficient character access\" can be reached if, e.g.,
//      the number of characters
//      are stored in a string, and the length of a character is fixed,
//      say 16 or 32 bit (if all Unicode characters shall be represented).
//      A vendor should adapt the reference implementation in this
//      respect.<br>&nbsp;</li>
// <li> <b>String copy = pointer copy</b><br>
//      The Modelica language has no mechanism to change a character
//      of a string. When a string has to be modified, the only way
//      to achieve this is to generate it newly. The advantage is that
//      a Modelica tool can treat a string as a constant entity and
//      can replace (expensive) string copy operations by pointer
//      copy operations. For example, when sorting a set of strings
//      the following type of operations occur:
//      <pre>
//      String s[:], s_temp;
//       ...
//      s_temp := s[i];
//      s[i]   := s[j];
//      s[j]   := s_temp;
//      </pre>
//      Formally, three strings are copied. Due to the feature
//      sketched above, a Modelica tool can replace this
//      copy operation by pointer assignments, a very \"cheap\"
//      operation. The Modelica.Utilities functions will perform
//      efficiently, if such types of optimizations are supported
//      by the tool.</li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.UsersGuide.ReleaseNotes)
// {"<HTML>
// <h4>Version 1.0, 2004-09-29</h4>
// <p>
// First version implemented.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.UsersGuide.Contact)
// {"<html>
// <dl>
// <dt><b>Responsible for Library:</b>
// <dd>Dag Br&uuml;ck, Dynasim AB, Sweden.<br>
//     email: <A HREF=\"mailto:Dag@Dynasim.se\">Dag@Dynasim.se</A><br>
// </dl>
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> This library has been designed by:<br>
//      <blockquote>
//      Dag Br&uuml;ck, Dynasim AB, Sweden <br>
//      Hilding Elmqvist, Dynasim AB, Sweden <br>
//      Hans Olsson, Dynasim AB, Sweden <br>
//      Martin Otter, DLR Oberpfaffenhofen, Germany.
//      </blockquote></li>
// <li> The library including the C reference implementation has
//      been implemented by Martin Otter and Dag Br&uuml;ck.</li>
// <li> The Examples.calculator demonstration to implement a calculator
//      with this library is from Hilding Elmqvist.</li>
// <li> Helpful comments from Kaj Nystr&ouml;m, PELAB, Link&ouml;ping, Sweden,
//      are appreciated, as well as discussions at the 34th, 36th, and 40th
//      Modelica Design Meetings in Vienna, Link&ouml;ping, and Dresden. </li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Examples.calculator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Examples.calculator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Examples.calculator)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// result = <b>calculator</b>(expression);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// This function demonstrates how a simple expression calculator
// can be implemented in form of a recursive decent parser
// using basically the Strings.scanToken(..) and Strings.scanDelimiter(..)
// function.
// </p>
// <p>
// The following operations are supported (pi=3.14.. is a predefined constant):
// </p>
// <pre>
//    +, -
//    *, /
//    (expression)
//    sin(expression)
//    cos(expression)
//    tan(expression)
//    sqrt(expression)
//    pi
// </pre>
// <h4>Example</h4>
// <blockquote><pre>
//   calculator(\"2+3*(4-1)\");  // returns 11
//   calculator(\"sin(pi/6)\");  // returns 0.5
// </pre></blockquote>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Examples.expression)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Examples.expression)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Examples.expression)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              result = <b>expression</b>(string);
// (result, nextIndex) = <b>expression</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// This function is nearly the same as Examples.<b>calculator</b>.
// The essential difference is that function \"expression\" might be
// used in other parsing operations: After the expression is
// parsed and evaluated, the function returns with the value
// of the expression as well as the position of the character
// directly after the expression.
// </p>
// <p>
// This function demonstrates how a simple expression calculator
// can be implemented in form of a recursive decent parser
// using basically the Strings.scanToken(..) and scanDelimiters(..)
// function. There are 2 local functions (term, primary) that
// implement the corresponding part of the grammar.
// </p>
// <p>
// The following operations are supported (pi=3.14.. is a predefined constant):
// </p>
// <pre>
//    +, -
//    *, /
//    (expression)
//    sin(expression)
//    cos(expression)
//    tan(expression)
//    sqrt(expression)
//    pi
// </pre>
// <p>
// The optional argument \"startIndex\" defines at which position
// scanning of the expression starts.
// </p>
// <p>
// In case of error,
// the optional argument \"message\" is appended to the error
// message, in order to give additional information where
// the error occured.
// </p>
// <p>
// This function parses the following grammaer
// </p>
// <pre>
//   expression: [ add_op ] term { add_op term }
//   add_op    : \"+\" | \"-\"
//   term      : primary { mul_op primary }
//   mul_op    : \"*\" | \"/\"
//   primary   : UNSIGNED_NUMBER
//               | pi
//               | ( expression )
//               | functionName( expression )
//   function  :   sin
//               | cos
//               | tan
//               | sqrt
// </pre>
// <p>
// Note, in Examples.readRealParameter it is shown, how the expression
// function can be used as part of another scan operation.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   expression(\"2+3*(4-1)\");  // returns 11
//   expression(\"sin(pi/6)\");  // returns 0.5
// </pre></blockquote>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Examples.readRealParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Examples.readRealParameter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Examples.readRealParameter)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// result = <b>readRealParameter</b>(fileName, name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// This function demonstrates how a function can be implemented
// that reads the value of a parameter from file. The function
// performs the following actions:
// </p>
// <ol>
// <li> It opens file \"fileName\" and reads the lines of the file.</li>
// <li> In every line, Modelica line comments (\"// ... end-of-line\")
//      are skipped </li>
// <li> If a line consists of \"name = expression\" and the \"name\"
//      in this line is identical to the second argument \"name\"
//      of the function call, the expression calculator Examples.expression
//      is used to evaluate the expression after the \"=\" character.
//      The expression can optionally be terminated with a \";\".</li>
// <li> The result of the expression evaluation is returned as
//      the value of the parameter \"name\". </li>
// </ol>
// <h4>Example</h4>
// <p>
// On file \"test.txt\" the following lines might be present:
// </p>
// <blockquote><pre>
// // Motor data
// J        = 2.3     // inertia
// w_rel0   = 1.5*2;  // relative angular velocity
// phi_rel0 = pi/3
// </pre></blockquote>
// <p>
// The function returns the value \"3.0\" when called as:
// </p>
// <blockquote><pre>
// readRealParameter(\"test.txt\", \"w_rel0\")
// </pre></blockquote>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Examples.readRealParameterModel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Examples.readRealParameterModel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Examples.readRealParameterModel)
// {"<html>
// <p>
// Model that shows the usage of Examples.readRealParameter and Examples.expression.
// The model has 3 parameters and the values of these parameters are read
// from a file.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.list)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.list)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.list)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>list</b>(name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// If \"name\" is a regular file, the content of the
// file is printed.
// </p>
// <p>
// If \"name\" is a directory, the directory and file names
// in the \"name\" directory are printed in sorted order.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.copy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.copy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.copy)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>copy</b>(oldName, newName);
// Files.<b>copy</b>(oldName, newName, replace = true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>copy</b>(..) copies a file or a directory
// to a new location. Via the optional argument <b>replace</b>
// it can be defined whether an already existing file may
// be replaced by the required copy.
// </p>
// <p>
// If oldName/newName are directories, then the newName
// directory may exist. In such a case the content of oldName
// is copied into directory newName. If replace = <b>false</b>
// it is required that the existing files
// in newName are different from the existing files in
// oldName.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   copy(\"C:/test1/directory1\", \"C:/test2/directory2\");
//      -> the content of directory1 is copied into directory2
//         if \"C:/test2/directory2\" does not exist, it is newly
//         created. If \"replace=true\", files in directory2
//         may be overwritten by their copy
//   copy(\"test1.txt\", \"test2.txt\")
//      -> make a copy of file \"test1.txt\" with the name \"test2.txt\"
//         in the current directory
// </pre></blockquote>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.move)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.move)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.move)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>move</b>(oldName, newName);
// Files.<b>move</b>(oldName, newName, replace = true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>move</b>(..) moves a file or a directory
// to a new location. Via the optional argument <b>replace</b>
// it can be defined whether an already existing file may
// be replaced.
// </p>
// <p>
// If oldName/newName are directories, then the newName
// directory may exist. In such a case the content of oldName
// is moved into directory newName. If replace = <b>false</b>
// it is required that the existing files
// in newName are different from the existing files in
// oldName.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   move(\"C:/test1/directory1\", \"C:/test2/directory2\");
//      -> the content of directory1 is moved into directory2.
//         Afterwards directory1 is deleted.
//         if \"C:/test2/directory2\" does not exist, it is newly
//         created. If \"replace=true\", files in directory2
//         may be overwritten
//    move(\"test1.txt\", \"test2.txt\")
//      -> rename file \"test1.txt\" into \"test2.txt\"
//         within the current directory
// </pre></blockquote>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.remove)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.remove)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.remove)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>remove</b>(name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Removes the file or directory \"name\". If \"name\" does not exist,
// the function call is ignored. If \"name\" is a directory, first
// the content of the directory is removed and afterwards
// the directory itself.
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.removeFile)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.removeFile)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.removeFile)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>removeFile</b>(fileName);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Removes the file \"fileName\". If \"fileName\" does not exist,
// the function call is ignored. If \"fileName\" exists but is
// no regular file (e.g., directory, pipe, device, etc.) an
// error is triggered.
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.createDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.createDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.createDirectory)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>createDirectory</b>(directoryName);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Creates directory \"directorName\". If this directory already exists,
// the function call is ignored. If several directories in \"directoryName\"
// do not exist, all of them are created. For example, assume
// that directory \"E:/test1\" exists and that directory
// \"E:/test1/test2/test3\" shall be created. In this case
// the directories \"test2\" in \"test1\" and \"test3\" in \"test2\"
// are created.
// </p>
// <p>
// This function is silent, i.e., it does not print a message.
// In case of error (e.g., \"directoryName\" is an existing regular
// file), an assert is triggered.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.exist)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.exist)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.exist)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// result = Files.<b>exist</b>(name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Returns true, if \"name\" is an existing file or directory.
// If this is not the case, the function returns false.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.assertNew)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.assertNew)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.assertNew)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Files.<b>assertNew</b>(name);
// Files.<b>assertNew</b>(name, message=\"This is not allowed\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Triggers an assert, if \"name\" is an existing file or
// directory. The error message has the following structure:
// </p>
// <pre>
//   File \"&lt;name&gt;\" already exists.
//   &lt;message&gt;
// </pre>
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.fullPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.fullPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.fullPathName)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// fullName = Files.<b>fullPathName</b>(name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Returns the full path name of a file or directory \"name\".
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.fullPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.fullPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.fullPathName)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// fullName = Files.<b>fullPathName</b>(name);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Returns the full path name of a file or directory \"name\".
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.splitPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.splitPathName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.splitPathName)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// (directory, name, extension) = Files.<b>splitPathName</b>(pathName);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>splitPathName</b>(..) splits a path name into its parts.
// </p>
// <h4>Example</h4>
// <pre>
//   (directory, name, extension) = Files.splitPathName(\"C:/user/test/input.txt\")
//
//   -> directory = \"C:/user/test/\"
//      name      = \"input\"
//      extension = \".txt\"
// </pre>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Files.temporaryFileName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Files.temporaryFileName)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Files.temporaryFileName)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// fileName = Files.<b>temporaryFileName</b>();
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Return arbitrary name of a file that does not exist
// and is in a directory where access rights allow to
// write to this file (useful for temporary output of files).
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, -100}, {80, 60}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 60}, {-80, 100}, {100, 100}, {80, 60}, {-100, 60}}, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {160, 160, 164}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 100}, {100, -60}, {80, -100}, {80, 60}, {100, 100}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, -100}, {80, 60}}, "%shapeType", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-132, 160}, {128, 100}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Internal.PartialModelicaServices.Animation.PartialShape)
// {"<html>
//
// <p>
// This model is documented at
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>.
// </p>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.print)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.print)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.print)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// Streams.<b>print</b>(string);
// Streams.<b>print</b>(string,fileName);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>print</b>(..) opens automatically the given file, if
// it is not yet open. If the file does not exist, it is created.
// If the file does exist, the given string is appended to the file.
// If this is not desired, call \"Files.remove(fileName)\" before calling print
// (\"remove(..)\" is silent, if the file does not exist).
// The Modelica environment may close the file whenever appropriate.
// This can be enforced by calling <b>Streams.close</b>(fileName).
// After every call of \"print(..)\" a \"new line\" is printed automatically.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   Streams.print(\"x = \" + String(x));
//   Streams.print(\"y = \" + String(y));
//   Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
// </pre></blockquote>
// <p>
// <h4>See also</h4>
// <p>
// <a href=\"Modelica://Modelica.Utilities.Streams\">Streams</a>,
// <a href=\"Modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
// <a href=\"Modelica://ModelicaReference.Operators.string\">String</a>
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.readFile)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.readFile)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.readFile)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// stringVector = Streams.<b>readFile</b>(fileName)
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>readFile</b>(..) opens the given file, reads the complete
// content, closes the file and returns the content as a vector of strings. Lines are separated by LF or CR-LF; the returned strings do not contain the line separators.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.readLine)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.readLine)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.readLine)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (string, endOfFile) = Streams.<b>readLine</b>(fileName, lineNumber)
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>readLine</b>(..) opens the given file, reads enough of the
// content to get the requested line, and returns the line as a string.
// Lines are separated by LF or CR-LF; the returned string does not
// contain the line separator. The file might remain open after
// the call.
// </p>
// <p>
// If lineNumber > countLines(fileName), an empty string is returned
// and endOfFile=true. Otherwise endOfFile=false.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.countLines)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.countLines)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.countLines)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// numberOfLines = Streams.<b>countLines</b>(fileName)
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>countLines</b>(..) opens the given file, reads the complete
// content, closes the file and returns the number of lines. Lines are
// separated by LF or CR-LF.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.error)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.error)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.error)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Streams.<b>error</b>(string);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Print the string \"string\" as error message and
// cancel all actions. Line breaks are characterized
// by \"\\n\" in the string.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
// </pre></blockquote>
// <h4>See also</h4>
// <p>
// <a href=\"Modelica://Modelica.Utilities.Streams\">Streams</a>,
// <a href=\"Modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
// <a href=\"Modelica://ModelicaReference.Operators.string\">String</a>
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Streams.close)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Streams.close)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Streams.close)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Streams.<b>close</b>(fileName)
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Close file if it is open. Ignore call if
// file is already closed or does not exist.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.length)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>length</b>(string);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Returns the number of characters of \"string\".
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.substring)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.substring)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.substring)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// string2 = Strings.<b>substring</b>(string, startIndex, endIndex);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// This function returns
// the substring from position startIndex
// up to and including position endIndex of \"string\" .
// </p>
// <p>
// If index, startIndex, or endIndex are not correct, e.g.,
// if endIndex &gt; length(string), an assert is triggered.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   string1 := \"This is line 111\";
//   string2 := Strings.substring(string1,9,12); // string2 = \"line\"
// </pre></blockquote>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.repeat)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.repeat)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.repeat)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// string2 = Strings.<b>repeat</b>(n);
// string2 = Strings.<b>repeat</b>(n, string=\" \");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// The first form returns a string consisting of n blanks.
// </p>
// <p>
// The second form returns a string consisting of n substrings
// defined by the optional argument \"string\".
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.compare)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.compare)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.compare)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// result = Strings.<b>compare</b>(string1, string2);
// result = Strings.<b>compare</b>(string1, string2, caseSensitive=true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Compares two strings. If the optional argument caseSensitive=false,
// upper case letters are treated as if they would be lower case letters.
// The result of the comparison is returned as:
// </p>
// <pre>
//   result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
//          = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
//          = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
// </pre>
// <p>
// Comparison is with regards to lexicographical order,
// e.g., \"a\" &lt; \"b\";
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.isEqual)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>isEqual</b>(string1, string2);
// Strings.<b>isEqual</b>(string1, string2, caseSensitive=true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Compare whether two strings are identical,
// optionally ignoring case.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.count)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.count)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.count)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>count</b>(string, searchString)
// Strings.<b>count</b>(string, searchString, startIndex=1,
//                      caseSensitive=true)
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Returns the number of non-overlapping occurrences of string \"searchString\"
// in \"string\". The search is started at index \"startIndex\" (default = 1).
// If the optional argument \"caseSensitive\" is false,
// for the counting it does not matter whether a letter is upper
// or lower case.
// /p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.find)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.find)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.find)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// index = Strings.<b>find</b>(string, searchString);
// index = Strings.<b>find</b>(string, searchString, startIndex=1,
//                      caseSensitive=true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Finds first occurence of \"searchString\" within \"string\"
// and return the corresponding index.
// Start search at index \"startIndex\" (default = 1).
// If the optional argument \"caseSensitive\" is false, lower
// and upper case are ignored for the search.
// If \"searchString\" is not found, a value of \"0\" is returned.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.findLast)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.findLast)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.findLast)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// index = Strings.<b>findLast</b>(string, searchString);
// index = Strings.<b>findLast</b>(string, searchString,
//                          startIndex=length(string), caseSensitive=true,
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Finds first occurence of \"searchString\" within \"string\"
// when searching from the last character of \"string\"
// backwards, and return the corresponding index.
// Start search at index \"startIndex\" (default = length(string)).
// If the optional argument \"caseSensitive\" is false, lower
// and upper case are ignored for the search.
// If \"searchString\" is not found, a value of \"0\" is returned.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.replace)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.replace)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.replace)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>replace</b>(string, searchString, replaceString);
// Strings.<b>replace</b>(string, searchString, replaceString,
//                 startIndex=1, replaceAll=true, caseSensitive=true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Search in \"string\" for \"searchString\" and replace the found
// substring by \"replaceString\".
// <p>
// <ul>
// <li> The search starts at the first character of \"string\",
//      or at character position \"startIndex\",
//      if this optional argument is provided.</li>
// <li> If the optional argument \"replaceAll\" is <b>true</b> (default),
//      all occurrences of \"searchString\" are replaced.
//      If the argument is <b>false</b>, only the first occurrence
//      is replaced. </li>
// <li> The search for \"searchString\" distinguishes upper and lower
//      case letters. If the optional argument \"caseSensitive\" is
//      <b>false</b>,
//      the search ignores whether letters are upper
//      or lower case. </li>
// </ul>
// <p>
// The function returns the \"string\" with the
// performed replacements.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.sort)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// stringVector2 = Streams.<b>sort</b>(stringVector1);
// stringVector2 = Streams.<b>sort</b>(stringVector1, caseSensitive=true);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>sort</b>(..) sorts a string vector stringVector1
// in lexicographical order and returns the result in stringVector2.
// If the optional argument \"caseSensitive\" is <b>false</b>, lower
// and upper case letters are not distinguished.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   s1 = {\"force\", \"angle\", \"pressure\"};
//   s2 = Strings.sort(s1);
//        -> s2 = {\"angle\", \"force\", \"pressure\"};
// </pre></blockquote>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanToken)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanToken)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanToken)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (token, nextIndex) = Strings.<b>scanToken</b>(string, startIndex, unsigned=false);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanToken</b> scans the string starting at index
// \"startIndex\" and returns the next token, as well as the
// index directly after the token. The returned token is a record
// that holds the type of the token and the value of the token:
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\">token.tokenType</td>
//       <td valign=\"top\">Type of the token, see below</td></tr>
//   <tr><td valign=\"top\">token.real</td>
//       <td valign=\"top\">Real value if tokenType == TokenType.RealToken</td></tr>
//   <tr><td valign=\"top\">token.integer</td>
//       <td valign=\"top\">Integer value if tokenType == TokenType.IntegerToken</td></tr>
//   <tr><td valign=\"top\">token.boolean</td>
//       <td valign=\"top\">Boolean value if tokenType == TokenType.BooleanToken</td></tr>
//   <tr><td valign=\"top\">token.string</td>
//       <td valign=\"top\">String value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken</td></tr>
// </table>
// <p>
// Variable token.tokenType is an enumeration (emulated as a package
// with constants) that can have the following values:
// </p>
// <pre>
//    import T = Modelica.Utilities.Types.TokenType;
// </pre>
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\">T.RealToken</td>
//       <td valign=\"top\">Modelica Real literal (e.g., 1.23e-4)</td></tr>
//   <tr><td valign=\"top\">T.IntegerToken</td>
//       <td valign=\"top\">Modelica Integer literal (e.g., 123)</td></tr>
//   <tr><td valign=\"top\">T.BooleanToken</td>
//       <td valign=\"top\">Modelica Boolean literal (e.g., false)</td></tr>
//   <tr><td valign=\"top\">T.StringToken</td>
//       <td valign=\"top\">Modelica String literal (e.g., \"string 123\")</td></tr>
//   <tr><td valign=\"top\">T.IdentifierToken</td>
//       <td valign=\"top\">Modelica identifier (e.g., \"force_a\")</td></tr>
//   <tr><td valign=\"top\">T.DelimiterToken</td>
//       <td valign=\"top\">any character without white space that does not appear<br>
//           as first character in the tokens above (e.g., \"&\")</td></tr>
//   <tr><td valign=\"top\">T.NoToken</td>
//       <td valign=\"top\">White space, line comments and no other token<br>
//           until the end of the string</td></tr>
// </table>
// <p>
// Modelica line comments (\"// ... end-of-line/end-of-string\")
// as well as white space is ignored.
// If \"unsigned=true\", a Real or Integer literal
// is not allowed to start with a \"+\" or \"-\" sign.
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   import Modelica.Utilities.Strings.*;
//   import T = Modelica.Utilities.Types.TokenType;
//   (token, index) := scanToken(string);
//   <b>if</b> token.tokenType == T.RealToken <b>then</b>
//      realValue := token.real;
//   <b>elseif</b> token.tokenType == T.IntegerToken <b>then</b>
//      integerValue := token.integer;
//   <b>elseif</b> token.tokenType == T.BooleanToken<b> then</b>
//      booleanValue := token.boolean;
//   <b>elseif</b> token.tokenType == T.Identifier <b>then</b>
//      name := token.string;
//   <b>else</b>
//      syntaxError(string,index,\"Expected Real, Integer, Boolean or identifier token\");
//   <b>end if</b>;
// </pre></blockquote>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanReal)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              number = Strings.<b>scanReal</b>(string);
// (number, nextIndex) = Strings.<b>scanReal</b>(string, startIndex=1,
//                                             unsigned=false, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// The first form, \"scanReal(string)\", scans \"string\" for a
// Real number with leading white space and returns the value.
// </p>
// <p>
// The second form, \"scanReal(string,startIndex,unsigned)\",
// scans the string starting at index
// \"startIndex\", checks whether the next token is a Real literal
// and returns its value as a Real number, as well as the
// index directly after the Real number.
// If the optional argument \"unsigned\" is <b>true</b>,
// the real number shall not have a leading \"+\" or \"-\" sign.
// </p>
// <p>
// If the required Real number with leading white space
// is not present in \"string\",  an assert is triggered.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanInteger)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              number = Strings.<b>scanInteger</b>(string);
// (number, nextIndex) = Strings.<b>scanInteger</b>(string, startIndex=1,
//                                                unsigned=false, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanInteger</b> scans the string starting at index
// \"startIndex\", checks whether the next token is an Integer literal
// and returns its value as an Integer number, as well as the
// index directly after the Integer number. An assert is triggered,
// if the scanned string does not contain an Integer literal with optional
// leading white space.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanBoolean)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              number = Strings.<b>scanBoolean</b>(string);
// (number, nextIndex) = Strings.<b>scanBoolean</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanBoolean</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a Boolean literal
// (i.e., is either the string \"false\" or \"true\", if converted to lower case letters)
// and returns its value as a Boolean number, as well as the
// index directly after the Boolean number. An assert is triggered,
// if the scanned string does not contain a Boolean literal with optional
// leading white space.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanString)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanString)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanString)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              string2 = Strings.<b>scanString</b>(string);
// (string2, nextIndex) = Strings.<b>scanString</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanString</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a String literal
// and returns its value as a String, as well as the
// index directly after the String. An assert is triggered,
// if the scanned string does not contain a String literal with optional
// leading white space.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanIdentifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanIdentifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanIdentifier)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              identifier = Strings.<b>scanIdentifier</b>(string);
// (identifier, nextIndex) = Strings.<b>scanIdentifier</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanIdentifier</b> scans the string starting at index
// \"startIndex\", checks whether the next token is an Identifier
// and returns its value as a string, as well as the
// index directly after the Identifier. An assert is triggered,
// if the scanned string does not contain an Identifier with optional
// leading white space.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanDelimiter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanDelimiter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanDelimiter)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
//              delimiter = Strings.<b>scanDelimiter</b>(string);
// (delimiter, nextIndex) = Strings.<b>scanDelimiter</b>(string, startIndex=1,
//                                  requiredDelimiters={\",\"}, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanDelimiter</b> scans the string starting at index
// \"startIndex\", checks whether the next token is a delimiter string
// and returns its value as a string, as well as the
// index directly after the delimiter. An assert is triggered,
// if the scanned string does not contain a delimiter out of the
// list of requiredDelimiters. Input argument requiredDelimiters is a vector
// of strings. The elements may have any length, including length 0.
// If an element of the requiredDelimiters is zero, white space
// is treated as delimiter. The function returns delimiter=\"\" and nextIndex
// is the index of the first non white space character.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.scanNoToken)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.scanNoToken)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.scanNoToken)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>scanNoToken</b>(string, startIndex=1, message=\"\");
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>scanNoToken</b> scans the string starting at index
// \"startIndex\" and checks whether there is no more token in the
// string. An assert is triggered if this is not the case,
// using the \"message\" argument as additional explanation in
// the error text.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.syntaxError)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.syntaxError)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.syntaxError)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// Strings.<b>syntaxError</b>(string, index, message);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Function <b>syntaxError</b> prints an error message in the
// following form:
// </p>
// <pre>
//    Syntax error at column &lt;index&gt; of
//    &lt;string&gt;
//        ^       // shows character that is wrong
//    &lt;message&gt;
// </pre>
// <p>
// where the strings withing &lt;..&gt; are the actual values of the
// input arguments of the function.
// </p>
// <p>
// If the given string is too long, only a relevant
// part of the string is printed.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanReal)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (nextIndex, realNumber) = <b>scanReal</b>(string, startIndex=1, unsigned=false);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a number
// of type Real with an optional sign according to the Modelica grammar:
// </p>
// <pre>
//     real     ::= [sign] unsigned [fraction] [exponent]
//     sign     ::= '+' | '-'
//     unsigned ::= digit [unsigned]
//     fraction ::= '.' [unsigned]
//     exponent ::= ('e' | 'E') [sign] unsigned
//     digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
// </pre>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found real number, as well as the value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is zero.
// </p>
// <p>
// If the optional argument \"unsigned\" is <b>true</b>, the number
// shall not start with '+' or '-'. The default of \"unsigned\" is <b>false</b>.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanInteger)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (nextIndex, integerNumber) = <b>scanInteger</b>(string, startIndex=1, unsigned=false);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a signed number
// of type Integer. An Integer starts with an optional '+'
// or '-', immediately
// followed by a non-empty sequence of digits.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found Integer number, as well as the Integer value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is zero.
// </p>
// <p>
// Note, a Real number, such as \"123.4\", is not treated
// as an Integer number and scanInteger will return
// nextIndex = startIndex in this case.
// </p>
// <p>
// If the optional argument \"unsigned\" is <b>true</b>, the number
// shall not start with '+' or '-'. The default of \"unsigned\" is <b>false</b>.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanString)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanString)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanString)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (nextIndex, string2) = <b>scanString</b>(string, startIndex=1);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a string
// according to the Modelica grammar, i.e., a string
// enclosed in double quotes.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found string, as well as the string value
// in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is an empty string.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.scanIdentifier)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// (nextIndex, identifier) = <b>scanIdentifier</b>(string, startIndex=1);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a Modelica
// identifier, i.e., a sequence of characters starting with
// a letter (\"a\"..\"z\" or \"A\"..\"Z\") followed by letters,
// digits or underscores (\"_\").
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found identifier, as well as the identifier
// as string in the second output argument.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex and
// the second output argument is an empty string.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.skipWhiteSpace)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// nextIndex = <b>skipWhiteSpace</b>(string, startIndex);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\" and
// skips white space. The function returns nextIndex = index of character
// of the first non white space character.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Strings.Advanced.skipLineComments)
// {"<html>
// <h4>Syntax</h4>
// <blockquote><pre>
// nextIndex = <b>skipLineComments</b>(string, startIndex);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// Starts scanning of \"string\" at position \"startIndex\".
// First skips white space and scans afterwards a Modelica (C/C++)
// line comment, i.e., a sequence of characters that
// starts with \"//\" and ends with an end-of-line \"\\n\" or
// with the end of the string. If end-of-line is reached,
// the function continues to skip white space and
// scanning of line comments until end-of-string is
// reached, or another token is detected.
// </p>
// <p>
// If successful, the function returns nextIndex = index of character
// directly after the found line comment.
// </p>
// <p>
// If not successful, on return nextIndex = startIndex.
// </p>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.getWorkDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.getWorkDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.getWorkDirectory)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.setWorkDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.setWorkDirectory)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.setWorkDirectory)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.getEnvironmentVariable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.getEnvironmentVariable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.getEnvironmentVariable)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.setEnvironmentVariable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.setEnvironmentVariable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.setEnvironmentVariable)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.command)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.command)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.command)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.System.exit)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.System.exit)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.System.exit)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Types.Compare)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Types.Compare)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Types.Compare)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Types.FileType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Types.FileType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Types.FileType)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Types.TokenType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Types.TokenType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Utilities.Types.TokenType)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Utilities.Types.TokenValue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Utilities.Types.TokenValue)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.SimpleCooling)
// {"<HTML>
// <p>
// 1st test example: SimpleCooling
// </p>
// A prescribed heat source dissipates its heat through a thermal conductor to a coolant flow. The coolant flow is taken from an ambient and driven by a pump with prescribed mass flow.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td valign=\"top\"><b>output</b></td>
// <td valign=\"top\"><b>explanation</b></td>
// <td valign=\"top\"><b>formula</b></td>
// <td valign=\"top\"><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td valign=\"top\">dTSource</td>
// <td valign=\"top\">Source over Ambient</td>
// <td valign=\"top\">dtCoolant + dtToPipe</td>
// <td valign=\"top\">20 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTtoPipe</td>
// <td valign=\"top\">Source over Coolant</td>
// <td valign=\"top\">Losses / ThermalConductor.G</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTCoolant</td>
// <td valign=\"top\">Coolant's temperature increase</td>
// <td valign=\"top\">Losses * cp * massFlow</td>
// <td valign=\"top\">10 K</td>
// </tr>
// </table>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelCooling)
// {"<HTML>
// <p>
// 2nd test example: ParallelCooling
// </p>
// Two prescribed heat sources dissipate their heat through thermal conductors to coolant flows. The coolant flow is taken from an ambient and driven by a pump with prescribed mass flow, then splitted into two coolant flows connected to the two heat sources, and afterwards merged. Splitting of coolant flows is determined by pressure drop characteristic of the two pipes.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td valign=\"top\"><b>output</b></td>
// <td valign=\"top\"><b>explanation</b></td>
// <td valign=\"top\"><b>formula</b></td>
// <td valign=\"top\"><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td valign=\"top\">dTSource1</td>
// <td valign=\"top\">Source1 over Ambient</td>
// <td valign=\"top\">dTCoolant1 + dTtoPipe1</td>
// <td valign=\"top\">15 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTtoPipe1</td>
// <td valign=\"top\">Source1 over Coolant1</td>
// <td valign=\"top\">Losses1 / ThermalConductor1.G</td>
// <td valign=\"top\"> 5 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTCoolant1</td>
// <td valign=\"top\">Coolant's temperature increase</td>
// <td valign=\"top\">Losses * cp * totalMassFlow/2</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTSource2</td>
// <td valign=\"top\">Source2 over Ambient</td>
// <td valign=\"top\">dTCoolant2 + dTtoPipe2</td>
// <td valign=\"top\">30 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTtoPipe2</td>
// <td valign=\"top\">Source2 over Coolant2</td>
// <td valign=\"top\">Losses2 / ThermalConductor2.G</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTCoolant2</td>
// <td valign=\"top\">Coolant's temperature increase</td>
// <td valign=\"top\">Losses * cp * totalMassFlow/2</td>
// <td valign=\"top\">20 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTmixedCoolant</td>
// <td valign=\"top\">mixed Coolant's temperature increase</td>
// <td valign=\"top\">(dTCoolant1+dTCoolant2)/2</td>
// <td valign=\"top\">15 K</td>
// </tr>
// </table>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.IndirectCooling)
// {"<HTML>
// <p>
// 3rd test example: IndirectCooling
// </p>
// A prescribed heat sources dissipates its heat through a thermal conductor to the inner coolant cycle. It is necessary to define the pressure level of the inner coolant cycle. The inner coolant cycle is coupled to the outer coolant flow through a thermal conductor.<br>
// Inner coolant's temperature rise near the source is the same as temperature drop near the cooler.<br>
// <b>Results</b>:<br>
// <table>
// <tr>
// <td valign=\"top\"><b>output</b></td>
// <td valign=\"top\"><b>explanation</b></td>
// <td valign=\"top\"><b>formula</b></td>
// <td valign=\"top\"><b>actual steady-state value</b></td>
// </tr>
// <tr>
// <td valign=\"top\">dTSource</td>
// <td valign=\"top\">Source over Ambient</td>
// <td valign=\"top\">dtouterCoolant + dtCooler + dTinnerCoolant + dtToPipe</td>
// <td valign=\"top\">40 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTtoPipe</td>
// <td valign=\"top\">Source over inner Coolant</td>
// <td valign=\"top\">Losses / ThermalConductor.G</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTinnerColant</td>
// <td valign=\"top\">inner Coolant's temperature increase</td>
// <td valign=\"top\">Losses * cp * innerMassFlow</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTCooler</td>
// <td valign=\"top\">Cooler's temperature rise between inner and outer pipes</td>
// <td valign=\"top\">Losses * (innerGc + outerGc)</td>
// <td valign=\"top\">10 K</td>
// </tr>
// <tr>
// <td valign=\"top\">dTouterColant</td>
// <td valign=\"top\">outer Coolant's temperature increase</td>
// <td valign=\"top\">Losses * cp * outerMassFlow</td>
// <td valign=\"top\">10 K</td>
// </tr>
// </table>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpAndValve)
// {"<HTML>
// <p>
// 4th test example: PumpAndValve
// </p>
// The pump is running with half speed for 0.4 s,
// afterwards with full speed (using a ramp of 0.1 s).<br>
// The valve is half open for 0.9 s, afterwards full open (using a ramp of 0.1 s).<br>
// You may try to:
// <ul>
// <li>drive the pump with variable speed and let the valve full open
//     to regulate the volume flow rate of coolant</li>
// <li>drive the pump with constant speed and throttle the valve
//     to regulate the volume flow rate of coolant</li>
// </ul>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.PumpDropOut)
// {"<HTML>
// <p>
// 5th test example: PumpDropOut
// </p>
// Same as 1st test example, but with a drop out of the pump:<br>
// The pump is running for 0.2 s, then shut down (using a ramp of 0.2 s) for 0.2 s,
// then started again (using a ramp of 0.2 s).
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.ParallelPumpDropOut)
// {"<HTML>
// <p>
// 6th test example: ParallelPumpDropOut
// </p>
// Same as 2nd test example, but with a drop out of the pump:<br>
// The pump is running for 0.2 s, then shut down (using a ramp of 0.2 s) for 0.2 s,
// then started again (using a ramp of 0.2 s).
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.OneMass)
// {"<HTML>
// <p>
// 7th test example: OneMass
// </p>
// A thermal capacity is coupled with a coolant flow.
// Different inital temperatures of thermal capacity and pipe's coolant get ambient's temperature,
// the time behaviour depending on coolant flow.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.TwoMass)
// {"<HTML>
// <p>
// 8th test example: TwoMass
// </p>
// Two thermal capacities are coupled with two parallel coolant flow.
// Different inital temperatures of thermal capacities and pipe's coolants get ambient's temperature,
// the time behaviour depending on coolant flow.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-80, 68}, {-80, -80}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 90}, {-88, 68}, {-72, 68}, {-80, 90}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, -70}, {82, -70}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, -70}, {68, -62}, {68, -78}, {90, -70}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, -60}, {-50, -60}, {-30, 60}, {10, 60}, {30, -20}, {70, -20}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// "[Modelica 3.1/Thermal/FluidHeatFlow.mo:1154:11-1172:49:writable] Error: Function Line has no parameter named fillColor.
// [Modelica 3.1/Thermal/FluidHeatFlow.mo:1154:11-1172:49:writable] Error: Function Line has no parameter named fillPattern.
// "
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Examples.Utilities.DoubleRamp)
// {"<HTML>
// Block generating the sum of two ramps.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 20}, {90, -20}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 100}, {150, 40}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.IsolatedPipe)
// {"<HTML>
// Pipe without heat exchange.<br>
// Thermodynamic equations are defined by Partials.TwoPortMass(Q_flow = 0).<br>
// <b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 20}, {90, -20}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 100}, {150, 40}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-10, -90}, {-10, -40}, {0, -20}, {10, -40}, {10, -90}, {-10, -90}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.HeatedPipe)
// {"<HTML>
// Pipe with heat exchange.<br>
// Thermodynamic equations are defined by Partials.TwoPort.<br>
// Q_flow is defined by heatPort.Q_flow.<br>
// <b>Note:</b> Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// <b>Note:</b> Injecting heat into a pipe with zero massflow causes
// temperature rise defined by storing heat in medium's mass.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, -60}, {150, -120}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 10}, {-60, 10}, {-60, 60}, {0, 0}, {60, 60}, {60, 10}, {90, 10}, {90, -10}, {60, -10}, {60, -60}, {0, 0}, {-60, -60}, {-60, -10}, {-90, -10}, {-90, 10}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 80}, {0, 0}}, {0, 0, 127}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Components.Valve)
// {"<HTML>
// Simple controlled valve.<br>
// Standard characteristic Kv=<i>f </i>(y) is given at standard conditions (dp0, rho0),<br>
// <tt>
// <ul>
// <li>either linear : Kv/Kv1 = Kv0/Kv1 + (1-Kv0/Kv1) * y/Y1</li>
// <li>or exponential: Kv/Kv1 = Kv0/Kv1 * exp[ln(Kv1/Kv0) * y/Y1]</li>
// </ul>
// where:
// <ul>
// <li>Kv0 ... min. flow @ y = 0</li>
// <li>Y1 .... max. valve opening</li>
// <li>Kv1 ... max. flow @ y = Y1</li>
// </ul>
// </tt>
// Flow resistance under real conditions is calculated by<br>
// <tt>V_flow**2 * rho / dp = Kv(y)**2 * rho0 / dp0</tt>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Medium)
// {"<html>
// Record containing (constant) medium properties.
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_30degC)
// {"<html>
// Medium: properties of air at 30 degC
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Air_70degC)
// {"<html>
// Medium: properties of air at 70 degC
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Media.Water)
// {"<html>
// Medium: properties of water
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{20, 80}, {80, 20}}, "p", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{20, -20}, {80, -80}}, "T", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.Ambient)
// {"<HTML>
// (Infinite) ambient with constant pressure and temperature.<br>
// Thermodynamic equations are defined by Partials.Ambient.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 90}}, "%name", 0, TextAlignment.Center), Ellipse(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 90}, {90, -90}}, 0, 360)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.AbsolutePressure)
// {"<HTML>
// AbsolutePressure to define pressure level of a closed cooling cycle.
// Coolant's mass flow, temperature and enthalpy flow are not affected.<br>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 90}, {90, -90}}, 0, 360), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, -90}, {150, -150}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, 68}, {90, 10}, {90, -10}, {-60, -68}, {-60, 68}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, 20}, {0, -20}}, "V", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.VolumeFlow)
// {"<HTML>
// Fan resp. pump with constant volume flow rate. Pressure increase is the response of the whole system.
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 90}, {90, -90}}, 0, 360), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, -90}, {150, -150}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, 68}, {90, 10}, {90, -10}, {-60, -68}, {-60, 68}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, 20}, {0, -20}}, "dp", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.PressureIncrease)
// {"<HTML>
// Fan resp. pump with constant pressure increase. Mass resp. volume flow is the response of the whole system.
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 90}, {90, -90}}, 0, 360), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 90}}, "%name", 0, TextAlignment.Center), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {175, 175, 175}, LinePattern.Solid, FillPattern.VerticalCylinder, 0.25, BorderPattern.None, {{-10, -40}, {10, -100}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, {{-60, 68}, {90, 10}, {90, -10}, {-60, -68}, {-60, 68}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sources.IdealPump)
// {"<HTML>
// Simple fan resp. pump where characteristic is dependent on shaft's speed, <br>
// torque * speed = pressure increase * volume flow (without losses)<br>
// Pressure increase versus volume flow is defined by a linear function,
// from dp0(V_flow=0) to V_flow0(dp=0).<br>
// The axis intersections vary with speed as follows:
// <ul>
// <li>dp prop. speed^2</li>
// <li>V_flow prop. speed</li>
// </ul>
// Coolant's temperature and enthalpy flow are not affected.<br>
// Setting parameter m (mass of medium within fan/pump) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Thermodynamic equations are defined by Partials.TwoPort.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "p", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.PressureSensor)
// {"<HTML>
// pSensor measures the absolute pressure.<br>
// Thermodynamic equations are defined by Partials.AbsoluteSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "T", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.TemperatureSensor)
// {"<HTML>
// TSensor measures the absolute temperature (Kelvin).<br>
// Thermodynamic equations are defined by Partials.AbsoluteSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "dp", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelPressureSensor)
// {"<HTML>
// dpSensor measures the pressure drop between flowPort_a and flowPort_b.<br>
// Thermodynamic equations are defined by Partials.RelativeSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "dT", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.RelTemperatureSensor)
// {"<HTML>
// dTSensor measures the temperature difference between flowPort_a and flowPort_b.<br>
// Thermodynamic equations are defined by Partials.RelativeSensor.<br>
// <b>Note:</b> Connected flowPorts have the same temperature (mixing temperature)!<br>
// Since mixing my occur, the outlet temperature of a component may be different from the connector's temperature.<br>
// Outlet temperature is defined by variable T of the corresponding component.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "m", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.MassFlowSensor)
// {"<HTML>
// m_flowSensor measures the mass flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "V", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.VolumeFlowSensor)
// {"<HTML>
// V_flowSensor measures the volume flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-22, -20}, {20, -60}}, "H", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Sensors.EnthalpyFlowSensor)
// {"<HTML>
// H_flowSensor measures the enthalpy flow rate.<br>
// Thermodynamic equations are defined by Partials.FlowSensor.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.FlowPort)
// {"<HTML>
// Basic definition of the connector.<br>
// <b>Variables:</b>
// <ul>
// <li>Pressure p</li>
// <li>flow MassFlowRate m_flow</li>
// <li>Specific Enthalpy h</li>
// <li>flow EnthaplyFlowRate H_flow</li>
// </ul>
// If ports with different media are connected, the simulation is asserted due to the check of parameter.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-80, 0}, {80, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 80}, {0, -80}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-40, -20}, {40, 20}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{40, 20}, {60, 40}, {70, 60}, {74, 80}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-40, -20}, {-60, -40}, {-70, -60}, {-74, -80}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{40, 20}, {40, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{60, 40}, {60, 0}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{40, 20}, {0, 20}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{60, 40}, {0, 40}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{18, 0}, {48, -20}}, "V_flowLaminar", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{50, 0}, {80, -20}}, "V_flowNominal", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, 30}, {-4, 10}}, "dpLaminar", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, 50}, {-4, 30}}, "dpNominal", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, 20}, {30, 0}}, "dp ~ V_flow", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{30, 60}, {60, 40}}, "dp ~ V_flow", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.SimpleFriction)
// {"<HTML>
// Definition of relationship between pressure drop and volume flow rate:<br>
// -V_flowLaminar &lt; VolumeFlow &lt; +V_flowLaminar: laminar i.e. linear dependency of pressure drop on volume flow.<br>
// -V_flowLaminar &gt; VolumeFlow or VolumeFlow &lt; +V_flowLaminar: turbulent i.e. quadratic dependency of pressure drop on volume flow.<br>
// Linear and quadratic dependency are coupled smoothly at V_flowLaminar / dpLaminar.<br>
// Quadratic dependency is defined by nominal volume flow and pressure drop (V_flowNominal / dpNominal).<br>
// See also sketch at diagram layer.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.TwoPort)
// {"<HTML>
// Partial model with two flowPorts.<br>
// Possible heat exchange with the ambient is defined by Q_flow; setting this = 0 means no energy exchange.<br>
// Setting parameter m (mass of medium within pipe) to zero
// leads to neglection of temperature transient cv*m*der(T).<br>
// Mixing rule is applied.<br>
// Parameter 0 &lt; tapT &lt; 1 defines temperature of heatPort between medium's inlet and outlet temperature.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-90, 90}, {90, -90}}, 0, 360), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 90}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.Ambient)
// {"<HTML>
// <p>
// Partial model of (Infinite) ambient, defines pressure and temperature.
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-70, 70}, {70, -70}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, 70}, {0, 40}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{22.9, 32.8}, {40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-22.9, 32.8}, {-40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{37.6, 13.7}, {65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-37.6, 13.7}, {-65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, 0.0}, {9.02, 28.6}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-0.48, 31.6}, {18.0, 26.0}, {18.0, 57.2}, {-0.48, 31.6}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-5, 5}, {5, -5}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{-70, 0}, {-90, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {100, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 130}, {150, 70}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.AbsoluteSensor)
// {"<HTML>
// Partial model for an absolute sensor (pressure/temperature).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-70, 70}, {70, -70}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, 70}, {0, 40}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{22.9, 32.8}, {40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-22.9, 32.8}, {-40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{37.6, 13.7}, {65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-37.6, 13.7}, {-65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, 0.0}, {9.02, 28.6}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-0.48, 31.6}, {18.0, 26.0}, {18.0, 57.2}, {-0.48, 31.6}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-5, 5}, {5, -5}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{-70, 0}, {-90, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {90, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, -100}, {0, -70}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 130}, {150, 70}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.RelativeSensor)
// {"<HTML>
// Partial model for a relative sensor (pressure drop/temperature difference).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-70, 70}, {70, -70}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, 70}, {0, 40}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{22.9, 32.8}, {40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-22.9, 32.8}, {-40.2, 57.3}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{37.6, 13.7}, {65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-37.6, 13.7}, {-65.8, 23.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, 0.0}, {9.02, 28.6}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-0.48, 31.6}, {18.0, 26.0}, {18.0, 57.2}, {-0.48, 31.6}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-5, 5}, {5, -5}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{-70, 0}, {-90, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{70, 0}, {90, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, -100}, {0, -70}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 130}, {150, 70}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.FlowSensor)
// {"<HTML>
// Partial model for a flow sensor (mass flow/heat flow).<br>
// Pressure, mass flow, temperature and enthalpy flow of medium are not affected, but mixing rule is applied.
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.TwoMasses)
// {"<HTML>
// <p>
// This example demonstrates the thermal response of two masses connected by
// a conducting element. The two masses have the same heat capacity but different
// initial temperatures (T1=100 [degC], T2= 0 [degC]). The mass with the higher
// temperature will cool off while the mass with the lower temperature heats up.
// They will each asymptotically approach the calculated temperature <b>T_final_K</b>
// (<b>T_final_degC</b>) that results from dividing the total initial energy in the system by the sum
// of the heat capacities of each element.
// </p>
// <p>
// Simulate for 5 s and plot the variables<br>
// mass1.T, mass2.T, T_final_K or <br>
// Tsensor1.T, Tsensor2.T, T_final_degC
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.ControlledTemperature)
// {"<HTML>
// <P>
// A constant voltage of 10 V is applied to a
// temperature dependent resistor of 10*(1+(T-20C)/(235+20C)) Ohms,
// whose losses v**2/r are dissipated via a
// thermal conductance of 0.1 W/K to ambient temperature 20 degree C.
// The resistor is assumed to have a thermal capacity of 1 J/K,
// having ambient temparature at the beginning of the experiment.
// The temperature of this heating resistor is held by an OnOff-controller
// at reference temperature within a given bandwith +/- 1 K
// by switching on and off the voltage source.
// The reference temperature starts at 25 degree C
// and rises between t = 2 and 8 seconds linear to 50 degree C.
// An approppriate simulating time would be 10 seconds.
// </P>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Examples.Motor)
// {"<HTML>
// <p>
// This example contains a simple second order thermal model of a motor.
// The periodic power losses are described by table \"lossTable\":<br>
// <table>
// <tr><td valign=\"top\">time</td><td valign=\"top\">winding losses</td><td valign=\"top\">core losses</td></tr>
// <tr><td valign=\"top\">   0</td><td valign=\"top\">           100</td><td valign=\"top\">        500</td></tr>
// <tr><td valign=\"top\"> 360</td><td valign=\"top\">           100</td><td valign=\"top\">        500</td></tr>
// <tr><td valign=\"top\"> 360</td><td valign=\"top\">          1000</td><td valign=\"top\">        500</td></tr>
// <tr><td valign=\"top\"> 600</td><td valign=\"top\">          1000</td><td valign=\"top\">        500</td></tr>
// </table><br>
// Since constant speed is assumed, the core losses keep constant
// whereas the winding losses are low for 6 minutes (no-load) and high for 4 minutes (over load).
// <br>
// The winding losses are corrected by (1 + alpha*(T - T_ref)) because the winding's resistance is temperature dependent whereas the core losses are kept constant (alpha = 0).
// </p>
// <p>
// The power dissipation to the environment is approximated by heat flow through
// a thermal conductance between winding and core,
// partially storage of the heat in the winding's heat capacity
// as well as the core's heat capacity and finally by forced convection to the environment.<br>
// Since constant speed is assumed, the cinvective conductance keeps constant.<br>
// Using Modelica.Thermal.FluidHeatFlow it would be possible to model the coolant air flow, too
// (instead of simple dissipation to a constant ambient's temperature).
// </p>
// <p>
// Simulate for 7200 s; plot Twinding.T and Tcore.T.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {175, 175, 175}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-10, -90}, {-10, 0}, {-100, 90}, {-80, 90}, {0, 20}, {80, 90}, {100, 90}, {10, 0}, {10, -90}, {-10, -90}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, -20}, {100, -80}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 80}, {100, 40}}, "m=%m", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Components.ThermalCollector)
// {"<html>
// <p>
// This is a model to collect the heat flows from <i>m</i> heatports to one single heatport.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.HeatPort)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Thermal.HeatTransfer.Interfaces.Element1D)
// {"<HTML>
// <p>
// This partial model contains the basic connectors and variables to
// allow heat transfer models to be created that <b>do not store energy</b>,
// This model defines and includes equations for the temperature
// drop across the element, <b>dT</b>, and the heat flow rate
// through the element from port_a to port_b, <b>Q_flow</b>.
// </p>
// <p>
// By extending this model, it is possible to write simple
// constitutive equations for many types of heat transfer components.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.OverView)
// {"<HTML>
// <p>
// Library <b>MultiBody</b> is a <b>free</b> Modelica package providing
// 3-dimensional mechanical components to model in a convenient way
// <b>mechanical systems</b>, such as robots, mechanisms, vehicles.
// A basic feature is that all components have <b>animation</b> information
// with appropriate default sizes and colors. A typical screenshot of the
// animation of a double pendulum is shown in the figure below, together
// with its schematic.
// </p>
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/DoublePendulumSmall.png\"> &nbsp;&nbsp;
// <IMG SRC=\"../Images/MultiBody/Tutorial/DoublePendulumDiagramSmall.png\"
//   ALT=\"double pendulum (diagram layer)\">
// <p>
// Note, that all components - the coordinate system of the world frame,
// the gravity acceleration vector, the revolute joints and the
// bodies - are visualized in the animation.<br>
// This library replaces the long available ModelicaAdditions.MultiBody
// library, since it is much more easier to use and more powerful.
// The main features of the library are:
// </p>
// <ul>
// <li>About <b>60 main components</b>, i.e., joint, force, part,
//     body, sensor and visualizer components that are ready to use
//     and have useful default animation properties. One-dimensional
//     force laws can be defined with components of the Modelica.Mechanics.Rotational
//     and of the Modelica.Mechanics.Translational library and can be
//     connected via available flange connectors to MultiBody
//     components.
// <li>About <b>75 functions</b> to operate in a convenient way on
//     orientation objects, e.g., to transform vector quantities between
//     frames, or compute the orientation object of a planar rotation.
//     The basic idea is to hide the actual definition of an <b>orientation</b>
//     by providing essentially an <b>Orientation</b> type together with
//     <b>functions</b> operating on instances of this type. Orientation
//     objects based on a 3x3 transformation matrix and on quaternions
//     are provided. As a side effect, the equations in all other
//     components are simpler and easier to understand.</li>
// <li> <b>A World model</b> has to be present in every model on top
//      level. Here the gravity field is defined (currently: no gravity,
//      uniform gravity, point gravity), the visualization of the
//      world coordinate system and default settings for animation.
//      If a world model is not present, it is automatically provided
//      together with a warning message.
// <li><b>Built-in animation properties</b> of all components, such as
//     joints, forces, bodies, sensors. This allows an easy visual
//     check of the constructed model. Animation of every component
//     can be switched off via a parameter. The animation of a complete
//     system can be switched off via one parameter in the <b>world</b>
//     model. If animation is switched off, all equations related
//     to animation are removed from the generated code. This is especially
//     important for real-time simulation.</li>
// <li><b>Automatic handling of kinematic loops</b>.
//     Components can be connected together in a nearly arbitrary fashion.
//     It does not matter whether components are flipped. This does not
//     influence the efficiency. If kinematic loop structures occur,
//     this is automatically handeled in an efficient way by a new
//     technique to transform a certain class of overdetermined sets of
//     differential algebraic equations symbolically to a system where
//     the number of equations and unknowns are the same (the user need
//     <b>not</b> cut loops with special cut-joints to construct a
//     tree-structure). </li>
// <li><b>Automatic state selection from joints and bodies</b>.
//     Most joints and all bodies have potential states. A Modelica
//     translator, such as Dymola, will use the generalized coordinates
//     of joints as states if possible. If this is not possible,
//     states are selected from body coordinates. As a consequence,
//     strange joints with 6 degrees of freedom are not necessary
//     to define a body moving freely in space. An advanced user
//     may select states manually from the <b>Advanced</b> menu of the
//     corresponding components or use a Modelica parameter modification
//     to set the \"stateSelect\" attribute directly. </li>
// <li> <b>Analytic solution of kinematic loops</b>. The non-linear
//     equations occuring in kinematic loops are solved <b>analytically</b>
//     for a large class of mechanisms, such as a 4 bar mechanism,
//     a slider-crank mechanism or a MacPherson suspension. This is performed
//     by constructing such loops with assembly joints JointXXX,
//     available in the Modelica.Mechanics.MultiBody.Joints package. Assembly joints consist
//     of 3 joints that have together 6 degrees of freedom, i.e., no
//     constraints.They do not have potential states. When the motion
//     of the two frame connectors are provided, a non-linear system of
//     equation is solved analytically to compute the motion of the 3 joints.
//     Analytic loop handling is especially important for real-time simulation.</li>
// <li> <b>Line force components may have mass</b>.
//      Masses of line force components are located on the line on which
//      the force is acting. They approximate the mass properties of
//      a real physical device by one or two point masses. For example,
//      a spring has often significant mass that has to be taken into
//      account. If masses are set to zero, the additional code to handle
//      these point masses is removed. If the masses are taken into
//      account, the calculation overhead is small (the reason is that
//      the occuring kinematic loops are analytically solved).<br>
//      Note, in this Beta-release, not all provided line force
//      components have already an optional mass. This will be fixed
//      in the next release.</li>
// <li> <b>Force components may be connected directly together</b>, e.g.,
//      3-dimensional springs in series connection. Usually,
//      multi-body programs have the restriction that force components
//      can only be connected between two bodies. Such restrictions are
//      not present in the Modelica multi-body library, since it is
//      a fully object-oriented, equation based library. Usually, if
//      force components are connected directly together, non-linear
//      systems of equations occur. The advantage is often, that this
//      may avoid stiff systems that would occur if a small mass has
//      to be put in between the two force elements.</li>
// <li><b>Initialization definition is available via menus</b>.
//     Initialization of states in joints and bodies can be
//     performed in the parameter menu, <b>without</b> typing Modelica
//     statements. For non-standard initialization, the usual
//     Modelica commands can be used.</li>
// <li><b>Multi-body specific error messages</b>. Annotations
//     and assert statements have been introduced that provide
//     in many cases warning or error messages that are related
//     to the library components (and not to specific equations
//     as it is usual in Modelica libraries). This requires
//     appropriate tool support, as it is, e.g., available in Dymola.</li>
// <li><b>Inverse models</b> of mechanical systems can be easily
//     defined by using motion generators, e.g.,
//     Modelica.Mechanics.Rotational.Position. Also, non-standard
//     inverse models can be generated, e.g., when elasticity is present
//     it might be necessary to differentiate equations several times.</li>
// </ul>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.FirstExample)
// {"<HTML>
// <p>
// As a first example it shall be demonstrated how to build up, simulate
// and animate a <b>simple pendulum</b>.
// </p>
// <p>
// A simple pendulum consisting of a <b>body</b> and a <b>revolute</b> joint
// with <b>linear damping</b> in the joint, is first build-up as
// Modelica composition diagram, resulting in:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/FirstExample/PenulumSchematic1.png\"
// ALT=\"Modelica composition diagram of simple pendulum\">
// </p>
// <p>
// In the following figure the location of the used
// model components is shown. Drag these components in the diagram layer
// and connect them according to the figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/FirstExample/PenulumSchematic2.png\">
// </p>
// <p>
// Every model that uses model components from the MultiBody library
// must have an instance of the Modelica.Mechanics.MultiBody.World model on highest level.
// The reason is that in the world object the gravity field is defined
// (uniform gravity or point gravity), as well as the default sizes of
// animation shapes and this information is reported to all used
// components. If the World object is missing, a warning message is
// printed and an instance of the World object with default settings is
// automatically utilized (this feature is defined with annotations and
// is, e.g., supported by Dymola).
// </p>
// <p>
// In a second step the parameters of the dragged components need to be
// defined. Some parameters are vectors that have to be defined with respect
// to a local coordinate system of the corresponding component. The easiest
// way to perform this is to define a <b>reference configuration</b> of your
// multi-body model: In this configuration, the relative coordinates of
// all joints are zero. This means that all coordinate systems on all
// components are parallel to each other. Therefore, this just means
// that all vectors are resolved in the world frame in this configuration.
// </p>
// <p>
// The reference configuration for the simple pendulum shall be defined
// in the following way: The y-axis of the world frame is directed
// upwards, i.e., the opposite direction of the gravity acceleration.
// The x-axis of the world frame is orthogonal to it. The revolute joint
// is placed in the origin of the world frame. The rotation axis of the revolute
// joint is directed along the z-axis of the world frame. The body is
// placed on the x-axis of the world frame (i.e., the rotation angle of the
// revolute joint is zero, when the body is on the x-axis).
// In the following figures the definition of this reference configuration
// is shown in the parameter menus of the revolute joint and the body:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/FirstExample/ActuatedRevolute.png\">
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/FirstExample/Body.png\">
// </p>
// <p>
// Translate and simulate the model, e.g., with Dymola.
// Automatically, all defined components are visualized in
// an animation using default absolute or relative sizes
// of the components. For example, a body is visualized as
// a sphere and as a cylinder. The default size of the sphere is defined
// as parameter in the world object. You may change this size
// in the \"Animation\" parameter menu of the body (see parameter menu
// above). The default size of the cylinder is defined relatively
// to the size of the sphere (half of the sphere size).
// With default settings, the following animation is defined:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/FirstExample/Pendulum.png\">
// </p>
// <p>
// The world coordinate system is visualized as coordinate system
// with axes labels. The direction of the gravity acceleration
// vector is shown as green arrow. The red cylinder represents
// the rotation axis of the revolute joint and the light blue
// shapes represent the body. The center of mass of the body is
// in the middle of the light blue sphere.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.Introduction)
// {"<HTML>
// <p>
// In principal, now special action is needed, if
// loop structures occur (contrary to the ModelicaAdditions.MultiBody library).
// An example is presented in the figure below. It is available as
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1\">
// MultiBody.Examples.Loops.Fourbar1</a>
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/Fourbar1a.png\">
// </p>
// <p>
// This mechanism consists of 6 revolute joints, 1 prismatic joint and forms a
// kinematical loop.
// It has has one degree of freedom. In the next figure the default animation
// is shown. Note, that the axes of the revolute joints are represented by the
// red cylinders and that the axis of the prismatic joint is represented by the
// red box on the lower right side.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/Fourbar1b.png\" width=\"205\" height=\"107\">
// </p>
// <p>
// Whenever loop structures occur, non-linear algebraic
// equations are present on \"position level\". It is then usually not possible by
// structural analysis to select states during translation (which is possible for
// non-loop structures). In the example above, Dymola detects a non-linear
// algebraic loop of 57 equations and reduces this to a system of 7 coupled
// algebraic equations. Note, that this is performed without using any
// \"cut-joints\" as it is usually done in multi-body programs, but by just
// appropriate symbolic equation manipulation. Via the dynamic dummy derivative
// method the generalized coordinates on position and velocity level from one of
// the 7 joints are dynamically selected as states during simulation. Whenever,
// these two states are no longer appropriate, states from one of the other
// joints are selected during simulation.
// </p>
// <p>
// The efficiency of loop structures can usually be
// enhanced, if states are statically fixed at translation time. For this
// mechanism, the generalized coordinates of joint j1 (i.e., the
// rotation angle of the revolute joint and its derivative) can always be used as
// states. This can be stated by setting parameter \"enforceStates = <b>true</b>\"
// in the \"Advanced\" menu of the desired joint. This flag sets the attribute
// stateSelect of the generalized coordinates of the coresponding joint to
// \"StateSelect.always\". When setting this flag to <b>true</b> for joint j1 in
// the four bar mechanism, Dymola detects a non-linear algebraic loop of 40
// equations and reduces this to a system of 5 coupled non-linear algebraic
// equations.
// </p>
// <p>
// In many mechanisms it is possible to solve the non-linear algebraic
// equations analytically. For a certain class of systems this can
// be performed also with the MultiBody library. This technique
// is described in section
// \"<a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">Analytic loop handling</a>\".
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.PlanarLoops)
// {"<HTML>
// <p>
// In the figure below, the model of a V6 engine is
// shown that has a simple combustion model. It is available as
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6\">
// MultiBody.Examples.Loops.EngineV6</a>.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_1.png\">
// </p>
// <p>
// The Modelica schematic of one cylinder
// is given in the figure below. Connecting 6 instances of this
// cylinder appropriately together results in the engine schematic displayed
// above.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_2.png\">
// </p>
// <p>
// In the next figure the animation of the engine is
// shown. Every cylinder consists essentially of 1 prismatic and 2 revolute
// joints that form a planar loop, since the axes of the two revolute joints are
// parallel to each other and the axis of the prismatic joint is orthogonal to
// the revolute joint axes. All 6 cylinders together form a coupled set of 6
// loops that have together 1 degree of freedom.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_3.png\" width=\"303\" height=\"136\">
// </p>
// <p>
// All planar loops, and especially the engine, result in
// a DAE (= Differential-Algebraic Equation system)
// that does not have a unique solution. The reason is that, e.g., the cut
// forces in direction of the axes of the revolute joints cannot be uniquely
// computed. Any value fulfills the DAE equations. This is a structural property
// that is determined by the symbolic algorithms. Since they detect that the DAE is
// structurally singular, a further processing is not possible. Without
// additional information it is also impossible that the symbolic algorithms
// could be enhanced because if the axes of rotations of the revolute joints are
// only slightly changed such that they are no longer parallel to each other, the
// planar loop can no longer move and has 0 degrees of freedom. Algorithms based
// on pure structural information cannot distinguish these two cases.
// </p>
// <p>
// The usual remedy is to remove superfluous constraints,
// e.g., along the axis of rotation of <b>one</b> revolute joint. Since this is
// not easy for an inexperienced modeler, the special joint:
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Joints.RevolutePlanarLoopConstraint\">
// RevolutePlanarLoopConstraint</a> is provided that removes these constraints.
// Exactly one revolute joint in a every planar loop must be replaced by this
// joint type. In the engine example, this special joinst is used for
// the revolute joint B2 in the cylinder model above. The icon of the joint is
// slightly different to other revolute joints to visualize this case.
// </p>
// <p>
// If a modeler is not aware of the problems with planar
// loops and models them without special consideration, a Modelica
// translator, such as Dymola, displays an error
// message and points out that a planar loop may be the reason and suggests to
// use the RevolutePlanarLoopConstraint joint.
// This error message is due to an annotation in
// the Frame connector.
// </p>
// <pre>
//   <b>connector</b> Frame
//      ...
//      <b>flow</b> SI.Force f[3] <b>annotation</b>(unassignedMessage=\"..\");
//   <b>end</b> Frame;
// </pre>
// <p>
// If no assignment can be found for some
// forces in a connector, the \"unassignedMessage\" is displayed. In most cases the
// reason for this is a planar loop or two joints that constrain the same motion.
// Both cases are discussed in the error message.
// </p>
// <p>
// Note, that the non-linear algebraic equations occurring
// in planar loops can be solved analytically in most cases and therefore it is
// highly recommended to use the techniques discussed in section
// \"<a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">Analytic loop handling</a>\"
// for such systems.
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling)
// {"<HTML>
// It is well known that the non-linear
// algebraic equations of most mechanical loops in technical devices can be
// solved analytically. It is, however, difficult to perform this fully
// automatically and therefore none of the commercial, general purpose multi-body
// programs, such as MSC ADAMS, LMS DADS, SIMPACK, have this feature.
// These programs solve loop structures with pure numerical methods. Multi-body
// programs that are designed for real-time simulation of the dynamics of
// specific vehicles, such as ve-DYNA, usually contain manual implementations
// of a particular multi-body system (the vehicle) where the occurring loops are
// either analytically solved, if this is possible, or are treated by table
// look-up where the tables are constructed in a pre-processing phase. Without
// these features the required real-time capability would be difficult to
// achieve.
// </p>
// <p>
// In a series of papers and dissertations
// Prof. Hiller and his group in Duisburg, Germany,
// have developed systematic methods to handle mechanical
// loops analytically. The \"characteristic pair of joints\" method
// basically cuts a loop at two joints and uses geometric
// invariants to reduce the number of algebraic
// equations, often down to one equation that can be solved analytically. Also
// several multi-body codes have been developed that are based on this method,
// e.g., MOBILE. Besides the very desired feature to solve non-linear
// algebraic equations analytically, i.e., efficiently and in a robust way, there
// are several drawbacks: It is difficult to apply this method automatically.
// Even if this would be possible in a good way, there is always the problem that
// it cannot be guaranteed that the statically selected states lead to no
// singularity during simulation. Therefore, the \"characteristic pair of joints\"
// method is usually manually applied which requires know-how and experience.
// </p>
// <p>
// In the MultiBody library the \"characteristic pair of
// joints\" method is supported in a restricted form such that it can be applied
// also by non-specialists. The idea is to provide aggregations of joints in package
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies\">
// MultiBody.Joints.Assemblies</a>.
// as one object that either have <b>6</b> degrees of freedom or
// <b>3</b> degrees of freedom (for usage in planar loops).
// </p>
// <p>
// As an example, a variant of the four bar mechanism is given in
// the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/FourbarAnalytic1.png\">
// </p>
// <p>
// Here, the mechanism is modeled with one revolute
// joint, two spherical joints and one prismatic joint.
// In the figure below, the two spherical joints
// and the prismatic joint are collected together in an assembly object
// called \"jointSSP\" from
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSP\">
// MultiBody.Joints.Assemblies.JointSSP</a>.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/FourbarAnalytic2.png\">
// </p>
// <p>
// The JointSSP joint aggregation has a frame at the
// left side of the left spherical joint (frame_a) and a frame at the right side
// of the prismatic joint (frame_b). JointSSP, as all other objects from the
// Joints.Assemblies package, has the property, that the <b>generalized
// coordinates, and all other frames
// defined in the assembly, can be calculated given the movement of frame_a and
// of frame_b</b>. This is performed by <b>analytically</b> solving non-linear
// systems of equations (details are given in section xxx). From a
// structural point of view, the equations in an assembly object are written in
// the form
// </p>
// <p align=\"center\">
//   <b>q</b> = <b>
//   f</b><sub>1</sub>(<b>r</b><sup>a</sup>, <b>R</b><sup>a</sup>,<b> r</b><sup>b</sup>,
//   <b>R</b><sup>b</sup>)
// </p>
// <p>
// where<b> r</b><sup>a</sup>, <b>R</b><sup>a</sup>,<b>
// r</b><sup>b</sup>, <b>R</b><sup>b</sup><b> </b>are the variables defining the
// position and orientation of the frame_a and frame_b connector,
// <b>q</b> are the generalized positional coordinates inside the
// assembly, e.g., the angle of a revolute joint. Given angle
// <span style=\"font-family:Symbol\">j</span> of revolute joint j1 from the four
// bar mechanism, frame_a and frame_b of the assembly object can be computed by a
// forward recursion
// </p>
// <p align=\"center\">
// (<b>r</b><sup>a</sup>,
// <b>R</b><sup>a</sup>,<b> r</b><sup>b</sup>, <b>R</b><sup>b</sup>) = <b>f</b>(<span style=\"font-family:Symbol\">j)</span>
// </p>
// <p>
// Since this is a structural property, the
// symbolic algorithms can automatically select <span style=\"font-family:Symbol\">
// j</span> and its derivative as states and then all positional variables can be
// computed in a forwards sequence. It is now understandable that a Modelica
// translator, such as Dymola, can
// transform the equations of the four bar mechanism to a recursive sequence of
// statements that has no non-linear algebraic loops anymore(remember,
// the previous \"straightforward\" solution with 6 revolute joints and 1
// prismatic joint has a nonlinear system of equations of order 5).
// </p>
// <p>
// The aggregated joint
// objects consist of a combination of either a revolute or prismatic joint and
// of a rod that has either two spherical joints at its two ends or a spherical
// and a universal joint, respectively. For all combinations, analytic solutions
// can be determined. For planar loops, combinations of 1, 2 or 3 revolute joints
// with parallel axes and of 2 or 1 prismatic joint with axes that are orthogonal
// to the revolute joints can be treated analytically. The currently supported
// combinations are listed in the table below.
// The missing combinations (such as JointSUP
// or Joint RPP) will be added in one of the next releases.
// </p>
// <div align=\"center\">
//     <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">
//       <tr>
//         <td colspan=\"2\"> <b>3-dimensional Loops:</b></td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointSSR</td>
//         <td valign=\"top\">Spherical - Spherical - Revolute</td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointSSP</td>
//         <td valign=\"top\">Spherical - Spherical - Prismatic</td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointUSR</td>
//         <td valign=\"top\">Universal - Spherical - Revolute</td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointUSP</td>
//         <td valign=\"top\">Universal - Spherical - Prismatic</td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointUPS</td>
//         <td valign=\"top\">Universal - Prismatic - Spherical</td>
//       </tr>
//       <tr>
//         <td colspan=\"2\"><b>Planar Loops:</b></td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointRRR</td>
//         <td valign=\"top\">Revolute - Revolute - Revolute</td>
//       </tr>
//       <tr>
//         <td valign=\"top\">JointRRP</td>
//         <td valign=\"top\">Revolute - Revolute - Prismatic</td>
//       </tr>
// </table>
// </div>
// <p>
// On first view this seems to be quite restrictive. However, mechanical devices are usually built up with rods connected by spherical joints on each end,
// and additionally with revolute and prismatic joints.
// Therefore, the combinations of the above table occur frequently.
// The universal joint is usually not present in actual devices but is used
// (a) if two JointXXX components can be connected such that a revolute
// and a universal joint together form a spherical joint
// and (b) if the orientation of the connecting rod between two
// spherical joints is needed, e.g., since a body shall be attached.
// In this case one of the spherical joints might be replaced by a
// universal joint. This approximation is fine as long as the mass
// and inertia of the rod is not significant.
// </p>
// <p>
// Let us discuss item (a) in more detail: The
// MacPherson suspension in the next figure
// is from the Modelica VehicleDynamics library.
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/MacPherson1.png\">
// </p>
// It has three frame
// connectors. The lower left one (frame_C) is fixed in the vehicle chassis. The
// upper left one (frame_S) is driven by the steering mechanism, i.e., the
// movement of both frames are given. The frame connector on the right (frame_U)
// drives the wheel. The three frames are connected by a mechanism consisting
// essentially of two rods with spherical joints on both ends. These are built up
// by a jointUPS and a jointSSR assembly.
// As can be seen, the universal joint from the jointUPS
// assembly is connected to the revolute joint of the jointSSR assembly.
// Therefore, we have 3 revolute joints connected together at one point and if
// the axes of rotations are chosen appropriately, this describes a spherical
// joint. In other words, the two connected assemblies define the desired two
// rods with spherical joints on each ends.
// </p>
// <p>
// The movement of the chassis, frame_C, is computed
// somewhere else. When the generalized coordinates of revolute joint
// \"innerJoint\" (lower left part in figure) are used as states, then frame_a and
// frame_b of the jointUPS joint can be calculated. After the non-linear loop
// with jointUPS is (analytically) solved, all frames on this assembly are
// known, especially,
// the one connected to frame_b of the jointSSR assembly. Since frame_b of
// jointSSR is connected to frame_S which is computed from the steering
// mechanism, again the two required frame movements of the jointSSR assembly are
// calculated, meaning in turn that also all other frames on the jointSSR
// assembly can be computed, especially, the one connected to frame_U that drives
// the wheel. From this analysis it is clear that a tool is able to solve these
// coupled loops analytically.
// </p>
// <p>
// Another example is the model of the V6 engine,
// see next figure for an animation view and the original definition
// of one cylinder with elementary joints.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_3.png\" width=\"303\" height=\"136\">
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_2.png\">
// </p>
//
// <p>
// It is sufficient to rewrite the basic cylinder model
// by replacing the joints with a JointRRP object that has two
// revolute and one prismatic joint, see next figure.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_4.png\">
// </p>
// <p>
// Since 6
// cylinders are connected together, 6 coupled loops with 6 JointRRP objects are
// present. This model is available as
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic\">
// MultiBody.Examples.Loops.EngineV6_analytic</a>.
// </p>
// <p>
// The composition diagram of the connected 6 cylinders is
// shown in the next figure
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Tutorial/LoopStructures/EngineV6_1.png\">
// </p>
// <p>
// It can be seen that the revolute joint
// of the crank shaft (joint \"bearing\" in left part of figure) might be
// selected as degree of freedom. Then the 4 connector frames of all cylinders
// can be computed. As a result the computations of the cylinders are decoupled
// from each other. Within one cylinder
// the position of frame_a and frame_b of the jointRRP assembly
// can be computed and therefore the generalized coordinates of the two revolute
// and the prismatic joint in the jointRRP object can be determined. From this
// analysis it is not surprising that a Modelica translator, such as Dymola,
// is able to transform the DAE
// equations into a sequential evaluation without any non-linear loop.
// Compare this nice result with the model using only elementary joints
// that leads to a DAE with 6 algebraic loops and 5 non-linear equations per
// loop. Additionally, a linear system of equations of order 43 is present.
// The simulation time is about 5 times faster with the analytic loop handling.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Upgrade)
// {"<HTML>
// <p>
// If different versions of the MultiBody library are not
// compatible to each other, corresponding conversion scripts are
// provided. As a result, models build with an older version
// of the MultiBody library are automatically converted to the
// new version when the model is loaded. The user is prompted
// whether automatic conversion shall take place or not.
// Problems are not to be expected. Still one should first make
// a copy of such a model as backup before the conversion
// is performed.
// </p>
// <p>
// <b><font color=\"#008000\">Upgrade from ModelicaAdditions.MultiBody</font></b>
// </p>
// <p>
// There is now also a conversion script from the \"old\"
// <b>ModelicaAdditions.MultiBody</b> library to the
// \"new\" Modelica.Mechanics.MultiBody library. This script is also
// automatically invoked. Since the differences between the \"old\" and the
// \"new\" MultiBody library are so large, not everything is
// converted and it might be that some pieces have to
// be adapted manually. Still, this script is useful, since
// many class names, parameters and modifiers are
// automatically converted.
// </p>
// <p>
// Components from the following sublibraries
// are automatically converted
// to the Modelica.Mechanics.MultiBody library:
// </p>
// <ul>
// <li> ModelicaAdditions.MultiBody.Parts</li>
// <li> ModelicaAdditions.MultiBody.Joints</li>
// <li> ModelicaAdditions.MultiBody.Forces</li>
// <li> Part of ModelicaAdditions.MultiBody.Interfaces</li>
// </ul>
// <p>
// Models using the ModelicaAdditions.MultiBody library
// that are programmed with <b>equations</b> are only partly converted:
// The Frame connectors will be converted to the \"new\"
// Frame connectors of the MultiBody library, but the equations
// that reference variables of the Frame connectors will
// <b>not</b> be converted. For a manual conversion, the following
// table might be helpful showing how the <b>variables</b> of the
// \"old\" and the \"new\" <b>Frame connectors</b> are
// related to each other (resolve2 and angularVelocity2 are
// functions from library Modelica.Mechanics.MultiBody.Frames):
// </p>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>ModelicaAdditions.MultiBody.<br>
//            Interfaces.Frame_a</b></th>
//     <th><b>MultiBody.Interfaces.Frame_a</b></th></tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>r0</b></td>
//   <td valign=\"top\">= frame_a.r_0 (is converted)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>S</b></td>
//   <td valign=\"top\">= transpose(frame_a.R)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>v</b></td>
//   <td valign=\"top\">= resolve2(frame_a.R, <b>der</b>(frame_a.r_0))</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>w</b></td>
//   <td valign=\"top\">= angularVelocity2(frame_a.R)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>a</b></td>
//   <td valign=\"top\">= resolve2(frame_a.R, <b>der</b>(v_0)); v_0 = der(r_0)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>z</b></td>
//   <td valign=\"top\">= <b>der</b>(w);  w = angulaVelocity2(frame_a.R)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>f</b></td>
//   <td valign=\"top\">= frame_a.f (no conversion needed)</td>
// </tr>
// <tr>
//   <td valign=\"top\">frame_a.<b>t</b></td>
//   <td valign=\"top\">= frame_a.t (no conversion needed)</td>
// </tr>
// </table>
// <p>
// <b><font color=\"#008000\">Upgrade from MultiBody 0.99 (and earlier) to 1.0 (and later)</font></b>
// <p>
// The conversion from MultiBody 0.99 to 1.0 does not work in some rare
// cases, where own components are implemented using functions of the
// MultiBody.Frames package. In this case, the conversion has to be
// performed manually. The changes in 1.0 with regards to 0.99 are:
// </p>
// <p>
// The definition of the Modelica.Mechanics.MultiBody.Frames.Orientation object has changed.
// In 0.99 this was just an alias type for a transformation matrix
// (now Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation).
// In 1.0 the orientation object is a record holding the
// transformation matrix from frame 1 to frame 2 and the angular
// velocity of the transformation matrix resolved in frame 2.
// The reason is that this allows to compute the angular velocity
// in many cases by standard recursive formulas and not by
// differentiation of the transformation matrix. This is usually
// much more efficient. As a consequence, the following
// calls in 0.99 should be changed:
// </p>
// <pre>
//    Frames.angularVelocity1(T,der(T)) -> Frames.angularVelocity1(T)
//    Frames.angularVelocity2(T,der(T)) -> Frames.angularVelocity2(T)
//    Frames.from_T(T)                  -> Frames.from_T2(T,der(T))
// </pre>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Literature)
// {"<html>
// <ul>
// <li>
// Technical details of this library are described in the
// 20 page paper:
// <dl>
// <dt>Otter M., Elmqvist H., and Mattsson S.E.:</dt>
// <dd> <b>The New Modelica MultiBody Library</b>.
//      Modelica 2003 Conference, Link&ouml;ping, Sweden,
//      pp. 311-330, Nov. 3-4, 2003.
//      Download from:
//      <a href=\"http://www.modelica.org/Conference2003/papers/h37_Otter_multibody.pdf\">http://www.modelica.org/Conference2003/papers/h37_Otter_multibody.pdf</a>
//      </dd>
// </dl>
// </li>
// <li>
// The method how to describe drive trains with 1-dimensional mechanics
// and to mount them on 3-dimensional components without neglecting
// dynamical effects is described in:
// <dl>
// <dt>Schweiger C., and Otter M.:</dt>
// <dd> <b>Modelling 3-dim. Mechanical Effects of 1-dim. Powertrains</b>.
//      Modelica 2003 Conference, Link&ouml;ping, Sweden,
//      pp. 149-158, Nov. 3-4, 2003.
//      Download from:
// <a href=\"http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf\">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>
//      </dd>
// </dl>
// </li>
// <li> The method to solve a certain class of kinematic loops
//      analytically is based on:
// <dl>
// <dt>Woernle C.:</dt>
// <dd><b>Ein systematisches Verfahren zur Aufstellung der geometrischen
//     Schliessbedingungen in kinematischen Schleifen mit Anwendung
//     bei der R&uuml;ckw&auml;rtstransformation f&uuml;r
//     Industrieroboter.</b><br>
//     Fortschritt-Berichte VDI, Reihe 18, Nr. 59, Duesseldorf: VDI-Verlag 1988,
//     ISBN 3-18-145918-6.<br>&nbsp;</dd>
// <dt>Hiller M., and Woernle C.:</dt
// <dd><b>A Systematic Approach for Solving the Inverse Kinematic
//     Problem of Robot Manipulators</b>.<br>
//     Proceedings 7th World Congress Th. Mach. Mech., Sevilla 1987. </dd>
// </dl>
// </li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.UsersGuide.Contact)
// {"<html>
// <dl>
// <dt><b>Library Officer:</b>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//     Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//     Institut f&uuml;r Robotik und Mechatronik<br>
//     Abteilung f&uuml;r Entwurfsorientierte Regelungstechnik<br>
//     Postfach 1116<br>
//     D-82230 Wessling<br>
//     Germany<br>
//     email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br>
// </dl>
// <p><b>Acknowledgements:</b></p>
// <ul>
// <li> The central idea to handle a certain class of overdetermined, consistent
//      set of differential algebraic equations (i.e., there are more equations than
//      unknowns) with symbolic transformation algorithms was developed together
//      with Hilding Elmqvist and Sven Erik Mattsson from Dynasim AB, Lund, Sweden.
//      The MultiBody library is heavily relying on this feature which is a
//      prerequiste for a truely \"object-oriented\" multi-body systems library,
//      where components can be connected together in any meaningful way.<li>
// <li> The Examples.Loops.EngineV6 demo of a six cylinder V6 engine with
//      6 planar loops and 1 degree of freedom is from Hilding Elmqvist and
//      Sven Erik Mattsson.</li>
// <li> Modelica.Mechanics.MultiBody.Forces.LineForceWithMass is based on model
//      \"RelativeDistance\" from the Modelica VehicleDynamics library of
//      Johan Andreasson from Royal Institute of Technology, Stockholm, Sweden.</li>
// <li> The 1-dim. components (Parts.Rotor1D, Parts.BevelGear1D, Mounting1D) and
//      Joints.GearConstraints are from Christian Schweiger.</li>
// <li> The design of this library is based on work carried out
//      in the EU RealSim project (Real-time Simulation for Design of
//      Multi-physics Systems) funded by the European Commission within
//      the Information Societies Technology (IST) programme under
//      contract number IST 1999-11979.
//      </li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.World)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Line(true, {0.0, 0.0}, 0, {{-100, -118}, {-100, 61}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 100}, {-120, 60}, {-80, 60}, {-100, 100}, {-100, 100}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-119, -100}, {59, -100}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{99, -100}, {59, -80}, {59, -120}, {99, -100}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-140, 165}, {140, 103}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{95, -113}, {144, -162}}, "%label1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-170, 127}, {-119, 77}}, "%label2", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-56, 78}, {-56, -26}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-68, -26}, {-56, -66}, {-44, -26}, {-68, -26}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{2, 78}, {2, -26}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-10, -26}, {2, -66}, {14, -26}, {-10, -26}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{66, 80}, {66, -26}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{54, -26}, {66, -66}, {78, -26}, {54, -26}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.World)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.World)
// {"<HTML>
// <p>
// Model <b>World</b> represents a global coordinate system fixed in
// ground. This model serves several purposes:
// <ul>
// <li> It is used as <b>inertial system</b> in which
//      the equations of all elements of the MultiBody library
//      are defined.</li>
// <li> It is the world frame of an <b>animation window</b> in which
//      all elements of the MultiBody library are visualized.</li>
// <li> It is used to define the <b>gravity field</b> in which a
//      multi-body model is present. Default is a uniform gravity
//      field where the gravity acceleration vector g is the
//      same at every position. Additionally, a point gravity field
//      can be selected.</li>
// <li> It is used to define <b>default settings</b> of animation properties
//      (e.g. the diameter of a sphere representing by default
//      the center of mass of a body, or the diameters of the cylinders
//      representing a revolute joint).</li>
// <li> It is used to define a <b>visual representation</b> of the
//      world model (= 3 coordinate axes with labels) and of the defined
//      gravity field.<br>
//     <IMG SRC=\"../Images/MultiBody/world.png\" ALT=\"MultiBodys.World\">
// </li>
// </ul>
// <p>
// Since the gravity field function is required from all bodies with mass
// and the default settings of animation properties are required
// from nearly every component, exactly one instance of model World needs
// to be present in every model on the top level. The basic declaration
// needs to be:
// </p>
// <pre>
//     <b>inner</b> Modelica.Mechanics.MultiBody.World world
// </pre>
// <p>
// Note, it must be an <b>inner</b> declaration with instance name <b>world</b>
// in order that this world object can be accessed from all objects in the
// model. When dragging the \"World\" object from the package browser into
// the diagram layer, this declaration is automatically generated
// (this is defined via annotations in model World).
// </p>
// <p>
// All vectors and tensors of a mechanical system are resolved in a
// frame that is local to the corresponding component. Usually,
// if all relative joint coordinates vanish, the local frames
// of all components are parallel to each other, as well as to the
// world frame (this holds as long as a Parts.FixedRotation,
// component is <b>not</b> used). In this \"reference configuration\"
// it is therefore
// alternatively possible to resolve all vectors in the world
// frame, since all frames are parallel to each other.
// This is often very convenient. In order to give some visual
// support in such a situation, in the icon of a World instance
// two axes of the world frame are shown and the labels
// of these axes can be set via parameters.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulum)
// {"<html>
// <p>
// This example demonstrates that by using joint and body
// elements animation is automatically available. Also the revolute
// joints are animated. Note, that animation of every component
// can be switched of by setting the first parameter <b>animation</b>
// to <b>false</b> or by setting <b>enableAnimation</b> in the <b>world</b>
// object to <b>false</b> to switch off animation of all components.
// </p>
//
// <table border=0 cellspacing=0 cellpadding=0><tr><td valign=\"top\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/DoublePendulum.png\"
// ALT=\"model Examples.Elementary.DoublePendulum\">
// </td></tr></table>
//
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ForceAndTorque)
// {"<HTML>
// In this example the usage of the general force element
// \"<a href=\"Modelica://Modelica.Mechanics.MultiBody.Forces.ForceAndTorque\">ForceAndTorque</a>\"
// is shown. A \"ForceAndTorque\" element is connected
// between a body and a fixed point in the world system. The force and torque
// is defined by the \"Constant\" block. The two vectors are resolved in the
// coordinate system defined by the \"fixedRotation\" component that is
// fixed in the world system:
// </p>
// <p>
// The animation view at time = 0 is shown in the figure below.
// The yellow line is directed from frame_a to frame_b of the
// forceAndTorque component. The green arrow characterizes the
// force acting at the body whereas the green double arrow characterizes
// the torque acting at the body. The lengths of the two vectors
// are proportional to the lengths of the force and torque vectors
// (constant scaling factors are defined as parameters in the
// forceAndTorque component):
// </p>
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/ForceAndTorque.png\">
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.FreeBody)
// {"<html>
// <p>
// This example demonstrates:
// </p>
// <ul>
// <li>The animation of spring and damper components</li>
// <li>A body can be freely moving without any connection to a joint.
//     In this case body coordinates are used automatically as
//     states (whenever joints are present, it is first tried to
//     use the generalized coordinates of the joints as states).</li>
// <li>If a body is freely moving, the initial position and velocity of the body
//     can be defined with the \"Initialization\" menu as shown with the
//     body \"body1\" in the left part (click on \"Initialization\").</li>
// </ul>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/FreeBody.png\"
// ALT=\"model Examples.Elementary.FreeBody\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.InitSpringConstant)
// {"<html>
// <p>
// This example demonstrates a non-standard type of initialization
// by calculating a spring constant such
// that a simple pendulum is at a defined position in steady state.
// </p>
// <p>
// The goal is that the pendulum should be in steady state
// when the rotation angle of the pendulum is zero. The spring
// constant of the spring shall be calculated during initialization
// such that this goal is reached.
// </p>
// <p>
// The pendulum has one degree of freedom, i.e., two states.
// Therefore, two additional equations have to be provided
// for initialization. However, parameter \"c\" of the spring
// component is defined with attribute \"fixed = <b>false</b>\", i.e.,
// the value of this parameter is computed during initialization.
// Therefore, there is one additional equation required during
// initialization. The 3 initial equations are the rotational
// angle of the revolute joint and its first and second
// derivative. The latter ones are zero, in order to initialize
// in steady state. By setting the start values of phi, w, a to zero and
// their fixed attributes to true, the required
// 3 initial equations are defined.
// </p>
// <p>
// After translation, this model is initialized in steady-state.
// The spring constant is computed as c = 49.05 N/m.
// An animation of this simulation is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/InitSpringConstant.png\"
// ALT=\"model Examples.Elementary.InitSpringConstant\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses)
// {"<html>
// <p>
// It is demonstrated how to implement line force components
// that shall have mass properties. Two alternative implementations
// are given:
// </p>
// <ul>
// <li> With
//      <a href=\"Modelica://Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS\">JointUPS</a>:<br>
//      Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS is an aggregation
//      of a universal, a prismatic and a spherical joint that approximates
//      a real force component, such as a hydraulic cylinder. At the two
//      frames of the prismatic joint (frame_ia, frame_ib of jointUPS)
//      two bodies are attached. The parameters are selected such that
//      the center of masses of the two bodies are located on the line
//      connecting frame_a and frame_b of the jointUPS component.
//      Both bodies have the same mass and the inertia tensor is set to zero,
//      i.e., the two bodies are treated as point masses.</li>
// <li> With <a href=\"Modelica://Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses\">
//      LineForceWithTwoMasses</a>:<br>
//      Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses is a line force component
//      with the built-in property that two point masses are located
//      on the line on which the line force is acting.
//      The parameters are selected in such a way that the same
//      system as with the jointUPS component is described.</li>
// </ul>
// <p>
// In both cases, a linear 1-dimensional translational damper from the
// Modelica.Mechanics.Translational library is used as
// line force between the two attachment points. Simulate
// this system and plot the differences of the cut forces at both sides
// of the line force component (\"rod_f_diff\" and \"body_f_diff\").
// Both vectors should be zero
// (depending on the choosen relative tolerance of the integration,
// the difference is in the order of 1.e-10 ... 1.e-15).
// </p>
// <p>
// Note, that the implementation with the LineForceWithTwoMasses
// component is simpler and more convenient.
// An animation of this simulation is shown in the figure below.
// The system on the left side in the front is the animation with
// the LineForceWithTwoMasses component whereas the system on the right
// side in the back is the animation with the JointUPS component.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/LineForceWithTwoMasses2.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.Pendulum)
// {"<html>
// <p>
// This simple model demonstrates that by just dragging components
// default animation is defined that shows the structure of the
// assembled system.
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/Pendulum.png\"
// ALT=\"model Examples.Elementary.Pendulum\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PendulumWithSpringDamper)
// {"<html>
// <p>
// A body is attached on a revolute and prismatic joint.
// A 3-dim. spring and a 3-dim. damper are connected between the body
// and a point fixed in the world frame:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/PendulumWithSpringDamper.png\"
// ALT=\"model Examples.Elementary.PendulumWithSpringDamper\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravity)
// {"<HTML>
// <p>
// This model demonstrates a point gravity field. Two bodies
// are placed in the gravity field. The initial positions and velocities of
// these bodies are selected such that one body rotates on a circle and
// the other body rotates on an ellipse around the center of the
// point gravity field.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/PointGravity.png\"
// ALT=\"model Examples.Elementary.PointGravity\">
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses)
// {"<HTML>
// <p>
// This model demonstrates the usage of model Parts.PointMass in a
// point gravity field. The PointMass model has the feature that
// that rotation is not taken into account and can therefore also not be
// calculated. This example demonstrates two cases where this does not matter:
// If a PointMass is not connected (body1, body2), the orientation object in
// these point masses is set to a unit rotation.
// If a PointMass is connected by a line force element, such as
// the used Forces.LineForceWithMass component, then the orientation object
// is set to a unit rotation within the line force element.
// These are the two cases where the rotation is automatically set to
// a default value, when the physical system does not provide the equations.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/PointGravityWithPointMasses.png\">
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.PointGravityWithPointMasses2)
// {"<html>
// <p>
// This model demonstrates the usage of model Parts.PointMass in a
// point gravity field. 6 point masses are connected rigidly together.
// Translating such a model results in an error, because point masses do
// not define an orientation object. The example demonstrates that in such
// a case (when the orientation object is not defined by an object that
// is connected to a point mass), a \"MultiBody.Joints.FreeMotion\" joint
// has to be used, to define the the degrees of freedom of this structure.
// </p>
//
// <p>
// In order to demonstrate that this approach is correct, in model
// \"referenceSystem\", the same system is again provided, but this time
// modeled with a generic body (Parts.Body) where the inertia tensor is
// set to zero. In this case, no FreeMotion object is needed because every
// body provides its absolute translational and rotational position and
// velocity as potential states.
// </p>
//
// <p>
// The two systems should move exactly in the same way. The system with the PointMasses
// object visulizes the point masses in \"red\", whereas the \"referenceSystem\" shows
// its bodies in \"blue\".
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/PointGravityWithPointMasses2.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheel)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetDriving)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.RollingWheelSetPulling)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringDamperSystem)
// {"<html>
// <p>
// This example demonstrates:
// </p>
// <ul>
// <li>The animation of spring and damper components</li>
// <li>A body can be freely moving without any connection to a joint.
//     In this case body coordinates are used automatically as
//     states (whenever joints are present, it is first tried to
//     use the generalized coordinates of the joints as states).</li>
// <li>If a body is freely moving, the initial position and velocity of the body
//     can be defined with the \"Initialization\" menu as shown with the
//     body \"body1\" in the left part (click on \"Initialization\").</li>
// </ul>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/SpringDamperSystem.png\"
// ALT=\"model Examples.Elementary.SpringDamperSystem\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringMassSystem)
// {"<html>
// <p>
// This example shows the two different ways how force laws
// can be utilized:
// </p>
// <ul>
// <li>In the left system a body is attached via a prismatic
//     joint to the world frame. The prismatic joint has two
//     1-dimensional translational flanges (called \"support\" and \"axis\")
//     that allows to connect elements from the Modelica.Mechanics.Translational
//     library between the support and the axis connector. The effect is
//     that the force generated by the 1-dimensional elements acts as driving
//     force in the axis of the prismatic joint. In the example a simple
//     spring is used.<br>
//     The advantage of this approach is that the many elements from the
//     Translational library can be easily used here and that this implementation
//     is usually more efficient as when using 3-dimensional springs.</li>
// <li>In the right system the same model is defined. The difference is
//     that a 3-dimensional spring from the Modelica.Mechanics.MultiBody.Forces library is used.
//     This has the advantage to get a nice animation of the force component.</li>
// </ul>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/SpringMassSystem.png\"
// ALT=\"model Examples.Elementary.SpringMassSystem\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.SpringWithMass)
// {"<html>
// <p>
// This example shows that a force component may have a mass.
// The 3-dimensional spring as used in this example, has an optional
// point mass between the two points where the spring is attached.
// In the animation, this point mass is represented by a small,
// light blue, sphere.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/SpringWithMass.png\"
// ALT=\"model Examples.Elementary.SpringWithMass\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Elementary.ThreeSprings)
// {"<html>
// <p>
// This example demonstrates that <b>3-dimensional line force</b> elements
// (here: Modelica.Mechanics.MultiBody.Forces.Spring elements) can be connected together
// in <b>series</b> without having a body with mass at the
// connection point (as usually required by multi-body programs).
// This is advantageous since stiff systems can be avoided, say, due to
// a stiff spring and a small mass at the connection point.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Elementary/ThreeSprings.png\"
// ALT=\"model Examples.Elementary.ThreeSprings\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a)
// {-100.0,-120.0,150.0,120.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a)
// {"<html>
// <p>
// This is a model of the mechanical part of one cylinder of an engine.
// The combustion is not modelled. The \"inertia\" component at the lower
// left part is the output inertia of the engine driving the gearbox.
// The angular velocity of the output inertia has a start value of 10 rad/s
// in order to demonstrate the movement of the engine.
// </p>
// <p>
// The engine is modeled solely by revolute and prismatic joints.
// Since this results in a <b>planar</b> loop there is the well known
// difficulty that the cut-forces perpendicular to the loop cannot be
// uniquely computed, as well as the cut-torques within the plane.
// This ambiguity is resolved by using the option <b>planarCutJoint</b>
// in the <b>Advanced</b> menu of one revolute joint in every planar loop
// (here: joint B1). This option sets the cut-force in direction of the
// axis of rotation, as well as the cut-torques perpendicular to the axis
// of rotation at this joint to zero and makes the problem mathematically
// well-formed.
// </p>
// <p>
// An animation of this example is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b)
// {-100.0,-120.0,150.0,120.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{3, 117}, {88, -23}}, 0), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, {{65, -30}, {145, -39}}, "jointRRP in model", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, {{66, -34}, {141, -52}}, "Loops.Engine1b_analytic", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b)
// {"<html>
// <p>
// This is a model of the mechanical part of one cylinder of an engine.
// It is similiar to
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1a#diagram\">Loops.Engine1a</a>.
// The difference is that a simple
// model for the gas force in the cylinder is added and that the
// model is restructured in such a way, that the central part of
// the planar kinematic loop can be easily replaced by the
// assembly joint \"Modelica.Mechanics.MultiBody.Joints.Assemblies.<b>JointRRP</b>\".
// This exchange of the kinematic loop is shown in
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic#diagram\">Loops.Engine1b_analytic</a>.
// The advantage of using JointRRP is, that the
// non-linear algebraic equation of this loop is solved analytically, and
// not numerically as in this model (Engine1b).
// </p>
// <p>
// An animation of this example is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic)
// {-100.0,-120.0,150.0,120.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b_analytic)
// {"<html>
// <p>
// This is the same model as
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b#diagram\">Loops.Engine1b</a>.
// The only difference is that the central part of
// the planar kinematic loop has been replaced by the
// assembly joint \"Modelica.Mechanics.MultiBody.Joints.Assemblies.<b>JointRRP</b>\".
// The advantage of using JointRRP is, that the
// non-linear algebraic equation of this loop is solved analytically, and
// not numerically as in
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b#diagram\">Loops.Engine1b</a>.
// </p>
// <p>
// An animation of this example is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6)
// {-120.0,-100.0,120.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6)
// {"<HTML>
// <p>
// This is a V6 engine with 6 cylinders. It is hierarchically built
// up by using instances of one cylinder. For more details on the
// modeling of one cylinder, see example
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Loops.Engine1b\">Engine1b</a>.
// An animation of the engine is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/EngineV6.png\" ALT=\"model Examples.Loops.EngineV6\">
// </p>
//
// <p>
// Simulate for 5 s, and plot the variables <b>engineSpeed_rpm</b>,
// <b>engineTorque</b>, and <b>filteredEngineTorque</b>. Note, the result file has
// a size of about 50 Mbyte (for 5000 output intervalls).
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.EngineV6_analytic)
// {"<HTML>
// <p>
// This is a similar model as the example \"EngineV6\". However, the cylinders
// have been built up with component Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR that
// solves the non-linear system of equations in an aggregation of 3 revolution
// joints <b>analytically</b> and only one body is used that holds the total
// mass of the crank shaft:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/EngineV6_CAD_small.png\">
// </p>
// <p>
// This model is about 20 times faster as the EngineV6 example and <b>no</b> linear or
// non-linear system of equations occur. In contrast, the \"EngineV6\" example
// leads to 6 systems of nonlinear equations (every system has dimension = 5, with
// Evaluate=false and dimension=1 with Evaluate=true) and a linear system of equations
// of about 40. This shows the power of the analytic loop handling.
// </p>
//
// <p>
// Simulate for 5 s, and plot the variables <b>engineSpeed_rpm</b>,
// <b>engineTorque</b>, and <b>filteredEngineTorque</b>. Note, the result file has
// a size of about 50 Mbyte (for 5000 output intervalls).
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar1)
// {"<html>
// <p>
// This is a simple kinematic loop consisting of 6 revolute joints, 1 prismatic joint
// and 4 bars that is often used as basic constructing unit in mechanisms.
// This example demonstrates that usually no particular knowledge
// of the user is needed to handle kinematic loops.
// Just connect the joints and bodies together according
// to the real system. In particular <b>no</b> cut-joints or a spanning tree has
// to be determined. In this case, the initial condition of the angular velocity
// of revolute joint j1 is set to 300 deg/s in order to drive this loop.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Fourbar1.png\" ALT=\"model Examples.Loops.Fourbar1\">
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar2)
// {"<html>
// <p>
// This is a second version of the \"four-bar\" mechanism, see figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Fourbar2.png\" ALT=\"model Examples.Loops.Fourbar2\">
// </p>
// <p>
// In this case
// the three revolute joints on the left top-side and the two revolute
// joints on the right top side have been replaced by the joint <b>UniversalSpherical</b>
// that is a rod connecting a spherical and a universal joint. This joint is defined
// by <b>1 constraint</b> stating that the distance between the two spherical joints is
// constant. Using this joint in a kinematic loop reduces the sizes of
// non-linear algebraic equations. For this loop, only one non-linear
// algebraic system of equations of order 1 remains.
// </p>
// <p>
// At the UniversalSpherical joint an additional frame_ia fixed to the rod
// is present where components can be attached to the connecting rod. In this
// example just a coordinate system is attached to visualize frame_ia (coordinate
// system on the right in blue color).
// </p>
// <p>
// Another feature is that the length of the connecting rod can be
// automatically calculated during <b>initialization</b>. In order to do this,
// another initialization condition has to be given. In this example, the
// initial value of the distance of the prismatic joint j2 has been fixed
// (via the \"Initialization\" menu) and the rod length of joint
// \"UniversalSpherical\" is computed during initialization since parameter
// <b>computeLength</b> = <b>true</b> is set in the joint parameter
// menu. The main advantage is that during initialization no non-linear
// system of equation is solved and therefore initialization always works.
// To be precise, the following trivial non-linear equation is actually solved
// for rodLength:
// </p>
// <pre>
//    rodLength*rodLength = f(angle of revolute joint, distance of prismatic joint)
// </pre>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Fourbar_analytic)
// {"<html>
// <p>
// This is a third version of the \"four-bar\" mechanism, see figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Fourbar_analytic.png\" ALT=\"model Examples.Loops.Fourbar_analytic\">
// </p>
// <p>
// In this case
// the three revolute joints on the left top-side and the two revolute
// joints on the right top side have been replaced by the assembly joint
// <b>Joints.Assemblies.JointSSP</b>
// which consists of two spherical joints and one prismatic joint.
// Since JointSSP solves the non-linear constraint equation internally
// analytically, no non-linear equation appears any more and a Modelica
// translator, such as Dymola, can transform the system into state space
// form without solving a system of equations. For more details, see
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">
// MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling</a>.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.PlanarLoops_analytic)
// {"<html>
// <p>
// It is demonstrated how the Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR joint can be
// used to solve the non-linear equations of coupled planar loops analytically.
// In the mechanism below no non-linear equation occurs any more from the tool
// view, since these equations are solved analytically in the JointRRR joints.
// For more details, see
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling\">
// MultiBody.UsersGuide.Tutorial.LoopStructures.AnalyticLoopHandling</a>.
// </p>
//
// <p>
// In the following figure the parameter vectors of this example are visualized in the
// animation view.
// </p>
//
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/PlanarLoops2.png\" ALT=\"model Examples.Loops.PlanarLoops2\">
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder)
// {-100.0,-150.0,100.0,150.0,true,0.1,1.0,1.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, -50}, {-60, 100}, {60, 100}, {60, -52}, {100, -52}, {100, 150}, {-100, 150}, {-100, -50}, {-60, -50}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.VerticalCylinder, 0.25, BorderPattern.None, {{-58, 89}, {58, 13}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 81}, {60, 75}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 67}, {60, 61}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 55}, {60, 49}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.None, FillPattern.Solid, 0.25, {{-60, 11}, {-42, 23}, {38, 23}, {56, 11}, {-60, 11}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-6, 41}, {2, 33}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, -129}, {40, -49}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{0, -90}, {26, -58}, {-2, 37}}, {0, 0, 0}, LinePattern.Solid, 1, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, -124}, {164, -186}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, -90}, {100, -91}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder)
// {-100.0,-150.0,100.0,150.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 50}, {90, -50}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-40, 50}, {-20, -50}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 10}, {-40, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{60, 2}, {54, 2}, {0, 2}, {0, 10}, {-20, 0}, {0, -10}, {0, -4}, {60, -4}, {60, 2}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 120}, {100, 60}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 50}, {90, -50}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-40, 50}, {-20, -50}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-90, 10}, {-40, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {255, 0, 0}, {255, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{60, 2}, {54, 2}, {0, 2}, {0, 10}, {-20, 0}, {0, -10}, {0, -4}, {60, -4}, {60, 2}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 120}, {100, 60}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.GasForce)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, -61}, {-60, 64}, {60, 64}, {60, -61}, {100, -61}, {100, 114}, {-100, 114}, {-100, -61}, {-60, -61}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.VerticalCylinder, 0.25, BorderPattern.None, {{-58, 63}, {58, -13}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 55}, {60, 49}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 41}, {60, 35}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-60, 29}, {60, 23}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.None, FillPattern.Solid, 0.25, {{-57, -13}, {-39, -1}, {41, -1}, {59, -13}, {-57, -13}}, Smooth.None), Ellipse(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-6, 15}, {2, 7}}, 0, 360), Ellipse(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-41, -139}, {39, -59}}, 0, 360), Line(true, {0.0, 0.0}, 0, {{-1, -99}, {25, -67}, {-2, 10}}, {0, 0, 0}, LinePattern.Solid, 1, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-156, 178}, {158, 116}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, -99}, {100, -100}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.CylinderBase)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Cylinder_analytic_CAD)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-137, 160}, {137, 104}}, "%name", 0, TextAlignment.Center), Bitmap(true, {0.0, 0.0}, 0, {{-97, 75}, {99, -39}}, "../../../../Images/MultiBody/Examples/Loops/EngineV6_CAD.png")}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.EngineV6_analytic)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase)
// {-100.0,-120.0,150.0,120.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.Engine1bBase)
// {"<html>
// <p>
// This is a model of the mechanical part of one cylinder of an engine.
// The combustion is not modelled. The \"inertia\" component at the lower
// left part is the output inertia of the engine driving the gearbox.
// The angular velocity of the output inertia has a start value of 10 rad/s
// in order to demonstrate the movement of the engine.
// </p>
// <p>
// The engine is modeled solely by revolute and prismatic joints.
// Since this results in a <b>planar</b> loop there is the well known
// difficulty that the cut-forces perpendicular to the loop cannot be
// uniquely computed, as well as the cut-torques within the plane.
// This ambiguity is resolved by using the option <b>planarCutJoint</b>
// in the <b>Advanced</b> menu of one revolute joint in every planar loop
// (here: joint B1). This option sets the cut-force in direction of the
// axis of rotation, as well as the cut-torques perpendicular to the axis
// of rotation at this joint to zero and makes the problem mathematically
// well-formed.
// </p>
// <p>
// An animation of this example is shown in the figure below.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Loops/Engine.png\" ALT=\"model Examples.Loops.Engine\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.oneAxis)
// {"<HTML>
// <p>
// With this model one axis of the r3 robot is checked.
// The mechanical structure is replaced by a simple
// load inertia.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot)
// {-100.0,-100.0,100.0,100.0,true,0.1,0.5,0.5,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-99.5, 100.0}, {100.0, -100.0}}, 0), Bitmap(true, {0.0, 0.0}, 0, {{-75.5, 98.25}, {87.0, -96.75}}, "../../../../Images/MultiBody/Examples/Systems/robot_kr15.bmp"), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-111.5, 130.0}, {108.5, 100.0}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-104.5, -104.0}, {115.0, -128.0}}, "mLoad=%mLoad", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot)
// {-100.0,-100.0,100.0,100.0,true,0.1,0.5,0.5}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.fullRobot)
// {"<HTML>
// <p>
// This is a detailed model of the robot. For animation CAD data
// is used. Translate and simulate with the default settings
// (default simulation time = 3 s). Use command script \"Scripts\\ExamplesfullRobotPlot.mos\"
// to plot variables.
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Examples/Systems/r3_fullRobot.png\" ALT=\"model Examples.Loops.Systems.RobotR3.fullRobot\">
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisControlBus)
// {"<html>
// <p>
// Signal bus that is used to communicate all signals for <b>one</b> axis.
// This is an expandable connector which is \"empty\".
// The actual signal content is defined by connecting to an instance
// of this connector. The signals that are usually used
// (and are by default listed as choices in the menu that defines
// the connection to this bus) are defined
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus\">here</a>.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.ControlBus)
// {"<html>
// <p>
// Signal bus that is used to communicate <b>all signals</b> of the robot.
// This is an expandable connector which is \"empty\".
// The actual signal content is defined by connecting to an instance
// of this connector. The sub-buses that are usually used
// (and are by default listed as choices in the menu that defines
// the connection to this bus) are defined
// <a href=\"Modelica://Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus\">here</a>.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 110}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 90}, {-88, 68}, {-72, 68}, {-80, 88}, {-80, 90}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, 78}, {-80, -82}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {82, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-42, 55}, {29, 12}}, "w", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, 0}, {-41, 69}, {26, 69}, {58, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-73, -44}, {82, -69}}, "1 axis", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning1)
// {"<html>
// <p>
// Given
// </p>
// <ul>
// <li> start and end angle of an axis</li>
// <li> maximum speed of the axis </li>
// <li> maximum acceleration of the axis </li>
// </ul>
//
// <p>
// this component computes the fastest movement under the
// given constraints. This means, that:
// </p>
//
// <ol>
// <li> The axis accelerates with the maximum acceleration
//      until the maximum speed is reached.</li>
// <li> Drives with the maximum speed as long as possible.</li>
// <li> Decelerates with the negative of the maximum acceleration
//      until rest.</li>
// </ol>
//
// <p>
// The acceleration, constant velocity and deceleration
// phase are determined in such a way that the movement
// starts form the start angles and ends at the end angles.
// The output of this block are the computed angles, angular velocities
// and angular acceleration and this information is stored as reference
// motion on the controlBus of the r3 robot.
// </p>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 100}, {100, -100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 110}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 90}, {-88, 68}, {-72, 68}, {-80, 88}, {-80, 90}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, 78}, {-80, -82}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, 0}, {82, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-42, 55}, {29, 12}}, "w", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, 0}, {-41, 69}, {26, 69}, {58, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-70, -43}, {85, -68}}, "6 axes", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathPlanning6)
// {"<html>
// <p>
// Given
// </p>
// <ul>
// <li> start and end angles of every axis</li>
// <li> maximum speed of every axis </li>
// <li> maximum acceleration of every axis </li>
// </ul>
//
// <p>
// this component computes the fastest movement under the
// given constraints. This means, that:
// </p>
//
// <ol>
// <li> Every axis accelerates with the maximum acceleration
//      until the maximum speed is reached.</li>
// <li> Drives with the maximum speed as long as possible.</li>
// <li> Decelerates with the negative of the maximum acceleration
//      until rest.</li>
// </ol>
//
// <p>
// The acceleration, constant velocity and deceleration
// phase are determined in such a way that the movement
// starts form the start angles and ends at the end angles.
// The output of this block are the computed angles, angular velocities
// and angular acceleration and this information is stored as reference
// motion on the controlBus of the r3 robot.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 98}, {-24, 68}}, "q", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, 46}, {-18, 16}}, "qd", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, -16}, {-20, -46}}, "qdd", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-2, 20}, {80, -18}}, "%axisUsed", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{2, 52}, {76, 28}}, "axis", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, -70}, {32, -96}}, "moving", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.PathToAxisControlBus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-100, 10}, {-60, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {128, 128, 128}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, {{-60, 10}, {-60, 20}, {-40, 40}, {-40, -40}, {-60, -20}, {-60, 10}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-40, 60}, {40, -60}}, 0), Polygon(true, {0.0, 0.0}, 0, {128, 128, 128}, {128, 128, 128}, LinePattern.Solid, FillPattern.Solid, 0.25, {{60, 20}, {40, 40}, {40, -40}, {60, -20}, {60, 20}}, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{60, 10}, {100, -10}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-60, -90}, {-50, -90}, {-20, -30}, {20, -30}, {48, -90}, {60, -90}, {60, -100}, {-60, -100}, {-60, -90}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, 128}, {0, 68}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-36, 40}, {38, -30}}, "2", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.GearType2)
// {"<html>
// <p>
// The elasticity and damping in the gearboxes of the outermost
// three joints of the robot is neglected.
// Default values for all parameters are given for joint 4.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, 120}, {0, 60}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{80, -102}, {80, -10}}, {255, 204, 51}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Motor)
// {"<html>
// <p>
// Default values are given for the motor of joint 1.
// The input of the motor is the desired current
// (the actual current is proportional to the torque
// produced by the motor).
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {235, 235, 235}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, -100}, {100, 100}}, 0), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-30, 54}, {30, 24}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-30, 40}, {-60, 50}, {-60, 30}, {-30, 40}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-31, -41}, {-78, -41}, {-78, 39}, {-30, 39}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-30, -26}, {30, -56}}, 0), Polygon(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{60, -32}, {30, -42}, {60, -52}, {60, -32}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{30, 39}, {76, 39}, {76, -41}, {30, -41}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 150}, {100, 110}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.Controller)
// {"<html>
// <p>
// This controller has an inner PI-controller to control the motor speed,
// and an outer P-controller to control the motor position of one axis.
// The reference signals are with respect to the gear-output, and the
// gear ratio is used in the controller to determine the motor
// reference signals. All signals are communicated via the
// \"axisControlBus\".
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {160, 160, 164}, LinePattern.Solid, FillPattern.HorizontalCylinder, 0.25, BorderPattern.None, {{-100, 50}, {100, -50}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 57}, {150, 97}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.AxisType2)
// {"<HTML>
// <p>
// The axis model consists of the <b>controller</b>, the <b>motor</b> including current
// controller and the <b>gearbox</b> including gear elasticity and bearing friction.
// The only difference to the axis model of joints 4,5,6 (= model axisType2) is
// that elasticity and damping in the gear boxes are not neglected.
// </p>
// <p>
// The input signals of this component are the desired angle and desired angular
// velocity of the joint. The reference signals have to be \"smooth\" (position
// has to be differentiable at least 2 times). Otherwise, the gear elasticity
// leads to significant oscillations.
// </p>
// <p>
// Default values of the parameters are given for the axis of joint 1.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure)
// {-200.0,-200.0,200.0,200.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-200, 200}, {200, -200}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, 280}, {200, 200}}, "%name", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, -150}, {-140, -190}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, -30}, {-140, -70}}, "3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, -90}, {-140, -130}}, "2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, 90}, {-140, 50}}, "5", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-200, 28}, {-140, -12}}, "4", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-198, 150}, {-138, 110}}, "6", 0, TextAlignment.Center), Bitmap(true, {0.0, 0.0}, 0, {{-130, 195}, {195, -195}}, "../../../../Images/MultiBody/Examples/Systems/robot_kr15.bmp")}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure)
// {-200.0,-200.0,200.0,200.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.MechanicalStructure)
// {"<HTML>
// <p>
// This model contains the mechanical components of the r3 robot
// (multibody system).
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.AxisControlBus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Systems.RobotR3.Components.InternalConnectors.ControlBus)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GyroscopicEffects)
// {"<html>
// <p>
// This example consists of a body that is attached to the world system
// with a spherical joint. On this body, a \"rotor\", i.e., a body with rotational
// symmetry is present. Two kinds of models are shown:
// </p>
//
// <ul>
// <li> In the upper part of the diagram layer, only multi-body components are used.</li>
// <li> In the lower part of the diagram layer, the same model is implemented,
//      but by a different modeling of the cylindrical body:
//      The cylindrical body is included, but it is rigidly attached to its mount.
//      This part takes into account the movement of the center of mass and of
//      the inertia tensor of the cylindrical body. Note, since the cylindrical body
//      has rotational symmetry, its center of mass and its inertia tensor is independent
//      of the angle of the inertia and can therefore be rigidly attached to its mount.
//      Additionally, with a \"MultiBody.Parts.Rotor1D\" model, a primarily 1-dim.
//      inertia is included that takes into account the additional effects when the
//      cylindrical body is moving relatively to its mounts</li>
// </ul>
//
// <p>
// The simulation reveals that both the kinematic movement and the reaction forces on the
// environment (object \"world\" and \"fixed\" respectively) are identical for both models.
// </p>
//
// <p>
// A typical usage scenario is to model a complete drive train of a vehicle, including
// the automatic gearbox, with elements of the \"Mechanics.Rotational\" library, but using
// the \"Rotor1D\" model instead of the \"Rotational.Components.Inertia\" component.
// This drive train model can be mounted on a 3-dim. multi-body model of the vehicle.
// Additionally, one rigid body has to be fixed to the vehicle that has the mass, center
// of mass and inertia tensor of the complete drive train. Both models together, give
// exactly the same effect, as if every part of the drive train would have been modelled
// solely with mult-body components. One benefit of this modeling is that the simulation
// is much faster.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.ActuatedDrive)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.MovingActuatedDrive)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Examples.Rotational3DEffects.GearConstraint)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-89, -46}, {91, -76}}, "resolve", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-100, 10}, {50, 10}, {50, 31}, {94, 0}, {50, -31}, {50, -10}, {-100, -10}, {-100, 10}}, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-149, 103}, {136, 42}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, -10}, {0, -95}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForce)
// {"<HTML>
//
// <p>
// The <b>3</b> signals of the <b>force</b> connector are interpreted
// as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
// connector to which frame_b of this component is attached.
// Via parameter <b>resolveInFrame</b> it is defined, in which frame these
// coordinates shall be resolved:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve input force in world frame (= default)</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve input force in frame_b</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
//
// <p>
// If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force coordinates
// are with respect to the frame, that is connected to <b>frame_resolve</b>.
// <p>
//
// <p>
// If force={100,0,0}, and for all parameters the default setting is used,
// then the interpretation is that a force of 100 N is acting along the positive
// x-axis of frame_b.
// </p>
//
// <p>
// Note, the cut-torque in frame_b (frame_b.t) is always set to zero.
// Conceptually, a force and torque acts on the world frame in such a way that
// the force and torque balance between world.frame_b and frame_b is fulfilled.
// For efficiency reasons, this reaction torque is, however, not computed.
// </p>
//
// <p>
// This force component is by default visualized as an arrow
// acting at the connector to which it is connected. The diameter
// and color of the arrow can be defined via
// variables <b>diameter</b> and <b>color</b>. The arrow
// points in the direction defined by the
// force signal. The length of the arrow is proportional
// to the length of the force vector using parameter
// <b>N_to_m</b> as scaling factor. For example, if N_to_m = 100 N/m,
// then a force of 350 N is displayed as an arrow of length 3.5 m.
// </p>
// <p>
// An example how to use this model is given in the
// following figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldForce1.png\">
// </p>
// <p>
// This leads to the following animation
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldForce2.png\">
// </p>
//
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-61, 64}, {46, 27}}, "resolve", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-145, -28}, {140, -89}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 95}, {0, 82}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-100, 0}, {-94, 13}, {-86, 28}, {-74, 48}, {-65, 60}, {-52, 72}, {-35, 81}, {-22, 84}, {-8, 84}, {7, 80}, {19, 73}, {32, 65}, {44, 55}, {52, 47}, {58, 40}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{94, 10}, {75, 59}, {41, 24}, {94, 10}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldTorque)
// {"<HTML>
//
// <p>
// The <b>3</b> signals of the <b>torque</b> connector are interpreted
// as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
// connector to which frame_b of this component is attached.
// Via parameter <b>resolveInFrame</b> it is defined, in which frame these
// coordinates shall be resolved:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve input torque in world frame (= default)</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve input torque in frame_b</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
//
// <p>
// If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the torque coordinates
// are with respect to the frame, that is connected to <b>frame_resolve</b>.
// <p>
//
// <p>
// If torque={100,0,0}, and for all parameters the default setting is used,
// then the interpretation is that a torque of 100 N is acting along the positive
// x-axis of frame_b.
// </p>
//
// <p>
// Note, the cut-force in frame_b (frame_b.f) is always set to zero.
// Conceptually, a force and torque acts on the world frame in such a way that
// the force and torque balance between world.frame_b and frame_b is fulfilled.
// For efficiency reasons, this reaction torque is, however, not computed.
// </p>
//
// <p>
// This torque component is by default visualized as a <b>double arrow</b>
// acting at the connector to which it is connected. The diameter
// and color of the arrow can be defined via
// variables <b>diameter</b> and <b>color</b>. The double arrow points
// in the direction defined by the
// torque vector. The length of the double arrow is proportional
// to the length of the torque vector using parameter
// <b>Nm_to_m</b> as scaling factor. For example, if Nm_to_m = 100 Nm/m,
// then a torque of 350 Nm is displayed as an arrow of length 3.5 m.
// </p>
// <p>
// An example how to use this model is given in the
// following figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldTorque1.png\">
// </p>
// <p>
// This leads to the following animation
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldTorque2.png\">
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-63, 56}, {44, 19}}, "resolve", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-151, -73}, {134, -134}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, 60}, {-86, 68}, {-80, 72}, {-70, 78}, {-64, 82}, {-46, 86}, {-34, 88}, {-16, 88}, {-2, 86}, {12, 80}, {24, 74}, {34, 68}, {46, 58}, {52, 54}, {58, 48}}, {0, 0, 0}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{89, 17}, {64, 76}, {30, 41}, {89, 17}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 95}, {0, -26}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, 0}, {96, 0}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-104, -48}, {54, 0}, {46, 20}, {96, 0}, {66, -42}, {60, -22}, {-96, -72}, {-104, -48}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque)
// {"<HTML>
// <p>
// The <b>3</b> signals of the <b>force</b> and <b>torque</b>
// connector are interpreted
// as the x-, y- and z-coordinates of a <b>force</b> and
// <b>torque</b> acting at the frame
// connector to which frame_b of this component is attached.
// Via parameter <b>resolveInFrame</b> it is defined, in which frame these
// coordinates shall be resolved:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve input forceand torque in world frame (= default)</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve input force and torque in frame_b</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve input force and torque in frame_resolve
//                     (frame_resolve must be connected)</td></tr>
// </table>
//
// <p>
// If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force and
// torque coordinates
// are with respect to the frame, that is connected to <b>frame_resolve</b>.
// <p>
//
// <p>
// If force={100,0,0}, and for all parameters the default setting is used,
// then the interpretation is that a force of 100 N is acting along the positive
// x-axis of frame_b.
// </p>
//
// <p>
// Conceptually, a force and torque acts on the world frame in such a way that
// the force and torque balance between world.frame_b and frame_b is fulfilled.
// For efficiency reasons, this reaction torque is, however, not computed.
// </p>
//
// <p>
// The force and torque are by default visualized as an arrow (force)
// and as a double arrow (torque) acting at the connector to which
// they are connected. The diameters
// and colors of the arrows can be defined via
// variables <b>forceDiameter</b>, <b>torqueDiameter</b>,
// <b>forceColor</b> and <b>torqueColor</b>. The arrows
// point in the directions defined by the
// force and torque vectors. The lengths of the arrows are proportional
// to the length of the force and torque vectors, respectively, using parameters
// <b>N_to_m</b> and <b>Nm_to_m</b> as scaling factors. For example, if N_to_m = 100 N/m,
// then a force of 350 N is displayed as an arrow of length 3.5 m.
// </p>
// <p>
// An example how to use this model is given in the
// following figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldForceAndTorque1.png\">
// </p>
// <p>
// This leads to the following animation
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/WorldForceAndTorque2.png\">
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.Force)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 255, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-98, 99}, {99, -98}}, 0), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-92, 61}, {87, 35}}, "resolve", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-136, -52}, {149, -113}}, "%name", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{40, 100}, {40, 0}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-94, 0}, {-64, 11}, {-64, -10}, {-94, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-60, 100}, {40, 100}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{94, 0}, {65, 12}, {65, -11}, {94, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-64, 0}, {-20, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{20, 0}, {65, 0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Force)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.Force)
// {"<html>
// <p>
// The <b>3</b> signals of the <b>force</b> connector are interpreted
// as the x-, y- and z-coordinates of a <b>force</b> acting at the frame
// connector to which frame_b of this component is attached.
// Via parameter <b>resolveInFrame</b> it is defined, in which frame these
// coordinates shall be resolved:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve input force in world frame</td></tr>
//
// <tr><td valign=\"top\">frame_a</td>
//     <td valign=\"top\">Resolve input force in frame_a</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve input force in frame_b (= default)</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve input force in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
//
// <p>
// If resolveInFrame = ResolveInFrameAB.frame_resolve, the force coordinates
// are with respect to the frame, that is connected to <b>frame_resolve</b>.
// <p>
//
// <p>
// If force={100,0,0}, and for all parameters the default setting is used,
// then the interpretation is that a force of 100 N is acting along the positive
// x-axis of frame_b.
// </p>
//
// <p>
// Note, the cut-torque in frame_b (frame_b.t) is always set to zero.
// Additionally, a force and torque acts on frame_a in such a way that
// the force and torque balance between frame_a and frame_b is fulfilled.
// </p>
//
// <p>
// An example how to use this model is given in the
// following figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/Force1.png\">
// </p>
// <p>
// This leads to the following animation (the yellow cylinder
// characterizes the line between frame_a and frame_b of the
// Force component, i.e., the force acts with negative sign
// also on the opposite side of this cylinder, but for
// clarity this is not shown in the animation):
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/Force2.png\">
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 255, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-98, 99}, {99, -98}}, 0), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-59, 55}, {72, 30}}, "resolve", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-139, -27}, {146, -88}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 20}, {84, 52}, {69, 39}, {100, 20}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{40, 100}, {76, 46}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-99, 20}, {-86, 53}, {-70, 42}, {-99, 20}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-60, 100}, {40, 100}}, {95, 95, 95}, LinePattern.Dot, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-79, 47}, {-70, 61}, {-59, 72}, {-45, 81}, {-32, 84}, {-20, 85}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{77, 45}, {66, 60}, {55, 69}, {49, 74}, {41, 80}, {31, 84}, {20, 85}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Forces.Torque)
// {"<HTML>
// <p>
// The <b>3</b> signals of the <b>torque</b> connector are interpreted
// as the x-, y- and z-coordinates of a <b>torque</b> acting at the frame
// connector to which frame_b of this component is attached.
// Via parameter <b>resolveInFrame</b> it is defined, in which frame these
// coordinates shall be resolved:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve input torque in world frame</td></tr>
//
// <tr><td valign=\"top\">frame_a</td>
//     <td valign=\"top\">Resolve input torque in frame_a</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve input torque in frame_b (= default)</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve input torque in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
//
// <p>
// If resolveInFrame = ResolveInFrameAB.frame_resolve, the torque coordinates
// are with respect to the frame, that is connected to <b>frame_resolve</b>.
// <p>
//
// <p>
// If torque={100,0,0}, and for all parameters the default setting is used,
// then the interpretation is that a torque of 100 N.m is acting along the positive
// x-axis of frame_b.
// </p>
//
// <p>
// Note, the cut-forces in frame_a and frame_b (frame_a.f, frame_b.f) are
// always set to zero and the cut-torque at frame_a (frame_a.t) is the same
// as the cut-torque at frame_b (frame_b.t) but with opposite sign.
// </p>
//
// <p>
// An example how to use this model is given in the
// following figure:
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/Torque1.png\">
// </p>
// <p>
// This leads to the following animation (the yellow cylinder
// characterizes the line between frame_a and frame_b of the
// Torque component, i.e., the torque acts with negative sign
// also on the opposite side of this cylinder, but for
// clarity this is not shown in the animation):
// </p>
// <p align=\"center\">
// <IMG SRC=\"../Images/MultiBody/Forces/Torque2.png\">
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.ForceAndTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Spring)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Internal.BasicForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Forces.Internal.BasicTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.orientationConstraint)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.angularVelocity2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolve2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveRelative)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.resolveDyade2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.nullRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.inverseRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.relativeRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.absoluteRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotationAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.planarRotationAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axisRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotations)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axesRotationsAngles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.smallRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_nxz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.from_Q)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_Q)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_vector)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.to_exy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.axis)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.axis)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.axis)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.der_Orientation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.orientationConstraint)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.angularVelocity2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.resolve2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.multipleResolve2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.inverseRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.relativeRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.absoluteRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.planarRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.smallRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.from_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Quaternions.to_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.der_Orientation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.orientationConstraint)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.angularVelocity2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolve2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.multipleResolve2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade1)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.resolveDyade2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.inverseRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.relativeRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.absoluteRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotationAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.planarRotationAngle)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axisRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotations)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotationsAngles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.axesRotationsAngles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.smallRotation)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_nxz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.from_Q)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_T_inv)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_Q)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_vector)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.to_exy)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.TransformationMatrix)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.QuaternionBase)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_d)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.maxWithoutEvent_dd)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve1_der)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolve2_der)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Frames.Internal.resolveRelative_der)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Interfaces.Frame)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.Frame)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.FlangeWithBearingAdaptor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_a)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialAbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialRelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.PartialVisualizer)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Prismatic)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Revolute)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Cylindrical)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Universal)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Planar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.GearConstraint)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.RollingWheelSet)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUSR)
// {-100.0,-100.0,100.0,100.0,true,0.2,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSR)
// {-100.0,-100.0,100.0,100.0,true,0.2,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointSSP)
// {-100.0,-100.0,100.0,100.0,true,0.2,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRR)
// {-100.0,-100.0,100.0,100.0,true,0.2,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Assemblies.JointRRP)
// {-100.0,-100.0,100.0,100.0,true,0.2,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativePosition)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeAngles)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.RelativeAngularVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.CutForceAndTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Power)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVector)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteBaseSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeBaseSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeBaseSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsolutePosition)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsolutePosition)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsoluteAngularVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicAbsoluteAngularVelocity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativePosition)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativePosition)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativeAngularVelocity)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicRelativeAngularVelocity)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformAbsoluteVector)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformAbsoluteVector)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformRelativeVector)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformRelativeVector)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.ZeroForceAndTorque)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.ZeroForceAndTorque)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceBaseSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicCutForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Sensors.Internal.BasicCutTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Axis)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Axis)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.AxisLabel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.RotationSequence)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Color)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Color)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.SpecularCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.SpecularCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeType)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeExtra)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ShapeExtra)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameA)
// {"<html>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameA.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve vector in world frame</td></tr>
//
// <tr><td valign=\"top\">frame_a</td>
//     <td valign=\"top\">Resolve vector in frame_a</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameB)
// {"<html>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve vector in world frame</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve vector in frame_b</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB)
// {"<html>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.ResolveInFrameAB.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">world</td>
//     <td valign=\"top\">Resolve vector in world frame</td></tr>
//
// <tr><td valign=\"top\">frame_a</td>
//     <td valign=\"top\">Resolve vector in frame_a</td></tr>
//
// <tr><td valign=\"top\">frame_b</td>
//     <td valign=\"top\">Resolve vector in frame_b</td></tr>
//
// <tr><td valign=\"top\">frame_resolve</td>
//     <td valign=\"top\">Resolve vector in frame_resolve (frame_resolve must be connected)</td></tr>
// </table>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.RotationTypes)
// {"<html>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.RotationTypes.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">RotationAxis</td>
//     <td valign=\"top\">frame_b is defined by rotating the coordinate system along
//         an axis fixed in frame_a and with a fixed angle.</td></tr>
//
// <tr><td valign=\"top\">TwoAxesVectors</td>
//     <td valign=\"top\">frame_b is defined by resolving two vectors of frame_b in frame_a.</td></tr>
//
// <tr><td valign=\"top\">PlanarRotationSequence</td>
//     <td valign=\"top\">frame_b is defined by rotating the coordinate system along
//         3 consecutive axes vectors with fixed rotation angles
//         (e.g. Cardan or Euler angle sequence rotation).</td></tr>
// </table>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.GravityTypes)
// {"<html>
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th><b>Types.GravityTypes.</b></th><th><b>Meaning</b></th></tr>
// <tr><td valign=\"top\">NoGravity</td>
//     <td valign=\"top\">No gravity field</td></tr>
//
// <tr><td valign=\"top\">UniformGravity</td>
//     <td valign=\"top\">Gravity field is described by a vector of constant gravity acceleration</td></tr>
//
// <tr><td valign=\"top\">PointGravity</td>
//     <td valign=\"top\">Central gravity field. The gravity acceleration vector is directed to
//         the field center and the gravity is proportional to 1/r^2, where
//         r is the distance to the field center.</td></tr>
// </table>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.MultiBody.Types.Init)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Types.Init)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Types.Init)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedShape)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedShape2)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedFrame)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.FixedArrow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.SignalArrow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Ground)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.DoubleArrow)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Internal.FixedLines)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Visualizers.Internal.Lines)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Body)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BodyBox)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BodyCylinder)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.PointMass)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Mounting1D)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.Rotor1D)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.BevelGear1D)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.MultiBody.Parts.RollingWheel)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.MultiBody.Parts.RollingWheel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Overview)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Overview)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.FlangeConnectors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.FlangeConnectors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SupportTorques)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SupportTorques)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SignConventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.SignConventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.UserDefinedComponents)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.UserDefinedComponents)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.RequirementsForSimulationTool)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.RequirementsForSimulationTool)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.First)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.First)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.FirstGrounded)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.FirstGrounded)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.Friction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.Friction)
// {-180.0,-100.0,120.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.CoupledClutches)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.CoupledClutches)
// {-140.0,-80.0,140.0,80.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo1)
// {-100.0,-80.0,100.0,80.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.LossyGearDemo2)
// {-140.0,-80.0,100.0,80.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.ElasticBearing)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.ElasticBearing)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.Backlash)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.Backlash)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Examples.RollingWheel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Examples.RollingWheel)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Inertia)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Disc)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.BearingFriction)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Brake)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Clutch)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.OneWayClutch)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealGear)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.LossyGear)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.Gearbox)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealGearR2T)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.IdealRollingWheel)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Components.InitializeFlange)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Position)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Speed)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Accelerate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.Move)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.LinearSpeedDependentTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.QuadraticSpeedDependentTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.ConstantTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.ConstantSpeed)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sources.TorqueStep)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.AngleSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.SpeedSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.AccSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelAngleSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelSpeedSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.RelAccSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.TorqueSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Sensors.PowerSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.InternalSupport)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliant)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryOneFlangeAndSupport2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialTorque)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialAbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialRelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Rotational.Interfaces.PartialFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.SignConvention)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.InitialConditions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.InitialConditions)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.WhyArrows)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Accelerate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Accelerate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Damper)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Damper)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Oscillator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Oscillator)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Sensors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Sensors)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Friction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.PreLoad)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.ElastoGap)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.ElastoGap)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Brake)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Brake)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Examples.Utilities.GenerateStribeckFrictionTable)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.Fixed)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.SupportFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.Brake)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Translational.Components.IdealGearR2T)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Translational.Components.IdealRollingWheel)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Components.InitializeFlange)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Position)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Speed)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Accelerate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Move)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Force)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.Force2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.LinearSpeedDependentForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.QuadraticSpeedDependentForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ConstantForce)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ConstantSpeed)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sources.ForceStep)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.PositionSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.SpeedSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.AccSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelPositionSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelSpeedSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.RelAccSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.ForceSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Sensors.PowerSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Translational.Interfaces.Support)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.InternalSupport)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialTwoFlanges)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialTwoFlanges)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRigid)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRigid)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliant)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialCompliantWithRelativeStates)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryOneFlangeAndSupport2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryTwoFlangesAndSupport2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialElementaryRotationalToTranslational)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialForce)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialAbsoluteSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialRelativeSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Mechanics.Translational.Interfaces.PartialFriction)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.norm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.norm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.length)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.normalize)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.normalize)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.reverse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.reverse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Vectors.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Vectors.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.isEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.norm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.norm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.sort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.solve)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.solve)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.solve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.solve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.leastSquares)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.leastSquares)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.equalityLeastSquares)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.equalityLeastSquares)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LU)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LU)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LU)
// {"<HTML>
// <h4>Syntax</h4>
// <blockquote><pre>
// (LU, pivots)       = Matrices.<b>LU</b>(A);
// (LU, pivots, info) = Matrices.<b>LU</b>(A);
// </pre></blockquote>
// <h4>Description</h4>
// <p>
// This function call returns the
// LU decomposition of a \"Real[m,n]\" matrix A, i.e.,
// </p>
// <blockquote>
// <p>
// <b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
// </p>
// </blockquote>
// <p>
// where <b>P</b> is a permutation matrix (implicitely
// defined by vector <code>pivots</code>),
// <b>L</b> is a lower triangular matrix with unit
// diagonal elements (lower trapezoidal if m &gt; n), and
// <b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
// Matrices <b>L</b> and <b>U</b> are stored in the returned
// matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
// With the companion function
// <a href=\"Modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
// this decomposition can be used to solve
// linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
// hand side vectors <b>b</b>. If a linear system of equations with
// just one right hand side vector <b>b</b> shall be solved, it is
// more convenient to just use the function
// <a href=\"Modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>.
// </p>
// <p>
// The optional third (Integer) output argument has the following meaning:
// <table border=0 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\">info = 0:</td
//       <td valign=\"top\">successful exit</td></tr>
//   <tr><td valign=\"top\">info &gt; 0:</td>
//       <td valign=\"top\">if info = i, U[i,i] is exactly zero. The factorization
//           has been completed, <br>
//           but the factor U is exactly
//           singular, and division by zero will occur<br> if it is used
//           to solve a system of equations.</td></tr>
// </table>
// </p>
// <p>
// The LU factorization is computed
// with the LAPACK function \"dgetrf\",
// i.e., by Gaussian elemination using partial pivoting
// with row interchanges. Vector \"pivots\" are the
// pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of
// matrix A was interchanged with row pivots[i].
// </p>
// <h4>Example</h4>
// <blockquote><pre>
//   Real A[3,3] = [1,2,3;
//                  3,4,5;
//                  2,1,4];
//   Real b1[3] = {10,22,12};
//   Real b2[3] = { 7,13,10};
//   Real    LU[3,3];
//   Integer pivots[3];
//   Real    x1[3];
//   Real    x2[3];
// <b>algorithm</b>
//   (LU, pivots) := Matrices.LU(A);
//   x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
//   x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
// </pre></blockquote>
// <h4>See also</h4>
// <a href=\"Modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
// <a href=\"Modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>,
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LU_solve)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LU_solve)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LU_solve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LU_solve2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.QR)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.QR)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.eigenValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.eigenValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.eigenValueMatrix)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.eigenValueMatrix)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.singularValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.singularValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.det)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.det)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.inv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.rank)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.rank)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.balance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.balance)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.exp)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.exp)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.integralExp)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.integralExp)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.integralExpT)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.integralExpT)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeev)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeev)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeev)
// {"Lapack documentation
//     Purpose
//     =======
//     DGEEV computes for an N-by-N real nonsymmetric matrix A, the
//     eigenvalues and, optionally, the left and/or right eigenvectors.
//     The right eigenvector v(j) of A satisfies
//                      A * v(j) = lambda(j) * v(j)
//     where lambda(j) is its eigenvalue.
//     The left eigenvector u(j) of A satisfies
//                   u(j)**H * A = lambda(j) * u(j)**H
//     where u(j)**H denotes the conjugate transpose of u(j).
//     The computed eigenvectors are normalized to have Euclidean norm
//     equal to 1 and largest component real.
//     Arguments
//     =========
//     JOBVL   (input) CHARACTER*1
//             = 'N': left eigenvectors of A are not computed;
//             = 'V': left eigenvectors of A are computed.
//     JOBVR   (input) CHARACTER*1
//             = 'N': right eigenvectors of A are not computed;
//             = 'V': right eigenvectors of A are computed.
//     N       (input) INTEGER
//             The order of the matrix A. N >= 0.
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//             On entry, the N-by-N matrix A.
//             On exit, A has been overwritten.
//     LDA     (input) INTEGER
//             The leading dimension of the array A.  LDA >= max(1,N).
//     WR      (output) DOUBLE PRECISION array, dimension (N)
//     WI      (output) DOUBLE PRECISION array, dimension (N)
//             WR and WI contain the real and imaginary parts,
//             respectively, of the computed eigenvalues.  Complex
//             conjugate pairs of eigenvalues appear consecutively
//             with the eigenvalue having the positive imaginary part
//             first.
//     VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
//             If JOBVL = 'V', the left eigenvectors u(j) are stored one
//             after another in the columns of VL, in the same order
//             as their eigenvalues.
//             If JOBVL = 'N', VL is not referenced.
//             If the j-th eigenvalue is real, then u(j) = VL(:,j),
//             the j-th column of VL.
//             If the j-th and (j+1)-st eigenvalues form a complex
//             conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
//             u(j+1) = VL(:,j) - i*VL(:,j+1).
//     LDVL    (input) INTEGER
//             The leading dimension of the array VL.  LDVL >= 1; if
//             JOBVL = 'V', LDVL >= N.
//     VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
//             If JOBVR = 'V', the right eigenvectors v(j) are stored one
//             after another in the columns of VR, in the same order
//             as their eigenvalues.
//             If JOBVR = 'N', VR is not referenced.
//             If the j-th eigenvalue is real, then v(j) = VR(:,j),
//             the j-th column of VR.
//             If the j-th and (j+1)-st eigenvalues form a complex
//             conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
//             v(j+1) = VR(:,j) - i*VR(:,j+1).
//     LDVR    (input) INTEGER
//             The leading dimension of the array VR.  LDVR >= 1; if
//             JOBVR = 'V', LDVR >= N.
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
//
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
//     LWORK   (input) INTEGER
//             The dimension of the array WORK.  LWORK >= max(1,3*N), and
//             if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
//             performance, LWORK must generally be larger.
//     INFO    (output) INTEGER
//             = 0:  successful exit
//             < 0:  if INFO = -i, the i-th argument had an illegal value.
//             > 0:  if INFO = i, the QR algorithm failed to compute all the
//                   eigenvalues, and no eigenvectors have been computed;
//                   elements i+1:N of WR and WI contain eigenvalues which
//                   have converged.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeev_eigenValues)
// {"Lapack documentation
//     Purpose
//     =======
//     DGEEV computes for an N-by-N real nonsymmetric matrix A, the
//     eigenvalues and, optionally, the left and/or right eigenvectors.
//     The right eigenvector v(j) of A satisfies
//                      A * v(j) = lambda(j) * v(j)
//     where lambda(j) is its eigenvalue.
//     The left eigenvector u(j) of A satisfies
//                   u(j)**H * A = lambda(j) * u(j)**H
//     where u(j)**H denotes the conjugate transpose of u(j).
//     The computed eigenvectors are normalized to have Euclidean norm
//     equal to 1 and largest component real.
//     Arguments
//     =========
//     JOBVL   (input) CHARACTER*1
//             = 'N': left eigenvectors of A are not computed;
//             = 'V': left eigenvectors of A are computed.
//     JOBVR   (input) CHARACTER*1
//             = 'N': right eigenvectors of A are not computed;
//             = 'V': right eigenvectors of A are computed.
//     N       (input) INTEGER
//             The order of the matrix A. N >= 0.
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//             On entry, the N-by-N matrix A.
//             On exit, A has been overwritten.
//     LDA     (input) INTEGER
//             The leading dimension of the array A.  LDA >= max(1,N).
//     WR      (output) DOUBLE PRECISION array, dimension (N)
//     WI      (output) DOUBLE PRECISION array, dimension (N)
//             WR and WI contain the real and imaginary parts,
//             respectively, of the computed eigenvalues.  Complex
//             conjugate pairs of eigenvalues appear consecutively
//             with the eigenvalue having the positive imaginary part
//             first.
//     VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
//             If JOBVL = 'V', the left eigenvectors u(j) are stored one
//             after another in the columns of VL, in the same order
//             as their eigenvalues.
//             If JOBVL = 'N', VL is not referenced.
//             If the j-th eigenvalue is real, then u(j) = VL(:,j),
//             the j-th column of VL.
//             If the j-th and (j+1)-st eigenvalues form a complex
//             conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
//             u(j+1) = VL(:,j) - i*VL(:,j+1).
//     LDVL    (input) INTEGER
//             The leading dimension of the array VL.  LDVL >= 1; if
//             JOBVL = 'V', LDVL >= N.
//     VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
//             If JOBVR = 'V', the right eigenvectors v(j) are stored one
//             after another in the columns of VR, in the same order
//             as their eigenvalues.
//             If JOBVR = 'N', VR is not referenced.
//             If the j-th eigenvalue is real, then v(j) = VR(:,j),
//             the j-th column of VR.
//             If the j-th and (j+1)-st eigenvalues form a complex
//             conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
//             v(j+1) = VR(:,j) - i*VR(:,j+1).
//     LDVR    (input) INTEGER
//             The leading dimension of the array VR.  LDVR >= 1; if
//             JOBVR = 'V', LDVR >= N.
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
//
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
//     LWORK   (input) INTEGER
//             The dimension of the array WORK.  LWORK >= max(1,3*N), and
//             if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
//             performance, LWORK must generally be larger.
//     INFO    (output) INTEGER
//             = 0:  successful exit
//             < 0:  if INFO = -i, the i-th argument had an illegal value.
//             > 0:  if INFO = i, the QR algorithm failed to compute all the
//                   eigenvalues, and no eigenvectors have been computed;
//                   elements i+1:N of WR and WI contain eigenvalues which
//                   have converged.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgegv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgegv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgegv)
// {"Purpose
// =======
//
// For a pair of N-by-N real nonsymmetric matrices A, B:
//    compute the generalized eigenvalues (alphar +/- alphai*i, beta)
//    compute the left and/or right generalized eigenvectors
//            (VL and VR)
// The second action is optional -- see the description of JOBVL and
// JOBVR below.
// A generalized eigenvalue for a pair of matrices (A,B) is, roughly
// speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
// is singular.  It is usually represented as the pair (alpha,beta),
// as there is a reasonable interpretation for beta=0, and even for
// both being zero.  A good beginning reference is the book, \"Matrix
// Computations\", by G. Golub & C. van Loan (Johns Hopkins U. Press)
// A right generalized eigenvector corresponding to a generalized
// eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
// that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
//                        H
// l  such that  (A - w B) l = 0 .
// Note: this routine performs \"full balancing\" on A and B -- see
// \"Further Details\", below.
// Arguments
// =========
// JOBVL   (input) CHARACTER*1
//         = 'N':  do not compute the left generalized eigenvectors;
//         = 'V':  compute the left generalized eigenvectors.
// JOBVR   (input) CHARACTER*1
//         = 'N':  do not compute the right generalized eigenvectors;
//         = 'V':  compute the right generalized eigenvectors.
// N       (input) INTEGER
//         The number of rows and columns in the matrices A, B, VL, and
//         VR.  N >= 0.
// A       (input/workspace) DOUBLE PRECISION array, dimension (LDA, N)
//         On entry, the first of the pair of matrices whose
//         generalized eigenvalues and (optionally) generalized
//         eigenvectors are to be computed.
//         On exit, the contents will have been destroyed.  (For a
//         description of the contents of A on exit, see \"Further
//         Details\", below.)
// LDA     (input) INTEGER
//         The leading dimension of A.  LDA >= max(1,N).
// B       (input/workspace) DOUBLE PRECISION array, dimension (LDB, N)
//         On entry, the second of the pair of matrices whose
//         generalized eigenvalues and (optionally) generalized
//         eigenvectors are to be computed.
//         On exit, the contents will have been destroyed.  (For a
//         description of the contents of B on exit, see \"Further
//         Details\", below.)
// LDB     (input) INTEGER
//         The leading dimension of B.  LDB >= max(1,N).
// ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
// ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
// BETA    (output) DOUBLE PRECISION array, dimension (N)
//         On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
//         be the generalized eigenvalues.  If ALPHAI(j) is zero, then
//         the j-th eigenvalue is real; if positive, then the j-th and
//         (j+1)-st eigenvalues are a complex conjugate pair, with
//         ALPHAI(j+1) negative.
//         Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
//         may easily over- or underflow, and BETA(j) may even be zero.
//         Thus, the user should avoid naively computing the ratio
//         alpha/beta.  However, ALPHAR and ALPHAI will be always less
//         than and usually comparable with norm(A) in magnitude, and
//         BETA always less than and usually comparable with norm(B).
// VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
//         If JOBVL = 'V', the left generalized eigenvectors.  (See
//         \"Purpose\", above.)  Real eigenvectors take one column,
//         complex take two columns, the first for the real part and
//         the second for the imaginary part.  Complex eigenvectors
//         correspond to an eigenvalue with positive imaginary part.
//         Each eigenvector will be scaled so the largest component
//         will have abs(real part) + abs(imag. part) = 1, *except*
//         that for eigenvalues with alpha=beta=0, a zero vector will
//         be returned as the corresponding eigenvector.
//         Not referenced if JOBVL = 'N'.
// LDVL    (input) INTEGER
//         The leading dimension of the matrix VL. LDVL >= 1, and
//         if JOBVL = 'V', LDVL >= N.
// VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
//         If JOBVL = 'V', the right generalized eigenvectors.  (See
//         \"Purpose\", above.)  Real eigenvectors take one column,
//         complex take two columns, the first for the real part and
//         the second for the imaginary part.  Complex eigenvectors
//         correspond to an eigenvalue with positive imaginary part.
//         Each eigenvector will be scaled so the largest component
//         will have abs(real part) + abs(imag. part) = 1, *except*
//         that for eigenvalues with alpha=beta=0, a zero vector will
//         be returned as the corresponding eigenvector.
//         Not referenced if JOBVR = 'N'.
// LDVR    (input) INTEGER
//         The leading dimension of the matrix VR. LDVR >= 1, and
//         if JOBVR = 'V', LDVR >= N.
// WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
//         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
// LWORK   (input) INTEGER
//         The dimension of the array WORK.  LWORK >= max(1,8*N).
//         For good performance, LWORK must generally be larger.
//         To compute the optimal value of LWORK, call ILAENV to get
//         blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
//         NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
//         The optimal LWORK is:
//             2*N + MAX( 6*N, N*(NB+1) ).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value.
//         = 1,...,N:
//               The QZ iteration failed.  No eigenvectors have been
//               calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
//               should be correct for j=INFO+1,...,N.
//         > N:  errors that usually indicate LAPACK problems:
//               =N+1: error return from DGGBAL
//               =N+2: error return from DGEQRF
//               =N+3: error return from DORMQR
//               =N+4: error return from DORGQR
//               =N+5: error return from DGGHRD
//               =N+6: error return from DHGEQZ (other than failed
//                                               iteration)
//               =N+7: error return from DTGEVC
//               =N+8: error return from DGGBAK (computing VL)
//               =N+9: error return from DGGBAK (computing VR)
//               =N+10: error return from DLASCL (various calls)
// Further Details
// ===============
// Balancing
// ---------
// This driver calls DGGBAL to both permute and scale rows and columns
// of A and B.  The permutations PL and PR are chosen so that PL*A*PR
// and PL*B*R will be upper triangular except for the diagonal blocks
// A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
// possible.  The diagonal scaling matrices DL and DR are chosen so
// that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have entries close to
// one (except for the entries that start out zero.)
// After the eigenvalues and eigenvectors of the balanced matrices
// have been computed, DGGBAK transforms the eigenvectors back to what
// they would have been (in perfect arithmetic) if they had not been
// balanced.
// Contents of A and B on Exit
// -------- -- - --- - -- ----
// If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
// both), then on exit the arrays A and B will contain the real Schur
// form[*] of the \"balanced\" versions of A and B.  If no eigenvectors
// are computed, then only the diagonal blocks will be correct.
// [*] See DHGEQZ, DGEGS, or read the book \"Matrix Computations\",
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgels_vec)
// {"Lapack documentation
//   Purpose
//   =======
//
//   DGELS solves overdetermined or underdetermined real linear systems
//   involving an M-by-N matrix A, or its transpose, using a QR or LQ
//   factorization of A.  It is assumed that A has full rank.
//
//   The following options are provided:
//
//   1. If TRANS = 'N' and m >= n:  find the least squares solution of
//      an overdetermined system, i.e., solve the least squares problem
//                   minimize || B - A*X ||.
//
//   2. If TRANS = 'N' and m < n:  find the minimum norm solution of
//      an underdetermined system A * X = B.
//
//   3. If TRANS = 'T' and m >= n:  find the minimum norm solution of
//      an undetermined system A**T * X = B.
//
//   4. If TRANS = 'T' and m < n:  find the least squares solution of
//      an overdetermined system, i.e., solve the least squares problem
//                   minimize || B - A**T * X ||.
//
//   Several right hand side vectors b and solution vectors x can be
//   handled in a single call; they are stored as the columns of the
//   M-by-NRHS right hand side matrix B and the N-by-NRHS solution
//   matrix X.
//
//   Arguments
//   =========
//
//   TRANS   (input) CHARACTER
//           = 'N': the linear system involves A;
//           = 'T': the linear system involves A**T.
//
//   M       (input) INTEGER
//           The number of rows of the matrix A.  M >= 0.
//
//   N       (input) INTEGER
//           The number of columns of the matrix A.  N >= 0.
//
//   NRHS    (input) INTEGER
//           The number of right hand sides, i.e., the number of
//           columns of the matrices B and X. NRHS >=0.
//
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//           On entry, the M-by-N matrix A.
//           On exit,
//             if M >= N, A is overwritten by details of its QR
//                        factorization as returned by DGEQRF;
//             if M <  N, A is overwritten by details of its LQ
//                        factorization as returned by DGELQF.
//
//   LDA     (input) INTEGER
//           The leading dimension of the array A.  LDA >= max(1,M).
//
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//           On entry, the matrix B of right hand side vectors, stored
//           columnwise; B is M-by-NRHS if TRANS = 'N', or N-by-NRHS
//           if TRANS = 'T'.
//           On exit, B is overwritten by the solution vectors, stored
//           columnwise:  if TRANS = 'N' and m >= n, rows 1 to n of B
//           contain the least squares solution vectors; the residual
//           sum of squares for the solution in each column is given by
//           the sum of squares of elements N+1 to M in that column;
//           if TRANS = 'N' and m < n, rows 1 to N of B contain the
//           minimum norm solution vectors;
//           if TRANS = 'T' and m >= n, rows 1 to M of B contain the
//           minimum norm solution vectors;
//           if TRANS = 'T' and m < n, rows 1 to M of B contain the
//           least squares solution vectors; the residual sum of squares
//           for the solution in each column is given by the sum of
//           squares of elements M+1 to N in that column.
//
//   LDB     (input) INTEGER
//           The leading dimension of the array B. LDB >= MAX(1,M,N).
//
//   WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
//
//   LWORK   (input) INTEGER
//           The dimension of the array WORK.
//           LWORK >= min(M,N) + MAX(1,M,N,NRHS).
//           For optimal performance,
//           LWORK >= min(M,N) + MAX(1,M,N,NRHS) * NB
//           where NB is the optimum block size.
//
//   INFO    (output) INTEGER
//           = 0:  successful exit
//           < 0:  if INFO = -i, the i-th argument had an illegal value
//                                                                           ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgelsx_vec)
// {"Lapack documentation
//   Purpose
//   =======
//
//   DGELSX computes the minimum-norm solution to a real linear least
//   squares problem:
//       minimize || A * X - B ||
//   using a complete orthogonal factorization of A.  A is an M-by-N
//   matrix which may be rank-deficient.
//
//   Several right hand side vectors b and solution vectors x can be
//   handled in a single call; they are stored as the columns of the
//   M-by-NRHS right hand side matrix B and the N-by-NRHS solution
//   matrix X.
//
//   The routine first computes a QR factorization with column pivoting:
//       A * P = Q * [ R11 R12 ]
//                   [  0  R22 ]
//   with R11 defined as the largest leading submatrix whose estimated
//   condition number is less than 1/RCOND.  The order of R11, RANK,
//   is the effective rank of A.
//
//   Then, R22 is considered to be negligible, and R12 is annihilated
//   by orthogonal transformations from the right, arriving at the
//   complete orthogonal factorization:
//      A * P = Q * [ T11 0 ] * Z
//                  [  0  0 ]
//   The minimum-norm solution is then
//      X = P * Z' [ inv(T11)*Q1'*B ]
//                 [        0       ]
//   where Q1 consists of the first RANK columns of Q.
//
//   Arguments
//   =========
//
//   M       (input) INTEGER
//           The number of rows of the matrix A.  M >= 0.
//
//   N       (input) INTEGER
//           The number of columns of the matrix A.  N >= 0.
//
//   NRHS    (input) INTEGER
//           The number of right hand sides, i.e., the number of
//           columns of matrices B and X. NRHS >= 0.
//
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//           On entry, the M-by-N matrix A.
//           On exit, A has been overwritten by details of its
//           complete orthogonal factorization.
//
//   LDA     (input) INTEGER
//           The leading dimension of the array A.  LDA >= max(1,M).
//
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//           On entry, the M-by-NRHS right hand side matrix B.
//           On exit, the N-by-NRHS solution matrix X.
//           If m >= n and RANK = n, the residual sum-of-squares for
//           the solution in the i-th column is given by the sum of
//           squares of elements N+1:M in that column.
//
//   LDB     (input) INTEGER
//           The leading dimension of the array B. LDB >= max(1,M,N).
//
//   JPVT    (input/output) INTEGER array, dimension (N)
//           On entry, if JPVT(i) .ne. 0, the i-th column of A is an
//           initial column, otherwise it is a free column.  Before
//           the QR factorization of A, all initial columns are
//           permuted to the leading positions; only the remaining
//           free columns are moved as a result of column pivoting
//           during the factorization.
//           On exit, if JPVT(i) = k, then the i-th column of A*P
//           was the k-th column of A.
//
//   RCOND   (input) DOUBLE PRECISION
//           RCOND is used to determine the effective rank of A, which
//           is defined as the order of the largest leading triangular
//           submatrix R11 in the QR factorization with pivoting of A,
//           whose estimated condition number < 1/RCOND.
//
//   RANK    (output) INTEGER
//           The effective rank of A, i.e., the order of the submatrix
//           R11.  This is the same as the order of the submatrix T11
//           in the complete orthogonal factorization of A.
//
//   WORK    (workspace) DOUBLE PRECISION array, dimension
//                       (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),
//
//   INFO    (output) INTEGER
//           = 0:  successful exit
//           < 0:  if INFO = -i, the i-th argument had an illegal value    ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesv)
// {"Lapack documentation:
//     Purpose
//     =======
//     DGESV computes the solution to a real system of linear equations
//        A * X = B,
//     where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
//     The LU decomposition with partial pivoting and row interchanges is
//     used to factor A as
//        A = P * L * U,
//     where P is a permutation matrix, L is unit lower triangular, and U is
//
//     upper triangular.  The factored form of A is then used to solve the
//     system of equations A * X = B.
//     Arguments
//     =========
//     N       (input) INTEGER
//             The number of linear equations, i.e., the order of the
//             matrix A.  N >= 0.
//     NRHS    (input) INTEGER
//             The number of right hand sides, i.e., the number of columns
//             of the matrix B.  NRHS >= 0.
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//             On entry, the N-by-N coefficient matrix A.
//             On exit, the factors L and U from the factorization
//             A = P*L*U; the unit diagonal elements of L are not stored.
//     LDA     (input) INTEGER
//             The leading dimension of the array A.  LDA >= max(1,N).
//     IPIV    (output) INTEGER array, dimension (N)
//             The pivot indices that define the permutation matrix P;
//             row i of the matrix was interchanged with row IPIV(i).
//     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//             On entry, the N-by-NRHS matrix of right hand side matrix B.
//             On exit, if INFO = 0, the N-by-NRHS solution matrix X.
//     LDB     (input) INTEGER
//             The leading dimension of the array B.  LDB >= max(1,N).
//     INFO    (output) INTEGER
//             = 0:  successful exit
//             < 0:  if INFO = -i, the i-th argument had an illegal value
//             > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
//
//                   has been completed, but the factor U is exactly
//                   singular, so the solution could not be computed.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesv_vec)
// {"
// Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
// For details of the arguments, see documentation of dgesv.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgglse_vec)
// {"Lapack documentation
//
//   Purpose
//   =======
//
//   DGGLSE solves the linear equality constrained least squares (LSE)
//   problem:
//
//           minimize || A*x - c ||_2   subject to B*x = d
//
//   using a generalized RQ factorization of matrices A and B, where A is
//   M-by-N, B is P-by-N, assume P <= N <= M+P, and ||.||_2 denotes vector
//   2-norm. It is assumed that
//
//                        rank(B) = P                                  (1)
//
//   and the null spaces of A and B intersect only trivially, i.e.,
//
//    intersection of Null(A) and Null(B) = {0} <=> rank( ( A ) ) = N  (2)
//                                                      ( ( B ) )
//
//   where N(A) denotes the null space of matrix A. Conditions (1) and (2)
//   ensure that the problem LSE has a unique solution.
//
//   Arguments
//   =========
//
//   M       (input) INTEGER
//           The number of rows of the matrix A.  M >= 0.
//
//   N       (input) INTEGER
//           The number of columns of the matrices A and B. N >= 0.
//           Assume that P <= N <= M+P.
//
//   P       (input) INTEGER
//           The number of rows of the matrix B.  P >= 0.
//
//   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//           On entry, the P-by-M matrix A.
//           On exit, A is destroyed.
//
//   LDA     (input) INTEGER
//           The leading dimension of the array A. LDA >= max(1,M).
//
//   B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)
//           On entry, the P-by-N matrix B.
//           On exit, B is destroyed.
//
//   LDB     (input) INTEGER
//           The leading dimension of the array B. LDB >= max(1,P).
//
//   C       (input/output) DOUBLE PRECISION array, dimension (M)
//           On entry, C contains the right hand side vector for the
//           least squares part of the LSE problem.
//           On exit, the residual sum of squares for the solution
//           is given by the sum of squares of elements N-P+1 to M of
//           vector C.
//
//   D       (input/output) DOUBLE PRECISION array, dimension (P)
//           On entry, D contains the right hand side vector for the
//           constrained equation.
//           On exit, D is destroyed.
//
//   X       (output) DOUBLE PRECISION array, dimension (N)
//           On exit, X is the solution of the LSE problem.
//
//   WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
//
//   LWORK   (input) INTEGER
//           The dimension of the array WORK. LWORK >= N+P+max(N,M,P).
//           For optimum performance LWORK >=
//           N+P+max(M,P,N)*max(NB1,NB2), where NB1 is the optimal
//           blocksize for the QR factorization of M-by-N matrix A.
//           NB2 is the optimal blocksize for the RQ factorization of
//           P-by-N matrix B.
//
//   INFO    (output) INTEGER
//           = 0:  successful exit.
//           < 0:  if INFO = -i, the i-th argument had an illegal value.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv)
// {"Lapack documentation:
//     Purpose
//     =======
//     DGTSV  solves the equation
//        A*X = B,
//     where A is an N-by-N tridiagonal matrix, by Gaussian elimination with
//
//     partial pivoting.
//     Note that the equation  A'*X = B  may be solved by interchanging the
//
//     order of the arguments DU and DL.
//     Arguments
//     =========
//     N       (input) INTEGER
//             The order of the matrix A.  N >= 0.
//     NRHS    (input) INTEGER
//             The number of right hand sides, i.e., the number of columns
//             of the matrix B.  NRHS >= 0.
//     DL      (input/output) DOUBLE PRECISION array, dimension (N-1)
//             On entry, DL must contain the (n-1) subdiagonal elements of
//             A.
//             On exit, DL is overwritten by the (n-2) elements of the
//             second superdiagonal of the upper triangular matrix U from
//             the LU factorization of A, in DL(1), ..., DL(n-2).
//     D       (input/output) DOUBLE PRECISION array, dimension (N)
//             On entry, D must contain the diagonal elements of A.
//             On exit, D is overwritten by the n diagonal elements of U.
//     DU      (input/output) DOUBLE PRECISION array, dimension (N-1)
//             On entry, DU must contain the (n-1) superdiagonal elements
//             of A.
//             On exit, DU is overwritten by the (n-1) elements of the first
//
//             superdiagonal of U.
//     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//             On entry, the N-by-NRHS right hand side matrix B.
//             On exit, if INFO = 0, the N-by-NRHS solution matrix X.
//     LDB     (input) INTEGER
//             The leading dimension of the array B.  LDB >= max(1,N).
//     INFO    (output) INTEGER
//             = 0:  successful exit
//             < 0:  if INFO = -i, the i-th argument had an illegal value
//             > 0:  if INFO = i, U(i,i) is exactly zero, and the solution
//                   has not been computed.  The factorization has not been
//
//                   completed unless i = N.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgtsv_vec)
// {"
// Same as function LAPACK.dgtsv, but right hand side is a vector and not a matrix.
// For details of the arguments, see documentation of dgtsv.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv)
// {"Lapack documentation:
// Purpose
// =======
// DGBSV computes the solution to a real system of linear equations
// A * X = B, where A is a band matrix of order N with KL subdiagonals
// and KU superdiagonals, and X and B are N-by-NRHS matrices.
// The LU decomposition with partial pivoting and row interchanges is
// used to factor A as A = L * U, where L is a product of permutation
// and unit lower triangular matrices with KL subdiagonals, and U is
// upper triangular with KL+KU superdiagonals.  The factored form of A
// is then used to solve the system of equations A * X = B.
// Arguments
// =========
// N       (input) INTEGER
//         The number of linear equations, i.e., the order of the
//         matrix A.  N >= 0.
// KL      (input) INTEGER
//         The number of subdiagonals within the band of A.  KL >= 0.
// KU      (input) INTEGER
//         The number of superdiagonals within the band of A.  KU >= 0.
// NRHS    (input) INTEGER
//         The number of right hand sides, i.e., the number of columns
//         of the matrix B.  NRHS >= 0.
// AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
//         On entry, the matrix A in band storage, in rows KL+1 to
//         2*KL+KU+1; rows 1 to KL of the array need not be set.
//         The j-th column of A is stored in the j-th column of the
//         array AB as follows:
//         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
//         On exit, details of the factorization: U is stored as an
//         upper triangular band matrix with KL+KU superdiagonals in
//         rows 1 to KL+KU+1, and the multipliers used during the
//         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
//         See below for further details.
// LDAB    (input) INTEGER
//         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
// IPIV    (output) INTEGER array, dimension (N)
//         The pivot indices that define the permutation matrix P;
//         row i of the matrix was interchanged with row IPIV(i).
// B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//         On entry, the N-by-NRHS right hand side matrix B.
//         On exit, if INFO = 0, the N-by-NRHS solution matrix X.
// LDB     (input) INTEGER
//         The leading dimension of the array B.  LDB >= max(1,N).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
//               has been completed, but the factor U is exactly
//               singular, and the solution has not been computed.
// Further Details
// ===============
// The band storage scheme is illustrated by the following example, when
// M = N = 6, KL = 2, KU = 1:
// On entry:                       On exit:
//     *    *    *    +    +    +       *    *    *   u14  u25  u36
//     *    *    +    +    +    +       *    *   u13  u24  u35  u46
//     *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
//    a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
//    a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
//    a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
// Array elements marked * are not used by the routine; elements marked
// + need not be set on entry, but are required by the routine to store
// elements of U because of fill-in resulting from the row interchanges.","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgbsv_vec)
// {"Lapack documentation:
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd)
// {"Lapack documentation:
//     Purpose
//     =======
//     DGESVD computes the singular value decomposition (SVD) of a real
//     M-by-N matrix A, optionally computing the left and/or right singular
//
//     vectors. The SVD is written
//          A = U * SIGMA * transpose(V)
//     where SIGMA is an M-by-N matrix which is zero except for its
//     min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
//     V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
//     are the singular values of A; they are real and non-negative, and
//     are returned in descending order.  The first min(m,n) columns of
//     U and V are the left and right singular vectors of A.
//     Note that the routine returns V**T, not V.
//     Arguments
//     =========
//     JOBU    (input) CHARACTER*1
//             Specifies options for computing all or part of the matrix U:
//
//             = 'A':  all M columns of U are returned in array U:
//             = 'S':  the first min(m,n) columns of U (the left singular
//                     vectors) are returned in the array U;
//             = 'O':  the first min(m,n) columns of U (the left singular
//                     vectors) are overwritten on the array A;
//             = 'N':  no columns of U (no left singular vectors) are
//                     computed.
//     JOBVT   (input) CHARACTER*1
//             Specifies options for computing all or part of the matrix
//             V**T:
//             = 'A':  all N rows of V**T are returned in the array VT;
//             = 'S':  the first min(m,n) rows of V**T (the right singular
//                     vectors) are returned in the array VT;
//             = 'O':  the first min(m,n) rows of V**T (the right singular
//                     vectors) are overwritten on the array A;
//             = 'N':  no rows of V**T (no right singular vectors) are
//                     computed.
//             JOBVT and JOBU cannot both be 'O'.
//     M       (input) INTEGER
//             The number of rows of the input matrix A.  M >= 0.
//     N       (input) INTEGER
//             The number of columns of the input matrix A.  N >= 0.
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//             On entry, the M-by-N matrix A.
//             On exit,
//             if JOBU = 'O',  A is overwritten with the first min(m,n)
//                             columns of U (the left singular vectors,
//                             stored columnwise);
//             if JOBVT = 'O', A is overwritten with the first min(m,n)
//                             rows of V**T (the right singular vectors,
//                             stored rowwise);
//             if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
//                             are destroyed.
//     LDA     (input) INTEGER
//             The leading dimension of the array A.  LDA >= max(1,M).
//     S       (output) DOUBLE PRECISION array, dimension (min(M,N))
//             The singular values of A, sorted so that S(i) >= S(i+1).
//     U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
//             (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
//             If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
//             if JOBU = 'S', U contains the first min(m,n) columns of U
//             (the left singular vectors, stored columnwise);
//             if JOBU = 'N' or 'O', U is not referenced.
//     LDU     (input) INTEGER
//             The leading dimension of the array U.  LDU >= 1; if
//             JOBU = 'S' or 'A', LDU >= M.
//     VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
//             If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
//             V**T;
//             if JOBVT = 'S', VT contains the first min(m,n) rows of
//             V**T (the right singular vectors, stored rowwise);
//             if JOBVT = 'N' or 'O', VT is not referenced.
//     LDVT    (input) INTEGER
//             The leading dimension of the array VT.  LDVT >= 1; if
//             JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
//
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
//             if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
//             superdiagonal elements of an upper bidiagonal matrix B
//             whose diagonal is in S (not necessarily sorted). B
//             satisfies A = U * B * VT, so it has the same singular values
//
//             as A, and singular vectors related by U and VT.
//     LWORK   (input) INTEGER
//             The dimension of the array WORK. LWORK >= 1.
//             LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
//             For good performance, LWORK should generally be larger.
//     INFO    (output) INTEGER
//             = 0:  successful exit.
//             < 0:  if INFO = -i, the i-th argument had an illegal value.
//             > 0:  if DBDSQR did not converge, INFO specifies how many
//                   superdiagonals of an intermediate bidiagonal form B
//                   did not converge to zero. See the description of WORK
//                   above for details.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgesvd_sigma)
// {"Lapack documentation:
//     Purpose
//     =======
//     DGESVD computes the singular value decomposition (SVD) of a real
//     M-by-N matrix A, optionally computing the left and/or right singular
//
//     vectors. The SVD is written
//          A = U * SIGMA * transpose(V)
//     where SIGMA is an M-by-N matrix which is zero except for its
//     min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
//     V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
//     are the singular values of A; they are real and non-negative, and
//     are returned in descending order.  The first min(m,n) columns of
//     U and V are the left and right singular vectors of A.
//     Note that the routine returns V**T, not V.
//     Arguments
//     =========
//     JOBU    (input) CHARACTER*1
//             Specifies options for computing all or part of the matrix U:
//
//             = 'A':  all M columns of U are returned in array U:
//             = 'S':  the first min(m,n) columns of U (the left singular
//                     vectors) are returned in the array U;
//             = 'O':  the first min(m,n) columns of U (the left singular
//                     vectors) are overwritten on the array A;
//             = 'N':  no columns of U (no left singular vectors) are
//                     computed.
//     JOBVT   (input) CHARACTER*1
//             Specifies options for computing all or part of the matrix
//             V**T:
//             = 'A':  all N rows of V**T are returned in the array VT;
//             = 'S':  the first min(m,n) rows of V**T (the right singular
//                     vectors) are returned in the array VT;
//             = 'O':  the first min(m,n) rows of V**T (the right singular
//                     vectors) are overwritten on the array A;
//             = 'N':  no rows of V**T (no right singular vectors) are
//                     computed.
//             JOBVT and JOBU cannot both be 'O'.
//     M       (input) INTEGER
//             The number of rows of the input matrix A.  M >= 0.
//     N       (input) INTEGER
//             The number of columns of the input matrix A.  N >= 0.
//     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//             On entry, the M-by-N matrix A.
//             On exit,
//             if JOBU = 'O',  A is overwritten with the first min(m,n)
//                             columns of U (the left singular vectors,
//                             stored columnwise);
//             if JOBVT = 'O', A is overwritten with the first min(m,n)
//                             rows of V**T (the right singular vectors,
//                             stored rowwise);
//             if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
//                             are destroyed.
//     LDA     (input) INTEGER
//             The leading dimension of the array A.  LDA >= max(1,M).
//     S       (output) DOUBLE PRECISION array, dimension (min(M,N))
//             The singular values of A, sorted so that S(i) >= S(i+1).
//     U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
//             (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
//             If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
//             if JOBU = 'S', U contains the first min(m,n) columns of U
//             (the left singular vectors, stored columnwise);
//             if JOBU = 'N' or 'O', U is not referenced.
//     LDU     (input) INTEGER
//             The leading dimension of the array U.  LDU >= 1; if
//             JOBU = 'S' or 'A', LDU >= M.
//     VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
//             If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
//             V**T;
//             if JOBVT = 'S', VT contains the first min(m,n) rows of
//             V**T (the right singular vectors, stored rowwise);
//             if JOBVT = 'N' or 'O', VT is not referenced.
//     LDVT    (input) INTEGER
//             The leading dimension of the array VT.  LDVT >= 1; if
//             JOBVT = 'A', LDVT >= N; if JOBVT = 'S', LDVT >= min(M,N).
//     WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
//
//             On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
//             if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged
//             superdiagonal elements of an upper bidiagonal matrix B
//             whose diagonal is in S (not necessarily sorted). B
//             satisfies A = U * B * VT, so it has the same singular values
//
//             as A, and singular vectors related by U and VT.
//     LWORK   (input) INTEGER
//             The dimension of the array WORK. LWORK >= 1.
//             LWORK >= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
//             For good performance, LWORK should generally be larger.
//     INFO    (output) INTEGER
//             = 0:  successful exit.
//             < 0:  if INFO = -i, the i-th argument had an illegal value.
//             > 0:  if DBDSQR did not converge, INFO specifies how many
//                   superdiagonals of an intermediate bidiagonal form B
//                   did not converge to zero. See the description of WORK
//                   above for details.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrf)
// {"Lapack documentation:
//   SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, M, N
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * )
//    ..
// Purpose
// =======
// DGETRF computes an LU factorization of a general M-by-N matrix A
// using partial pivoting with row interchanges.
// The factorization has the form
//    A = P * L * U
// where P is a permutation matrix, L is lower triangular with unit
// diagonal elements (lower trapezoidal if m > n), and U is upper
// triangular (upper trapezoidal if m < n).
// This is the right-looking Level 3 BLAS version of the algorithm.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix A.  M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix A.  N >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the M-by-N matrix to be factored.
//         On exit, the factors L and U from the factorization
//         A = P*L*U; the unit diagonal elements of L are not stored.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,M).
// IPIV    (output) INTEGER array, dimension (min(M,N))
//         The pivot indices; for 1 <= i <= min(M,N), row i of the
//         matrix was interchanged with row IPIV(i).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
//               has been completed, but the factor U is exactly
//               singular, and division by zero will occur if it is used
//               to solve a system of equations.
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs)
// {"Lapack documentation:
//   SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    CHARACTER          TRANS
//    INTEGER            INFO, LDA, LDB, N, NRHS
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
//    ..
// Purpose
// =======
// DGETRS solves a system of linear equations
//    A * X = B  or  A' * X = B
// with a general N-by-N matrix A using the LU factorization computed
// by DGETRF.
// Arguments
// =========
// TRANS   (input) CHARACTER*1
//         Specifies the form of the system of equations:
//         = 'N':  A * X = B  (No transpose)
//         = 'T':  A'* X = B  (Transpose)
//         = 'C':  A'* X = B  (Conjugate transpose = Transpose)
// N       (input) INTEGER
//         The order of the matrix A.  N >= 0.
// NRHS    (input) INTEGER
//         The number of right hand sides, i.e., the number of columns
//         of the matrix B.  NRHS >= 0.
// A       (input) DOUBLE PRECISION array, dimension (LDA,N)
//         The factors L and U from the factorization A = P*L*U
//         as computed by DGETRF.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,N).
// IPIV    (input) INTEGER array, dimension (N)
//         The pivot indices from DGETRF; for 1<=i<=N, row i of the
//         matrix was interchanged with row IPIV(i).
// B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//         On entry, the right hand side matrix B.
//         On exit, the solution matrix X.
// LDB     (input) INTEGER
//         The leading dimension of the array B.  LDB >= max(1,N).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetrs_vec)
// {"Lapack documentation:
//   SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    CHARACTER          TRANS
//    INTEGER            INFO, LDA, LDB, N, NRHS
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
//    ..
// Purpose
// =======
// DGETRS solves a system of linear equations
//    A * X = B  or  A' * X = B
// with a general N-by-N matrix A using the LU factorization computed
// by DGETRF.
// Arguments
// =========
// TRANS   (input) CHARACTER*1
//         Specifies the form of the system of equations:
//         = 'N':  A * X = B  (No transpose)
//         = 'T':  A'* X = B  (Transpose)
//         = 'C':  A'* X = B  (Conjugate transpose = Transpose)
// N       (input) INTEGER
//         The order of the matrix A.  N >= 0.
// NRHS    (input) INTEGER
//         The number of right hand sides, i.e., the number of columns
//         of the matrix B.  NRHS >= 0.
// A       (input) DOUBLE PRECISION array, dimension (LDA,N)
//         The factors L and U from the factorization A = P*L*U
//         as computed by DGETRF.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,N).
// IPIV    (input) INTEGER array, dimension (N)
//         The pivot indices from DGETRF; for 1<=i<=N, row i of the
//         matrix was interchanged with row IPIV(i).
// B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
//         On entry, the right hand side matrix B.
//         On exit, the solution matrix X.
// LDB     (input) INTEGER
//         The leading dimension of the array B.  LDB >= max(1,N).
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgetri)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgetri)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgetri)
// {"Lapack documentation:
//    SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, LWORK, N
//    ..
//    .. Array Arguments ..
//    INTEGER            IPIV( * )
//    DOUBLE PRECISION   A( LDA, * ), WORK( LWORK )
//    ..
// Purpose
// =======
// DGETRI computes the inverse of a matrix using the LU factorization
// computed by DGETRF.
// This method inverts U and then computes inv(A) by solving the system
// inv(A)*L = inv(U) for inv(A).
// Arguments
// =========
// N       (input) INTEGER
//         The order of the matrix A.  N >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the factors L and U from the factorization
//         A = P*L*U as computed by DGETRF.
//         On exit, if INFO = 0, the inverse of the original matrix A.
// LDA     (input) INTEGER
//         The leading dimension of the array A.  LDA >= max(1,N).
// IPIV    (input) INTEGER array, dimension (N)
//         The pivot indices from DGETRF; for 1<=i<=N, row i of the
//         matrix was interchanged with row IPIV(i).
// WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
// LWORK   (input) INTEGER
//         The dimension of the array WORK.  LWORK >= max(1,N).
//         For optimal performance LWORK >= N*NB, where NB is
//         the optimal blocksize returned by ILAENV.
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
//         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
//               singular and its inverse could not be computed.","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dgeqpf)
// {"Lapack documentation:
//    SUBROUTINE DGEQPF( M, N, A, LDA, JPVT, TAU, WORK, INFO )
// -- LAPACK test routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, LDA, M, N
//    ..
//    .. Array Arguments ..
//    INTEGER            JPVT( * )
//    DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( * )
//    ..
// Purpose
// =======
// DGEQPF computes a QR factorization with column pivoting of a
// real M-by-N matrix A: A*P = Q*R.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix A. M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix A. N >= 0
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the M-by-N matrix A.
//         On exit, the upper triangle of the array contains the
//         min(M,N)-by-N upper triangular matrix R; the elements
//         below the diagonal, together with the array TAU,
//         represent the orthogonal matrix Q as a product of
//         min(m,n) elementary reflectors.
// LDA     (input) INTEGER
//         The leading dimension of the array A. LDA >= max(1,M).
// JPVT    (input/output) INTEGER array, dimension (N)
//         On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
//         to the front of A*P (a leading column); if JPVT(i) = 0,
//         the i-th column of A is a free column.
//         On exit, if JPVT(i) = k, then the i-th column of A*P
//         was the k-th column of A.
// TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
//         The scalar factors of the elementary reflectors.
// WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument had an illegal value
// Further Details
// ===============
// The matrix Q is represented as a product of elementary reflectors
//    Q = H(1) H(2) . . . H(n)
// Each H(i) has the form
//    H = I - tau * v * v'
// where tau is a real scalar, and v is a real vector with
// v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
// The matrix P is represented in jpvt as follows: If
//    jpvt(j) = i
// then the jth column of P is the ith canonical unit vector.","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.Matrices.LAPACK.dorgqr)
// {"Lapack documentation:
//    SUBROUTINE DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
// -- LAPACK routine (version 1.1) --
//    Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//    Courant Institute, Argonne National Lab, and Rice University
//    March 31, 1993
//    .. Scalar Arguments ..
//    INTEGER            INFO, K, LDA, LWORK, M, N
//    ..
//    .. Array Arguments ..
//    DOUBLE PRECISION   A( LDA, * ), TAU( * ), WORK( LWORK )
//    ..
// Purpose
// =======
// DORGQR generates an M-by-N real matrix Q with orthonormal columns,
// which is defined as the first N columns of a product of K elementary
// reflectors of order M
//       Q  =  H(1) H(2) . . . H(k)
// as returned by DGEQRF.
// Arguments
// =========
// M       (input) INTEGER
//         The number of rows of the matrix Q. M >= 0.
// N       (input) INTEGER
//         The number of columns of the matrix Q. M >= N >= 0.
// K       (input) INTEGER
//         The number of elementary reflectors whose product defines the
//         matrix Q. N >= K >= 0.
// A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
//         On entry, the i-th column must contain the vector which
//         defines the elementary reflector H(i), for i = 1,2,...,k, as
//         returned by DGEQRF in the first k columns of its array
//         argument A.
//         On exit, the M-by-N matrix Q.
// LDA     (input) INTEGER
//         The first dimension of the array A. LDA >= max(1,M).
// TAU     (input) DOUBLE PRECISION array, dimension (K)
//         TAU(i) must contain the scalar factor of the elementary
//         reflector H(i), as returned by DGEQRF.
// WORK    (workspace) DOUBLE PRECISION array, dimension (LWORK)
//         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
// LWORK   (input) INTEGER
//         The dimension of the array WORK. LWORK >= max(1,N).
//         For optimum performance LWORK >= N*NB, where NB is the
//         optimal blocksize.
// INFO    (output) INTEGER
//         = 0:  successful exit
//         < 0:  if INFO = -i, the i-th argument has an illegal value
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.sin)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 0.0}, {-68.7, 34.2}, {-61.5, 53.1}, {-55.1, 66.40000000000001}, {-49.4, 74.59999999999999}, {-43.8, 79.09999999999999}, {-38.2, 79.8}, {-32.6, 76.59999999999999}, {-26.9, 69.7}, {-21.3, 59.4}, {-14.9, 44.1}, {-6.83, 21.2}, {10.1, -30.8}, {17.3, -50.2}, {23.7, -64.2}, {29.3, -73.09999999999999}, {35.0, -78.40000000000001}, {40.6, -80.0}, {46.2, -77.59999999999999}, {51.9, -71.5}, {57.5, -61.9}, {63.9, -47.2}, {72.0, -24.8}, {80.0, 0.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{12, 84}, {84, 36}}, "sin", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.sin)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 0}, {84, 6}, {84, -6}, {100, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 0.0}, {-68.7, 34.2}, {-61.5, 53.1}, {-55.1, 66.40000000000001}, {-49.4, 74.59999999999999}, {-43.8, 79.09999999999999}, {-38.2, 79.8}, {-32.6, 76.59999999999999}, {-26.9, 69.7}, {-21.3, 59.4}, {-14.9, 44.1}, {-6.83, 21.2}, {10.1, -30.8}, {17.3, -50.2}, {23.7, -64.2}, {29.3, -73.09999999999999}, {35.0, -78.40000000000001}, {40.6, -80.0}, {46.2, -77.59999999999999}, {51.9, -71.5}, {57.5, -61.9}, {63.9, -47.2}, {72.0, -24.8}, {80.0, 0.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-105, 72}, {-85, 88}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{70, 25}, {90, 5}}, "2*pi", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-103, -72}, {-83, -88}}, "-1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{82, -6}, {102, -26}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, 80}, {-28, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, -80}, {50, -80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.sin)
// {"<html>
// <p>
// This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/sin.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.cos)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-74.40000000000001, 78.09999999999999}, {-68.7, 72.3}, {-63.1, 63.0}, {-56.7, 48.7}, {-48.6, 26.6}, {-29.3, -32.5}, {-22.1, -51.7}, {-15.7, -65.3}, {-10.1, -73.8}, {-4.42, -78.8}, {1.21, -79.90000000000001}, {6.83, -77.09999999999999}, {12.5, -70.59999999999999}, {18.1, -60.6}, {24.5, -45.7}, {32.6, -23.0}, {50.3, 31.3}, {57.5, 50.7}, {63.9, 64.59999999999999}, {69.5, 73.40000000000001}, {75.2, 78.59999999999999}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-36, 82}, {36, 34}}, "cos", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.cos)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-103, 72}, {-83, 88}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-103, -72}, {-83, -88}}, "-1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{70, 25}, {90, 5}}, "2*pi", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, 0}, {82, 6}, {82, -6}, {98, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-74.40000000000001, 78.09999999999999}, {-68.7, 72.3}, {-63.1, 63.0}, {-56.7, 48.7}, {-48.6, 26.6}, {-29.3, -32.5}, {-22.1, -51.7}, {-15.7, -65.3}, {-10.1, -73.8}, {-4.42, -78.8}, {1.21, -79.90000000000001}, {6.83, -77.09999999999999}, {12.5, -70.59999999999999}, {18.1, -60.6}, {24.5, -45.7}, {32.6, -23.0}, {50.3, 31.3}, {57.5, 50.7}, {63.9, 64.59999999999999}, {69.5, 73.40000000000001}, {75.2, 78.59999999999999}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{78, -6}, {98, -26}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, -80}, {18, -80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.cos)
// {"<html>
// <p>
// This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/cos.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.tan)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-78.40000000000001, -68.40000000000001}, {-76.8, -59.7}, {-74.40000000000001, -50.0}, {-71.2, -40.9}, {-67.09999999999999, -33.0}, {-60.7, -24.8}, {-51.1, -17.2}, {-35.8, -9.98}, {-4.42, -1.07}, {33.4, 9.119999999999999}, {49.4, 16.2}, {59.1, 23.2}, {65.5, 30.6}, {70.40000000000001, 39.1}, {73.59999999999999, 47.4}, {76.0, 56.1}, {77.59999999999999, 63.8}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-90, 72}, {-18, 24}}, "tan", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.tan)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-37, -72}, {-17, -88}}, "-5.8", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-33, 86}, {-13, 70}}, " 5.8", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{68, -13}, {88, -33}}, "1.4", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, 0}, {82, 6}, {82, -6}, {98, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-78.40000000000001, -68.40000000000001}, {-76.8, -59.7}, {-74.40000000000001, -50.0}, {-71.2, -40.9}, {-67.09999999999999, -33.0}, {-60.7, -24.8}, {-51.1, -17.2}, {-35.8, -9.98}, {-4.42, -1.07}, {33.4, 9.119999999999999}, {49.4, 16.2}, {59.1, 23.2}, {65.5, 30.6}, {70.40000000000001, 39.1}, {73.59999999999999, 47.4}, {76.0, 56.1}, {77.59999999999999, 63.8}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{82, 22}, {102, 2}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {86, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 88}, {80, -16}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.tan)
// {"<html>
// <p>
// This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
// (if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
// </p>
//
// <p>
// <img src=\"../Images/Math/tan.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.asin)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-79.2, -72.8}, {-77.59999999999999, -67.5}, {-73.59999999999999, -59.4}, {-66.3, -49.8}, {-53.5, -37.3}, {-30.2, -19.7}, {37.4, 24.8}, {57.5, 40.8}, {68.7, 52.7}, {75.2, 62.2}, {77.59999999999999, 67.5}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-88, 78}, {-16, 30}}, "asin", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.asin)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-40, -72}, {-15, -88}}, "-pi/2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-38, 88}, {-13, 72}}, " pi/2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{68, -9}, {88, -29}}, "+1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-90, 21}, {-70, 1}}, "-1", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, 0}, {82, 6}, {82, -6}, {98, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-79.2, -72.8}, {-77.59999999999999, -67.5}, {-73.59999999999999, -59.4}, {-66.3, -49.8}, {-53.5, -37.3}, {-30.2, -19.7}, {37.4, 24.8}, {57.5, 40.8}, {68.7, 52.7}, {75.2, 62.2}, {77.59999999999999, 67.5}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{82, 24}, {102, 4}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {86, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 86}, {80, -10}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.asin)
// {"<html>
// <p>
// This function returns y = asin(u), with -1 &le; u &le; +1:
// </p>
//
// <p>
// <img src=\"../Images/Math/asin.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.acos)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, -80}, {68, -80}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, -80}, {68, -72}, {68, -88}, {90, -80}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-79.2, 72.8}, {-77.59999999999999, 67.5}, {-73.59999999999999, 59.4}, {-66.3, 49.8}, {-53.5, 37.3}, {-30.2, 19.7}, {37.4, -24.8}, {57.5, -40.8}, {68.7, -52.7}, {75.2, -62.2}, {77.59999999999999, -67.5}, {80.0, -80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-86, -14}, {-14, -62}}, "acos", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.acos)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, -80}, {84, -80}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, -80}, {82, -74}, {82, -86}, {98, -80}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-79.2, 72.8}, {-77.59999999999999, 67.5}, {-73.59999999999999, 59.4}, {-66.3, 49.8}, {-53.5, 37.3}, {-30.2, 19.7}, {37.4, -24.8}, {57.5, -40.8}, {68.7, -52.7}, {75.2, -62.2}, {77.59999999999999, -67.5}, {80.0, -80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, 88}, {-5, 72}}, " pi", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, -57}, {-74, -77}}, "-1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{60, -81}, {80, -101}}, "+1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{82, -56}, {102, -76}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-2, 80}, {84, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 82}, {80, -86}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.acos)
// {"<html>
// <p>
// This function returns y = acos(u), with -1 &le; u &le; +1:
// </p>
//
// <p>
// <img src=\"../Images/Math/acos.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.atan)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-52.7, -75.2}, {-37.4, -69.7}, {-26.9, -63.0}, {-19.7, -55.2}, {-14.1, -45.8}, {-10.1, -36.4}, {-6.03, -23.9}, {-1.21, -5.06}, {5.23, 21.0}, {9.25, 34.1}, {13.3, 44.2}, {18.1, 52.9}, {24.5, 60.8}, {33.4, 67.59999999999999}, {47.0, 73.59999999999999}, {69.5, 78.59999999999999}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-86, 68}, {-14, 20}}, "atan", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.atan)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{96, 0}, {80, 6}, {80, -6}, {96, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-52.7, -75.2}, {-37.4, -69.7}, {-26.9, -63.0}, {-19.7, -55.2}, {-14.1, -45.8}, {-10.1, -36.4}, {-6.03, -23.9}, {-1.21, -5.06}, {5.23, 21.0}, {9.25, 34.1}, {13.3, 44.2}, {18.1, 52.9}, {24.5, 60.8}, {33.4, 67.59999999999999}, {47.0, 73.59999999999999}, {65.0, 77.0}, {80.0, 78.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-34, 87}, {-14, 74}}, "pi/2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-32, -71}, {-12, -91}}, "-pi/2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{84, -4}, {104, -24}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-2, 80}, {84, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.atan)
// {"<html>
// <p>
// This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/atan.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.atan2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, -80.0}, {8.93, -67.2}, {17.1, -59.3}, {27.3, -53.6}, {42.1, -49.4}, {69.90000000000001, -45.8}, {80.0, -45.1}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -34.9}, {-46.1, -31.4}, {-29.4, -27.1}, {-18.3, -21.5}, {-10.3, -14.5}, {-2.03, -3.17}, {7.97, 11.6}, {15.5, 19.4}, {24.3, 25.0}, {39.0, 30.0}, {62.1, 33.5}, {80.0, 34.9}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 45.1}, {-45.9, 48.7}, {-29.1, 52.9}, {-18.1, 58.6}, {-10.2, 65.8}, {-1.82, 77.2}, {0.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-90, -46}, {-18, -94}}, "atan2", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.atan2)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{96, 0}, {80, 6}, {80, -6}, {96, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0.0, -80.0}, {8.93, -67.2}, {17.1, -59.3}, {27.3, -53.6}, {42.1, -49.4}, {69.90000000000001, -45.8}, {80.0, -45.1}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -34.9}, {-46.1, -31.4}, {-29.4, -27.1}, {-18.3, -21.5}, {-10.3, -14.5}, {-2.03, -3.17}, {7.97, 11.6}, {15.5, 19.4}, {24.3, 25.0}, {39.0, 30.0}, {62.1, 33.5}, {80.0, 34.9}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 45.1}, {-45.9, 48.7}, {-29.1, 52.9}, {-18.1, 58.6}, {-10.2, 65.8}, {-1.82, 77.2}, {0.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-32, 89}, {-10, 74}}, "pi", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-32, -72}, {-4, -88}}, "-pi", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, 55}, {20, 42}}, "pi/2", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 40}, {-8, 40}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{0, -40}, {-8, -40}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{0, -23}, {20, -42}}, "-pi/2", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{62, -4}, {94, -26}}, "u1, u2", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-88, 40}, {86, 40}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-86, -40}, {86, -40}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.atan2)
// {"<HTML>
// This function returns y = atan2(u1,u2) such that tan(y) = u1/u2 and
// y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
// u1 is not zero. Usually u1, u2 is provided in such a form that
// u1 = sin(y) and u2 = cos(y):
// </p>
//
// <p>
// <img src=\"../Images/Math/atan2.png\">
// </p>
//
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.sinh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-76.0, -65.40000000000001}, {-71.2, -51.4}, {-65.5, -38.8}, {-59.1, -28.1}, {-51.1, -18.7}, {-41.4, -11.4}, {-27.7, -5.5}, {-4.42, -0.653}, {24.5, 4.57}, {39.0, 10.1}, {49.4, 17.2}, {57.5, 25.9}, {63.9, 35.8}, {69.5, 47.4}, {74.40000000000001, 60.4}, {78.40000000000001, 73.8}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-88, 80}, {-16, 32}}, "sinh", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.sinh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, 0}, {82, 6}, {82, -6}, {98, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-76.0, -65.40000000000001}, {-71.2, -51.4}, {-65.5, -38.8}, {-59.1, -28.1}, {-51.1, -18.7}, {-41.4, -11.4}, {-27.7, -5.5}, {-4.42, -0.653}, {24.5, 4.57}, {39.0, 10.1}, {49.4, 17.2}, {57.5, 25.9}, {63.9, 35.8}, {69.5, 47.4}, {74.40000000000001, 60.4}, {78.40000000000001, 73.8}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-31, 72}, {-11, 88}}, "27", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-35, -88}, {-15, -72}}, "-27", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{68, -7}, {88, -27}}, "4", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-98, 21}, {-78, 1}}, "-4", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{80, 26}, {100, 6}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {86, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 84}, {80, -6}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.sinh)
// {"<html>
// <p>
// This function returns y = sinh(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/sinh.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.cosh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90.0, -86.083}, {68.0, -86.083}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90.0, -86.083}, {68.0, -78.083}, {68.0, -94.083}, {90.0, -86.083}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-77.59999999999999, 61.1}, {-74.40000000000001, 39.3}, {-71.2, 20.7}, {-67.09999999999999, 1.29}, {-63.1, -14.6}, {-58.3, -29.8}, {-52.7, -43.5}, {-46.2, -55.1}, {-39.0, -64.3}, {-30.2, -71.7}, {-18.9, -77.09999999999999}, {-4.42, -79.90000000000001}, {10.9, -79.09999999999999}, {23.7, -75.2}, {34.2, -68.7}, {42.2, -60.6}, {48.6, -51.2}, {54.3, -40.0}, {59.1, -27.5}, {63.1, -14.6}, {67.09999999999999, 1.29}, {71.2, 20.7}, {74.40000000000001, 39.3}, {77.59999999999999, 61.1}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{4, 66}, {66, 20}}, "cosh", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.cosh)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100.0, -84.083}, {84.0, -84.083}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98.0, -84.083}, {82.0, -78.083}, {82.0, -90.083}, {98.0, -84.083}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, 80.0}, {-77.59999999999999, 61.1}, {-74.40000000000001, 39.3}, {-71.2, 20.7}, {-67.09999999999999, 1.29}, {-63.1, -14.6}, {-58.3, -29.8}, {-52.7, -43.5}, {-46.2, -55.1}, {-39.0, -64.3}, {-30.2, -71.7}, {-18.9, -77.09999999999999}, {-4.42, -79.90000000000001}, {10.9, -79.09999999999999}, {23.7, -75.2}, {34.2, -68.7}, {42.2, -60.6}, {48.6, -51.2}, {54.3, -40.0}, {59.1, -27.5}, {63.1, -14.6}, {67.09999999999999, 1.29}, {71.2, 20.7}, {74.40000000000001, 39.3}, {77.59999999999999, 61.1}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-31, 72}, {-11, 88}}, "27", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{64, -83}, {84, -103}}, "4", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-94, -63}, {-74, -83}}, "-4", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{80, -60}, {100, -80}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {88, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 84}, {80, -90}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.cosh)
// {"<html>
// <p>
// This function returns y = cosh(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/cosh.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.tanh)
// {-100.0,-100.0,100.0,100.0,true,0.1,0.5,0.5,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-47.8, -78.7}, {-35.8, -75.7}, {-27.7, -70.59999999999999}, {-22.1, -64.2}, {-17.3, -55.9}, {-12.5, -44.3}, {-7.64, -29.2}, {-1.21, -4.82}, {6.83, 26.3}, {11.7, 42.0}, {16.5, 54.2}, {21.3, 63.1}, {26.9, 69.90000000000001}, {34.2, 75.0}, {45.4, 78.40000000000001}, {72.0, 79.90000000000001}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-88, 72}, {-16, 24}}, "tanh", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.tanh)
// {-100.0,-100.0,100.0,100.0,true,0.1,0.5,0.5,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{96, 0}, {80, 6}, {80, -6}, {96, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.5}, {-47.8, -79.2}, {-35.8, -76.2}, {-27.7, -71.09999999999999}, {-22.1, -64.7}, {-17.3, -56.4}, {-12.5, -44.8}, {-7.64, -29.7}, {-1.21, -5.32}, {6.83, 25.8}, {11.7, 41.5}, {16.5, 53.7}, {21.3, 62.6}, {26.9, 69.40000000000001}, {34.2, 74.5}, {45.4, 77.90000000000001}, {72.0, 79.40000000000001}, {80.0, 79.5}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-29, 72}, {-9, 88}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{3, -72}, {23, -88}}, "-1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{82, -2}, {102, -22}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {88, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.tanh)
// {"<html>
// <p>
// This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/tanh.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.exp)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90.0, -80.3976}, {68.0, -80.3976}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90.0, -80.3976}, {68.0, -72.3976}, {68.0, -88.3976}, {90.0, -80.3976}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-31.0, -77.90000000000001}, {-6.03, -74.0}, {10.9, -68.40000000000001}, {23.7, -61.0}, {34.2, -51.6}, {43.0, -40.3}, {50.3, -27.8}, {56.7, -13.5}, {62.3, 2.23}, {67.09999999999999, 18.6}, {72.0, 38.2}, {76.0, 57.6}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-86, 50}, {-14, 2}}, "exp", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.exp)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100.0, -80.3976}, {84.0, -80.3976}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98.0, -80.3976}, {82.0, -74.3976}, {82.0, -86.3976}, {98.0, -80.3976}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-31.0, -77.90000000000001}, {-6.03, -74.0}, {10.9, -68.40000000000001}, {23.7, -61.0}, {34.2, -51.6}, {43.0, -40.3}, {50.3, -27.8}, {56.7, -13.5}, {62.3, 2.23}, {67.09999999999999, 18.6}, {72.0, 38.2}, {76.0, 57.6}, {80.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-31, 72}, {-11, 88}}, "20", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-92, -81}, {-72, -101}}, "-3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{66, -81}, {86, -101}}, "3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{2, -69}, {22, -89}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{78, -54}, {98, -74}}, "u", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{0, 80}, {88, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 84}, {80, -84}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.exp)
// {"<html>
// <p>
// This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
// </p>
//
// <p>
// <img src=\"../Images/Math/exp.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.log)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80.0, -80.0}, {-79.2, -50.6}, {-78.40000000000001, -37.0}, {-77.59999999999999, -28.0}, {-76.8, -21.3}, {-75.2, -11.4}, {-72.8, -1.31}, {-69.5, 8.08}, {-64.7, 17.9}, {-57.5, 28.0}, {-47.0, 38.1}, {-31.8, 48.1}, {-10.1, 58.0}, {22.1, 68.0}, {68.7, 78.09999999999999}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-6, -24}, {66, -72}}, "log", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.log)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 0}, {84, 6}, {84, -6}, {100, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-78.0, -80.0}, {-77.2, -50.6}, {-76.40000000000001, -37.0}, {-75.59999999999999, -28.0}, {-74.8, -21.3}, {-73.2, -11.4}, {-70.8, -1.31}, {-67.5, 8.08}, {-62.7, 17.9}, {-55.5, 28.0}, {-45.0, 38.1}, {-29.8, 48.1}, {-8.1, 58.0}, {24.1, 68.0}, {70.7, 78.09999999999999}, {82.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-105, 72}, {-85, 88}}, "3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{60, -3}, {80, -23}}, "20", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-78, -7}, {-58, -27}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{84, 26}, {104, 6}}, "u", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 9}, {-80, -11}}, "0", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, 80}, {84, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{82, 82}, {82, -6}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.log)
// {"<html>
// <p>
// This function returns y = log(10) (the natural logarithm of u),
// with u &gt; 0:
// </p>
//
// <p>
// <img src=\"../Images/Math/log.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.log10)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-90, 0}, {68, 0}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, 0}, {68, 8}, {68, -8}, {90, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-79.8, -80.0}, {-79.2, -50.6}, {-78.40000000000001, -37.0}, {-77.59999999999999, -28.0}, {-76.8, -21.3}, {-75.2, -11.4}, {-72.8, -1.31}, {-69.5, 8.08}, {-64.7, 17.9}, {-57.5, 28.0}, {-47.0, 38.1}, {-31.8, 48.1}, {-10.1, 58.0}, {22.1, 68.0}, {68.7, 78.09999999999999}, {80.0, 80.0}}, {0, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-30, -22}, {60, -70}}, "log10", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.log10)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-100, 0}, {84, 0}}, {95, 95, 95}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {95, 95, 95}, {95, 95, 95}, LinePattern.Solid, FillPattern.Solid, 0.25, {{98, 0}, {82, 6}, {82, -6}, {98, 0}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-77.8, -80.0}, {-77.2, -50.6}, {-76.40000000000001, -37.0}, {-75.59999999999999, -28.0}, {-74.8, -21.3}, {-73.2, -11.4}, {-70.8, -1.31}, {-67.5, 8.08}, {-62.7, 17.9}, {-55.5, 28.0}, {-45.0, 38.1}, {-29.8, 48.1}, {-8.1, 58.0}, {24.1, 68.0}, {70.7, 78.09999999999999}, {82.0, 80.0}}, {0, 0, 255}, LinePattern.Solid, 0.5, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{66, -13}, {86, -33}}, "20", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-78, -1}, {-58, -21}}, "1", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-83, 62}, {-63, 78}}, " 1.3", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {95, 95, 95}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{80, 24}, {100, 4}}, "u", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 9}, {-80, -11}}, "0", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-80, 80}, {86, 80}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{80, 92}, {80, -12}}, {175, 175, 175}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Math.log10)
// {"<html>
// <p>
// This function returns y = log10(u),
// with u &gt; 0:
// </p>
//
// <p>
// <img src=\"../Images/Math/log10.png\">
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.tempInterpol1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.tempInterpol1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Math.tempInterpol2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Math.tempInterpol2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.FluxTubeConcept)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.FluxTubeConcept)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.ReluctanceForceCalculation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.ReluctanceForceCalculation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SaturatedInductor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceCurrentBehaviour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceStrokeBehaviour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ForceStrokeBehaviour)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.ArmatureStroke)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.Components.PermeanceActuator)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.MovingCoilActuator.Components.ConstantActuator)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonQuasiStationary)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonQuasiStationary)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonPullInStroke)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.ComparisonPullInStroke)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.Components.SimpleSolenoid)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.SolenoidActuator.Components.AdvancedSolenoid)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Examples.Utilities.CoilDesign)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.ConstantReluctance)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.LeakageWithCoefficient)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Basic.EddyCurrent)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.HollowCylinderAxialFlux)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.HollowCylinderRadialFlux)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.FixedShape.Cuboid)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderAxialFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderAxialFlux)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderRadialFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.HollowCylinderRadialFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidParallelFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidParallelFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidOrthogonalFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.CuboidOrthogonalFlux)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.LeakageAroundPoles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Force.LeakageAroundPoles)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfHollowCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.HalfHollowCylinder)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.QuarterHollowSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfHollowSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.EighthOfHollowSphere)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.CoaxCylindersEndFaces)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Shapes.Leakage.CoaxCylindersEndFaces)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.BaseData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.BaseData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMnPb28)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMnPb28)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.Steel_9SMn28K)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC01)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.DC03)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.X6Cr17)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_1008)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.Steel.AISI_12L14)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M330_50A)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M350_50A)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M530_50A)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M700_100A)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.ElectricSheet.M940_100A)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.RFe80)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.PureIron.VacoferS2)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.CobaltIron.Vacoflux50)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.MuMetall)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.NickelIron.Permenorm3601K3)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.mu_rApprox)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.SoftMagnetic.mu_rApprox)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.BaseData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.BaseData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.NdFeB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.NdFeB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.Sm2Co17)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.Sm2Co17)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.SmCo5)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.SmCo5)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticNdFeB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticNdFeB)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticSmCo)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticSmCo)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.HardFerrite)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.HardFerrite)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticHardFerrite)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Material.HardMagnetic.PlasticHardFerrite)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.MagneticPort)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.MagneticPort)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PositiveMagneticPort)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.NegativeMagneticPort)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPortsElementary)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPorts)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialTwoPorts)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialFixedShape)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialForce)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Interfaces.PartialLeakage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.ConstantMagneticPotentialDifference)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.SignalMagneticPotentialDifference)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sources.SignalMagneticFlux)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticPotentialDifferenceSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticFluxSensor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Magnetic.FluxTubes.Sensors.MagneticFluxSensor)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.Utilities.RealSwitch)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.AmplifierWithOpAmpDetailed)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.AmplifierWithOpAmpDetailed)
// {"<html>
// <p>
// With the test circuit AmplifierWithOpAmpDetailed a time domain analysis of the example arrangement with a sinusoidal input voltage (12 V amplitude, frequency 1 kHz) using the operational amplifier model OpAmpDetailed is carried out. The working voltages are 15 V and -15 V.
// </p>
//
// </HTML>","<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i>Juni 17, 2009   </i>
//        by Susann Wolf<br> realized<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-88, 102}, {92, 48}}, "Characteristic Ideal Diodes", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicIdealDiodes)
// {"<HTML>
// <P>
// Three examples of ideal diodes are shown:<br><br>
// the <b>totally ideal diode</b> (Ideal) with all parameters to be zero <br>
// the <b>nearly ideal diode</b> with <i>Ron=0.1</i> and <i>Goff=0.1</i> <br>
// the nearly ideal but <b>displaced diode</b> with <i>Vknee=5</i> and <i>Ron=0.1</i> and
// <i>Goff=0.1</i> <br><br>
// The resistance and conductance are chosen untypically high since the slopes should
// be seen in the graphics.
// </P>
// <P>
// Simulate until T=1 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// Ideal.i versus Ideal.v <br>
// With_Ron_Goff.i versus With_Ron_Goff.v<br>
// With_Ron_Goff_Vknee.i versus With_Ron_Goff_Vknee.v<br>
// </P>
//
// </HTML>
// ","<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, 100}, {98, 60}}, "Characteristic Thyristors", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CharacteristicThyristors)
// {"<HTML>
// <P>
// Two examples of thyristors are shown:<br><br>
// the <b>ideal thyristor</b>  <br>
// and the <b>ideal GTO thyristor</b>  with <i>Vknee=5</i>  <br><br>
// </P>
// <P>
// Simulate until T=2 s.
// </P>
// <P>
// Plot in separate windows:<br> <br>
// IdealThyristor1.i and IdealGTOThyristor1.i <br>
// IdealThyristor1.v and IdealGTOThyristor1.v <br>
// </P>
//
// </HTML>
// ","<html>
// <p><b>Release Notes:</b></p>
// <ul>
// <li><i>Mai 7, 2004   </i>
//        by Christoph Clauss<br> realized<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-60, -80}, {60, -100}}, "try considerMagnetization=false/true", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-60, 20}, {60, 0}}, "Basic.Transformer (mutual inductance)", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.CompareTransformers)
// {"<html>
// <p>
// This example is o demonstrate the behaviour of transformer models. The Basic.Transformer, which consists of mutual coupled inductors,<br>
// is compared with the ideal transformer model. If the ideal model is used with considerMagnetization=true eakage inductances are taken <br>
// into account, otherwise not.
// </p>
// <p>
// The example is constructed in such a way that the ideal transformer circuit with considerMagnetization=true shows the same behaviour as the basic transformer.
// </p>
//
// Simulate until T=50 s with both considerMagnetization=false and <br>
// considerMagnetization=true of the ideal transformer.<br>
// Plot in separate windows for comparison:<br> <br>
// basicTransformer.p1.v and idealTransformer.p1.v <br>
// basicTransformer.p1.i and idealTransformer.p1.i <br>
// basicTransformer.p2.v and idealTransformer.p2.v <br>
// basicTransformer.p2.i and idealTransformer.p2.i <br>
//
// </P>
//
//
// </html>","<html>
// <ul>
// <li><i>  </i>
//        </li>
// <li><i> 2009   </i>
//        by Anton Haumer<br> initially implemented<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-100, 80}, {100, 60}}, "Compare voltage and current of inductor1 and inductor2", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Analog.Examples.ControlledSwitchWithArc)
// {"<html>
// <P>
// This example is to compare the behaviour of switch models with
// and without an electric arc taking into consideration.<br><br>
//
// </P>
// <P>
// Simulate until T=2 s.
// </P>
// <P>
// Plot in one windows:<br> <br>
// switch1.i and switch2.i <br><br>
//
// The difference in the closing area shows that the simple arc model avoids
// the suddenly switching.
//
// </P>
// </html>","<html>
// <ul>
// <li><i>May, 2009   </i>
//        by Anton Haumer<br> initially realized<br>
//        </li>
// </ul>
// </html>",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingMOSInverter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingNPN_OrGate)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingRectifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.HeatingResistor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.OvervoltageProtection)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.Rectifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.ShowSaturatingInductor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.ShowVariableResistor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Examples.SwitchWithArc)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Examples.ThyristorBehaviourTest)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Basic.M_Transformer)
// {annotation(
//   Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {Ellipse(extent = {{-36, 24}, {-18, 42}}), Ellipse(extent = {{18, 24}, {36, 42}}), Ellipse(extent = {{0, 24}, {18, 42}}), Ellipse(extent = {{-18, 24}, {0, 42}}), Rectangle(extent = {{42, 24}, {-44, 34}}, lineColor = {0, 0, 255}, pattern = LinePattern.None, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Line(points = {{-36, 34}, {-62, 34}}, color = {0, 0, 255}, pattern = LinePattern.None), Line(points = {{62, 34}, {36, 34}}, color = {0, 0, 255}, pattern = LinePattern.None), Ellipse(extent = {{-36, 8}, {-18, 26}}), Ellipse(extent = {{18, 8}, {36, 26}}), Ellipse(extent = {{0, 8}, {18, 26}}), Ellipse(extent = {{-18, 8}, {0, 26}}), Rectangle(extent = {{42, 6}, {-44, 18}}, lineColor = {0, 0, 255}, pattern = LinePattern.None, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Line(points = {{-36, 18}, {-62, 18}}, color = {0, 0, 255}, pattern = LinePattern.None), Line(points = {{62, 18}, {36, 18}}, color = {0, 0, 255}, pattern = LinePattern.None), Line(points = {{-36, -29}, {-62, -29}}, color = {0, 0, 255}, pattern = LinePattern.None), Ellipse(extent = {{-36, -40}, {-18, -22}}), Ellipse(extent = {{-18, -40}, {0, -22}}), Ellipse(extent = {{0, -40}, {18, -22}}), Ellipse(extent = {{18, -40}, {36, -22}}), Line(points = {{62, -29}, {36, -29}}, color = {0, 0, 255}, pattern = LinePattern.None), Rectangle(extent = {{42, -42}, {-44, -30}}, lineColor = {0, 0, 255}, pattern = LinePattern.None, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Line(points = {{0, 8}, {0, -18}}, color = {0, 0, 255}, pattern = LinePattern.Dot), Text(extent = {{-150, 103}, {150, 63}}, textString = "%name", lineColor = {0, 0, 255})}, Ellipse(extent = [-36, 24; -18, 42]), Ellipse(extent = [18, 24; 36, 42]), Ellipse(extent = [0, 24; 18, 42]), Ellipse(extent = [-18, 24; 0, 42]), Rectangle(extent = [42, 24; -44, 34], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255})), Line(points = [-36, 34; -62, 34], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Line(points = [62, 34; 36, 34], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Ellipse(extent = [-36, 8; -18, 26]), Ellipse(extent = [18, 8; 36, 26]), Ellipse(extent = [0, 8; 18, 26]), Ellipse(extent = [-18, 8; 0, 26]), Rectangle(extent = [42, 6; -44, 18], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255})), Line(points = [-36, 18; -62, 18], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Line(points = [62, 18; 36, 18], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Line(points = [-36, -29; -62, -29], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Ellipse(extent = [-36, -40; -18, -22]), Ellipse(extent = [-18, -40; 0, -22]), Ellipse(extent = [0, -40; 18, -22]), Ellipse(extent = [18, -40; 36, -22]), Line(points = [62, -29; 36, -29], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)), Rectangle(extent = [42, -42; -44, -30], style(pattern = 0, fillColor = 7, rgbfillColor = {255, 255, 255})), Line(points = [0, 8; 0, -18], style(pattern = 3, fillColor = 7, rgbfillColor = {255, 255, 255}, fillPattern = 1)))) }
// Evaluating: getErrorString()
// "[Modelica 3.1/Electrical/Analog/Basic.mo:737:15-737:38:writable] Notification: From here:
// [Modelica 3.1/Electrical/Analog/Basic.mo:738:15-738:36:writable] Error: Duplicate modification of element Ellipse.extent on component Icon.
// "
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Basic.M_Transformer)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Interfaces.TwoPin)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Interfaces.OnePort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Analog.Interfaces.TwoPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.VoltageSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Interfaces.CurrentSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Lines.M_OLine)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Analog.Sensors.PowerSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.ReleaseNotes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.Literature)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Digital.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Multiplexer)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.FlipFlop)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.HalfAdder)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.FullAdder)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Adder4)
// {-200.0,-200.0,200.0,200.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Counter3)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Counter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.MUX4)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.RS)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.RSFF)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.DFF)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.JKFF)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.HalfAdder)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.FullAdder)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.Adder)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Examples.Utilities.Counter3)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Digital.Interfaces.Logic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.Logic)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Digital.Interfaces.Logic)
// {"<html>
// <p><b>Code Table:</b></p>
//
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\"><b>Logic value</b></td>
//       <td valign=\"top\"><b>Meaning</b></td>
//   </tr>
//
//   <tr><td valign=\"top\">'U'</td> <td valign=\"top\">Uninitialized</td></tr>
//   <tr><td valign=\"top\">'X'</td> <td valign=\"top\">Forcing Unknown</td></tr>
//   <tr><td valign=\"top\">'0'</td> <td valign=\"top\">Forcing 0</td></tr>
//   <tr><td valign=\"top\">'1'</td> <td valign=\"top\">Forcing 1</td></tr>
//   <tr><td valign=\"top\">'Z'</td> <td valign=\"top\">High Impedance</td></tr>
//   <tr><td valign=\"top\">'W'</td> <td valign=\"top\">Weak Unknown</td></tr>
//   <tr><td valign=\"top\">'L'</td> <td valign=\"top\">Weak 0</td></tr>
//   <tr><td valign=\"top\">'H'</td> <td valign=\"top\">Weak 1</td></tr>
//   <tr><td valign=\"top\">'-'</td> <td valign=\"top\">Don't care</td></tr>
// </table>
//
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.DigitalSignal)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Digital.Interfaces.DigitalOutput)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.SISO)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Interfaces.MISO)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Digital.Delay.DelayParams)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Delay.DelayParams)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Delay.TransportDelay)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Delay.InertialDelay)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Delay.InertialDelaySensitive)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Not)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.And)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Nand)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Or)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Nor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Xor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Basic.Xnor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.InvGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.AndGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.NandGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.OrGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.NorGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.XorGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.XnorGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Gates.BufGate)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Set)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Step)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Table)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Pulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Sources.Clock)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToXO1)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToXO1Z)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToUX01)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.BooleanToLogic)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.RealToLogic)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Digital.Converters.LogicToReal)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_DOL)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_DOL)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_YD)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_YD)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMS_Start)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMS_Start)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Inverter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Inverter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.SMR_Inverter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMR_Inverter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.SMPM_Inverter)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMPM_Inverter)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.SMEE_Generator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.SMEE_Generator)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.DCPM_Start)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCPM_Start)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.DCEE_Start)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCEE_Start)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.DCSE_Start)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.DCSE_Start)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.TransformerTestbench)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.TransformerTestbench)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.Rectifier6pulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.Rectifier6pulse)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.Rectifier12pulse)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.Rectifier12pulse)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Examples.AIMC_Steinmetz)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SquirrelCage)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines.AIM_SlipRing)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_PermanentMagnet)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ElectricalExcited)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.SM_ReluctanceRotor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_PermanentMagnet)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_ElectricalExcited)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.DCMachines.DC_SeriesExcited)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy00)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy00)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy02)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy02)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy04)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy04)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy06)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy06)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy08)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy08)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy10)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yy.Yy10)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd01)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd01)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd03)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd03)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd05)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd05)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd07)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd07)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd09)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd09)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd11)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yd.Yd11)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz01)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz01)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz03)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz03)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz05)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz05)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz07)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz07)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz09)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz09)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz11)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Yz.Yz11)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy01)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy01)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy03)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy03)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy05)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy05)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy07)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy07)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy09)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy09)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy11)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dy.Dy11)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd00)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd00)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd02)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd02)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd04)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd04)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd06)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd06)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd08)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd08)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd10)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dd.Dd10)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz00)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz00)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz02)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz02)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz04)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz04)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz06)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz06)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz08)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz08)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz10)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Transformers.Dz.Dz10)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialAirGap)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapS)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapR)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.SquirrelCage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.DamperCage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.ElectricalExcitation)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PermanentMagnet)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialAirGapDC)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.AirGapDC)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.BasicTransformer)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.PartialCore)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.IdealCore)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.BasicMachines.Components.IdealCore)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.VoltageQuasiRMSSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.CurrentQuasiRMSSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.ElectricalPowerSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.MechanicalPowerSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Sensors.RotorDisplacementAngle)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Components.SpacePhasor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Components.Rotator)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.FromSpacePhasor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.Rotator)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.ToPolar)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Blocks.FromPolar)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromSpacePhasor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromSpacePhasor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.Rotator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.Rotator)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToPolar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.ToPolar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromPolar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.SpacePhasors.Functions.FromPolar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicMachine)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicInductionMachine)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Interfaces.PartialBasicDCMachine)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.VfController)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.SwitchYD)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.TerminalBox)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.SwitchedRheostat)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.SwitchedRheostat)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.RampedRheostat)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.RampedRheostat)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Electrical.Machines.Utilities.TransformerData)
// {"","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYY)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYY)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYD)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.TransformerYD)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Examples.Rectifier)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Examples.Rectifier)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Star)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Delta)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.PlugToPin_p)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.PlugToPin_n)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Resistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Conductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Capacitor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Inductor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.SaturatingInductor)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.Transformer)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableResistor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableConductor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableCapacitor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Basic.VariableInductor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealThyristor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealGTOThyristor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealCommutingSwitch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealIntermediateSwitch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealDiode)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealTransformer)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.Idle)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.Short)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealOpeningSwitch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.IdealClosingSwitch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.OpenerWithArc)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Ideal.CloserWithArc)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.Plug)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.ConditionalHeatPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPlug)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPlug)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.OnePort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.OnePort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.FourPlug)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.FourPlug)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Interfaces.TwoPort)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.PotentialSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.VoltageSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.CurrentSensor)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sensors.PowerSensor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SignalVoltage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.ConstantVoltage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SineVoltage)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SignalCurrent)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.ConstantCurrent)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Electrical.MultiPhase.Sources.SineCurrent)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.PID_Controller)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.PID_Controller)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-99, 48}, {-32, 8}}, 0), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-98, 59}, {-31, 51}}, "reference speed generation", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-98, -46}, {-60, -52}}, "PI controller", 0, TextAlignment.Center), Line(true, {0.0, 0.0}, 0, {{-76, -44}, {-57, -23}}, {255, 0, 0}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.Filled}, 3, Smooth.None), Rectangle(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, BorderPattern.None, {{-25, 6}, {99, -50}}, 0), Text(true, {0.0, 0.0}, 0, {255, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{4, 14}, {71, 7}}, "plant (simple drive train)", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.PID_Controller)
// {"<html>
//
// <p>
// This is a simple drive train controlled by a PID controller:
// </p>
//
// <ul>
// <li> The two blocks \"kinematic_PTP\" and \"integrator\" are used to generate
//      the reference speed (= constant acceleration phase, constant speed phase,
//      constant deceleration phase until inertia is at rest). To check
//      whether the system starts in steady state, the reference speed is
//      zero until time = 0.5 s and then follows the sketched trajectory.</li>
//
// <li> The block \"PI\" is an instance of \"Blocks.Continuous.LimPID\" which is
//      a PID controller where several practical important aspects, such as
//      anti-windup-compensation has been added. In this case, the control block
//      is used as PI controller.</li>
//
// <li> The output of the controller is a torque that drives a motor inertia
//      \"inertia1\". Via a compliant spring/damper component, the load
//      inertia \"inertia2\" is attached. A constant external torque of 10 Nm
//      is acting on the load inertia.</li>
// </ul>
//
// <p>
// The PI controller settings included \"limitAtInit=false\", in order that
// the controller output limits of 12 Nm are removed from the initialization
// problem.
// </p>
//
// <p>
// The PI controller is initialized in steady state (initType=SteadyState)
// and the drive shall also be initialized in steady state.
// However, it is not possible to initialize \"inertia1\" in SteadyState, because
// \"der(inertia1.phi)=inertia1.w=0\" is an input to the PI controller that
// defines that the derivative of the integrator state is zero (= the same
// condition that was already defined by option SteadyState of the PI controller).
// Furthermore, one initial condition is missing, because the absolute position
// of inertia1 or inertia2 is not defined. The solution shown in this examples is
// to initialize the angle and the angular acceleration of \"inertia1\".
// </p>
//
// <p>
// In the following figure, results of a typical simulation are shown:
// </p>
//
// <p>
// <img src=\"../Images/Blocks/PID_controller.png\"><br>
// <img src=\"../Images/Blocks/PID_controller2.png\">
// </p>
//
// <p>
// In the upper figure the reference speed (= integrator.y) and
// the actual speed (= inertia1.w) are shown. As can be seen,
// the system initializes in steady state, since no transients
// are present. The inertia follows the reference speed quite good
// until the end of the constant speed phase. Then there is a deviation.
// In the lower figure the reason can be seen: The output of the
// controller (PI.y) is in its limits. The anti-windup compensation
// works reasonably, since the input to the limiter (PI.limiter.u)
// is forced back to its limit after a transient phase.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.InverseModel)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.InverseModel)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.InverseModel)
// {"<html>
// <p>
// This example demonstrates how to construct an inverse model in Modelica
// (for more details see <a href=\"http://www.modelica.org/events/Conference2005/online_proceedings/Session3/Session3c3.pdf\">Looye, Th&uuml;mmel, Kurze, Otter, Bals: Nonlinear Inverse Models for Control</a>).
// </p>
//
// <p>
// For a linear, single input, single output system
// </p>
//
// <pre>
//    y = n(s)/d(s) * u   // plant model
// </pre>
//
// <p>
// the inverse model is derived by simply exchanging the numerator and
// the denominator polynomial:
// </p>
//
// <pre>
//    u = d(s)/n(s) * y   // inverse plant model
// </pre>
//
// <p>
// If the denominator polynomial d(s) has a higher degree as the
// numerator polynomial n(s) (which is usually the case for plant models),
// then the inverse model is no longer proper, i.e., it is not causal.
// To avoid this, an approximate inverse model is constructed by adding
// a sufficient number of poles to the denominator of the inverse model.
// This can be interpreted as filtering the desired output signal y:
// </p>
//
// <pre>
//    u = d(s)/(n(s)*f(s)) * y  // inverse plant model with filtered y
// </pre>
//
// <p>
// With Modelica it is in principal possible to construct inverse models not only
// for linear but also for non-linear models and in particular for every
// Modelica model. The basic construction mechanism is explained at hand
// of this example:
// </p>
//
// <p>
// <img src=\"../Images/Blocks/InverseModelSchematic.png\">
// </p>
//
// <p>
// Here the first order block \"firstOrder1\" shall be inverted. This is performed
// by connecting its inputs and outputs with an instance of block
// Modelica.Blocks.Math.<b>InverseBlockConstraints</b>. By this connection,
// the inputs and outputs are exchanged. The goal is to compute the input of the
// \"firstOrder1\" block so that its output follows a given sine signal.
// For this, the sine signal \"sin\" is first filtered with a \"CriticalDamping\"
// filter of order 1 and then the output of this filter is connected to the output
// of the \"firstOrder1\" block (via the InverseBlockConstraints block, since
// 2 outputs cannot be connected directly together in a block diagram).
// </p>
//
// <p>
// In order to check the inversion, the computed input of \"firstOrder1\" is used
// as input in an identical block \"firstOrder2\". The output of \"firstOrder2\" should
// be the given \"sine\" function. The difference is constructed with the \"feedback\"
// block. Since the \"sine\" function is filtered, one cannot expect that this difference
// is zero. The higher the cut-off frequency of the filter, the closer is the
// agreement. A typical simulation result is shown in the next figure:
// </p>
//
// <p>
// <img src=\"../Images/Blocks/InverseModel.png\">
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.ShowLogicalSources)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.ShowLogicalSources)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.ShowLogicalSources)
// {"<html>
// <p>
// This simple example demonstrates the logical sources in
// <a href=\"Modelica://Modelica.Blocks.Sources\">Modelica.Blocks.Sources</a> and demonstrate
// their diagram animation (see \"small circle\" close to the output connector).
// The \"booleanExpression\" source shows how a logical expression can be defined
// in its parameter menu refering to variables available on this level of the
// model.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.LogicalNetwork1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.LogicalNetwork1)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.LogicalNetwork1)
// {"<html>
// <p>
// This example demonstrates a network of logical blocks. Note, that
// the Boolean values of the input and output signals are visualized
// in the diagram animation, by the small \"circles\" close to the connectors.
// If a \"circle\" is \"white\", the signal is <b>false</b>. It a
// \"circle\" is \"green\", the signal is <b>true</b>.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage)
// {"<html>
// <p><b>Signal bus concept</b></p>
// <p>
// In technical systems, such as vehicles, robots or satellites, many signals
// are exchanged between components. In a simulation system, these signals
// are  usually modelled by signal connections of input/output blocks.
// Unfortunately, the signal connection structure may become very complicated,
// especially for hierarchical models.
// </p>
//
// <p>
// The same is also true for real technical systems. To reduce complexity
// and get higher flexibility, many technical systems use data buses to
// exchange data between components. For the same reasons, it is often better
// to use a \"signal bus\" concept also in a Modelica model. This is demonstrated
// at hand of this model (Modelica.Blocks.Examples.BusUsage):
// </p>
//
// <p align=\"center\">
// <img src=\"../Images/Blocks/BusUsage.png\">
// </p>
//
// <ul>
// <li> Connector instance \"controlBus\" is a hierarchical connector that is
//      used to exchange signals between different components. It is
//      defined as \"expandable connector\" in order that <b>no</b> central definition
//      of the connector is needed but is automatically constructed by the
//      signals connected to it (see also Modelica specification 2.2.1).</li>
// <li> Input/output signals can be directly connected to the \"controlBus\".</li>
// <li> A component, such as \"part\", can be directly connected to the \"controlBus\",
//      provided it has also a bus connector, or the \"part\" connector is a
//      sub-connector contained in the \"controlBus\". </li>
// </ul>
//
// <p>
// The control and sub-control bus icons are provided within Modelica.Icons.
// In <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces\">Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces</a>
// the buses for this example are defined. Both the \"ControlBus\" and the \"SubControlBus\" are
// <b>expandable</b> connectors that do not define any variable. For example,
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus#text\">Interfaces.ControlBus</a>
// is defined as:
// </p>
// <pre>  <b>expandable connector</b> ControlBus
//       <b>extends</b> Modelica.Icons.ControlBus;
//       <b>annotation</b> (Icon(Rectangle(extent=[-20, 2; 22, -2],
//                        style(rgbcolor={255,204,51}, thickness=0.5))));
//   <b>end</b> ControlBus;
// </pre>
// <p>
// Note, the \"annotation\" in the connector is important since the color
// and thickness of a connector line are taken from the first
// line element in the icon annotation of a connector class. Above, a small rectangle in the
// color of the bus is defined (and therefore this rectangle is not
// visible). As a result, when connecting from an instance of this
// connector to another connector instance, the connecting line has
// the color of the \"ControlBus\" with double width (due to \"thickness=0.5\").
// </p>
//
// <p>
// An <b>expandable</b> connector is a connector where the content of the connector
// is constructed by the variables connected to instances of this connector.
// For example, if \"sine.y\" is connected to the \"controlBus\", the following
// menu pops-up in Dymola:
// </p>
//
// <p align=\"center\">
// <img src=\"../Images/Blocks/BusUsage2.png\">
// </p>
//
// <p>
// The \"Add variable/New name\" field allows the user to define the name of the signal on
// the \"controlBus\". When typing \"realSignal1\" as \"New name\", a connection of the form:
// </p>
//
// <pre>     <b>connect</b>(sine.y, controlBus.realSignal1)
// </pre>
//
// <p>
// is generated and the \"controlBus\" contains the new signal \"realSignal1\". Modelica tools
// may give more support in order to list potential signals for a connection.
// For example, in Dymola all variables are listed in the menu that are contained in
// connectors which are derived by inheritance from \"controlBus\". Therefore, in
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors\">BusUsage_Utilities.Interfaces.InternalConnectors</a>
// the expected implementation of the \"ControlBus\" and of the \"SubControlBus\" are given.
// For example \"Internal.ControlBus\" is defined as:
// </p>
//
// <pre>  <b>expandable connector</b> StandardControlBus
//     <b>extends</b> BusUsage_Utilities.Interfaces.ControlBus;
//
//     <b>import</b> SI = Modelica.SIunits;
//     SI.AngularVelocity    realSignal1   \"First Real signal\";
//     SI.Velocity           realSignal2   \"Second Real signal\";
//     Integer               integerSignal \"Integer signal\";
//     Boolean               booleanSignal \"Boolean signal\";
//     StandardSubControlBus subControlBus \"Combined signal\";
//   <b>end</b> StandardControlBus;
// </pre>
//
// <p>
// Consequently, when connecting now from \"sine.y\" to \"controlBus\", the menu
// looks differently:
// </p>
// <p align=\"center\">
// <img src=\"../Images/Blocks/BusUsage3.png\">
// </p>
// <p>
// Note, even if the signals from \"Internal.StandardControlBus\" are listed, these are
// just potential signals. The user might still add different signal names.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus)
// {"<html>
// <p>
// This connector defines the \"expandable connector\" ControlBus that
// is used as bus in the
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage\">BusUsage</a> example.
// Note, this connector is \"empty\". When using it, the actual content is
// constructed by the signals connected to this bus.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus)
// {"<html>
// <p>
// This connector defines the \"expandable connector\" SubControlBus that
// is used as sub-bus in the
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage\">BusUsage</a> example.
// Note, this connector is \"empty\". When using it, the actual content is
// constructed by the signals connected to this bus.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardControlBus)
// {"<html>
// <p>
// This connector is used to show default signals that might be added
// to the
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.ControlBus\">ControlBus</a>.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {255, 204, 51}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.5, BorderPattern.None, {{-20, 2}, {22, -2}}, 0)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.InternalConnectors.StandardSubControlBus)
// {"<html>
// <p>
// This connector is used to show default signals that might be added
// to the
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage_Utilities.Interfaces.SubControlBus\">SubControlBus</a>.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 255}, {159, 159, 223}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, 60}, {100, -60}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-106, 124}, {114, 68}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Examples.BusUsage_Utilities.Part)
// {"<html>
// <p>
// <p>
// This model is used to demonstrate the bus usage in example
// <a href=\"Modelica://Modelica.Blocks.Examples.BusUsage\">BusUsage</a>.
// </p>
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Continuous.PID)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-80, 78}, {-80, -90}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 90}, {-88, 68}, {-72, 68}, {-80, 90}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, -80}, {82, -80}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, -80}, {68, -72}, {68, -88}, {90, -80}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, -80}, {-80, 50}, {-80, -20}, {60, 80}}, {0, 0, 127}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, -20}, {80, -60}}, "PID", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, -150}, {150, -110}}, "Ti=%Ti", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Continuous.PID)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Continuous.PID)
// {"<HTML>
// <p>
// This is the text-book version of a PID-controller.
// For a more practically useful PID-controller, use
// block LimPID.
// </p>
//
// <p>
// The PID block can be initialized in different
// ways controlled by parameter <b>initType</b>. The possible
// values of initType are defined in
// <a href=\"Modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
// This type is identical to
// <a href=\"Modelica://Modelica.Blocks.Types.Init\">Types.Init</a>,
// with the only exception that the additional option
// <b>DoNotUse_InitialIntegratorState</b> is added for
// backward compatibility reasons (= integrator is initialized with
// InitialState whereas differential part is initialized with
// NoInit which was the initialization in version 2.2 of the Modelica
// standard library).
// </p>
//
// <p>
// Based on the setting of initType, the integrator (I) and derivative (D)
// blocks inside the PID controller are initialized according to the following table:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\"><b>initType</b></td>
//       <td valign=\"top\"><b>I.initType</b></td>
//       <td valign=\"top\"><b>D.initType</b></td></tr>
//
//   <tr><td valign=\"top\"><b>NoInit</b></td>
//       <td valign=\"top\">NoInit</td>
//       <td valign=\"top\">NoInit</td></tr>
//
//   <tr><td valign=\"top\"><b>SteadyState</b></td>
//       <td valign=\"top\">SteadyState</td>
//       <td valign=\"top\">SteadyState</td></tr>
//
//   <tr><td valign=\"top\"><b>InitialState</b></td>
//       <td valign=\"top\">InitialState</td>
//       <td valign=\"top\">InitialState</td></tr>
//
//   <tr><td valign=\"top\"><b>InitialOutput</b><br>
//           and initial equation: y = y_start</td>
//       <td valign=\"top\">NoInit</td>
//       <td valign=\"top\">SteadyState</td></tr>
//
//   <tr><td valign=\"top\"><b>DoNotUse_InitialIntegratorState</b></td>
//       <td valign=\"top\">InitialState</td>
//       <td valign=\"top\">NoInit</td></tr>
// </table>
//
// <p>
// In many cases, the most useful initial condition is
// <b>SteadyState</b> because initial transients are then no longer
// present. If initType = InitPID.SteadyState, then in some
// cases difficulties might occur. The reason is the
// equation of the integrator:
// </p>
//
// <pre>
//    <b>der</b>(y) = k*u;
// </pre>
//
// <p>
// The steady state equation \"der(x)=0\" leads to the condition that the input u to the
// integrator is zero. If the input u is already (directly or indirectly) defined
// by another initial condition, then the initialization problem is <b>singular</b>
// (has none or infinitely many solutions). This situation occurs often
// for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
// since speed is both a state and a derivative, it is natural to
// initialize it with zero. As sketched this is, however, not possible.
// The solution is to not initialize u or the variable that is used
// to compute u by an algebraic equation.
// </p>
//
//
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Continuous.LimPID)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{-80, 78}, {-80, -90}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{-80, 90}, {-88, 68}, {-72, 68}, {-80, 90}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-90, -80}, {82, -80}}, {192, 192, 192}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Polygon(true, {0.0, 0.0}, 0, {192, 192, 192}, {192, 192, 192}, LinePattern.Solid, FillPattern.Solid, 0.25, {{90, -80}, {68, -72}, {68, -88}, {90, -80}}, Smooth.None), Line(true, {0.0, 0.0}, 0, {{-80, -80}, {-80, 50}, {-80, -20}, {30, 60}, {80, 60}}, {0, 0, 127}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Text(true, {0.0, 0.0}, 0, {192, 192, 192}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-20, -20}, {80, -60}}, "PID", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Continuous.LimPID)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Continuous.LimPID)
// {"<HTML>
// <p>
// Via parameter <b>controllerType</b> either <b>P</b>, <b>PI</b>, <b>PD</b>,
// or <b>PID</b> can be selected. If, e.g., PI is selected, all components belonging to the
// D-part are removed from the block (via conditional declarations).
// The example model
// <a href=\"Modelica://Modelica.Blocks.Examples.PID_Controller\">Modelica.Blocks.Examples.PID_Controller</a>
// demonstrates the usage of this controller.
// Several practical aspects of PID controller design are incorporated
// according to chapter 3 of the book:
// </p>
//
// <dl>
// <dt>&Aring;str&ouml;m K.J., and H&auml;gglund T.:</dt>
// <dd> <b>PID Controllers: Theory, Design, and Tuning</b>.
//      Instrument Society of America, 2nd edition, 1995.
// </dd>
// </dl>
//
// <p>
// Besides the additive <b>proportional, integral</b> and <b>derivative</b>
// part of this controller, the following features are present:
// </p>
// <ul>
// <li> The output of this controller is limited. If the controller is
//      in its limits, anti-windup compensation is activated to drive
//      the integrator state to zero. </li>
// <li> The high-frequency gain of the derivative part is limited
//      to avoid excessive amplification of measurement noise.</li>
// <li> Setpoint weighting is present, which allows to weight
//      the setpoint in the proportional and the derivative part
//      independantly from the measurement. The controller will respond
//      to load disturbances and measurement noise independantly of this setting
//      (parameters wp, wd). However, setpoint changes will depend on this
//      setting. For example, it is useful to set the setpoint weight wd
//      for the derivative part to zero, if steps may occur in the
//      setpoint signal.</li>
// </ul>
//
// <p>
// The parameters of the controller can be manually adjusted by performing
// simulations of the closed loop system (= controller + plant connected
// together) and using the following strategy:
// </p>
//
// <ol>
// <li> Set very large limits, e.g., yMax = Modelica.Constants.inf</li>
// <li> Select a <b>P</b>-controller and manually enlarge parameter <b>k</b>
//      (the total gain of the controller) until the closed-loop response
//      cannot be improved any more.</li>
// <li> Select a <b>PI</b>-controller and manually adjust parameters
//      <b>k</b> and <b>Ti</b> (the time constant of the integrator).
//      The first value of Ti can be selected, such that it is in the
//      order of the time constant of the oscillations occuring with
//      the P-controller. If, e.g., vibrations in the order of T=10 ms
//      occur in the previous step, start with Ti=0.01 s.</li>
// <li> If you want to make the reaction of the control loop faster
//      (but probably less robust against disturbances and measurement noise)
//      select a <b>PID</b>-Controller and manually adjust parameters
//      <b>k</b>, <b>Ti</b>, <b>Td</b> (time constant of derivative block).</li>
// <li> Set the limits yMax and yMin according to your specification.</li>
// <li> Perform simulations such that the output of the PID controller
//      goes in its limits. Tune <b>Ni</b> (Ni*Ti is the time constant of
//      the anti-windup compensation) such that the input to the limiter
//      block (= limiter.u) goes quickly enough back to its limits.
//      If Ni is decreased, this happens faster. If Ni=infinity, the
//      anti-windup compensation is switched off and the controller works bad.</li>
// </ol>
//
// <p>
// <b>Initialization</b>
// </p>
//
// <p>
// This block can be initialized in different
// ways controlled by parameter <b>initType</b>. The possible
// values of initType are defined in
// <a href=\"Modelica://Modelica.Blocks.Types.InitPID\">Modelica.Blocks.Types.InitPID</a>.
// This type is identical to
// <a href=\"Modelica://Modelica.Blocks.Types.Init\">Types.Init</a>,
// with the only exception that the additional option
// <b>DoNotUse_InitialIntegratorState</b> is added for
// backward compatibility reasons (= integrator is initialized with
// InitialState whereas differential part is initialized with
// NoInit which was the initialization in version 2.2 of the Modelica
// standard library).
// </p>
//
// <p>
// Based on the setting of initType, the integrator (I) and derivative (D)
// blocks inside the PID controller are initialized according to the following table:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
//   <tr><td valign=\"top\"><b>initType</b></td>
//       <td valign=\"top\"><b>I.initType</b></td>
//       <td valign=\"top\"><b>D.initType</b></td></tr>
//
//   <tr><td valign=\"top\"><b>NoInit</b></td>
//       <td valign=\"top\">NoInit</td>
//       <td valign=\"top\">NoInit</td></tr>
//
//   <tr><td valign=\"top\"><b>SteadyState</b></td>
//       <td valign=\"top\">SteadyState</td>
//       <td valign=\"top\">SteadyState</td></tr>
//
//   <tr><td valign=\"top\"><b>InitialState</b></td>
//       <td valign=\"top\">InitialState</td>
//       <td valign=\"top\">InitialState</td></tr>
//
//   <tr><td valign=\"top\"><b>InitialOutput</b><br>
//           and initial equation: y = y_start</td>
//       <td valign=\"top\">NoInit</td>
//       <td valign=\"top\">SteadyState</td></tr>
//
//   <tr><td valign=\"top\"><b>DoNotUse_InitialIntegratorState</b></td>
//       <td valign=\"top\">InitialState</td>
//       <td valign=\"top\">NoInit</td></tr>
// </table>
//
// <p>
// In many cases, the most useful initial condition is
// <b>SteadyState</b> because initial transients are then no longer
// present. If initType = InitPID.SteadyState, then in some
// cases difficulties might occur. The reason is the
// equation of the integrator:
// </p>
//
// <pre>
//    <b>der</b>(y) = k*u;
// </pre>
//
// <p>
// The steady state equation \"der(x)=0\" leads to the condition that the input u to the
// integrator is zero. If the input u is already (directly or indirectly) defined
// by another initial condition, then the initialization problem is <b>singular</b>
// (has none or infinitely many solutions). This situation occurs often
// for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
// since speed is both a state and a derivative, it is natural to
// initialize it with zero. As sketched this is, however, not possible.
// The solution is to not initialize u_m or the variable that is used
// to compute u_m by an algebraic equation.
// </p>
//
// <p>
// If parameter <b>limitAtInit</b> = <b>false</b>, the limits at the
// output of this controller block are removed from the initialization problem which
// leads to a much simpler equation system. After initialization has been
// performed, it is checked via an assert whether the output is in the
// defined limits. For backward compatibility reasons
// <b>limitAtInit</b> = <b>true</b>. In most cases it is best
// to use <b>limitAtInit</b> = <b>false</b>.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Continuous.Der)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Text(true, {0.0, 0.0}, 0, {0, 0, 127}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-80, 76}, {80, -82}}, "der()", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Continuous.Der)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Continuous.Der)
// {"<HTML>
// <p>
// Defines that the output y is the <i>derivative</i>
// of the input u. Note, that Modelica.Blocks.Continuous.Derivative
// computes the derivative in an approximate sense, where as this block computes
// the derivative exactly. This requires that the input u is differentiated
// by the Modelica translator, if this derivative is not yet present in
// the model.
// </p>
// </HTML>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Line(true, {0.0, 0.0}, 0, {{-78, -42}, {-52, -42}, {-52, 0}, {-26, 0}, {-26, 24}, {-6, 24}, {-6, 64}, {18, 64}, {18, 20}, {38, 20}, {38, 0}, {44, 0}, {44, 0}, {62, 0}}, {0, 0, 127}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Discrete.ZeroOrderHold)
// {"<HTML>
// <p>
// The output is identical to the sampled input signal at sample
// time instants and holds the output at the value of the last
// sample instant during the sample points.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Discrete.FirstOrderHold)
// {-100.0,-100.0,100.0,100.0,true,0.1,1.0,1.0,{Line(true, {0.0, 0.0}, 0, {{-79, -41}, {-59, -33}, {-40, 1}, {-20, 9}, {0, 63}, {21, 20}, {41, 10}, {60, 20}}, {0, 0, 127}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None), Line(true, {0.0, 0.0}, 0, {{60, 19}, {81, 10}}, {0, 0, 255}, LinePattern.Solid, 0.25, {Arrow.None, Arrow.None}, 3, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Discrete.FirstOrderHold)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Discrete.FirstOrderHold)
// {"<HTML>
// <p>
// The output signal is the extrapolation through the
// values of the last two sampled input signals.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.BlockIcon)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 127}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.None, {{-100, -100}, {100, 100}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 150}, {150, 110}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.BlockIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.BlockIcon)
// {"<html>
// <p>
// Block that has only the basic icon for an input/output
// block (no declarations, no equations). Most blocks
// of package Modelica.Blocks inherit directly or indirectly
// from this block.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SO)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.SO)
// {"<html>
// <p>
// Block has one continuous Real output signal.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.MO)
// {"<html>
// <p>
// Block has one continuous Real output signal vector.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.SISO)
// {"<html>
// <p>
// Block has one continuous Real input and one continuous Real output signal.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SI2SO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SI2SO)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.SI2SO)
// {"<html>
// <p>
// Block has two continuous Real input signals u1 and u2 and one
// continuous Real output signal y.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.SIMO)
// {"<HTML>
// <p> Block has one continuous Real input signal and a
//     vector of continuous Real output signals.</p>
//
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.MISO)
// {"<HTML>
// <p>
// Block has a vector of continuous Real input signals and
// one continuous Real output signal.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.MIMO)
// {"<HTML>
// <p>
// Block has a continuous Real input and a continuous Real output signal vector.
// The signal sizes of the input and output vector may be different.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.MIMOs)
// {"<HTML>
// <p>
// Block has a continuous Real input and a continuous Real output signal vector
// where the signal sizes of the input and output vector are identical.
// </p>
// </HTML>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MI2MO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MI2MO)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.MI2MO)
// {"<html>
// <p>
// Block has two continuous Real input vectors u1 and u2 and one
// continuous Real output vector y.
// All vectors have the same number of elements.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SignalSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SignalSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Interfaces.SignalSource)
// {"<html>
// <p>
// Basic block for Real sources of package Blocks.Sources.
// This component has one continuous Real output signal y
// and two parameters (offset, startTime) to shift the
// generated signal.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SVcontrol)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MVcontrol)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteBlockIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteBlock)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteBlock)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteSISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteSISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.DiscreteMIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SVdiscrete)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MVdiscrete)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanBlockIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.BooleanSISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanSISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.BooleanMIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanMIMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.MI2BooleanMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.MI2BooleanMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.SI2BooleanSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.SI2BooleanSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.BooleanSignalSource)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerBlockIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.IntegerMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerMO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSignalSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSignalSource)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.IntegerSIBooleanSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerSIBooleanSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Interfaces.IntegerMIBooleanMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.IntegerMIBooleanMOs)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanBlockIcon)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSISO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI2SO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI3SO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSI)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanSO)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanThresholdComparison)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.partialBooleanComparison)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.SendInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveBoolean)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.Adaptors.ReceiveInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Interfaces.PartialConversionBlock)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.And)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Or)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Xor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Nor)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Nand)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Not)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Pre)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Edge)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.FallingEdge)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Change)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.GreaterThreshold)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.GreaterEqualThreshold)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.LessThreshold)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.LessEqualThreshold)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Greater)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.GreaterEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Less)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.LessEqual)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.ZeroCrossing)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.LogicalSwitch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.Switch)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.OnOffController)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Logical.TerminateSimulation)
// {-200.0,-20.0,200.0,20.0,true,0.2,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degC)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degF)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_degRk)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_deg)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_rpm)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_kmh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_day)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_hour)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_minute)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_litre)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_kWh)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_bar)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.To_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.UnitConversions.From_gps)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.InverseBlockConstraints)
// {-200.0,-120.0,200.0,120.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.RealToInteger)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.IntegerToReal)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.BooleanToReal)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.BooleanToInteger)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.RealToBoolean)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.IntegerToBoolean)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.RectangularToPolar)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.PolarToRectangular)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.Max)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.Min)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.Edge)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.BooleanChange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Math.IntegerChange)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Routing.Replicator)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Routing.RealPassThrough)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Routing.IntegerPassThrough)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Routing.BooleanPassThrough)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Sources.RealExpression)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Sources.IntegerExpression)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {235, 235, 235}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.Raised, {{-100, 40}, {100, -40}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, 15}, {96, -15}}, "%y", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 90}, {140, 50}}, "%name", 0, TextAlignment.Center)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Sources.IntegerExpression)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Sources.IntegerExpression)
// {"<html>
// <p>
// The (time varying) Integer output signal of this block can be defined in its
// parameter menu via variable <b>y</b>. The purpose is to support the
// easy definition of Integer expressions in a block diagram. For example,
// in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
// to define that the output signal is one, if time &ge; 1 and otherwise
// it is zero. Note, that \"time\" is a built-in variable that is always
// accessible and represents the \"model time\" and that
// Variable <b>y</b> is both a variable and a connector.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Sources.BooleanExpression)
// {-100.0,-100.0,100.0,100.0,false,0.1,2.0,2.0,{Rectangle(true, {0.0, 0.0}, 0, {0, 0, 0}, {235, 235, 235}, LinePattern.Solid, FillPattern.Solid, 0.25, BorderPattern.Raised, {{-100, 40}, {100, -40}}, 0), Text(true, {0.0, 0.0}, 0, {0, 0, 0}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-96, 15}, {96, -15}}, "%y", 0, TextAlignment.Center), Text(true, {0.0, 0.0}, 0, {0, 0, 255}, {0, 0, 0}, LinePattern.Solid, FillPattern.None, 0.25, {{-150, 90}, {140, 50}}, "%name", 0, TextAlignment.Center), Polygon(true, {0.0, 0.0}, 0, {255, 0, 255}, {255, 255, 255}, LinePattern.Solid, FillPattern.Solid, 0.25, {{100, 10}, {120, 0}, {100, -10}, {100, 10}}, Smooth.None)}}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Sources.BooleanExpression)
// {-100.0,-100.0,100.0,100.0,true,0.1,2.0,2.0}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Sources.BooleanExpression)
// {"<html>
// <p>
// The (time varying) Boolean output signal of this block can be defined in its
// parameter menu via variable <b>y</b>. The purpose is to support the
// easy definition of Boolean expressions in a block diagram. For example,
// in the y-menu the definition \"time &gt;= 1 and time &lt;= 2\" can be given in order
// to define that the output signal is <b>true</b> in the time interval
// 1 &le; time &le; 2 and otherwise it is <b>false</b>.
// Note, that \"time\" is a built-in variable that is always
// accessible and represents the \"model time\" and that
// Variable <b>y</b> is both a variable and a connector.
// </p>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Types.Smoothness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Types.Smoothness)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Types.Smoothness)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Types.Extrapolation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Types.Extrapolation)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Types.Extrapolation)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Types.Init)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Types.Init)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Types.Init)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Types.InitPID)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Types.InitPID)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Types.InitPID)
// {"<html>
// <p>
// This initialization type is identical to Types.Init and has just one
// additional option <b>DoNotUse_InitialIntegratorState</b>. This option
// is introduced in order that the default initialization for the
// Continuous.PID and Continuous.LimPID blocks are backward
// compatible. In Modelica 2.2, the integrators have been initialized
// with their given states where as the D-part has not been initialized.
// The option \"DoNotUse_InitialIntegratorState\" leads to this
// initialization definition.
// </p>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.Blocks.Types.SimpleController)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.Blocks.Types.SimpleController)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.Blocks.Types.SimpleController)
// {"<html>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.Overview)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.Overview)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.Overview)
// {"<html>
// <p>
// The Modelica Standard Library consists of the following
// main sub-libraries:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><th>Library Components</th> <th>Description</th></tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Electrical.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Electrical.Analog\">Analog</a><br>
//  Analog electric and electronic components, such as
//  resistor, capacitor, transformers, diodes, transistors,
//  transmission lines, switches, sources, sensors.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Digital.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Electrical.Digital\">Digital</a><br>
//  Digital electrical components based on the VHDL standard,
//  like basic logic blocks with 9-value logic, delays, gates,
//  sources, converters between 2-, 3-, 4-, and 9-valued logic.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Machines.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Electrical.Machines\">Machines</a><br>
//             Electrical asynchronous-, synchronous-, and DC-machines
//  (motors and generators) as well as 3-phase transformers.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-FluxTubes.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Magnetic.FluxTubes\">FluxTubes</a><br>
// Based on magnetic flux tubes concepts. Especially to model electro-magnetic actuators. Nonlinear shape, force, leackage, and material models. Material data for steel, electric sheet, pure iron, Cobalt iron, Nickel iron, NdFeB, Sm2Co17, and more.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Translational.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Mechanics.Translational\">Translational</a><br>
//  1-dim. mechanical, translational systems, e.g.,
//  sliding mass, mass with stops, spring, damper.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Rotational.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Mechanics.Rotational\">Rotational</a><br>
//  1-dim. mechanical, rotational systems, e.g., inertias, gears,
//  planetary gears, convenient definition of speed/torque dependent friction
//  (clutches, brakes, bearings, ..)
//  </td>
// </tr>
//
// <tr><td valign=\"top\" width=100>
//  <img src=\"../Images/UsersGuide/Lib-MultiBody1.png\"><br>
//  <img src=\"../Images/UsersGuide/Lib-MultiBody2.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Mechanics.MultiBody\">MultiBody</a>
//  3-dim. mechanical systems consisting of joints, bodies, force and
//  sensor elements. Joints can be driven by drive trains defined by
//  1-dim. mechanical system library (Rotational).
//  Every component has a default animation.
//  Components can be arbitrarily connected together.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Fluid.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Fluid\">Fluid</a><br>
//         1-dim. thermo-fluid flow in networks of vessels, pipes,
//         fluid machines, valves and fittings. All media from the
//         Modelica.Media library can be used (so incompressible or compressible,
//         single or multiple substance, one or two phase medium).
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Media.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Media\">Media</a><br>
//  Large media library providing models and functions
//  to compute media properties, such as h = h(p,T), d = d(p,T),
//  for the following media:
//  <ul>
//  <li> 1240 gases and mixtures between these gases.</li>
//  <li> incompressible, table based liquids (h = h(T), etc.).</li>
//  <li> compressible liquids</li>
//  <li> dry and moist air</li>
//  <li> high precision model for water (IF97).</li>
//  </ul>
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Thermal.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Thermal.FluidHeatFlow\">FluidHeatFlow</a>,
//  <a href=\"Modelica://Modelica.Thermal.HeatTransfer\">HeatTransfer</a>
//  Simple thermo-fluid pipe flow, especially to model cooling of machines
//  with air or water (pipes, pumps, valves, ambient, sensors, sources) and
//  lumped heat transfer with heat capacitors, thermal conductors, convection,
//  body radiation, sources and sensors.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-Blocks1.png\"><br>
//  <img src=\"../Images/UsersGuide/Lib-Blocks2.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Blocks\">Blocks</a><br>
//  Input/output blocks to model block diagrams and logical networks, e.g.,
//  integerator, PI, PID, transfer function, linear state space system,
//  sampler, unit delay, discrete transfer function, and/or blocks,
//  timer, hysteresis, nonlinear and routing blocks, sources, tables.
//  </td>
// </tr>
//
// <tr><td valign=\"top\">
//  <img src=\"../Images/UsersGuide/Lib-StateGraph.png\">
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.StateGraph\">StateGraph</a><br>
//  Hierarchical state machines with a similar modeling power as Statecharts.
//  Modelica is used as synchronous action language, i.e. deterministic
//  behavior is guaranteed
//  </td>
// </tr>
//
//
// <tr><td valign=\"top\">
//  <pre>
//  A = [1,2,3;
//    3,4,5;
//    2,1,4];
//  b = {10,22,12};
//  x = Matrices.solve(A,b);
//  Matrices.eigenValues(A);
//  </pre>
//  </td>
//  <td valign=\"top\">
//  <a href=\"Modelica://Modelica.Math\">Math</a>,
//  <a href=\"Modelica://Modelica.Utilities\">Utilities</a><br>
//  Functions operating on vectors and matrices, such as for solving
//  linear systems, eigen and singular values etc.,  and
//  functions operating on strings, streams, files, e.g.,
//  to copy and remove a file or sort a vector of strings.
//  </td>
// </tr>
//
// </table>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.Connectors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.Connectors)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.Connectors)
// {"<html>
//
// <p>
// The Modelica standard library defines the most important
// <b>elementary connectors</b> in various domains. If any possible,
// a user should utilize these connectors in order that components
// from the Modelica Standard Library and from other libraries
// can be combined without problems. The following elementary
// connectors are defined (potential variables are connector variables
// without the flow attribute, flow variables are connector variables
// that have the flow attribute):
// </p>
//
// <table border=1 cellspacing=0 cellpadding=1>
// <tr><td valign=\"top\"><b>domain</b></td>
//    <td valign=\"top\"><b>pot. variables</b></td>
//    <td valign=\"top\"><b>flow variables</b></td>
//    <td valign=\"top\"><b>connector definition</b></td>
//    <td valign=\"top\"><b>icons</b></td></tr>
//
// <tr><td valign=\"top\"><b>electrical<br>analog</b></td>
//    <td valign=\"top\">electrical potential</td>
//    <td valign=\"top\">electrical current</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Analog.Interfaces\">Modelica.Electrical.Analog.Interfaces</a>
//      <br>Pin, PositivePin, NegativePin</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/ElectricalPins.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>electrical<br>multi-phase</b></td>
//    <td colspan=\"2\">vector of electrical pins</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.MultiPhase.Interfaces\">Modelica.Electrical.MultiPhase.Interfaces</a>
//      <br>Plug, PositivePlug, NegativePlug</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/ElectricalPlugs.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>electrical <br>sphace phasor</b></td>
//    <td valign=\"top\">2 electrical potentials</td>
//    <td valign=\"top\">2 electrical currents</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Machines.Interfaces\">Modelica.Electrical.Machines.Interfaces</a>
//      <br>SpacePhasor</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/SpacePhasor.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>electrical <br>digital</b></td>
//    <td valign=\"top\">Integer (1..9)</td>
//    <td valign=\"top\">---</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Digital.Interfaces\">Modelica.Electrical.Digital.Interfaces</a>
//      <br>DigitalSignal, DigitalInput, DigitalOutput</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/Digital.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>magnetic</b></td>
//    <td valign=\"top\">magnetic potential</td>
//    <td valign=\"top\">magnetic flux</td>
//    <td valign=\"top\">
// <a href=\"Modelica://Modelica.Magnetic.FluxTubes.Interfaces\">Modelica.Magnetic.FluxTubes.Interfaces</a>
//      <br>MagneticPort, PositiveMagneticPort, <br>NegativeMagneticPort</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/MagneticPorts.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>translational</b></td>
//    <td valign=\"top\">distance</td>
//    <td valign=\"top\">cut-force</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.Translational.Interfaces\">Modelica.Mechanics.Translational.Interfaces</a>
//      <br>Flange_a, Flange_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/TranslationalFlanges.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>rotational</b></td>
//    <td valign=\"top\">angle</td>
//    <td valign=\"top\">cut-torque</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.Rotational.Interfaces\">Modelica.Mechanics.Rotational.Interfaces</a>
//      <br>Flange_a, Flange_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/RotationalFlanges.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>3-dim.<br>mechanics</b></td>
//    <td valign=\"top\">position vector<br>
//     orientation object</td>
//    <td valign=\"top\">cut-force vector<br>
//     cut-torque vector</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.MultiBody.Interfaces\">Modelica.Mechanics.MultiBody.Interfaces</a>
//      <br>Frame, Frame_a, Frame_b, Frame_resolve</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/MultiBodyFrames.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>simple<br>fluid flow</b></td>
//    <td valign=\"top\">pressure<br>
//     specific enthalpy</td>
//    <td valign=\"top\">mass flow rate<br>
//     enthalpy flow rate</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Thermal.FluidHeatFlow.Interfaces\">Modelica.Thermal.FluidHeatFlow.Interfaces</a>
//      <br>FlowPort, FlowPort_a, FlowPort_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/FluidHeatFlowPorts.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>thermo<br>fluid flow</b></td>
//    <td valign=\"top\">pressure<br>
//                   <u>stream</u> variables:<br>
//     &nbsp;&nbsp;specific enthalpy<br>
//     &nbsp;&nbsp;mass fractions</td>
//    <td valign=\"top\">mass flow rate</td>
//    <td valign=\"top\">
// <a href=\"Modelica://Modelica.Fluid.Interfaces\">Modelica.Fluid.Interfaces</a>
//      <br>FluidPort, FluidPort_a, FluidPort_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/FluidPorts.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>heat<br>transfer</b></td>
//    <td valign=\"top\">temperature</td>
//    <td valign=\"top\">heat flow rate</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Thermal.HeatTransfer.Interfaces\">Modelica.Thermal.HeatTransfer.Interfaces</a>
//      <br>HeatPort, HeatPort_a, HeatPort_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/ThermalHeatPorts.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>block<br>diagram</b></td>
//    <td valign=\"top\">Real variable<br>
//     Integer variable<br>
//     Boolean variable</td>
//    <td valign=\"top\">---</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Interfaces\">Modelica.Blocks.Interfaces</a>
//      <br>RealSignal, RealInput, RealOutput<br>
//       IntegerSignal, IntegerInput, IntegerOutput<br>
//       BooleanSignal, BooleanInput, BooleanOutput</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/Signals.png\"></tr>
//
// <tr><td valign=\"top\"><b>state<br>machine</b></td>
//    <td valign=\"top\">Boolean variables<br>
//     (occupied, set, <br>
//      available, reset)</td>
//    <td valign=\"top\">---</td>
//    <td valign=\"top\"><a href=\"Modelica://Modelica.StateGraph.Interfaces\">Modelica.StateGraph.Interfaces</a>
//      <br>Step_in, Step_out, Transition_in, Transition_out</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/StateGraphPorts.png\"></td></tr>
//
//
// <tr><td colspan=\"5\">&nbsp;<br><b>Connectors from other libraries</b></td></tr>
//
// <tr><td valign=\"top\"><b>hydraulic</b></td>
//    <td valign=\"top\">pressure</td>
//    <td valign=\"top\">volume flow rate</td>
//    <td valign=\"top\">HyLibLight.Interfaces
//      <br>Port_A, Port_b</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/HydraulicPorts.png\"></td></tr>
//
// <tr><td valign=\"top\"><b>pneumatic</b></td>
//    <td valign=\"top\">pressure</td>
//    <td valign=\"top\">mass flow rate</td>
//    <td valign=\"top\">PneuLibLight.Interfaces
//      <br>Port_1, Port_2</td>
//    <td valign=\"top\"><img src=\"../Images/UsersGuide/PneumaticPorts.png\"></td></tr>
// </table>
//
// <p>
// In all domains, usually 2 connectors are defined. The variable declarations
// are <b>identical</b>, only the icons are different in order that it is easy
// to distinguish connectors of the same domain that are attached at the same
// component.
// </p>
//
// <p>
// Modelica supports also hierarchical connectors, in a similar way as hierarchical models.
// As a result, it is, e.g., possible, to collect elementary connectors together.
// For example, an electrical plug consisting of two electrical pins can be defined as:
// </p>
//
// <pre>   <b>connector</b> Plug
//    <b>import</b> Modelica.Electrical.Analog.Interfaces;
//    Interfaces.PositivePin phase;
//    Interfaces.NegativePin ground;
// <b>end</b> Plug;
// </pre>
//
// <p>
// With one connect(..) equation, either two plugs can be connected
// (and therefore implicitly also the phase and ground pins) or a
// Pin connector can be directly connected to the phase or ground of
// a Plug connector, such as \"connect(resistor.p, plug.phase)\".
// </p>
//
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.Conventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.Conventions)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.Conventions)
// {"<html>
//
// <p>
// Note, in the html documentation of any Modelica library,
// the headings \"h1, h2, h3\" should not be used,
// because they are utilized from the automatically generated documentation/headings.
// Additional headings in the html documentation should start with \"h4\".
// </p>
//
// <p>
// In the Modelica package the following conventions are used:
// </p>
// <ol>
// <li> Class and instance names are written in upper and lower case
//   letters, e.g., \"ElectricCurrent\". An underscore is only used
//   at the end of a name to characterize a lower or upper index,
//   e.g., \"pin_a\".<br>&nbsp;</li>
//
// <li> <b>Class names</b> start always with an upper case letter.<br>&nbsp;</li>
//
// <li> <b>Instance names</b>, i.e., names of component instances and
//   of variables (with the exception of constants),
//   start usually with a lower case letter with only
//   a few exceptions if this is common sense
//   (such as \"T\" for a temperature variable).<br>&nbsp;</li>
//
// <li> <b>Constant names</b>, i.e., names of variables declared with the
//   \"constant\" prefix, follow the usual naming conventions
//   (= upper and lower case letters) and start usually with an
//   upper case letter, e.g. UniformGravity, SteadyState.<br>&nbsp;<li>
//
// <li> The two connectors of a domain that have identical declarations
//   and different icons are usually distinguished by \"_a\", \"_b\"
//   or \"_p\", \"_n\", e.g., Flange_a/Flange_b, HeatPort_a, HeatPort_b.<br>&nbsp;</li>
//
// <li> The <b>instance name</b> of a component is always displayed in its icon
//   (= text string \"%name\") in <b>blue color</b>. A connector class has the instance
//   name definition in the diagram layer and not in the icon layer.
//   <b>Parameter</b> values, e.g., resistance, mass, gear ratio, are displayed
//   in the icon in <b>black color</b> in a smaller font size as the instance name.
//  <br>&nbsp;<li>
//
// <li> A main package has usually the following subpackages:
//   <ul>
//   <li><b>UsersGuide</b> containing an overall description of the library
//    and how to use it.</li>
//   <li><b>Examples</b> containing models demonstrating the
//    usage of the library.</li>
//   <li><b>Interfaces</b> containing connectors and partial
//    models.</li>
//   <li><b>Types</b> containing type, enumeration and choice
//    definitions.</li>
//   </ul>
//   </li>
// </ol>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ParameterDefaults)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ParameterDefaults)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ParameterDefaults)
// {"<html>
//
// <p>
// In this section the convention is summarized how default parameters are
// handled in the Modelica Standard Library (since version 3.0).
// </p>
//
// <p>
// Many models in this library have parameter declarations to define
// constants of a model that might be changed before simulation starts.
// Example:
// </p>
//
// <blockquote>
// <pre>
// <b>model</b> SpringDamper
// <b>parameter</b> Real c(final unit=\"N.m/rad\")    = 1e5 \"Spring constant\";
// <b>parameter</b> Real d(final unit=\"N.m.s/rad\")  = 0   \"Damping constant\";
// <b>parameter</b> Modelica.SIunits.Angle phi_rel0 = 0   \"Unstretched spring angle\";
// ...
// <b>end</b> SpringDamper;
// </pre>
// </blockquote>
//
// <p>
// In Modelica it is possible to define a default value of a parameter in
// the parameter declaration. In the example above, this is performed for
// all parameters. Providing default values for all parameters can lead to
// errors that are difficult to detect, since a modeler may have forgotten
// to provide a meaningful value (the model simulates but gives wrong
// results due to wrong parameter values). In general the following basic
// situations are present:
// </p>
//
// <ol>
// <li> The parameter value could be anything (e.g., a spring constant or
//   a resistance value) and therefore the user should provide a value in
//   all cases. A Modelica translator should warn, if no value is provided.
//   <br><br></li>
//
// <li> The parameter value is not changed in &gt; 95 % of the cases
//   (e.g. initialization or visualization parameters, or parameter phi_rel0
//   in the example above). In this case a default parameter value should be
//   provided, in order that the model or function can be conveniently
//   used by a modeler.
//   <br><br></li>
//
// <li> A modeler would like to quickly utilize a model, e.g.,
//   <ul>
//   <li> to automatically check that the model still translates and/or simulates
//     (after some changes in the library),</li>
//   <li> to make a quick demo of a library by drag-and-drop of components,</li>
//   <li> to implement a simple test model in order to get a better understanding
//     of the desired component.</li>
//   </ul>
//   In all these cases, it would be not practical, if the modeler would
//   have to provide explicit values for all parameters first.
//   </li>
// </ol>
//
// <p>
// To handle the conflicting goals of (1) and (3), the Modelica Standard Library
// uses two approaches to define default parameters, as demonstrated with the
// following example:
// </p>
//
// <blockquote>
// <pre>
// <b>model</b> SpringDamper
// <b>parameter</b> Real c(final unit=\"N.m/rad\"  , start=1e5) \"Spring constant\";
// <b>parameter</b> Real d(final unit=\"N.m.s/rad\", start=  0) \"Damping constant\";
// <b>parameter</b> Modelica.SIunits.Angle phi_rel0 = 0       \"Unstretched spring angle\";
// ...
// <b>end</b> SpringDamper;
//
// SpringDamper sp1;              // warning for \"c\" and \"d\"
// SpringDamper sp2(c=1e4, d=0);  // fine, no warning
// </pre>
// </blockquote>
//
// <p>
// Both definition forms, using a \"start\" value (for \"c\" and \"d\") and providing
// a declaration equation (for \"phi_rel0\"), are valid Modelica and define the value
// of the parameter. By convention, it is expected that Modelica translators will
// trigger a warning message for parameters that are <b>not</b> defined by a declaration
// equation, by a modifier equation or in an initial equation/algorithm section.
// A Modelica translator might have options to change this behavior, especially,
// that no messages are printed in such cases and/or that an error is triggered
// instead of a warning.
// </p>
//
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.VersionManagement)
// {"<html>
// <p>
// Maintenance of the Modelica Standard Library is performed with
// three branches on the subversion server of the Modelica Association
// (<a href=\"https://svn.modelica.org/projects/Modelica\">https://svn.modelica.org/projects/Modelica</a>):
// </p>
//
// <h4>Released branch</h4>
// <p>
// Example: \"/tags/v3.0.1/Modelica\"
// </p>
//
// <p>
// This branch contains the released Modelica versions (e.g., version 3.0.1),
// where all available test cases and compatibility checks with other Modelica
// libraries have been performed on the respective release. This version is
// usually shipped with a Modelica modeling and simulation environment and
// utilized by a Modelica user.
// </p>
//
// <h4>Development branch</h4>
// <p>
// Example: \"/trunk/Modelica\"
// </p>
//
// <p>
// This branch contains the actual development version, i.e., all bug fixes
// and new features based on the last Modelica release.
// New features should have been tested before including them.
// However, the exhaustive tests for a new version are (usually) not performed.
// This version is usually only be used by the developers of the
// Modelica Standard Library and is not utilized by Modelica users.
// </p>
//
//
// <h4>Maintenance branch</h4>
// <p>
// Example: \"/branches/maintenance/3.0.1/Modelica\"
// </p>
//
// <p>
// This branch contains the released Modelica version (e.g., version 3.0.1)
// where all bug fixes since this release date are included (up to a  new release,
// when becoming available; i.e., after a new release, the previous maintenance
// versions are no longer changed).
// These bug fixes might be not yet tested with all test cases or with
// other Modelica libraries. The goal is that a vendor may take this version at
// any time for a new release of its software, in order to incorporate the latest
// bug fixes, without changing the version number of the Modelica Standard Library.
// </p>
//
// <p>
// Incorporation of bug fixes (subversion \"commit\") shall be performed in the following way:
// </p>
//
// <ul>
// <li> One person is fixing the bug and another person is checking whether the
//          fix is fine.</li>
// <li> It is up to the library developer, whether he opens a new branch for
//          testing and then merges it with the \"head\" maintenance branch or not.</li>
// <li> Every change to the maintenance branch has to be done at the development
//          branch (see above) as well.</li>
// <li> Every change to the maintenance branch requires introducing a
//          description of the bug fix under
//          Modelica.UsersGuide.ReleaseNotes.Version_&lt;release-number&gt;_BugFixes.</li>
// <li> Annotations \"version\" and \"versionDate\" must <u>not</u> be changed in a maintenance release.</li>
// <li> Every change to the maintenance branch requires changing the
//      \"versionBuild\" number (incrementing it by one), as well as the \"revisionId\".
//      The latter one is automatically done once a commit of file Modelica\\package.mo
//      is performed. Example:
//          <pre>  annotation(version      = \"3.1\",
//              versionDate  = \"2009-06-22\",
//              versionBuild = 3,
//              dateModified = \"2009-06-21 08:13:18Z\",
//              revisionId   = \"$Id::                                       $\").</pre></li>
// <li> If time does not permit, a vendor makes the bug fix in its local version
//          and then has to include it in the maintenance version. It would be best to make these
//          changes at a new branch in order to get a unique release number.</li>
// </ul>
//
// <p>
// A valid \"commit\" to the maintenance branch may contain one or
// more of the following changes.
// </p>
//
// <ul>
// <li> Correcting an equation.</li>
// <li> Correcting attributes quantity/unit/defaultUnit in a declaration.</li>
// <li> Improving/fixing the documentation.</li>
// <li> Introducing a new name in the public section of a class
//          (model, package, ...) or in any section of a partial class is <b>not</b> allowed.
//          Since otherwise, a user might use this new name and when storing its model
//          and loading it with an older build-version, an error would occur.</li>
// <li> Introducing a new name in the protected section of a non-partial
//          class should only be done if absolutely necessary to fix a bug.
//          The problem is that this might be non-backward compatible,
//          because a user might already extend from this class and already using the same name.</li>
// </ul>
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1_BugFixes)
// {"<html>
// <p>
// In this section bug fixes are summarized that have been incorporated
// for version 3.1-<b>SVN</b>:
// </p>
//
// <blockquote>
// <p>
// Modelica.Fluid.Pipes.BaseClasses.HeatTransfer.PartialPipeFlowHeatTransfer: Corrected calculation of Reynolds numbers for the heat transfer through walls of nParallel&gt;1 parallel pipes. This partial model is used by LocalPipeFlowHeatTransfer for laminar and turbulent forced convection in pipes, local coefficients.
// </p>
// </blockquote>
//
// <hr>
//
// <p>
// In this section bug fixes are summarized that have been incorporated
// for version 3.1-<b>build 6</b>:
// </p>
//
// <blockquote>
// <p>
// An \"unassignedMessage\" annotation was added to the electrical connector variables
// (Modelica.Electrical.Analog.Interfaces.*Pin). If appropriate support in the
// Modelica tool is available, then missing ground objects (Electrical.Analog.Basic.Ground)
// lead to a meaningful error message.
// </p>
// </blockquote>
//
// <hr>
//
// <p>
// In this section bug fixes are summarized that have been incorporated
// for release of version 3.1-<b>build 5</b>.
// </p>
//
// <p><br>
// The following <b style=\"color:red\">critical errors</b> have been fixed (i.e. errors
// that can lead to wrong simulation results):
// </p>
//
// <p>
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
//   <tr><td colspan=\"2\"><b>Electrical.Analog.SemiConductors.</b></td></tr>
//   <tr><td valign=\"top\"> NPN<br>
//                         PNP<br>
//                         HeatingPNP </td>
//       <td valign=\"top\"> LossPower was wrongly calculated.
//       This was corrected (<a href=\"http://trac.modelica.org/Modelica/changeset/2925/Modelica\">changeset:2925</a>,
// <a href=\"https://trac.modelica.org/Modelica/changeset/3115/\">changeset:3115</a>).</td>
//   </tr>
//
//  <tr><td colspan=\"2\"><b>Fluid.</b></td></tr>
//   <tr><td valign=\"top\">Pipes </td>
//       <td valign=\"top\"><a href=\"http://trac.modelica.org/Modelica/ticket/215\">ticket:215</a>:
//       <ul><li>fix consideration of nParallel>1 for velocity of fluid flow</li>
//           <li>fix consideration of nParallel>1 for transient changes defined by mass, energy and momentum balances</li>
//           <li>fix consideration of nNodes in nominal (inverse) flow models</li>
//       </ul>
//
//       </td>
//   </tr>
//
//  <tr><td colspan=\"2\"><b>Fluid.Examples</b></td></tr>
//   <tr><td valign=\"top\">HeatExchanger </td>
//       <td valign=\"top\"> Wrong heat transfer modifier \"perimeter\" removed.
//                         New parameter use_heatTransfer added, in order that heat transfer
//                         can be switched on (was previously always switched off)
//       </td>
//   </tr>
//
//  <tr><td colspan=\"2\"><b>Media.Interfaces.PartialMedium.</b></td></tr>
//   <tr><td valign=\"top\">IsobaricExpansionCoefficient </td>
//       <td valign=\"top\">Changed minimum from 1e-8 to 0. </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>Media.Interfaces.PartialLinearFluid.</b></td></tr>
//   <tr><td valign=\"top\">setState_psX<br>
//                        isentropicEnthalpy </td>
//       <td valign=\"top\">Wrong equations corrected. </td>
//   </tr>
//   <tr><td valign=\"top\">density_derX </td>
//       <td valign=\"top\">Missing function added. </td>
//   </tr>
//
//
//   <tr><td colspan=\"2\"><b>Media.Interfaces.PartialSimpleMedium.</b></td></tr>
//   <tr><td valign=\"top\"> specificInternalEnergy<br>
//                         specificEntropy<br>
//                         specificGibbsEnergy<br>
//                         specificHelmholtzEnergy<br>
//                         isentropicEnthalpy<br>
//                         isobaricExpansionCoefficient<br>
//                         isothermalCompressibility<br>
//                         density_derp_T<br>
//                         density_derT_p<br>
//                         density_derX<br>
//                         molarMass</td>
//       <td valign=\"top\">Missing functions added. </td>
//   </tr>
//
//
//   <tr><td colspan=\"2\"><b>Media.Interfaces.PartialSimpleIdealGasMedium.</b></td></tr>
//   <tr><td valign=\"top\"> specificInternalEnergy</td>
//       <td valign=\"top\"> wrong equation corrected </td>
//   <tr><td valign=\"top\"> isentropicEnthalpy<br>
//                         isobaricExpansionCoefficient<br>
//                         isothermalCompressibility<br>
//                         density_derp_T<br>
//                         density_derT_p<br>
//                         density_derX<br>
//                         molarMass</td>
//       <td valign=\"top\"> Missing functions added. </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>Media.CompressibleLiquids.LinearColdWater.</b></td></tr>
//   <tr><td valign=\"top\"> dynamicViscosity<br>
//                         thermalConductivity</td>
//       <td valign=\"top\"> Wrong values corrected (computed from IF97 with reference values) </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>Media.CompressibleLiquids.LinearWater_pT_Ambient.</b></td></tr>
//   <tr><td valign=\"top\"> dynamicViscosity<br>
//                         thermalConductivity</td>
//       <td valign=\"top\"> Missing functions added </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
//   <tr><td valign=\"top\"> density_derX</td>
//       <td valign=\"top\"> Wrong equation corrected. </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.</b></td></tr>
//   <tr><td valign=\"top\"> waterBaseProp_dT</td>
//       <td valign=\"top\"> Fixed dpT-calculation
//                         (<a href=\"http://trac.modelica.org/Modelica/ticket/224\">ticket: 224</a>). </td>
//   </tr>
//
//   <tr><td colspan=\"2\"><b>StateGraph.Examples.Utilities.</b></td></tr>
//   <tr><td valign=\"top\"> TankController </td>
//       <td valign=\"top\"> A graphical annotation was wrong leading to a syntax error in some Modelica tools.
//                         This has been corrected (<a href=\"http://trac.modelica.org/Modelica/ticket/206\">ticket:206</a>,
//                         <a href=\"http://trac.modelica.org/Modelica/changeset/2926/Modelica\">changeset:2926</a>). </td>
//   </tr>
// </table>
// </p>
//
// <p>
// Additionally, the following (backward compatible and uncritical) bug fixes have been applied:
// </p>
// <ul>
// <li> All class annotations have been moved just before the 'end' keyword of the class,
//      as required from Modelica 3.1.</li>
// <li> Wrong links in html-documentation to other classes and to images have been fixed.</li>
// <li> Removed fillPattern and fillColor attributes from Line annotaion
//      (<a href=\"http://trac.modelica.org/Modelica/ticket/155\">ticket:155</a>)</li>
// <li> Moved misplaced \"visible\" annotation inside \"Placement\" annotation
//      (in Modelica.StateGraph.Temporary.NumericValue).</li>
// <li> Replacement of wrong usages of \"ampersand\" in the html-documentation of
//      Machines, MultiPhase, Rotational, Translational, FluidHeatFlow, HeatTransfer
//      with the correct html-keyword.</li>
// <li> Replacement of non-standard annotations by tool specific annotations:<br>
//      Images -> __Dymola_Images,<br>
//      keepConstant -> __Dymola_keepConstant,<br>
//      editButton -> __Dymola_editButton,<br>
//      experimentSetupOutput -> __Dymola_experimentSetupOutput</li>
// <li> Replaced misspelled annotation \"tolerance\" by \"Tolerance in
//      Modelica.Fluid.Examples.TraceSubstances.RoomCO2WithControls.</li>
// <li> Added a new example Fluid.Examples.Explanatory.MeasuringTemperature
//       (copied from ModelicaTest.Fluid and adapted) since the example is useful
//       to demonstrate the differences between one- and two-port sensors and
//       because the link in Fluid.Sensors to this examples is then only inside the
//       Fluid-library and not to ModelicaTest that most people will not have.</li>
// </ul>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_1)
// {"<html>
//
// <p>
// Version 3.1 is backward compatible to version 3.0 and 3.0.1,
// i.e., models developed with version 3.0 or 3.0.1 will work without any
// changes also with version 3.1.
// </p>
//
// <p>
// Version 3.1 is slightly based on the Modelica Specification 3.1. It uses
// the following new language elements (compared to Modelica Specification 3.0):
// </p>
//
// <ul>
// <li> Prefix <u>stream</u> and built-in operators <u>inStream(..)</u>
//      and <u>actualStream(..)</u> in Modelica.Fluid.</li>
// <li> Annotation <u>connectorSizing</u> in Modelica.Fluid.</li>
// <li> Annotation <u>inverse</u> in Modelica.Media.</li>
// <li> Annotations <u>versionBuild</u>, <u>dateModified</u>,
//      <u>revisionId</u> at the root level annotation of package Modelica,
//      to improve the version handling.</li>
// <li> Modifiers can be used in connectors instances (so balanced models
//      are less restrictive). This allowed to make the implementation
//      of conditional connectors (support and heatPort) in the Rotational,
//      Translational and Electrical libraries simpler.<li>
// <li>
// </ul>
//
// <p>
// The following <b style=\"color:blue\">new libraries</b> have been added:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Fluid\">Modelica.Fluid</a></td>
//     <td valign=\"top\">
//      Components to model 1-dim. thermo-fluid flow in networks of vessels, pipes,
//      fluid machines, valves and fittings. All media from the
//      Modelica.Media library can be used (so incompressible or compressible,
//      single or multiple substance, one or two phase medium).
//     The library is using the stream-concept from Modelica Specification 3.1.
//     </td>
//
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Magnetic.FluxTubes\">Modelica.Magnetic.FluxTubes</a></td>
//     <td valign=\"top\">
//      Components to model magnetic devices based on the magnetic flux tubes concepts.
//      Especially to model
//      electro-magnetic actuators. Nonlinear shape, force, leackage, and
//      Material models. Material data for steel, electric sheet, pure iron,
//      Cobalt iron, Nickel iron, NdFeB, Sm2Co17, and more.
//     </td>
//
//
// <tr><td valign=\"top\"><a href=\"Modelica://ModelicaServices\">ModelicaServices</a></td>
//     <td valign=\"top\">
//      New top level package that shall contain functions and models to be used in the
//      Modelica Standard Library that requires a tool specific implementation.
//      ModelicaServices is then used in the Modelica package.
//      In this first version, the 3-dim. animation with model Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape
//      was moved to ModelicaServices. Tool vendors can now provide their own implementation
//      of the animation.
//     </td>
// </table>
//
//
// <p><br>
// The following <b style=\"color:blue\">new components</b> have been added
// to <b style=\"color:blue\">existing</b> libraries:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
// <tr><td valign=\"top\"> versionBuild<br>versionDate<br>dateModified<br>revisionId </td>
//     <td valign=\"top\"> New annotations from Modelica 3.1 for version handling added.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.UsersGuide.ReleaseNotes.</b></td></tr>
// <tr><td valign=\"top\"> VersionManagement </td>
//     <td valign=\"top\"> Copied from info layer of previous ReleaseNotes (to make it more
//                       visible) and adapted it to the new possibilities in
//                       Modelica Specification 3.1.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\"> RectangularToPolar<br>
//                       PolarToRectangular </td>
//     <td valign=\"top\"> New blocks to convert between rectangular and polar form
//                       of space phasors. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Routing.</b></td></tr>
// <tr><td valign=\"top\"> Replicator </td>
//     <td valign=\"top\"> New block to replicate an input signal to many output signals. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Examples.</b></td></tr>
// <tr><td valign=\"top\"> AmplifierWithOpAmpDetailed<br>
//                       HeatingResistor<br>
//                       CompareTransformers<br>
//                       OvervoltageProtection<br>
//                       ControlledSwitchWithArc<br>
//                       SwitchWithArc<br>
//                       ThyristorBehaviourTest</td>
//     <td valign=\"top\"> New examples to demonstrate the usage of new components. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\"> OpAmpDetailed<br>
//                       TranslationalEMF<br>
//                       M_Transformer</td>
//     <td valign=\"top\"> New detailed model of an operational amplifier. <br>
//                       New electromotoric force from electrical energy into mechanical translattional energy.<br>
//                       Generic transformer with choosable number of inductors</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Ideal.</b></td></tr>
// <tr><td valign=\"top\"> OpenerWithArc<br>
//                       CloserWithArc<br>
//                       ControlledOpenerWithArc<br>
//                       ControlledCloserWithArc</td>
//     <td valign=\"top\"> New switches with simple arc model. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> ConditionalHeatPort</td>
//     <td valign=\"top\"> New partial model to add a conditional HeatPort to
//                       an electrical component. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Lines.</b></td></tr>
// <tr><td valign=\"top\"> M_Oline</td>
//     <td valign=\"top\"> New multiple line model, both the number of lines and the number of segmants choosable. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors.</b></td></tr>
// <tr><td valign=\"top\"> ZDiode<br>Thyristor</td>
//     <td valign=\"top\"> Zener Diode with 3 working areas and simple thyristor model. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase.Ideal.</b></td></tr>
// <tr><td valign=\"top\"> OpenerWithArc<br>CloserWithArc</td>
//     <td valign=\"top\"> New switches with simple arc model (as in Modelica.Electrical.Analog.Ideal. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Examples.Elementary.</b></td></tr>
// <tr><td valign=\"top\"> RollingWheel<br>
//                       RollingWheelSetDriving<br>
//                       RollingWheelSetPulling</td>
//     <td valign=\"top\"> New examples to demonstrate the usage of new components.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Joints.</b></td></tr>
// <tr><td valign=\"top\"> RollingWheel<br>
//                       RollingWheelSet</td>
//     <td valign=\"top\"> New joints (no mass, no inertia) that describe an
//                       ideal rolling wheel and a ideal rolling wheel set consisting
//                       of two wheels rolling on the plane z=0.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Parts.</b></td></tr>
// <tr><td valign=\"top\"> RollingWheel<br>
//                       RollingWheelSet</td>
//     <td valign=\"top\"> New ideal rolling wheel and ideal rolling wheel set consisting
//                       of two wheels rolling on the plane z=0.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Visualizers.</b></td></tr>
// <tr><td valign=\"top\"> Ground</td>
//     <td valign=\"top\"> New model to visualize the ground (box at z=0).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialElementaryOneFlangeAndSupport2<br>
//                       PartialElementaryTwoFlangesAndSupport2</td>
//     <td valign=\"top\"> New partial model with one and two flanges and the support flange
//                       with a much simpler implementation as previously.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialElementaryOneFlangeAndSupport2<br>
//                       PartialElementaryTwoFlangesAndSupport2</td>
//     <td valign=\"top\"> New partial model with one and two flanges and the support flange
//                       with a much simpler implementation as previously.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Media.IdealGases.Common.MixtureGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> setSmoothState</td>
//     <td valign=\"top\"> Return thermodynamic state so that it smoothly approximates:
//                       if x &gt; 0 then state_a else state_b.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Utilities.Internal.</b></td></tr>
// <tr><td valign=\"top\"> PartialModelicaServices</td>
//     <td valign=\"top\"> New package containing the interface description of
//                       models and functions that require a tool dependent
//                       implementation (currently only \"Shape\" for 3-dim. animation,
//                       but will be extended in the future)</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Thermal.HeatTransfer.Components.</b></td></tr>
// <tr><td valign=\"top\"> ThermalCollector</td>
//     <td valign=\"top\"> New auxiliary model to collect the heat flows
//                       from m heatports to a single heatport;
//                       useful for multiphase resistors (with heatports)
//                       as a junction of the m heatports.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
// <tr><td valign=\"top\"> VariantLibrary<br>
//                       BaseClassLibrary<br>
//                       ObsoleteModel</td>
//     <td valign=\"top\"> New icons (VariantLibrary and BaseClassLibrary have been moved
//                       from Modelica_Fluid.Icons to this place).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
// <tr><td valign=\"top\"> ElectricalForceConstant </td>
//     <td valign=\"top\"> New type added (#190).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.SIunits.Conversions.</b></td></tr>
// <tr><td valign=\"top\"> from_Hz<br>
//                       to_Hz</td>
//     <td valign=\"top\"> New functions to convert between frequency [Hz] and
//                       angular velocity [1/s]. (#156) </td> </tr>
//
// </table>
//
//
//
// <p><br>
// The following <b style=\"color:blue\">existing components</b>
// have been <b style=\"color:blue\">improved</b> in a
// <b style=\"color:blue\">backward compatible</b> way:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
// <tr><td valign=\"top\"> Blocks<br>Mechanics<br>StateGraph </td>
//     <td valign=\"top\"> Provided missing parameter values for examples
//                       (these parameters had only start values)</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic</b></td></tr>
// <tr><td valign=\"top\"> Resistor, Conductor, VariableResistor, VariableConductor</td>
//     <td valign=\"top\"> Conditional heatport added for coupling to thermal network. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Ideal</b></td></tr>
// <tr><td valign=\"top\"> Thyristors, Switches, IdealDiode</td>
//     <td valign=\"top\"> Conditional heatport added for coupling to thermal network. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors</b></td></tr>
// <tr><td valign=\"top\"> Diode, ZDiode, PMOS, NMOS, NPN, PNP</td>
//     <td valign=\"top\"> Conditional heatport added for coupling to thermal network. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase.Basic</b></td></tr>
// <tr><td valign=\"top\"> Resistor, Conductor, VariableResistor, VariableConductor</td>
//     <td valign=\"top\"> Conditional heatport added for coupling to thermal network (as in Modelica.Electrical.Analog). </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase.Ideal</b></td></tr>
// <tr><td valign=\"top\"> Thyristors, Switches, IdealDiode</td>
//     <td valign=\"top\"> Conditional heatport added for coupling to thermal network (as in Modelica.Electrical.Analog). </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Visualizers.Advanced.</b></td></tr>
// <tr><td valign=\"top\"> Shape </td>
//     <td valign=\"top\"> New implementation by inheriting from ModelicaServices. This allows a
//                       tool vendor to provide its own implementation of Shape. </td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.StateGraph.</b></td></tr>
// <tr><td valign=\"top\"> Examples </td>
//     <td valign=\"top\"> Introduced \"StateGraphRoot\" on the top level of all example models. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.StateGraph.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> StateGraphRoot<br>PartialCompositeStep<br>CompositeStepState </td>
//     <td valign=\"top\"> Replaced the wrong Modelica code \"flow output Real xxx\"
//                       by \"Real dummy; flow Real xxx;\".
//                       As a side effect, several \"blocks\" had to be changed to \"models\". </td> </tr>
// <tr><td valign=\"top\"> PartialStep </td>
//     <td valign=\"top\"> Changed model by packing the protected outer connecter in to a model.
//                       Otherwise, there might be differences in the sign of the flow variable
//                       in Modelica 3.0 and 3.1. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Utilities.Examples.</b></td></tr>
// <tr><td valign=\"top\"> expression </td>
//     <td valign=\"top\"> Changed local variable \"operator\" to \"opString\" since \"operator\"
//                       is a reserved keyword in Modelica 3.1 </td> </tr>
// </table>
//
// <p><br>
// The following <b style=\"color:red\">critical errors</b> have been fixed (i.e. errors
// that can lead to wrong simulation results):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Components</b></td></tr>
// <tr><td valign=\"top\">ElastoGap</td>
//           <td valign=\"top\"> The ElastoGap component was changed in a non backwards
// compatible way. This was fixed in the <code>versionBuild=3</code> version of Modelica Standard Library 3.1
// (see also <a href=\"http://trac.modelica.org/Modelica/ticket/203\">Ticket #203</a>).</td>
// </tr>
// </table>
//
// <p><br>
// The following <b style=\"color:red\">uncritical errors</b> have been fixed (i.e. errors
// that do <b style=\"color:red\">not</b> lead to wrong simulation results, but, e.g.,
// units are wrong or errors in documentation):
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
// <tr><td valign=\"top\"> Many models</td>
//     <td valign=\"top\"> Removed wrong usages of annotations fillColor and fillPattern
//                       in text annotations (#155, #185).</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines</b></td></tr>
// <tr><td valign=\"top\"> All machine models</td>
//     <td valign=\"top\"> The conditional heatports of the instantiated resistors
//                         (which are new in Modelica.Electrical.Analog and Modelica.Electrical.MultiPhase)
//                         are finally switched off until a thermal connector design for machines is implemented. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Media.Air.MoistAir</b></td></tr>
// <tr><td valign=\"top\"> saturationPressureLiquid<br>
//                       sublimationPressureIce<br>
//                       saturationPressure</td>
//           <td valign=\"top\"> For these three functions, an error in the <code>derivative</code> annotation was corrected. However, the effect of
//                             this bug was minor, as a Modelica tool was allowed to compute derivatives automatically via
//                             the <code>smoothOrder</code> annotation.</td>
// </tr>
// <tr><td colspan=\"2\"><b>Modelica.Math.Matrices.</b></td></tr>
// <tr><td valign=\"top\"> eigenValues</td>
//     <td valign=\"top\"> Wrong documentation corrected (#162)</td> </tr>
// </table>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0_1)
// {"<html>
//
// <p>
// This Modelica package is provided under the
// <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica License 2</a>
// and no longer under Modelica License 1.1. There are the following reasons
// why the Modelica Association changes from Modelica License 1.1 to this
// new license text (note, the text below is not a legal interpretation of the
// Modelica License 2. In case of a conflict, the language of the license shall prevail):
// </p>
//
// <ol>
// <li> The rights of licensor and licensee are much more clearly defined. For example:
//          <ul>
//          <li> The licensed work (Original Work) can be used in unmodified form in
//                   open source and commercial software (the licensee cannot change the
//                   license and the work must be provided without fees)</li>
//          <li> If a model component is copied out of a Modelica package under
//                   Modelica License 2 and is modified in order to adapt it to the needs
//                   of the modeler, then the result can be licensed under any license
//                   (including a commercial license).</li>
//          <li> It is practically not possible to change the license of a
//                   Modelica package under Modelica License 2 to another license, i.e., a
//                   licensee cannot change the license by adding material or changing classes,
//                   so the work must remain under Modelica License 2 (to be more precise,
//                   if the licensee makes modifications to the Original Work \"which represents,
//                   as a whole, an original work of authorship\", he/she can change the license
//                   to another license. However, for a Modelica package this would
//                   require a lot of changes which is usually unrealistic).</li>
//          <li> If an executable is constructed using a Modelica package under
//                   Modelica License 2, then this executable can be licensed under any
//                   license (including a commercial license).</li>
//          </ul>
//          We hope that this compromise between open source contributors, commercial
//          Modelica environments and Modelica users will motivate even more people to
//          provide their Modelica packages freely under the Modelica License 2.<br><br></li>
// <li> There are several new provisions that shall make law suites against licensors and licensees more unlikely (so the small risk is further reduced).</li>
// </ol>
//
//
//
// <p><br>
// The following <b style=\"color:blue\">new components</b> have been added
// to <b style=\"color:blue\">existing</b> libraries:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\">M_Transformer</td>
//           <td valign=\"top\"> Transformer, with the possibility to
//         choose the number of inductors. The inductances and the coupled inductances
//         can be chosen arbitrarily.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Lines.</b></td></tr>
// <tr><td valign=\"top\">M_OLine</td>
//           <td valign=\"top\"> Segmented line model that enables the use of
//         multiple lines, that means, the number of segments and the number of
//         single lines can be chosen by the user. The model allows to investigate
//         phenomena at multiple lines like mutual magnetic or capacitive influence.</td> </tr>
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Components.Examples.</b></td></tr>
// <tr><td valign=\"top\">Brake</td>
//           <td valign=\"top\"> Demonstrates the usage of the translational brake component.</td> </tr>
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialMedium.</b></td></tr>
// <tr><td valign=\"top\">ThermoStates</td>
//           <td valign=\"top\"> Enumeration type for independent variables to identify the independent
//                                                 variables of the medium (pT, ph, phX, pTX, dTX).<br>
//                                                 An implementation of this enumeration is provided for every medium.
//                                                 (This is useful for fluid libraries that do not use the
//                                                 PartialMedium.BaseProperties model). </td> </tr>
// <tr><td valign=\"top\">setSmoothState</td>
//           <td valign=\"top\"> Function that returns the thermodynamic state which smoothly approximates:
//                                                 if x > 0 then state_a else state_b.<br>
//                                                 (This is useful for pressure drop components in fluid libraries
//                                                  where the upstream density and/or viscosity has to be computed
//                                                  and these properties should be smooth a zero mass flow rate)<br>
//                                                 An implementation of this function is provided for every medium.</td> </tr>
// <tr><td colspan=\"2\"><b>Media.Common.</b></td></tr>
// <tr><td valign=\"top\">smoothStep</td>
//           <td valign=\"top\"> Approximation of a general step, such that the characteristic
//                                                 is continuous and differentiable.</td> </tr>
// <tr><td colspan=\"2\"><b>Media.UsersGuide.</b></td></tr>
// <tr><td valign=\"top\">Future</td>
//           <td valign=\"top\"> Short description of goals and changes of upcoming release of Modelica.Media. </td> </tr>
// <tr><td colspan=\"2\"><b>Media.Media.Air.MoistAir.</b></td></tr>
// <tr><td valign=\"top\">isentropicExponent</td>
//           <td valign=\"top\"> Implemented Missing Function from interface. </td> </tr>
// <tr><td valign=\"top\">isentropicEnthalpyApproximation</td>
// <td valign=\"top\"> Implemented function that approximates the isentropic enthalpy change.
// This is only correct as long as there is no liquid in the stream.</td> </tr>
// </table>
//
//
// <p><br>
// The following <b style=\"color:blue\">existing components</b>
// have been <b style=\"color:blue\">changed</b> (in a
// <b style=\"color:blue\">backward compatible</b> way):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialFriction </td>
//           <td valign=\"top\"> Improvement of friction model so that in certain situations
//                                                 the number of iterations is much smaller.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Components.Examples.</b></td></tr>
// <tr><td valign=\"top\"> Friction </td>
//           <td valign=\"top\"> Added a third variant, where friction is modelled with
//                                                 the SupportFriction component.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Components.</b></td></tr>
// <tr><td valign=\"top\"> MassWithStopAndFriction </td>
//           <td valign=\"top\"> Improvement of friction model so that in certain situations
//                                                 the number of iterations is much smaller.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialFriction </td>
//           <td valign=\"top\"> Improvement of friction model so that in certain situations
//                                                 the number of iterations is much smaller.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Examples.</b></td></tr>
// <tr><td valign=\"top\"> SimpleLiquidWater <br>
//                                                 IdealGasH20 <br>
//                                                 WaterIF97 <br>
//                                                 MixtureGases <br>
//                                                 MoistAir </td>
//           <td valign=\"top\"> Added equations to test the new setSmoothState(..) functions
//                                                 including the analytic derivatives of these functions.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialLinearFluid.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX <br>
//                                                 setState_phX <br>
//                                                 setState_psX <br>
//                                                 setState_dTX </td>
//           <td valign=\"top\"> Rewritten function in one statement so that it is usually inlined.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialLinearFluid.</b></td></tr>
// <tr><td valign=\"top\"> consistent use of reference_d instead of density(state </td>
//           <td valign=\"top\"> Change was done to achieve consistency with analytic inverse functions.</td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Media.Air.MoistAir.</b></td></tr>
// <tr><td valign=\"top\"> T_phX </td>
//           <td valign=\"top\"> Interval of nonlinear solver to compute T from p,h,X changed
//                                                 from 200..6000 to 240 ..400 K.</td> </tr>
//
// </table>
//
//
// <p><br>
// The following <b style=\"color:red\">critical errors</b> have been fixed (i.e. errors
// that can lead to wrong simulation results):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Forces</b></td></tr>
// <tr><td valign=\"top\"> WorldTorque </td>
//           <td valign=\"top\"> Parameter \"ResolveInFrame\" was not propagated and therefore
//                                                 always the default (resolved in world frame) was used, independently
//                                                 of the setting of this parameter. </td>
// </tr>
// <tr><td valign=\"top\"> WorldForceAndTorque </td>
//           <td valign=\"top\"> Parameter \"ResolveInFrame\" was not propagated and therefore
//                                                 always the default (resolved in world frame) was used, independently
//                                                 of the setting of this parameter.<br>
//                                                 Furthermore, internally WorldTorque was used instead of
//                                                 Internal.BasicWorldTorque and therefore the visualization of
//                                                 worldTorque was performed twice. </td>
// </tr>
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Sensors</b></td></tr>
// <tr><td valign=\"top\"> AbsoluteSensor </td>
//           <td valign=\"top\"> Velocity, acceleration and angular acceleration were computed
//                                                   by differentiating in the resolveInFrame frame. This has been corrected, by
//                                                   first transforming the vectors in to the world frame, differentiating here
//                                                   and then transforming into resolveInFrame. The parameter in the Advanced menue
//                                                   resolveInFrameAfterDifferentiation is then superfluous and was removed . </td>
// </tr>
// <tr><td valign=\"top\"> AbsoluteVelocity </td>
//           <td valign=\"top\"> The velocity was computed
//                                                   by differentiating in the resolveInFrame frame. This has been corrected, by
//                                                   first transforming the velocity in to the world frame, differentiating here
//                                                   and then transforming into resolveInFrame </td>
// </tr>
// <tr><td valign=\"top\"> RelativeSensor </td>
//           <td valign=\"top\"> If resolveInFrame &lt;&gt; frame_resolve and
//                                                    resolveInFrameAfterDifferentiation = frame_resolve, a translation
//                                                 error occured, since frame_resolve was not enabled in this situation.
//                                                 This has been corrected.</td>
// </tr>
// <tr><td valign=\"top\"> RelativeVelocity </td>
//           <td valign=\"top\"> The velocity has have been computed
//                                                   by differentiating in the resolveInFrame frame. This has been corrected, by
//                                                   first transforming the relative position in to frame_a, differentiating here
//                                                   and then transforming into resolveInFrame </td>
// </tr>
// <tr><td valign=\"top\"> TransformRelativeVector </td>
//           <td valign=\"top\"> The transformation was wrong, since the parameters frame_r_in and frame_r_out
//                                                 have not been propagated to the submodel that performs the transformation.
//                                                 This has been corrected. </td>
// </tr>
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Components.</b></td></tr>
// <tr><td valign=\"top\"> SupportFriction<br>
//                                                 Brake </td>
//           <td valign=\"top\"> The sign of the friction force was wrong and therefore friction accelerated
//                                                 instead of decelerated. This was fixed. </td>
// <tr><td valign=\"top\"> SupportFriction</td>
//           <td valign=\"top\"> The component was only correct for fixed support.
//                                                 This was corrected. </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialSimpleMedium<br>
//                                                 PartialSimpleIdealGasMedium </td>
//           <td valign=\"top\"> BaseProperties.p was not defined as preferred state and BaseProperties.T was
//                                                 always defined as preferred state. This has been fixed by
//                                                 Defining p,T as preferred state if parameter preferredMediumState = true.
//                                                 This error had the effect that mass m is selected as state instead of p
//                                                 and if default initialization is used then m=0 could give not the expected
//                                                 behavior. This means, simulation is not wrong but the numerics is not as good
//                                                 and if a model relies on default initial values, the result could be not
//                                                 as expected. </td>
// </tr>
//
// </table>
//
//
// <p><br>
// The following <b style=\"color:red\">uncritical errors</b> have been fixed (i.e. errors
// that do <b style=\"color:red\">not</b> lead to wrong simulation results, but, e.g.,
// units are wrong or errors in documentation):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\"> InverseBlockConstraint </td>
//           <td valign=\"top\"> Changed annotation preserveAspectRatio from true to false.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Sources.</b></td></tr>
// <tr><td valign=\"top\"> RealExpression<br>
//                                                 IntegerExpression<br>
//                                                 BooleanExpression </td>
//           <td valign=\"top\"> Changed annotation preserveAspectRatio from true to false.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\"> SaturatingInductor</td>
//           <td valign=\"top\"> Replaced non-standard \"arctan\" by \"atan\" function.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Digital.</b></td></tr>
// <tr><td valign=\"top\"> UsersGuide</td>
//           <td valign=\"top\"> Removed empty documentation placeholders and added the missing
//                                                   release comment for version 1.0.7</td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.Components.</b></td></tr>
// <tr><td valign=\"top\"> MassWithStopAndFriction </td>
//           <td valign=\"top\"> Changed usage of reinit(..), in order that it appears
//                                                 only once for one variable according to the language specification
//                                                 (if a tool could simulate the model, there is no difference).</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialSimpleMedium</b></td></tr>
// <tr><td valign=\"top\"> pressure<br>
//                                                 temperature<br>
//                                                 density<br>
//                                                 specificEnthalpy </td>
//           <td valign=\"top\"> Missing functions added.</td>
// </tr>
//
// </table>
//
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_3_0)
// {"<html>
// <p>
// Version 3.0 is <b>not</b> backward compatible to previous versions.
// A conversion script is provided to transform models and libraries
// of previous versions to the new version. Therefore, conversion
// should be automatic.
// </p>
//
// <p>
// The following changes are present for the whole library:
// </p>
//
// <ul>
// <li> In the Modelican language version 3.0, several restrictions have been
//          introduced to allow better checking, e.g., models on all levels must be balanced
//          (number of equations = number of unknown variables - unknown variables that have
//          to be defined when using the component). A few models of the Modelica
//          Standard Library did not fulfill these new restrictions and had
//          either to be moved to library ObsoleteModelica3 (e.g. Blocks.Math.TwoInputs)
//          or had to be differently implemented
//          (e.g. Media.Interfaces.PartialMedium.BaseProperties).
//          The Modelica Standard Library version 3.0 fulfills all the restrictions of
//          the Modelica Language version 3.0.<br>&nbsp;
//          </li>
//
// <li> The graphical annotations describing the layout of icon and diagram layer
//          are changed from Modelica language version 1 to Modelica language version 3.
//          This gives several significant improvements:<br>Especially, the coordinate systems
//          of icon and diagram layers are no longer coupled and therefore the size of the
//          icon layer can be changed independently of the size of the diagram layer.
//          Also it can be defined that the aspect ratio of a component icon is kept when changing
//          its size in a model. This flag is set so that all icons of the Modelica
//          Standard Library keep its aspect ratios. This is slightly non-backward compatible:
//          If the aspect ratio was not kept when using a component from the Modelica
//          Standard Library, it is now resized so that the aspect ratio is maintained.<br>&nbsp; </li>
//
// <li> All non-standard annotations removed by:<br>
//          (1) Removing the annotation since without effect
//                  (e.g., \"__Dymola_experimentSetupOutput\", \"Window\", \"Terminal\" removed).<br>
//          (2) Renaming the annotation to a standard name (e.g., \"Hide\" renamed to \"HideResult\").<br>
//          (3) Renaming the annotation to a vendor specific name
//                  (e.g., \"checkBox\" renamed to \"__Dymola_checkBox\").<br>&nbsp; </li>
//
// <li> All emulated enumerations (defined via packages and constants) have been
//          replaced by \"real\" enumerations. User models are automatically correctly
//          converted, provided the user models used the package constants previously.
//          <b>Existing models that use directly literal values for enumerations, might give in
//          some cases wrong results</b> (if the first constant of the emulated enumeration
//          had value zero, whereas the first value of an enumeration is one).<br>&nbsp; </li>
//
// <li> The operator \"cardinality\" will be removed in one of the next versions of the
//          Modelica language, since it is a reflective operator and its usage significantly
//          reduces the possibilities of advanced model checks (e.g. to guarantee that a model
//          is \"balanced\", i.e., the number of equations and unknowns is identical,
//          for all valid usages of the component). As a preparation for this change, all
//          models that contain the \"cardinality(..)\" operator are rewritten: If possible
//          the operator is removed. If this is not possible, it is only used in asserts to
//          check that, e.g., a connector is connected at least once or is connected exactly
//          once. In the next Modelica language version new language elements will be introduced
//          to specifiy such a property check without the cardinality operator. Once these
//          language elements are available, the cardinality operator will be removed completely
//          from the Modelica Standard Library.<br>
//          The changes with respect to the cardinality(..) operator are usually not backward
//          compatible. This is the reason for the changes of the
//          Rotational and Translational library (see below).<br>&nbsp;</li>
//
// <li> The design of the <b>Rotational</b> and <b>Translational</b> libraries have been changed
//          (especially to remove the cardinality(..) operator, see above):
//          <ul>
//          <li> Components have a <b>useSupport</b> flag to enable or disable a support flange.
//                   If the support flange is enabled, it must be connected. If it is disabled, it must
//                   not be connected and the component is then internally grounded. The grounding
//                   is visualized in the icon.</li>
//          <li> The relative angle/distance and the relative speed of all force/torque elements
//                   (that need the relative speed) are by default defined with \"StateSelect.prefer\", i.e.,
//                   to use these variables as preferred states. This improves the numerics if the
//                   absolute angle or the absolute distance are continuously increasing during
//                   operation (e.g. driving shaft of the wheels of a car). The effect is that relative
//                   angles/distances and speeds are used as states and the size of these variables is
//                   limited. Previously, the default was to use the absolute angle/distance
//                   and absolute speed of every inertia/mass which has the disadvantage that the absolute
//                   angle and or distance are state variables that grow in size continuously.<br>
//                   A significant advantage is also, that default initialization is usually better,
//                   because a default value of zero for a relative angle/distance is usually what the
//                   user would like to have. Previously, say, the load was initialized to a non-zero
//                   angle and then the elastically coupled motor inertia had to be explicitly
//                   also initialized with this value. This is now, no longer needed. Since the default
//                   nominal value of 1 is usually too large for a relative quantity, the nominal
//                   values of the relative angle/distance was changed to 1e-4.</li>
//          <li> The two libraries have been restructured in sublibraries to cope
//                   with the growing number of components.</li>
//          <li> Finally, the Translational library has been
//                   made as similar as possible to the Rotational library by, e.g., adding missing
//                   components.<br>&nbsp;</li>
//          </ul></li>
//
// <li> The initialization of the MultiBody, Rotational and Translational libraries have
//          been signficantly simplified by removing the \"initType\" parameters and only
//          using start/fixed values. This design assumes that a tool has special support
//          for start/fixed values in the parameter menu.<br>&nbsp;</li>
//
// <li> Nearly all parameters defined in the Modelica Standard Library had been
//          defined with a default equation, e.g.,
//          <pre>   <b>parameter</b> Modelica.SIunits.Resistance R=1; </pre>
//          Physical parameters, such as a resistance, mass, gear ratio, do not have a meaningful
//          default and in nearly all cases, the user of the corresponding component has to
//          provide values for such parameters. If the user forgets this, a tool
//          cannot provide diagnostics, since a default value is present in the library
//          (such as 1 Ohm for the resistance). In most cases the model will simulate but will
//          give wrong results due to wrong parameter values. To improve this situation, all physical
//          parameter declarations in the Modelica Standard Library have been changed, so
//          that the previous default becomes a start value. For example, the above
//          declaration is changed to:
//          <pre>   <b>parameter</b> Modelica.SIunits.Resistance R(start=1);  </pre>
//          This is a backward compatible change and completely equivalent from the perspective
//          of the Modelica language. It is, however, advised that tools will print a warning
//          or optionally an error message, if the start value of a parameter is defined, but
//          no value for the parameter is given via a modification. Furthermore, it is expected,
//          that the input field of a parameter menu is empty, if no default equation is defined,
//          but only a start value. This shows clearly to the modeler that a value has to
//          be provided.</li>
// </ul>
//
// <p><br>
// The following <b style=\"color:blue\">new components</b> have been added
// to <b style=\"color:blue\">existing</b> libraries (note, the names in paranthesis
// are the new sublibrary names that are introduced in version 3.0):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Examples.</b></td></tr>
// <tr><td valign=\"top\">InverseModel</td>
//           <td valign=\"top\"> Demonstrates the construction of an inverse model.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\">InverseBlockConstraints</td>
//           <td valign=\"top\"> Construct inverse model by requiring that two inputs
//                                                 and two outputs are identical (replaces the previously,
//                                                 unbalanced, TwoInputs and TwoOutputs blocks).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Utilities</b></td></tr>
// <tr><td valign=\"top\">TransformerData</td>
//           <td valign=\"top\"> A record that calculates required impedances (parameters) from nominal data of transformers.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Examples.Rotational3DEffects</b></td></tr>
// <tr><td valign=\"top\"> GyroscopicEffects<br>
//                                                 ActuatedDrive<br>
//                                                 MovingActuatedDrive<br>
//                                                 GearConstraint </td>
//           <td valign=\"top\"> New examples to demonstrate the usage of the Rotational library
//                                                 in combination with multi-body components. </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Sensors</b></td></tr>
// <tr><td valign=\"top\"> AbsolutePosition<br>
//                                                 AbsoluteVelocity<br>
//                                                 AbsoluteAngles<br>
//                                                 AbsoluteAngularVelocity<br>
//                                                 RelativePosition<br>
//                                                 RelativeVelocity<br>
//                                                 RelativeAngles<br>
//                                                 RelativeAngularVelocity</td>
//           <td valign=\"top\"> New sensors to measure one vector. </td>
// </tr>
// <tr><td valign=\"top\"> TransformAbsoluteVector<br>
//                                                 TransformRelativeVector</td>
//           <td valign=\"top\"> Transform absolute and/or relative vector into another frame. </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.(Components)</b></td></tr>
// <tr><td valign=\"top\"> Disc </td>
//           <td valign=\"top\"> Right flange is rotated by a fixed angle with respect to left flange</td> </tr>
// <tr><td valign=\"top\"> IdealRollingWheel </td>
//           <td valign=\"top\"> Simple 1-dim. model of an ideal rolling wheel without inertia</td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Sensors</b></td></tr>
// <tr><td valign=\"top\">RelPositionSensor<br>RelSpeedSensor<br>RelAccSensor<br>PowerSensor</td>
//           <td valign=\"top\"> Relative position sensor, i.e. distance between two flanges<br>
//                                                 Relative speed sensor<br>
//                                                 Relative acceleration sensor<br>
//                                                 Ideal power sensor</td> </tr>
// <tr><td colspan=\"2\"><b>Mechanics.Translational(.Components)</b></td></tr>
// <tr><td valign=\"top\">SupportFriction<br>Brake<br>InitializeFlange</td>
//           <td valign=\"top\"> Model of friction due to support<br>
//                                                 Model of a brake, base on Coulomb friction<br>
//                                                 Initializes a flange with pre-defined postion, speed and acceleration .</td> </tr>
// <tr><td colspan=\"2\"><b>Mechanics.Translational(.Sources)</b></td></tr>
// <tr><td valign=\"top\">Force2<br>LinearSpeedDependentForce<br>QuadraticSpeedDependentForce<br>
//                                            ConstantForce<br>ConstantSpeed<br>ForceStep</td>
//           <td valign=\"top\"> Force acting on 2 flanges<br>
//                                                 Force linearly dependent on flange speed<br>
//                                                 Force quadratic dependent on flange speed<br>
//                                                 Constant force source<br>
//                                                 Constant speed source<br>
//                                                 Force step</td> </tr>
// </tr>
// </table>
//
//
// <p><br>
// The following <b style=\"color:blue\">existing components</b>
// have been <b style=\"color:blue\">changed</b> in a
// <b style=\"color:blue\">non-backward compatible</b> way
// (the conversion script transforms models and libraries
// of previous versions to the new version. Therefore, conversion
// should be automatic):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Continuous.</b></td></tr>
// <tr><td valign=\"top\"> CriticalDamping </td>
//           <td valign=\"top\"> New parameter \"normalized\" to define whether filter is provided
//                                                 in normalized or non-normalized form. Default is \"normalized = true\".
//                                                 The previous implementation was a non-normalized filter.
//                                                 The conversion script automatically introduces the modifier
//                                                 \"normalized=false\" for existing models.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> RealInput<br>
//                                                 RealOutput</td>
//           <td valign=\"top\"> Removed \"SignalType\", since extending from a replaceable class
//                                                 and this is not allowed in Modelica 3.<br>The conversion script
//                                                 removes modifiers to SignalType.</td> </tr>
//
// <tr><td valign=\"top\"> RealSignal<br>
//                                                 IntegerSignal<br>
//                                                 BooleanSignal</td>
//           <td valign=\"top\"> Moved to library ObsoleteModelica3, since these connectors
//                                                 are no longer allowed in Modelica 3<br>
//                                                 (prefixes input and/or output are required). </td> </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Interfaces.Adaptors.</b></td></tr>
// <tr><td valign=\"top\"> AdaptorReal<br>
//                                                 AdaptorBoolean<br>
//                                                 AdaptorInteger</td>
//           <td valign=\"top\"> Moved to library ObsoleteModelica3, since the models are not \"balanced\".
//                                                 These are completely obsolete adaptors<br>between the Real, Boolean, Integer
//                                                 signal connectors of version 1.6 and version &ge; 2.1 of the Modelica
//                                                 Standard Library. </td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\"> ConvertAllUnits</td>
//           <td valign=\"top\"> Moved to library ObsoleteModelica3, since extending from a replaceable class
//                                                 and this is not allowed in Modelica 3.<br> It would be possible to rewrite this
//                                                 model to use a replaceable component. However, the information about the
//                                                 conversion<br> cannot be visualized in the icon in this case.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Math.UnitConversions.</b></td></tr>
// <tr><td valign=\"top\"> TwoInputs<br>
//                                                 TwoOutputs</td>
//           <td valign=\"top\"> Moved to library ObsoleteModelica3, since the models are not \"balanced\".
//                                                 A new component<br>\"InverseBlockConstraints\"
//                                                 is provided instead that has the same feature, but is \"balanced\".</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Baisc.</b></td></tr>
// <tr><td valign=\"top\"> HeatingResistor</td>
//           <td valign=\"top\"> The heatPort has to be connected; otherwise the component Resistor (without heatPort) has to be used.<br>
//                                                 cardinality() is only used to check whether the heatPort is connected.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.MultiPhase.Examples.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Changed the instance names of components used in the examples to more up-to-date style.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Moved package <tt>Machines.Examples.Utilities</tt> to <tt>Machines.Utilities</tt></td> </tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Removed all nonSIunits; especially in DCMachines<br>
//                                                 parameter NonSIunits.AngularVelocity_rpm rpmNominal was replaced by<br>
//                                                 parameter SIunits.AngularVelocity wNominal</td> </tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Changed the following component variable and parameter names to be more concise:<br>
//                                                 Removed suffix \"DamperCage\" from all synchronous induction machines
//                                                 since the user can choose whether the damper cage is present or not.<br><tt>
//                                                 RotorAngle ... RotorDisplacementAngle<br>
//                                                 J_Rotor ... Jr<br>
//                                                 Rr ........ Rrd (damper of synchronous induction machines)<br>
//                                                 Lrsigma ... Lrsigmad (damper of synchronous induction machines)<br>
//                                                 phi_mechanical ... phiMechanical<br>
//                                                 w_mechanical ..... wMechanical<br>
//                                                 rpm_mechanical ... rpmMechanical<br>
//                                                 tau_electrical ... tauElectrical<br>
//                                                 tau_shaft ........ tauShaft<br>
//                                                 TurnsRatio ....... turnsRatio    (AIMS)<br>
//                                                 VsNom ............ VsNominal     (AIMS)<br>
//                                                 Vr_Lr ............ VrLockedRotor (AIMS)<br>
//                                                 DamperCage ....... useDamperCage (synchronous induction machines)<br>
//                                                 V0 ............... VsOpenCicuit  (SMPM)<br>
//                                                 Ie0 .............. IeOpenCicuit  (SMEE)
//                                                 </tt></td> </tr>
// <tr><td valign=\"top\">Interfaces.</td>
//           <td valign=\"top\"> Moved as much code as possible from specific machine models to partials to reduce redundant code.</td> </tr>
// <tr><td valign=\"top\">Interfaces.Adapter</td>
//           <td valign=\"top\"> Removed to avoid cardinality; instead, the following solution has been implemented:</td> </tr>
// <tr><td valign=\"top\">Sensors.RotorDisplacementAngle<br>Interfaces.PartialBasicMachine</td>
//           <td valign=\"top\"> Introduced <tt>parameter Boolean useSupport=false \"enable / disable (=fixed stator) support\"</tt><br>
//                                                 The rotational support connector is only present with <tt>useSupport = true;</tt><br>
//                                                 otherwise the stator is fixed internally.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Examples.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Changed the names of the examples to more meaninglful names.<br>
//                                                 Changed the instance names of components used in the examples to more up-to-date style.</td> </tr>
// <tr><td valign=\"top\">SMEE_Generator</td>
//           <td valign=\"top\"> Initialization of <tt>smee.phiMechanical</tt> with <tt>fixed=true</tt></td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\"> World</td>
//           <td valign=\"top\"> Changed default value of parameter driveTrainMechanics3D from false to true.<br>
//                                                 3-dim. effects in Rotor1D, Mounting1D and BevelGear1D are therefore taken<br>
//                                                 into account by default (previously this was only the case, if
//                                                 world.driveTrainMechanics3D was explicitly set).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Forces.</b></td></tr>
// <tr><td valign=\"top\"> FrameForce<br>
//                                                 FrameTorque<br>
//                                                 FrameForceAndTorque</td>
//           <td valign=\"top\"> Models removed, since functionality now available via Force, Torque, ForceAndTorque</td> </tr>
// <tr><td valign=\"top\"> WorldForce<br>
//                                                 WorldTorque<br>
//                                                 WorldForceAndTorque<br>
//                                                 Force<br>
//                                                 Torque<br>
//                                                 ForceAndTorque</td>
//           <td valign=\"top\"> Connector frame_resolve is optionally enabled via parameter resolveInFrame<br>.
//                                                 Forces and torques and be resolved in all meaningful frames defined
//                                                 by enumeration resolveInFrame.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Frames.</b></td></tr>
// <tr><td valign=\"top\"> length<br>
//                                                 normalize</td>
//           <td valign=\"top\"> Removed functions, since available also in Modelica.Math.Vectors
//                                                 <br>The conversion script changes the references correspondingly.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Joints.</b></td></tr>
// <tr><td valign=\"top\"> Prismatic<br>
//                                                 ActuatedPrismatic<br>
//                                                 Revolute<br>
//                                                 ActuatedRevolute<br>
//                                                 Cylindrical<br>
//                                                 Universal<br>
//                                                 Planar<br>
//                                                 Spherical<br>
//                                                 FreeMotion</td>
//           <td valign=\"top\"> Changed initialization, by replacing initial value parameters with
//                                                 start/fixed attributes.<br>
//                                                 When start/fixed attributes are properly supported
//                                                 in the parameter menu by a Modelica tool,<br>
//                                                 the initialization is considerably simplified for the
//                                                 user and the implementation is much simpler.<br>
//                                                 Replaced parameter \"enforceStates\" by the more general
//                                                 built-in enumeration stateSelect=StateSelection.xxx.<br>
//                                                 The conversion script automatically
//                                                 transforms from the \"old\" to the \"new\" forms.</td> </tr>
// <tr><td valign=\"top\"> Revolute<br>
//                                                 ActuatedRevolute</td>
//           <td valign=\"top\"> Parameter \"planarCutJoint\" in the \"Advanced\" menu of \"Revolute\" and of
//                                                 \"ActuatedRevolute\" removed.<br>
//                                                 A new joint \"RevolutePlanarLoopConstraint\" introduced that defines the constraints
//                                                 of a revolute joint<br> as cut-joint in a planar loop.
//                                                 This change was needed in order that the revolute joint can be
//                                                 properly used<br>in advanced model checking.<br>
//                                                 ActuatedRevolute joint removed. Flange connectors of Revolute joint<br>
//                                                 can be enabled with parameter useAxisFlange.</td> </tr>
// <tr><td valign=\"top\"> Prismatic<br>
//                                                 ActuatedPrismatic</td>
//           <td valign=\"top\"> ActuatedPrismatic joint removed. Flange connectors of Prismatic joint<br>
//                                                 can be enabled with parameter useAxisFlange.</td> </tr>
// <tr><td valign=\"top\"> Assemblies</td>
//           <td valign=\"top\"> Assembly joint implementation slightly changed, so that
//                                                 annotation \"structurallyIncomplete\" <br>could be removed
//                                                 (all Assembly joint models are now \"balanced\").</td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Joints.Internal</b></td></tr>
// <tr><td valign=\"top\"> RevoluteWithLengthConstraint<br>
//                                                 PrismaticWithLengthConstraint</td>
//           <td valign=\"top\"> These joints should not be used by a user of the MultiBody library.
//                                                 They are only provided to built-up the
//                                                 MultiBody.Joints.Assemblies.JointXYZ joints.
//                                                 These two joints have been changed in a slightly not backward compatible
//                                                 way, in order that the usage in the Assemblies.JointXYZ joints results in
//                                                 balanced models (<b>no conversion is provided for this change since the
//                                                 user should not have used these joints and the conversion would be too
//                                                 complicated</b>):
//                                                 In releases before version 3.0 of the Modelica Standard Library,
//                                                 it was possible to activate the torque/force projection equation
//                                                 (= cut-torque/-force projected to the rotation/translation
//                                                 axis must be identical to
//                                                 the drive torque/force of flange axis) via parameter <b>axisTorqueBalance</b>.
//                                                 This is no longer possible, since otherwise this model would not be
//                                                 \"balanced\" (= same number of unknowns as equations). Instead, when
//                                                 using this model in version 3.0 and later versions, the torque/force
//                                                 projection equation must be provided in the Advanced menu of joints
//                                                 Joints.SphericalSpherical and Joints.UniversalSpherical
//                                                 via the new parameter \"constraintResidue\".</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Parts.</b></td></tr>
// <tr><td valign=\"top\"> BodyBox<br>
//                                                 BodyCylinder</td>
//           <td valign=\"top\"> Changed unit of parameter density from g/cm3 to the SI unit kg/m3
//                                                 in order to allow stricter unit checking.<br>The conversion script multiplies
//                                                 previous density values with 1000.</td> </tr>
// <tr><td valign=\"top\"> Body<br>
//                                                 BodyShape<br>
//                                                 BodyBox<br>
//                                                 BodyCylinder<br>
//                                                 PointMass
//                                                 Rotor1D</td>
//           <td valign=\"top\"> Changed initialization, by replacing initial value parameters with
//                                                 start/fixed attributes.<br>
//                                                 When start/fixed attributes are properly supported
//                                                 in the parameter menu by a Modelica tool,<br>
//                                                 the initialization is considerably simplified for the
//                                                 user and the implementation is much simpler.<br>The conversion script automatically
//                                                 transforms from the \"old\" to the \"new\" form of initialization.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Sensors.</b></td></tr>
// <tr><td valign=\"top\"> AbsoluteSensor<br>
//                                                 RelativeSensor<br>
//                                                 CutForceAndTorque</td>
//           <td valign=\"top\"> New design of sensor components: Via Boolean parameters<br>
//                                                 signal connectors for the respective vectors are enabled/disabled.<br>
//                                                 It is not possible to automatically convert models to this new design.<br>
//                                                 Instead, references in existing models are changed to ObsoleteModelice3.<br>
//                                                 This means that these models must be manually adapted.</td> </tr>
// <tr><td valign=\"top\"> CutForce<br>
//                                                 CutTorque</td>
//           <td valign=\"top\"> Slightly new design. The force and/or torque component can be
//                                                 resolved in world, frame_a, or frame_resolved.<br>
//                                                 Existing models are automatically converted.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Moved components to structured sub-packages (Sources, Components)</td> </tr>
// <tr><td valign=\"top\"> Inertia<br>
//                                                 SpringDamper<br>
//                                                 RelativeStates</td>
//           <td valign=\"top\"> Changed initialization, by replacing initial value parameters with
//                                                 start/fixed attributes.<br>
//                                                 When start/fixed attributes are properly supported
//                                                 in the parameter menu by a Modelica tool,<br>
//                                                 the initialization is considerably simplified for the
//                                                 user and the implementation is much simpler.<br>
//                                                 Parameter \"stateSelection\" in \"Inertia\" and \"SpringDamper\" replaced
//                                                 by the built-in enumeration<br>stateSelect=StateSelection.xxx.
//                                                 Introduced the \"stateSelect\" enumeration in \"RelativeStates\".<br>
//                                                 The conversion script automatically
//                                                 transforms from the \"old\" to the \"new\" forms.</td> </tr>
// <tr><td valign=\"top\"> LossyGear<br>
//                                                 GearBox</td>
//           <td valign=\"top\"> Renamed gear ratio parameter \"i\" to \"ratio\", in order to have a
//                                                 consistent naming convention.<br>
//                                                 Existing models are automatically converted. </td> </tr>
// <tr><td valign=\"top\"> SpringDamper<br>
//                                                 ElastoBacklash<br>
//                                                 Clutch<br>
//                                                 OneWayClutch</td>
//           <td valign=\"top\"> Relative quantities (phi_rel, w_rel) are used as states, if possible
//                                                 (due to StateSelect.prefer). <br>
//                                                 In most cases, relative states in drive trains are better suited as
//                                                 absolute states. <br> This change might give changes in the selected states
//                                                 of existing models.<br>
//                                                 This might give rise to problems if, e.g., the initialization was not
//                                                 completely defined in a user model,<br> since the default
//                                                 initialization heuristic may give different initial values.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Moved components to structured sub-packages (Sources, Components)</td> </tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Adaptions corresponding to Rotational</td> </tr>
// <tr><td valign=\"top\"> Stop</td>
//           <td valign=\"top\"> Renamed to Components.MassWithStopAndFriction to be more concise.<br>
//                                                 MassWithStopAndFriction is not available with a support connector, <br>
//                                                 since the reaction force can't be modeled in a meaningful way due to reinit of velocity v.<br>
//                                                 Until a sound implementation of a hard stop is available, the old model may be used.</td> </tr>
// <tr><td colspan=\"2\"><b>Media.</b></td></tr>
// <tr><td valign=\"top\"> constant nX <br>
//                                                 constant nXi <br>
//                                                 constant reference_X<br>
//                                                 BaseProperties</td>
//           <td valign=\"top\"> The package constant nX = nS, now always, even for single species media. This also allows to define mixtures with only 1 element. The package constant nXi=if fixedX then 0 else if reducedX or nS==1 then nS - 1 else nS. This required that all BaseProperties for single species media get an additional equation to define the composition X as {1.0} (or reference_X, which is {1.0} for single species). This will also mean that all user defined single species media need to be updated by that equation.</td> </tr>
//
// <tr><td colspan=\"2\"><b>SIunits.</b></td></tr>
// <tr><td valign=\"top\"> CelsiusTemperature </td>
//           <td valign=\"top\"> Removed, since no SI unit. The conversion script changes references to
//                                                 SIunits.Conversions.NonSIunits.Temperature_degC </td> </tr>
// <tr><td valign=\"top\"> ThermodynamicTemperature <br>
//                                                 TemperatureDifference</td>
//           <td valign=\"top\"> Added annotation \"__Dymola_absoluteValue=true/false\"
//                                                 in order that unit checking is possible<br>
//                                                 (the unit checker needs to know for a unit that has an offset,
//                                                 whether it is used as absolute or as a relative number)</td> </tr>
//
// <tr><td colspan=\"2\"><b>SIunits.Conversions.NonSIunits.</b></td></tr>
// <tr><td valign=\"top\"> Temperature_degC<br>
//                                                 Temperature_degF<br>
//                                                 Temperature_degRk </td>
//           <td valign=\"top\"> Added annotation \"__Dymola_absoluteValue=true\"
//                                                 in order that unit checking is possible<br>
//                                                 (the unit checker needs to know for a unit that has an offset,
//                                                 whether it is used as absolute or as a relative number)</td> </tr>
//
// <tr><td colspan=\"2\"><b>StateGraph.Examples.</b></td></tr>
// <tr><td valign=\"top\"> ControlledTanks </td>
//           <td valign=\"top\"> The connectors of the ControlledTanks did not fulfill the new
//                                                 restrictions of Modelica 3. This has been fixed.</td> </tr>
// <tr><td valign=\"top\"> Utilities </td>
//           <td valign=\"top\"> Replacing inflow, outflow by connectors inflow1, inflow2,
//                                                 outflow1, outflow2 with appropriate input/output prefixes in
//                                                 order to fufill the restrictions of Modelica 3 to arrive
//                                                 at balanced models. No conversion is provided, since
//                                                 too difficult and since the non-backward compatible change is in
//                                                 an example. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Sensors.</b></td></tr>
// <tr><td valign=\"top\"> <br>
//                                                 pSensor<br>TSensor<br>dpSensor<br>dTSensor<br>m_flowSensor<br>V_flowSensor<br>H_flowSensor</td>
//           <td valign=\"top\"> renamed to:<br>
//                                                 PressureSensor<br>TemperatureSensor<br>RelPressureSensor<br>RelTemperatureSensor<br>MassFlowSensor<br>VolumeFlowSensor<br>EnthalpyFlowSensor
//                                                 </td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Sources.</b></td></tr>
// <tr><td valign=\"top\"> Ambient<br>PrescribedAmbient</td>
//           <td valign=\"top\"> available as one combined component Ambient<br>
//                                                 Boolean parameters usePressureInput and useTemperatureInput decide
//                                                 whether pressure and/or temperature are constant or prescribed</td> </tr>
// <tr><td valign=\"top\"> ConstantVolumeFlow<br>PrescribedVolumeFlow</td>
//           <td valign=\"top\"> available as one combined component VolumeFlow<br>
//                                                 Boolean parameter useVolumeFlowInput decides
//                                                 whether volume flow is constant or prescribed</td> </tr>
// <tr><td valign=\"top\"> ConstantPressureIncrease<br>PrescribedPressureIncrease</td>
//           <td valign=\"top\"> available as one combined component PressureIncrease<br>
//                                                 Boolean parameter usePressureIncreaseInput decides
//                                                 whether pressure increase is constant or prescribed</td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Examples.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Changed the instance names of components used in the examples to more up-to-date style.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.HeatTransfer.(Components)</b></td></tr>
// <tr><td valign=\"top\"> HeatCapacitor</td>
//           <td valign=\"top\"> Initialization changed: SteadyStateStart removed. Instead
//                                                 start/fixed values for T and der_T<br>(initial temperature and its derivative).</td> </tr>
//
// <tr><td valign=\"top\"> <br><br>HeatCapacitor<br>ThermalConductor<br>ThermalConvection<br>BodyRadiation<br><br>
//                                                 TemperatureSensor<br>RelTemperatureSensor<br>HeatFlowSensor<br><br>
//                                                 FixedTemperature<br>PrescribedTemperature<br>FixedHeatFlow<br>PrescribedHeatFlow</td>
//           <td valign=\"top\"> Moved components to sub-packages:<br><br>
//                                                 Components.HeatCapacitor<br>Components.ThermalConductor<br>Components.ThermalConvection<br>Components.BodyRadiation<br><br>
//                                                 Sensors.TemperatureSensor<br>Sensors.RelTemperatureSensor<br>Sensors.HeatFlowSensor<br><br>
//                                                 Sources.FixedTemperature<br>Sources.PrescribedTemperature<br>Sources.FixedHeatFlow<br>Sources.PrescribedHeatFlow
//                                                 </tt></td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Examples.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Changed the instance names of components used in the examples to more up-to-date style.</td> </tr>
// </table>
//
//
//
// <p><br>
// The following <b style=\"color:blue\">existing components</b>
// have been <b style=\"color:blue\">improved</b> in a
// <b style=\"color:blue\">backward compatible</b> way:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td valign=\"top\"> <b>Modelica.*</b> </td>
//           <td valign=\"top\"> Parameter declarations, input and output function arguments without description
//                                                 strings improved<br> by providing meaningful description texts.
//                                                 </td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Continuous.</b></td></tr>
// <tr><td valign=\"top\"> TransferFunction </td>
//           <td valign=\"top\"> Internal scaling of the controller canonical states introduced
//                                                 in order to enlarge the range of transfer functions where the default
//                                                 relative tolerance of the simulator is sufficient.</td>
// </tr>
//
// <tr><td valign=\"top\"> Butterworth<br>CriticalDamping </td>
//           <td valign=\"top\"> Documentation improved and plots of the filter characteristics added.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\"> EMF </td>
//           <td valign=\"top\"> New parameter \"useSupport\" to optionally enable a support connector.</td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Icons.</b></td></tr>
// <tr><td valign=\"top\"> TranslationalSensor<br>
//                                                 RotationalSensor</td>
//           <td valign=\"top\"> Removed drawing from the diagram layer (kept drawing only in
//                                                 icon layer),<br> in order that this icon can be used in situations
//                                                 where components are dragged in the diagram layer.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Math.Vectors.</b></td></tr>
// <tr><td valign=\"top\"> normalize</td>
//           <td valign=\"top\"> Implementation changed, so that the result is awalys continuous<br>
//                                                 (previously, this was not the case for small vectors: normalize(eps,eps)).
//                                                 </td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\"> </td>
//           <td valign=\"top\"> Renamed non-standard keywords defineBranch, defineRoot, definePotentialRoot,
//                                                 isRooted to the standard names:<br>
//                                                 Connections.branch/.root/.potentialRoot/.isRooted.</td> </tr>
// <tr><td valign=\"top\"> Frames </td>
//           <td valign=\"top\"> Added annotation \"Inline=true\" to all one-line functions
//                                                 (which should be all inlined).</td> </tr>
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Parts.</b></td></tr>
// <tr><td valign=\"top\"> Mounting1D<br>
//                                                 Rotor1D<br>
//                                                 BevelGear1D</td>
//           <td valign=\"top\"> Changed implementation so that no longer modifiers for connector
//                                                 variables are used,<br>because this violates the restrictions on
//                                                 \"balanced models\" of Modelica 3. </td> </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> InitializeFlange</td>
//           <td valign=\"top\"> Changed implementation so that counting unknowns and
//                                                 equations is possible without actual values of parameters.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Interfaces.Partials.</b></td></tr>
// <tr><td valign=\"top\">TwoPort</td>
//           <td valign=\"top\"> Introduced <tt>parameter Real tapT(final min=0, final max=1)=1</tt> <br> that defines the temperature of the heatPort
//                                                 betwen inlet and outlet.</td> </tr>
//
// <tr><td colspan=\"2\"><b>StateGraph.</b></td></tr>
// <tr><td valign=\"top\"> InitialStep<br>
//                                                 InitialStepWithSignal<br>
//                                                 Step<br>
//                                                 StepWithSignal</td>
//           <td valign=\"top\"> Changed implementation so that no longer modifiers for output
//                                                 variables are used,<br>because this violates the restrictions on
//                                                 \"balanced models\" of Modelica 3. </td> </tr>
//
// </table>
//
//
// <p><br>
// The following <b style=\"color:red\">critical errors</b> have been fixed (i.e. errors
// that can lead to wrong simulation results):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Electrical.Analog.Examples.</b></td></tr>
// <tr><td valign=\"top\"> CauerLowPassSC </td>
//           <td valign=\"top\"> Wrong calculation of Capacitor1 both in Rn and Rp corrected
//                                                 (C=clock/R instead of C=clock*R) </td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Parts.</b></td></tr>
// <tr><td valign=\"top\"> Rotor1D </td>
//           <td valign=\"top\"> The 3D reaction torque was not completely correct and gave in
//                                                 some situations a wrong result. This bug should not influence the
//                                                 movement of a multi-body system, but only the constraint torques
//                                                 are sometimes not correct. </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> ElastoBacklash </td>
//           <td valign=\"top\"> If the damping torque was too large, the reaction torque
//                                                 could \"pull\" which is unphysical. The component was
//                                                 newly written by limiting the damping torque in such a case
//                                                 so that \"pulling\" torques can no longer occur. Furthermore,
//                                                 during initialization the characteristics is made continuous
//                                                 to reduce numerical errors. The relative angle and relative
//                                                 angular velocities are used as states, if possible
//                                                 (StateSelect.prefer), since relative quantities lead usually
//                                                 to better behavior.  </td>
// </tr>
// <tr><td valign=\"top\"> Position<br>Speed<br>Accelerate<br>Move</td>
//           <td valign=\"top\"> The movement of the flange was wrongly defined as absolute;
//                                                 this is corrected as relative to connector support.<br>
//                                                 For Accelerate, it was necessary to rename
//                                                 RealInput a to a_ref, as well as the start values
//                                                 phi_start to phi.start and w_start to w.start.
//                                                 The conversion script performs the necessary conversion of
//                                                 existing models automatically.</td>
// </tr>
// <tr><td colspan=\"2\"><b>Media.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialSimpleIdealGasMedium </td>
//           <td valign=\"top\"> Inconsisteny in reference temperature corrected. This may give
//                                                 different results for functions:<br>
//                                                 specificEnthalpy, specificInternalEnergy, specificGibbsEnergy,
//                                                 specificHelmholtzEnergy. </td>
// </tr>
// <tr><td colspan=\"2\"><b>Media.Air.</b></td></tr>
// <tr><td valign=\"top\"> specificEntropy </td>
//           <td valign=\"top\"> Small bug in entropy computation of ideal gas mixtures corrected.</td>
// </tr>
// <tr><td colspan=\"2\"><b>Media.IdealGases.Common.MixtureGasNasa</b></td></tr>
// <tr><td valign=\"top\"> specificEntropy </td>
//           <td valign=\"top\"> Small bug in entropy computation of ideal gas mixtures corrected.</td>
// </tr>
// </table>
//
//
// <p><br>
// The following <b style=\"color:red\">uncritical errors</b> have been fixed (i.e. errors
// that do <b style=\"color:red\">not</b> lead to wrong simulation results, but, e.g.,
// units are wrong or errors in documentation):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Tables.</b></td></tr>
// <tr><td valign=\"top\"> CombiTable2D</td>
//           <td valign=\"top\"> Documentation improved.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrica.Digital.Gates</b></td></tr>
// <tr><td valign=\"top\"> AndGate<br>
//                                                 NandGate<br>
//                                                 OrGate<br>
//                                                 NorGate<br>
//                                                 XorGate<br>
//                                                 XnorGate</td>
//           <td valign=\"top\"> The number of inputs was not correctly propagated
//                                                 to the included base model.<br>
//                                                 This gave a translation error, if the number
//                                                 of inputs was changed (and not the default used).</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrica.Digital.Sources</b></td></tr>
// <tr><td valign=\"top\"> Pulse </td>
//           <td valign=\"top\"> Model differently implemented, so that
//                                                 warning message about \"cannot properly initialize\" is gone.</td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> BearingFriction<br>
//                                                 Clutch<br>
//                                                 OneWayClutch<br>
//                                                 Brake <br>
//                                                 Gear </td>
//           <td valign=\"top\"> Declaration of table parameter changed from
//                                                 table[:,:] to table[:,2].</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Examples.Loops.Utilities.</b></td></tr>
// <tr><td valign=\"top\"> GasForce </td>
//           <td valign=\"top\"> Unit of variable \"press\" corrected (from Pa to bar)</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>StateGraph.Examples.</b></td></tr>
// <tr><td valign=\"top\">SimpleFriction</td>
//           <td valign=\"top\"> The internal parameter k is defined and calculated with the appropriate unit.</td> </tr>
//
//
// <tr><td colspan=\"2\"><b>Thermal.FluidHeatFlow.Interfaces.Partials.</b></td></tr>
// <tr><td valign=\"top\">SimpleFriction</td>
//           <td valign=\"top\"> The internal parameter k is defined and calculated with the appropriate unit.</td> </tr>
//
// </table>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_2)
// {"<html>
// <p>
// Version 2.2.2 is backward compatible to version 2.2.1 and 2.2 with
// the following exceptions:
// </p>
// <ul>
// <li> Removal of package Modelica.Media.Interfaces.PartialTwoPhaseMediumWithCache
//          (this was not yet utilized).</li>
// <li> Removal of the media packages in
//          Modelica.Media.IdealGases.SingleGases that are not type compatible
//          to Modelica.Media.Interfaces.PartialMedium, because a FluidConstants
//          record definition is missing,
//          for details, see
//           <a href=\"Modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>
//          (this is seen as a bug fix).
// </ul>
//
// <p>
// An overview of the differences between version 2.2.2 and the previous
// version 2.2.1 is given below. The exact differences (but without
// differences in the documentation) are available
// <a href=\"Documentation/Differences-Modelica-221-222.html\">here</a>.
// This comparison file was generated automatically with Dymolas
// ModelManagement.compare function.
// </p>
//
// <p>
// In this version, <b>no</b> new libraries have been added. The <b>documentation</b>
// of the whole library was improved. Especially, the documentation is now also
// available as
// <a href=\"Documentation/ModelicaStandardLibrary.pdf\">one pdf file</a>.
// </p>
//
//
// <p><br>
// The following <b style=\"color:blue\">new components</b> have been added
// to <b style=\"color:blue\">existing</b> libraries:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Logical.</b></td></tr>
// <tr><td valign=\"top\"> TerminateSimulation</td>
//           <td valign=\"top\"> Terminate a simulation by a given condition.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Routing.</b></td></tr>
// <tr><td valign=\"top\"> RealPassThrough<br>
//                    IntegerPassThrough<br>
//                    BooleanPassThrough</td>
//           <td valign=\"top\"> Pass a signal from input to output
//                    (useful in combination with a bus due to restrictions
//                    of expandable connectors).</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Sources.</b></td></tr>
// <tr><td valign=\"top\"> KinematicPTP2 </td>
//           <td valign=\"top\"> Directly gives q,qd,qdd as output (and not just qdd as KinematicPTP).
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Examples.</b></td></tr>
// <tr><td valign=\"top\"> TransformerTestbench </td>
//           <td valign=\"top\"> Transformer Testbench
//           </td>
// <tr><td valign=\"top\"> Rectifier6pulse </td>
//           <td valign=\"top\"> 6-pulse rectifier with 1 transformer
//           </td>
// </tr>
// <tr><td valign=\"top\"> Rectifier12pulse </td>
//           <td valign=\"top\"> 12-pulse rectifier with 2 transformers
//           </td>
// </tr>
// <tr><td valign=\"top\"> AIMC_Steinmetz </td>
//           <td valign=\"top\"> Asynchronous induction machine squirrel cage with Steinmetz connection
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.BasicMachines.Components.</b></td></tr>
// <tr><td valign=\"top\"> BasicAIM </td>
//           <td valign=\"top\"> Partial model for asynchronous induction machine
//           </td>
// <tr><td valign=\"top\"> BasicSM </td>
//           <td valign=\"top\"> Partial model for synchronous induction machine
//           </td>
// <tr><td valign=\"top\"> PartialAirGap </td>
//           <td valign=\"top\"> Partial airgap model
//           </td>
// <tr><td valign=\"top\"> BasicDCMachine </td>
//           <td valign=\"top\"> Partial model for DC machine
//           </td>
// <tr><td valign=\"top\"> PartialAirGapDC </td>
//           <td valign=\"top\"> Partial airgap model of a DC machine
//           </td>
// <tr><td valign=\"top\"> BasicTransformer </td>
//           <td valign=\"top\"> Partial model of threephase transformer
//           </td>
// <tr><td valign=\"top\"> PartialCore </td>
//           <td valign=\"top\"> Partial model of transformer core with 3 windings
//           </td>
// <tr><td valign=\"top\"> IdealCore </td>
//           <td valign=\"top\"> Ideal transformer with 3 windings
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.BasicMachines.</b></td></tr>
// <tr><td valign=\"top\"> Transformers </td>
//           <td valign=\"top\"> Sub-Library for technical 3phase transformers
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> Adapter </td>
//           <td valign=\"top\"> Adapter to model housing of electrical machine
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Math.</b></td></tr>
// <tr><td valign=\"top\"> Vectors </td>
//           <td valign=\"top\"> New library of functions operating on vectors
//           </td>
// </tr>
// <tr><td valign=\"top\"> atan3 </td>
//           <td valign=\"top\"> Four quadrant inverse tangens (select solution that is closest to given angle y0)
//           </td>
// </tr>
// <tr><td valign=\"top\"> asinh </td>
//           <td valign=\"top\"> Inverse of sinh (area hyperbolic sine)
//           </td>
// </tr>
// <tr><td valign=\"top\"> acosh </td>
//           <td valign=\"top\"> Inverse of cosh (area hyperbolic cosine)
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Math.Vectors</b></td></tr>
// <tr><td valign=\"top\"> isEqual </td>
//           <td valign=\"top\"> Determine if two Real vectors are numerically identical
//           </td>
// </tr>
// <tr><td valign=\"top\"> norm </td>
//           <td valign=\"top\"> Return the p-norm of a vector
//           </td></tr>
// <tr><td valign=\"top\"> length </td>
//           <td valign=\"top\"> Return length of a vector (better as norm(), if further symbolic processing is performed)
//           </td></tr>
// <tr><td valign=\"top\"> normalize </td>
//           <td valign=\"top\"> Return normalized vector such that length = 1 and prevent zero-division for zero vector
//           </td></tr>
// <tr><td valign=\"top\"> reverse </td>
//           <td valign=\"top\"> Reverse vector elements (e.g. v[1] becomes last element)
//           </td></tr>
// <tr><td valign=\"top\"> sort </td>
//           <td valign=\"top\"> Sort elements of vector in ascending or descending order
//           </td></tr>
//
// <tr><td colspan=\"2\"><b>Math.Matrices</b></td></tr>
// <tr><td valign=\"top\"> solve2 </td>
//           <td valign=\"top\"> Solve real system of linear equations A*X=B with a B matrix
//                    (Gaussian elemination with partial pivoting)
//           </td>
// </tr>
// <tr><td valign=\"top\"> LU_solve2 </td>
//           <td valign=\"top\"> Solve real system of linear equations P*L*U*X=B with a B matrix
//                    and an LU decomposition (from LU(..))
//           </td></tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> InitializeFlange </td>
//           <td valign=\"top\"> Initialize a flange according to given signals
//                    (useful if initialization signals are provided by a signal bus).
//           </td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialMedium.</b></td></tr>
// <tr><td valign=\"top\"> density_pTX </td>
//           <td valign=\"top\"> Return density from p, T, and X or Xi
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialTwoPhaseMedium.</b></td></tr>
// <tr><td valign=\"top\"> BaseProperties </td>
//           <td valign=\"top\"> Base properties (p, d, T, h, u, R, MM, x) of a two phase medium
//           </td>
// </tr>
// <tr><td valign=\"top\"> molarMass </td>
//           <td valign=\"top\"> Return the molar mass of the medium
//           </td>
// </tr>
// <tr><td valign=\"top\"> saturationPressure_sat </td>
//           <td valign=\"top\"> Return saturation pressure
//           </td>
// </tr>
// <tr><td valign=\"top\"> saturationTemperature_sat </td>
//           <td valign=\"top\"> Return saturation temperature
//           </td>
// </tr>
// <tr><td valign=\"top\"> saturationTemperature_derp_sat </td>
//           <td valign=\"top\"> Return derivative of saturation temperature w.r.t. pressure
//           </td>
// </tr>  <tr><td valign=\"top\"> setState_px </td>
//           <td valign=\"top\"> Return thermodynamic state from pressure and vapour quality
//           </td>
// </tr>  <tr><td valign=\"top\"> setState_Tx </td>
//           <td valign=\"top\"> Return thermodynamic state from temperature and vapour quality
//           </td>
// </tr>  <tr><td valign=\"top\"> vapourQuality </td>
//           <td valign=\"top\"> Return vapour quality
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialLinearFluid </td>
//           <td valign=\"top\"> Generic pure liquid model with constant cp,
//                    compressibility and thermal expansion coefficients
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Air.MoistAir.</b></td></tr>
// <tr><td valign=\"top\"> massFraction_pTphi </td>
//           <td valign=\"top\"> Return the steam mass fraction from relative humidity and T
//           </td>
// </tr>
// <tr><td valign=\"top\"> saturationTemperature </td>
//           <td valign=\"top\"> Return saturation temperature from (partial) pressure
//                    via numerical inversion of function saturationPressure
//           </td>
// </tr>
// <tr><td valign=\"top\"> enthalpyOfWater </td>
//           <td valign=\"top\"> Return specific enthalpy of water (solid/liquid) near
//                    atmospheric pressure from temperature
//           </td>
// </tr>
// <tr><td valign=\"top\"> enthalpyOfWater_der </td>
//           <td valign=\"top\"> Return derivative of enthalpyOfWater()\" function
//           </td>
// </tr>
// <tr><td valign=\"top\"> PsychrometricData </td>
//           <td valign=\"top\"> Model to generate plot data for psychrometric chart
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.CompressibleLiquids.</b><br>
//           New sub-library for simple compressible liquid models</td></tr>
// <tr><td valign=\"top\"> LinearColdWater </td>
//           <td valign=\"top\"> Cold water model with linear compressibility
//           </td>
// <tr><td valign=\"top\"> LinerWater_pT_Ambient </td>
//           <td valign=\"top\"> Liquid, linear compressibility water model at 1.01325 bar
//                    and 25 degree Celsius
//           </td>
//
// <tr><td colspan=\"2\"><b>SIunits.</b></td></tr>
// <tr><td valign=\"top\"> TemperatureDifference </td>
//           <td valign=\"top\"> Type for temperature difference
//           </td>
// </table>
//
//
// <p><br>
// The following <b style=\"color:blue\">existing components</b>
// have been <b style=\"color:blue\">improved</b>:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.Examples.</b></td></tr>
// <tr><td valign=\"top\"> BusUsage</td>
//           <td valign=\"top\"> Example changed from the \"old\" to the \"new\" bus concept with
//                    expandable connectors.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Discrete.</b></td></tr>
// <tr><td valign=\"top\"> ZeroOrderHold</td>
//           <td valign=\"top\"> Sample output ySample moved from \"protected\" to \"public\"
//                    section with new attributes (start=0, fixed=true).
//           </td>
// </tr>
// <tr><td valign=\"top\"> TransferFunction</td>
//           <td valign=\"top\"> Discrete state x with new attributes (each start=0, each fixed=0).
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.</b></td></tr>
// <tr><td valign=\"top\"> Analog<br>MultiPhase</td>
//           <td valign=\"top\"> Improved some icons.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> MISO</td>
//           <td valign=\"top\"> Removed \"algorithm\" from this partial block.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Delay.</b></td></tr>
// <tr><td valign=\"top\"> DelayParams</td>
//           <td valign=\"top\"> Removed \"algorithm\" from this partial block.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Delay.</b></td></tr>
// <tr><td valign=\"top\"> DelayParams</td>
//           <td valign=\"top\"> Removed \"algorithm\" from this partial block.
//           </td>
// </tr>
// <tr><td valign=\"top\"> TransportDelay</td>
//           <td valign=\"top\">  If delay time is zero, an infinitely small delay is
//                         introduced via pre(x) (previously \"x\" was used).
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Sources.</b></td></tr>
// <tr><td valign=\"top\"> Clock<br>Step</td>
//           <td valign=\"top\"> Changed if-conditions from \"xxx < time\" to \"time >= xxx\"
//                    (according to the Modelica specification, in the second case
//                    a time event should be triggered, i.e., this change leads
//                    potentially to a faster simulation).
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Converters.</b></td></tr>
// <tr><td valign=\"top\"> BooleanToLogic<br>
//                    LogicToBoolean<br>
//                    RealToLogic<br>
//                    LogicToReal</td>
//           <td valign=\"top\"> Changed from \"algorithm\" to \"equation\" section
//                    to allow better symbolic preprocessing
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.</b></td></tr>
// <tr><td valign=\"top\"> Machines</td>
//           <td valign=\"top\"> Slightly improved documentation, typos in
//                    documentation corrected
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Examples.</b></td></tr>
// <tr><td valign=\"top\"> AIMS_start</td>
//           <td valign=\"top\"> Changed QuadraticLoadTorque1(TorqueDirection=true) to
//                    QuadraticLoadTorque1(TorqueDirection=false) since more realistic
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialBasicMachine</td>
//           <td valign=\"top\"> Introduced support flange to model the
//                    reaction torque to the housing
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Machines.Sensors.</b></td></tr>
// <tr><td valign=\"top\"> Rotorangle</td>
//           <td valign=\"top\"> Introduced support flange to model the
//                    reaction torque to the housing
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Examples.Elementary.</b></td></tr>
// <tr><td valign=\"top\"> PointMassesWithGravity</td>
//           <td valign=\"top\"> Added two point masses connected by a line force to demonstrate
//                    additionally how this works. Connections of point masses
//                    with 3D-elements are demonstrated in the new example
//                    PointMassesWithGravity (there is the difficulty that the orientation
//                    is not defined in a PointMass object and therefore some
//                    special handling is needed in case of a connection with
//                    3D-elements, where the orientation of the point mass is not
//                    determined by these elements.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Examples.Systems.</b></td></tr>
// <tr><td valign=\"top\"> RobotR3</td>
//           <td valign=\"top\"> Changed from the \"old\" to the \"new\" bus concept with expandable connectors.
//                    Replaced the non-standard Modelica function \"constrain()\" by
//                    standard Modelica components. As a result, the non-standard function
//                    constrain() is no longer used in the Modelica Standard Library.</td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Frames.Orientation.</b></td></tr>
// <tr><td valign=\"top\"> equalityConstraint</td>
//           <td valign=\"top\"> Use a better residual for the equalityConstraint function.
//                    As a result, the non-linear equation system of a kinematic
//                    loop is formulated in a better way (the range where the
//                    desired result is a unique solution of the non-linear
//                    system of equations becomes much larger).</td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\"> Visualizers.</td>
//           <td valign=\"top\"> Removed (misleading) annotation \"structurallyIncomplete\"
//                    in the models of this sub-library
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> Examples</td>
//           <td valign=\"top\"> For all models in this sub-library:
//                    <ul>
//                    <li> Included a housing object in all examples to compute
//                                 all support torques.</li>
//                    <li> Replaced initialization by modifiers via the
//                                 initialization menu parameters of Inertia components.</li>
//                    <li> Removed \"encapsulated\" and unnecessary \"import\". </li>
//                    <li> Included \"StopTime\" in the annotations.</li>
//                    </ul>
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> FrictionBase</td>
//           <td valign=\"top\"> Introduced \"fixed=true\" for Boolean variables startForward,
//                    startBackward, mode.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> FrictionBase</td>
//           <td valign=\"top\"> Introduced \"fixed=true\" for Boolean variables startForward,
//                    startBackward, mode.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.UsersGuide.MediumUsage.</b></td></tr>
// <tr><td valign=\"top\"> TwoPhase</td>
//           <td valign=\"top\"> Improved documentation and demonstrating the newly introduced functions
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Examples.</b></td></tr>
// <tr><td valign=\"top\"> WaterIF97</td>
//           <td valign=\"top\"> Provided (missing) units for variables V, dV, H_flow_ext, m, U.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialMedium</td>
//           <td valign=\"top\"> Final modifiers are removed from nX and nXi, to allow
//                    customized medium models such as mixtures of refrigerants with oil, etc.
//           </td>
// </tr>
// <tr><td valign=\"top\"> PartialCondensingGases</td>
//           <td valign=\"top\"> Included attributes \"min=1, max=2\" for input argument FixedPhase
//                    for functions setDewState and setBubbleState (in order to guarantee
//                    that input arguments are correct).
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Interfaces.PartialMedium.</b></td></tr>
// <tr><td valign=\"top\"> BaseProperties</td>
//           <td valign=\"top\"> New Boolean parameter \"standardOrderComponents\".
//                    If true, last element vector X is computed from 1-sum(Xi) (= default)
//                    otherwise, no equation is provided for it in PartialMedium.
//           </td>
// </tr>
// <tr><td valign=\"top\"> IsentropicExponent</td>
//           <td valign=\"top\"> \"max\" value changed from 1.7 to 500000
//           </td>
// </tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_psX<br>
//                    setState_dTX<br>
//                    specificEnthalpy_pTX<br>
//                    temperature_phX<br>
//                    density_phX<br>
//                    temperature_psX<br>
//                    density_psX<br>
//                    specificEnthalpy_psX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Interfaces.PartialSimpleMedium.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_psX<br>
//                    setState_dTX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Interfaces.PartialSimpleIdealGasMedium.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_psX<br>
//                    setState_dTX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Air.MoistAir.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_dTX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_psX<br>
//                    setState_dTX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.IdealGases.Common.MixtureGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> setState_pTX<br>
//                    setState_phX<br>
//                    setState_psX<br>
//                    setState_dTX<br>
//                    h_TX</td>
//           <td valign=\"top\"> Introduced defaut value \"reference_X\" for input argument \"X\".
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Common.</b></td></tr>
// <tr><td valign=\"top\"> IF97PhaseBoundaryProperties<br>
//                    gibbsToBridgmansTables </td>
//           <td valign=\"top\"> Introduced unit for variables vt, vp.
//           </td>
// </tr>
// <tr><td valign=\"top\"> SaturationProperties</td>
//           <td valign=\"top\"> Introduced unit for variable dpT.
//           </td>
// </tr>
// <tr><td valign=\"top\"> BridgmansTables</td>
//           <td valign=\"top\"> Introduced unit for dfs, dgs.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Common.ThermoFluidSpecial.</b></td></tr>
// <tr><td valign=\"top\"> gibbsToProps_ph<br>
//                    gibbsToProps_ph  <br>
//                    gibbsToBoundaryProps<br>
//                    gibbsToProps_dT<br>
//                    gibbsToProps_pT</td>
//           <td valign=\"top\"> Introduced unit for variables vt, vp.
//           </td>
// <tr><td valign=\"top\"> TwoPhaseToProps_ph</td>
//           <td valign=\"top\"> Introduced unit for variables dht, dhd, detph.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.</b></td></tr>
// <tr><td valign=\"top\"> MoistAir</td>
//           <td valign=\"top\"> Documentation of moist air model significantly improved.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.MoistAir.</b></td></tr>
// <tr><td valign=\"top\"> enthalpyOfVaporization</td>
//           <td valign=\"top\"> Replaced by linear correlation since simpler and more
//                    accurate in the entire region.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Media.Water.IF97_Utilities.BaseIF97.Regions.</b></td></tr>
// <tr><td valign=\"top\"> drhovl_dp</td>
//           <td valign=\"top\"> Introduced unit for variable dd_dp.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b> Thermal.</b></td></tr>
// <tr><td valign=\"top\"> FluidHeatFlow</td>
//           <td valign=\"top\"> Introduced new parameter tapT (0..1) to define the
//                    temperature of the HeatPort as linear combination of the
//                    flowPort_a (tapT=0) and flowPort_b (tapT=1) temperatures.
//           </td>
// </tr>
// </table>
//
//
//
// <p><br>
// The following <b style=\"color:red\">critical errors</b> have been fixed (i.e. errors
// that can lead to wrong simulation results):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Electrical.Machines.BasicMachines.Components.</b></td></tr>
// <tr><td valign=\"top\"> ElectricalExcitation</td>
//           <td valign=\"top\"> Excitation voltage ve is calculated as
//                    \"spacePhasor_r.v_[1]*TurnsRatio*3/2\" instead of
//                    \"spacePhasor_r.v_[1]*TurnsRatio
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Parts.</b></td></tr>
// <tr><td valign=\"top\"> FixedRotation</td>
//           <td valign=\"top\"> Bug corrected that the torque balance was wrong in the
//                    following cases (since vector r was not transformed
//                    from frame_a to frame_b; note this special case occurs very seldomly in practice):
//                    <ul><li> frame_b is in the spanning tree closer to the root
//                                         (usually this is frame_a).</li>
//                            <li> vector r from frame_a to frame_b is not zero.</li>
//                    </ul>
//            </td>
// </tr>
//
// <tr><td valign=\"top\"> PointMass</td>
//          <td valign=\"top\"> If a PointMass model is connected so that no equations are present
//                   to compute its orientation object, the orientation was arbitrarily
//                   set to a unit rotation. In some cases this can lead to a wrong overall
//                   model, depending on how the PointMass model is used. For this reason,
//                   such cases lead now to an error (via an assert(..)) with an explanation
//                   how to fix this.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialPureSubstance.</b></td></tr>
// <tr><td valign=\"top\"> pressure_dT<br>
//                    specificEnthalpy_dT
//           </td>
//           <td valign=\"top\"> Changed wrong call from \"setState_pTX\" to \"setState_dTX\"
//            </td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialTwoPhaseMedium.</b></td></tr>
// <tr><td valign=\"top\"> pressure_dT<br>
//                    specificEnthalpy_dT
//           </td>
//           <td valign=\"top\"> Changed wrong call from \"setState_pTX\" to \"setState_dTX\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Common.ThermoFluidSpecial.</b></td></tr>
// <tr><td valign=\"top\"> gibbsToProps_dT<br>
//                    helmholtzToProps_ph<br>
//                    helmholtzToProps_pT<br>
//                    helmholtzToProps_dT</td>
//           <td valign=\"top\"> Bugs in equations corrected </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Common.</b></td></tr>
// <tr><td valign=\"top\"> helmholtzToBridgmansTables<br>
//                    helmholtzToExtraDerivs</td>
//           <td valign=\"top\"> Bugs in equations corrected </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> density_derp_T</td>
//           <td valign=\"top\"> Bug in equation of partial derivative corrected </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.</b></td></tr>
// <tr><td valign=\"top\"> BaseIF97.Inverses.dtofps3<br>
//                    isentropicExponent_props_ph<br>
//                    isentropicExponent_props_pT<br>
//                    isentropicExponent_props_dT</td>
//           <td valign=\"top\"> Bugs in equations corrected </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Air.MoistAir.</b></td></tr>
// <tr><td valign=\"top\"> h_pTX</td>
//           <td valign=\"top\"> Bug in setState_phX due to wrong vector size in h_pTX corrected.
//                    Furthermore, syntactical errors corrected:
//                    <ul><li> In function massFractionpTphi an equation
//                                         sign is used in an algorithm.</li>
//                            <li> Two consecutive semicolons removed</li>
//                    </ul>
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.</b></td></tr>
// <tr><td valign=\"top\"> waterConstants</td>
//           <td valign=\"top\"> Bug in equation of criticalMolarVolume corrected.
//           </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.BaseIF97.Regions.</b></td></tr>
// <tr><td valign=\"top\"> region_ph<br>
//                    region_ps</td>
//           <td valign=\"top\"> Bug in region determination corrected.
//           </td>
// </tr>
//
// <tr><td valign=\"top\"> boilingcurve_p<br>
//                    dewcurve_p</td>
//           <td valign=\"top\"> Bug in equation of plim corrected.
//           </td>
// </tr>
// </table>
//
//
// <p><br>
// The following <b style=\"color:red\">uncritical errors</b> have been fixed (i.e. errors
// that do <b style=\"color:red\">not</b> lead to wrong simulation results, but, e.g.,
// units are wrong or errors in documentation):
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2 style=\"border-collapse:collapse;\">
// <tr><td colspan=\"2\"><b>Blocks.</b></td></tr>
// <tr><td valign=\"top\"> Examples</td>
//           <td valign=\"top\"> Corrected typos in description texts of bus example models.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Continuous.</b></td></tr>
// <tr><td valign=\"top\"> LimIntegrator</td>
//           <td valign=\"top\"> removed incorrect smooth(0,..) because expression might be discontinuous.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Blocks.Math.UnitConversions.</b></td></tr>
// <tr><td valign=\"top\"> block_To_kWh<br>block_From_kWh</td>
//           <td valign=\"top\"> Corrected unit from \"kWh\" to (syntactically correct) \"kW.h\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Examples.</b></td></tr>
// <tr><td valign=\"top\"> HeatingNPN_OrGate</td>
//           <td valign=\"top\"> Included start values, so that initialization is
//                                                 successful </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Analog.Lines.</b></td></tr>
// <tr><td valign=\"top\"> OLine</td>
//           <td valign=\"top\"> Corrected unit from \"Siemens/m\" to \"S/m\".
//            </td>
// <tr><td valign=\"top\"> TLine2</td>
//           <td valign=\"top\"> Changed wrong type of parameter NL (normalized length) from
//                    SIunits.Length to Real.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital.Delay.</b></td></tr>
// <tr><td valign=\"top\"> TransportDelay</td>
//           <td valign=\"top\"> Syntax error corrected
//                    (\":=\" in equation section is converted by Dymola silently to \"=\").
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.Digital</b></td></tr>
// <tr><td valign=\"top\"> Converters</td>
//           <td valign=\"top\"> Syntax error corrected
//                    (\":=\" in equation section is converted by Dymola silently to \"=\").
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.MultiPhase.Basic.</b></td></tr>
// <tr><td valign=\"top\"> Conductor</td>
//           <td valign=\"top\"> Changed wrong type of parameter G from SIunits.Resistance to
//                    SIunits.Conductance.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.MultiPhase.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> Plug<br></td>
//           <td valign=\"top\"> Made used \"pin\" connectors non-graphical (otherwise,
//                    there are difficulties to connect to Plug).
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Electrical.MultiPhase.Sources.</b></td></tr>
// <tr><td valign=\"top\"> SineCurrent</td>
//           <td valign=\"top\"> Changed wrong type of parameter offset from SIunits.Voltage to
//                    SIunits.Current.
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Examples.Loops.</b></td></tr>
// <tr><td valign=\"top\"> EngineV6</td>
//           <td valign=\"top\"> Corrected wrong crankAngleOffset of some cylinders
//                    and improved the example.
//            </td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Examples.Loops.Utilities.</b></td></tr>
// <tr><td valign=\"top\"> GasForce</td>
//           <td valign=\"top\"> Wrong units corrected:
//                    \"SIunitsPosition x,y\" to \"Real x,y\";
//            \"SIunits.Pressure press\" to \"SIunits.Conversions.NonSIunits.Pressure_bar\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> GasForce2</td>
//           <td valign=\"top\"> Wrong unit corrected: \"SIunits.Position x\" to \"Real x\".
//            </td>
// </tr>
// <tr><td valign=\"top\"> EngineV6_analytic</td>
//           <td valign=\"top\"> Corrected wrong crankAngleOffset of some cylinders.
//            </td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> PartialLineForce</td>
//           <td valign=\"top\"> Corrected wrong unit: \"SIunits.Position eRod_a\" to \"Real eRod_a\";
//            </td>
// </tr>
// <tr><td valign=\"top\"> FlangeWithBearingAdaptor </td>
//           <td valign=\"top\"> If includeBearingConnector = false, connector \"fr\"
//                            + \"ame\" was not
//                    removed. As long as the connecting element to \"frame\" determines
//                    the non-flow variables, this is fine. In the corrected version, \"frame\"
//                    is conditionally removed in this case.</td>
// </tr>
//
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Forces.</b></td></tr>
// <tr><td valign=\"top\"> ForceAndTorque</td>
//           <td valign=\"top\"> Corrected wrong unit: \"SIunits.Force t_b_0\" to \"SIunits.Torque t_b_0\".
//            </td>
// </tr>
// <tr><td valign=\"top\"> LineForceWithTwoMasses</td>
//           <td valign=\"top\"> Corrected wrong unit: \"SIunits.Position e_rel_0\" to \"Real e_rel_0\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Frames.</b></td></tr>
// <tr><td valign=\"top\"> axisRotation</td>
//           <td valign=\"top\"> Corrected wrong unit: \"SIunits.Angle der_angle\" to
//                         \"SIunits.AngularVelocity der_angle\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Joints.Assemblies.</b></td></tr>
// <tr><td valign=\"top\"> JointUSP<br>JointSSP</td>
//           <td valign=\"top\"> Corrected wrong unit: \"SIunits.Position aux\"  to \"Real\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Sensors.</b></td></tr>
// <tr><td valign=\"top\"> AbsoluteSensor</td>
//           <td valign=\"top\"> Corrected wrong units: \"SIunits.Acceleration angles\" to
//                    \"SIunits.Angle angles\" and
//                    \"SIunits.Velocity w_abs_0\" to \"SIunits.AngularVelocity w_abs_0\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> RelativeSensor</td>
//           <td valign=\"top\"> Corrected wrong units: \"SIunits.Acceleration angles\" to
//                    \"SIunits.Angle angles\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> Distance</td>
//           <td valign=\"top\"> Corrected wrong units: \"SIunits.Length L2\" to \"SIunits.Area L2\" and
//                    SIunits.Length s_small2\" to \"SIunits.Area s_small2\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.MultiBody.Visualizers.Advanced.</b></td></tr>
// <tr><td valign=\"top\"> Shape</td>
//           <td valign=\"top\"> Changed \"MultiBody.Types.Color color\" to \"Real color[3]\", since
//                    \"Types.Color\" is \"Integer color[3]\" and there have been backward
//                    compatibility problems with models using \"color\" before it was changed
//                    to \"Types.Color\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> FrictionBase</td>
//           <td valign=\"top\"> Rewrote equations with new variables \"unitAngularAcceleration\" and
//                    \"unitTorque\" in order that the equations are correct with respect
//                    to units (previously, variable \"s\" can be both a torque and an
//                    angular acceleration and this lead to unit incompatibilities)
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> OneWayClutch<br>LossyGear</td>
//           <td valign=\"top\"> Rewrote equations with new variables \"unitAngularAcceleration\" and
//                    \"unitTorque\" in order that the equations are correct with respect
//                    to units (previously, variable \"s\" can be both a torque and an
//                    angular acceleration and this lead to unit incompatibilities)
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> FrictionBase</td>
//           <td valign=\"top\"> Rewrote equations with new variables \"unitAngularAcceleration\" and
//                    \"unitTorque\" in order that the equations are correct with respect
//                    to units (previously, variable \"s\" can be both a torque and an
//                    angular acceleration and this lead to unit incompatibilities)
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Mechanics.Translational.</b></td></tr>
// <tr><td valign=\"top\"> Speed</td>
//           <td valign=\"top\"> Corrected unit of v_ref from SIunits.Position to SIunits.Velocity
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Examples.Tests.Components.</b></td></tr>
// <tr><td valign=\"top\"> PartialTestModel<br>PartialTestModel2</td>
//           <td valign=\"top\"> Corrected unit of h_start from \"SIunits.Density\" to \"SIunits.SpecificEnthalpy\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Examples.SolveOneNonlinearEquation.</b></td></tr>
// <tr><td valign=\"top\"> Inverse_sh_T
//                    InverseIncompressible_sh_T<br>
//                    Inverse_sh_TX</td>
//           <td valign=\"top\"> Rewrote equations so that dimensional (unit) analysis is correct\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Incompressible.Examples.</b></td></tr>
// <tr><td valign=\"top\"> TestGlycol</td>
//           <td valign=\"top\"> Rewrote equations so that dimensional (unit) analysis is correct\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Interfaces.PartialTwoPhaseMedium.</b></td></tr>
// <tr><td valign=\"top\"> dBubbleDensity_dPressure<br>dDewDensity_dPressure</td>
//           <td valign=\"top\"> Changed wrong type of ddldp from \"DerDensityByEnthalpy\"
//                    to \"DerDensityByPressure\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Common.ThermoFluidSpecial.</b></td></tr>
// <tr><td valign=\"top\"> ThermoProperties</td>
//           <td valign=\"top\"> Changed wrong units:
//                    \"SIunits.DerEnergyByPressure dupT\" to \"Real dupT\" and
//                    \"SIunits.DerEnergyByDensity dudT\" to \"Real dudT\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> ThermoProperties_ph</td>
//           <td valign=\"top\"> Changed wrong unit from \"SIunits.DerEnergyByPressure duph\" to \"Real duph\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> ThermoProperties_pT</td>
//           <td valign=\"top\"> Changed wrong unit from \"SIunits.DerEnergyByPressure dupT\" to \"Real dupT\"
//            </td>
// </tr>
// <tr><td valign=\"top\"> ThermoProperties_dT</td>
//           <td valign=\"top\">  Changed wrong unit from \"SIunits.DerEnergyByDensity dudT\" to \"Real dudT\"
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> cp_Tlow_der</td>
//           <td valign=\"top\"> Changed wrong unit from \"SIunits.Temperature dT\" to \"Real dT\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.BaseIF97.Basic.</b></td></tr>
// <tr><td valign=\"top\"> p1_hs<br>
//                    h2ab_s<br>
//                    p2a_hs<br>
//                    p2b_hs<br>
//                    p2c_hs<br>
//                    h3ab_p<br>
//                    T3a_ph<br>
//                    T3b_ph<br>
//                    v3a_ph<br>
//                    v3b_ph<br>
//                    T3a_ps<br>
//                    T3b_ps<br>
//                    v3a_ps<br>
//                    v3b_ps</td>
//           <td valign=\"top\"> Changed wrong unit of variables h/hstar, s, sstar from
//                    \"SIunits.Enthalpy\" to \"SIunits.SpecificEnthalpy\",
//                    \"SIunits.SpecificEntropy\", \"SIunits.SpecificEntropy
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.BaseIF97.Transport.</b></td></tr>
// <tr><td valign=\"top\"> cond_dTp</td>
//           <td valign=\"top\"> Changed wrong unit of TREL, rhoREL, lambdaREL from
//                    \"SIunits.Temperature\", \"SIunit.Density\", \"SIunits.ThermalConductivity\"
//                    to \"Real\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.BaseIF97.Inverses.</b></td></tr>
// <tr><td valign=\"top\"> tofps5<br>tofpst5</td>
//           <td valign=\"top\"> Changed wrong unit of pros from \"SIunits.SpecificEnthalpy\" to
//                    \"SIunits.SpecificEntropy\".
//            </td>
// </tr>
//
// <tr><td colspan=\"2\"><b>Media.Water.IF97_Utilities.</b></td></tr>
// <tr><td valign=\"top\"> waterBaseProp_ph</td>
//           <td valign=\"top\"> Improved calculation at the limits of the validity.
//            </td>
// </tr>
//
//         <tr><td colspan=\"2\"><b>Thermal.</b></td></tr>
// <tr><td valign=\"top\"> FluidHeatFlow<br>HeatTransfer</td>
//           <td valign=\"top\"> Corrected wrong unit \"SIunits.Temperature\" of difference temperature
//                         variables with \"SIunits.TemperatureDifference\".
//            </td>
// </tr>
//
// </table>
//
// </html>","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2_1)
// {"<html>
//
// <p>
// Version 2.2.1 is backward compatible to version 2.2.
// </p>
//
// <p>
// In this version, <b>no</b> new libraries have been added.
// The following major improvements have been made:
// </p>
//
// <ul>
// <li> The <b>Documentation</b> of the Modelica standard library was
//          considerably improved:<br>
//          In Dymola 6, the new feature was introduced to automatically add tables
//          for class content and component interface definitions (parameters and
//          connectors) to the info layer. For this reason, the corresponding (partial)
//          tables previously present in the Modelica Standard Library have been
//          removed. The new feature of Dymola 6 has the significant advantage that
//          all tables are now guaranteed to be up-to-date.<br>
//          Additionally, the documentation has been improved by adding appropriate
//          description texts to parameters, connector instances, function input
//          and output arguments etc., in order that the automatically generated
//          tables do not have empty entries. Also new User's Guides for sublibraries
//          Rotational and SIunits have been added and the User's Guide on top
//          level (Modelica.UsersGuide) has been improved.<br>&nbsp;</li>
//
// <li> Initialization options have been added to the Modelica.Blocks.<b>Continuous</b>
//          blocks (NoInit, SteadyState, InitialState, InitialOutput). If InitialOutput
//          is selected, the block output is provided as initial condition. The states
//          of the block are then initialized as close as possible to steady state.
//          Furthermore, the Continuous.LimPID block has been significantly
//          improved and much better documented.<br>&nbsp;</li>
//
// <li> The Modelica.<b>Media</b> library has been significantly improved:<br>
//          New functions setState_pTX, setState_phX, setState_psX, setState_dTX
//          have been added to PartialMedium to compute the independent medium variables
//          (= state of medium) from p,T,X, or from p,h,X or from p,s,X or from
//          d,T,X. Then functions are provided for all interesting medium variables
//          to compute them from its medium state. All these functions are
//          implemented in a robust way for all media (with a few exceptions, if the
//          generic function does not make sense for a particular medium).</li>
// </ul>
//
// <p>
// The following <b>new components</b> have been added to <b>existing</b> libraries:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Examples.</b></td></tr>
// <tr><td valign=\"top\"> PID_Controller</td>
//           <td valign=\"top\"> Example to demonstrate the usage of the
//                    Blocks.Continuous.LimPID block.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\"> UnitConversions.*</td>
//           <td valign=\"top\"> New package that provides blocks for unit conversions.
//                    UnitConversions.ConvertAllBlocks allows to select all
//                    available conversions from a menu.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines.</b></td></tr>
// <tr><td valign=\"top\"> SM_ElectricalExcitedDamperCage</td>
//           <td valign=\"top\"> Electrical excited synchronous induction machine with damper cage</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.Components.</b></td></tr>
// <tr><td valign=\"top\"> ElectricalExcitation </td>
//           <td valign=\"top\"> Electrical excitation for electrical excited synchronous
//                    induction machines</td> </tr>
// <tr><td valign=\"top\"> DamperCage</td>
//           <td valign=\"top\"> Unsymmetrical damper cage for electrical excited synchronous
//                    induction machines. At least the user has to specify the dampers
//                    resistance and stray inductance in d-axis; if he omits the
//                    parameters of the q-axis, the same values as for the d.axis
//                    are used, assuming a symmetrical damper.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.Examples.</b></td></tr>
// <tr><td valign=\"top\"> SMEE_Gen </td>
//           <td valign=\"top\"> Test example 7: ElectricalExcitedSynchronousInductionMachine
//                    as Generator</td> </tr>
// <tr><td valign=\"top\"> Utilities.TerminalBox</td>
//           <td valign=\"top\"> Terminal box for three-phase induction machines to choose
//                    either star (wye) ? or delta ? connection</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Math.Matrices.</b></td></tr>
// <tr><td valign=\"top\"> equalityLeastSquares</td>
//           <td valign=\"top\"> Solve a linear equality constrained least squares problem:<br>
//                   min|A*x-a|^2 subject to B*x=b</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\"> Parts.PointMass</td>
//           <td valign=\"top\"> Point mass, i.e., body where inertia tensor is neglected.</td> </tr>
// <tr><td valign=\"top\"> Interfaces.FlangeWithBearing</td>
//           <td valign=\"top\"> Connector consisting of 1-dim. rotational flange and its
//                    3-dim. bearing frame.</td> </tr>
// <tr><td valign=\"top\"> Interfaces.FlangeWithBearingAdaptor</td>
//           <td valign=\"top\"> Adaptor to allow direct connections to the sub-connectors
//                    of FlangeWithBearing.</td> </tr>
// <tr><td valign=\"top\"> Types.SpecularCoefficient</td>
//           <td valign=\"top\"> New type to define a specular coefficient.</td> </tr>
// <tr><td valign=\"top\"> Types.ShapeExtra</td>
//           <td valign=\"top\"> New type to define the extra data for visual shape objects and to
//                    have a central place for the documentation of this data.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Examples.Elementary</b></td></tr>
// <tr><td valign=\"top\"> PointGravityWithPointMasses</td>
//           <td valign=\"top\"> Example of two point masses in a central gravity field.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\">UsersGuide</td>
//           <td valign=\"top\"> A User's Guide has been added by using the documentation previously
//                    present in the package documentation of Rotational.</td> </tr>
// <tr><td valign=\"top\">Sensors.PowerSensor</td>
//           <td valign=\"top\"> New component to measure the energy flow between two connectors
//                    of the Rotational library.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.</b></td></tr>
// <tr><td valign=\"top\">Speed</td>
//           <td valign=\"top\"> New component to move a translational flange
//                    according to a reference speed</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Media.Interfaces.PartialMedium.</b></td></tr>
// <tr><td valign=\"top\">specificEnthalpy_pTX</td>
//           <td valign=\"top\"> New function to compute specific enthalpy from pressure, temperature
//                    and mass fractions.</td> </tr>
// <tr><td valign=\"top\">temperature_phX</td>
//           <td valign=\"top\"> New function to compute temperature from pressure, specific enthalpy,
//                    and mass fractions.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
// <tr><td valign=\"top\"> SignalBus</td>
//           <td valign=\"top\"> Icon for signal bus</td> </tr>
// <tr><td valign=\"top\"> SignalSubBus</td>
//           <td valign=\"top\"> Icon for signal sub-bus</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
// <tr><td valign=\"top\">UsersGuide</td>
//           <td valign=\"top\"> A User's Guide has been added that describes unit handling.</td> </tr>
// <tr><td valign=\"top\"> Resistance<br>
//                    Conductance</td>
//           <td valign=\"top\"> Attribute 'min=0' removed from these types.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.</b></td></tr>
// <tr><td valign=\"top\"> Components.Valve</td>
//           <td valign=\"top\"> Simple controlled valve with either linear or
//                    exponential characteristic.</td> </tr>
// <tr><td valign=\"top\"> Sources. IdealPump </td>
//           <td valign=\"top\"> Simple ideal pump (resp. fan)  dependent on the shaft?s speed;
//                    pressure increase versus volume flow is defined as a linear
//                    function. Torque * Speed = Pressure invrease * Volume flow
//                    (without losses).</td> </tr>
// <tr><td valign=\"top\"> Examples.PumpAndValve </td>
//           <td valign=\"top\"> Test example for valves.</td> </tr>
// <tr><td valign=\"top\"> Examples.PumpDropOut </td>
//           <td valign=\"top\"> Drop out of 1 pump to test behavior of semiLinear.</td> </tr>
// <tr><td valign=\"top\"> Examples.ParallelPumpDropOut </td>
//           <td valign=\"top\"> Drop out of 2 parallel pumps to test behavior of semiLinear.</td> </tr>
// <tr><td valign=\"top\"> Examples.OneMass </td>
//           <td valign=\"top\"> Cooling of 1 hot mass to test behavior of semiLinear.</td> </tr>
// <tr><td valign=\"top\"> Examples.TwoMass </td>
//           <td valign=\"top\"> Cooling of 2 hot masses to test behavior of semiLinear.</td> </tr>
// </table>
//
// <p>
// The following <b>components</b> have been improved:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
// <tr><td valign=\"top\"> UsersGuide</td>
//           <td valign=\"top\"> User's Guide and package description of Modelica Standard Library improved.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Interfaces.</b></td></tr>
// <tr><td valign=\"top\"> RealInput<br>
//                    BooleanInput<br>
//                    IntegerInput</td>
//           <td valign=\"top\"> When dragging one of these connectors the width and height
//                    is a factor of 2 larger as a standard icon. Previously,
//                    these connectors have been dragged and then manually enlarged
//                    by a factor of 2 in the Modelica standard library.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Blocks.</b></td></tr>
// <tr><td valign=\"top\"> Continuous.*</td>
//           <td valign=\"top\"> Initialization options added to all blocks
//                    (NoInit, SteadyState, InitialState, InitialOutput).
//                    New parameter limitsAtInit to switch off the limits
//                    of LimIntegrator or LimPID during initialization</td> </tr>
// <tr><td valign=\"top\"> Continuous.LimPID</td>
//           <td valign=\"top\"> Option to select P, PI, PD, PID controller.
//                    Documentation significantly improved.</td> </tr>
// <tr><td valign=\"top\"> Nonlinear.Limiter<br>
//                    Nonlinear.VariableLimiter<br>
//                    Nonlinear.Deadzone</td>
//           <td valign=\"top\"> New parameter limitsAtInit/deadZoneAtInit to switch off the limits
//                    or the dead zone during initialization</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog. </b></td></tr>
// <tr><td valign=\"top\"> Sources</td>
//           <td valign=\"top\"> Icon improved (+/- added to voltage sources, arrow added to
//                    current sources).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors. </b></td></tr>
// <tr><td valign=\"top\"> Diode</td>
//           <td valign=\"top\"> smooth() operator included to improve numerics.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.SynchronousInductionMachines. </b></td></tr>
// <tr><td valign=\"top\"> SM_PermanentMagnetDamperCage<br>
//                    SM_ElectricalExcitedDamperCage<br>
//                    SM_ReluctanceRotorDamperCage</td>
//           <td valign=\"top\"> The user can choose \"DamperCage = false\" (default: true)
//                    to remove all equations for the damper cage from the model.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Machines.BasicMachines.AsynchronousInductionMachines. </b></td></tr>
// <tr><td valign=\"top\"> AIM_SlipRing</td>
//           <td valign=\"top\"> Easier parameterization: if the user selects \"useTrunsRatio = false\"
//                    (default: true, this is the same behavior as before),
//                         parameter TurnsRatio is calculated internally from
//                         Nominal stator voltage and Locked-rotor voltage.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Math.Matrices.</b></td></tr>
// <tr><td valign=\"top\">leastSquares</td>
//           <td valign=\"top\">The A matrix in the least squares problem might be rank deficient.
//                   Previously, it was required that A has full rank.</td>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\">all models</td>
//           <td valign=\"top\"> <ul>
//                    <li> All components with animation information have a new variable
//                                 <b>specularCoefficient</b> to define the reflection of ambient light.
//                                 The default value is world.defaultSpecularCoefficient which has
//                                 a default of 0.7. By changing world.defaultSpecularCoefficient, the
//                                 specularCoefficient of all components is changed that are not
//                                 explicitly set differently. Since specularCoefficient is a variable
//                                 (and no parameter), it can be changed during simulation. Since
//                                 annotation(Dialog) is set, this variable still appears in the
//                                 parameter menus.<br>
//                                 Previously, a constant specularCoefficient of 0.7 was used
//                                 for all components.</li>
//                    <li> Variable <b>color</b> of all components is no longer a parameter
//                                 but an input variable. Also all parameters in package <b>Visualizers</b>,
//                                 with the exception of <b>shapeType</b> are no longer parameters but
//                                 defined as input variables with annotation(Dialog). As a result,
//                                 all these variables appear still in parameter menus, but they can
//                                 be changed during simulation (e.g., color might be used to
//                                 display the temperature of a part).</li>
//                    <li> All menus have been changed to follow the Modelica 2.2 annotations
//                                 \"Dialog, group, tab, enable\" (previously, a non-standard Dymola
//                                 definition for menus was used). Also, the \"enable\" annotation
//                                 is used in all menus
//                                 to disable input fields if the input would be ignored.</li>
//                    <li> All visual shapes are now defined with conditional declarations
//                                 (to remove them, if animation is switched off). Previously,
//                                 these (protected) objects have been defined by arrays with
//                                 dimension 0 or 1.</li>
//                    </ul></td></tr>
//
// <tr><td valign=\"top\">Frames.resolveRelative</td>
//           <td valign=\"top\"> The derivative of this function added as function and defined via
//                    an annotation. In certain situations, tools had previously
//                    difficulties to differentiate the inlined function automatically.</td>
//
//
// <tr><td valign=\"top\">Forces.*</td>
//           <td valign=\"top\"> The scaling factors N_to_m and Nm_to_m have no longer a default
//                    value of 1000 but a default value of world.defaultN_to_m (=1000)
//                    and world.defaultNm_to_m (=1000). This allows to change the
//                    scaling factors for all forces and torques in the world
//                    object.</td>
// <tr><td valign=\"top\">Interfaces.Frame.a<br>
//                   Interfaces.Frame.b<br>
//                   Interfaces.Frame_resolve</td>
//           <td valign=\"top\"> The Frame connectors are now centered around the origin to ease
//                    the usage. The shape was changed, such that the icon is a factor
//                    of 1.6 larger as a standard icon (previously, the icon had a
//                    standard size when dragged and then the icon was manually enlarged
//                    by a factor of 1.5 in the y-direction in the MultiBody library;
//                    the height of 16 allows easy positioning on the standard grid size of 2).
//                    The double line width of the border in icon and diagram layer was changed
//                    to a single line width and when making a connection the connection
//                    line is dark grey and no longer black which looks better.</td>
// <tr><td valign=\"top\">Joints.Assemblies.*</td>
//           <td valign=\"top\"> When dragging an assembly joint, the icon is a factor of 2
//                    larger as a standard icon. Icon texts and connectors have a
//                    standard size in this enlarged icon (and are not a factor of 2
//                    larger as previously). </td>
// <tr><td valign=\"top\">Types.*</td>
//           <td valign=\"top\"> All types have a corresponding icon now to visualize the content
//                    in the package browser (previously, the types did not have an icon).</td>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\"> Inertia</td>
//           <td valign=\"top\"> Initialization and state selection added.</td> </tr>
// <tr><td valign=\"top\"> SpringDamper</td>
//           <td valign=\"top\"> Initialization and state selection added.</td> </tr>
// <tr><td valign=\"top\"> Move</td>
//           <td valign=\"top\"> New implementation based solely on Modelica 2.2 language
//                    (previously, the Dymola specific constrain(..) function was used).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Translational.</b></td></tr>
// <tr><td valign=\"top\"> Move</td>
//           <td valign=\"top\"> New implementation based solely on Modelica 2.2 language
//                    (previously, the Dymola specific constrain(..) function was used).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.Interfaces.Partials.</b></td></tr>
// <tr><td valign=\"top\"> SimpleFriction</td>
//           <td valign=\"top\"> Calculates friction losses from pressure drop and volume flow.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Thermal.FluidHeatFlow.Components.</b></td></tr>
// <tr><td valign=\"top\"> IsolatedPipe <br>
//                    HeatedPipe</td>
//           <td valign=\"top\"> Added geodetic height as a source of pressure change;
//                    feeds friction losses as calculated by simple friction to
//                    the energy balance of the medium.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Media.Interfaces.PartialMedium.FluidConstants.</b></td></tr>
// <tr><td valign=\"top\">HCRIT0</td><td valign=\"top\">Critical specifc enthalpy of the fundamental
//                   equation (base formulation of the fluid medium model). </td></tr>
// <tr><td valign=\"top\">SCRIT0</td><td valign=\"top\">Critical specifc entropy of the fundamental
//                   equation (base formulation of the fluid medium model). </td></tr>
// <tr><td valign=\"top\">deltah</td><td valign=\"top\">Enthalpy offset (default: 0) between the
//                   specific enthalpy of the fluid model and the user-visible
//                   specific enthalpy in the model: deltah = h_model - h_fundamentalEquation.
// </td></tr>
// <tr><td valign=\"top\">deltas</td><td valign=\"top\">Entropy offset (default: 0) between the
//                   specific entropy of the fluid model and the user-visible
//                   specific entropy in the model: deltas = s_model - s_fundamentalEquation.</td></tr>
// <tr><td valign=\"top\">T_default</td><td valign=\"top\">Default value for temperature of medium (for initialization)</td></tr>
// <tr><td valign=\"top\">h_default</td><td valign=\"top\">Default value for specific enthalpy of medium (for initialization)</td></tr>
// <tr><td valign=\"top\">p_default</td><td valign=\"top\">Default value for pressure of medium (for initialization)</td></tr>
// <tr><td valign=\"top\">X_default</td><td valign=\"top\">Default value for mass fractions of medium (for initialization)</td></tr>
// </table>
// <p>
// The following <b>errors</b> have been fixed:
// </p>
//
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Tables.</b></td></tr>
// <tr><td valign=\"top\">CombiTable1D<br>
//                   CombiTable1Ds<br>
//                   CombiTable2D</td>
//           <td valign=\"top\"> Parameter \"tableOnFile\" determines now whether a table is read from
//                    file or used from parameter \"table\". Previously, if \"fileName\" was not
//                    \"NoName\", a table was always read from file \"fileName\", independently
//                    of the setting of \"tableOnFile\". This has been corrected.<br>
//                    Furthermore, the initialization of a table is now performed in a
//                    when-clause and no longer in a parameter declaration, because some
//                    tools evaluate the parameter declaration in some situation more than
//                    once and then the table is unnecessarily read several times
//                    (and occupies also more memory).</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
// <tr><td valign=\"top\">CombiTimeTable</td>
//           <td valign=\"top\"> Same bug fix/improvement as for the tables from Modelica.Blocks.Tables
//                    as outlined above.</td> </tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors. </b></td></tr>
// <tr><td valign=\"top\"> PMOS<br>
//                    NMOS<br>
//                    HeatingPMOS<br>
//                    HeatingNMOS</td>
//           <td valign=\"top\"> The Drain-Source-Resistance RDS had actually a resistance of
//                    RDS/v, with v=Beta*(W+dW)/(L+dL). The correct formula is without
//                    the divison by \"v\". This has now been corrected.<br>
//                    This bug fix should not have an essential effect in most applications.
//                    In the default case (Beta=1e-5), the Drain-Source-Resistance was
//                    a factor of 1e5 too large and had in the default case the
//                    wrong value 1e12, although it should have the value 1e7. The effect
//                    was that this resistance had practically no effect.</td> </tr>
//
// <tr><td colspan=\"2\"> <b>Modelica.Media.IdealGases.Common.SingleGasNasa.</b></td></tr>
// <tr><td valign=\"top\"> dynamicViscosityLowPressure</td>
//           <td valign=\"top\"> Viscosity and thermal conductivity (which needs viscosity as input)
//                    were computed wrong for polar gases and gas mixtures
//                    (i.e. if dipole moment not 0.0). This has been fixed in version 2.2.1.</td> </tr>
// <tr><td colspan=\"2\"><b>Modelica.Utilities.Streams.</b></td></tr>
// <tr><td valign=\"top\">readLine</td>
//           <td valign=\"top\"> Depending on the C-implementation, the stream was not correctly closed.
//                    This has been corrected by adding a \"Streams.close(..)\"
//                    after reading the file content.</td> </tr>
//
// </table>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_2)
// {"<html>
//
// <p>
// Version 2.2 is backward compatible to version 2.1.
// </p>
// The following <b>new libraries</b> have been added:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Media\">Modelica.Media</a></td>
//           <td valign=\"top\"> Property models of liquids and gases, especially
//                    <ul>
//                    <li>1241 detailed gas models,</li>
//                    <li> moist air,</li>
//                    <li> high precision water model (according to IAPWS/IF97 standard), </li>
//                    <li> incompressible media defined by tables (cp(T), rho(t), eta(T), etc. are defined by tables).</li>
//                    </ul>
//                    The user can conveniently define mixtures of gases between the
//                    1241 gas models. The models are
//                    designed to work well in dynamic simulations. They
//                    are based on a new standard interface for media with
//                    single and multiple substances and one or multiple phases
//                    with the following features:
//                    <ul>
//                    <li> The independent variables of a medium model do not influence the
//                                 definition of a fluid connector port or how the
//                                 balance equations have to be implemented.<br>
//                                 Used independent variables: \"p,T\", \"p,T,X\", \"p,h\", \"d,T\".</li>
//                    <li> Optional variables, e.g., dynamic viscosity, are only computed
//                                 if needed.<li>
//                    <li> The medium models are implemented with regards to efficient
//                                 dynamic simulation.</li>
//                    </ul>
//           </td><tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Thermal.FluidHeatFlow\">Modelica.Thermal.FluidHeatFlow</a></td>
//           <td valign=\"top\"> Simple components for 1-dim., incompressible thermo-fluid flow
//                    to model coolant flows, e.g., of electrical machines.
//                    Components can be connected arbitrarily together (= ideal mixing
//                    at connection points) and fluid may reverse direction of flow.
// </td><tr>
// </table>
// <p>
// The following <b>changes</b> have been performed in the
// <b>Modelica.Mechanics.MultiBody</b> library:
// </p>
// <ul>
// <li> Component MultiBody.World has a new parameter
//          <b>driveTrainMechanics3D</b>. If set to <b>true</b>, 3D mechanical effects
//          of MultiBody.Parts.Mounting1D/Rotor1D/BevelGear1D are taken into account. If set to
//          <b>false</b> (= default), 3D mechanical effects in these elements
//          are not taken into account and the
//          frame connectors to connect to 3D parts are disabled (all
//          connections to such a disabled connector are also disabled, due to the
//          new feature of conditional declarations in Modelica language 2.2)</li>
// <li> All references to \"MultiBody.xxx\" have
//          been changed to \"Modelica.Mechanics.MultiBodys.xxx\" in order that after
//          copying of a component outside of the Modelica library, the references
//          still remain valid.</li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_2_1)
// {"<html>
//
// <p> This is a major change with respect to previous versions of the
//         Modelica Standard Library, because <b>many new libraries</b> and components
//         are included and because the input/output blocks (Modelica.Blocks)
//         have been considerably simplified:
// </p>
// <ul>
// <li> An input/output connector is defined <b>without</b> a hierarchy (this is possible
//          due to new features of the Modelica language). For example, the input
//          signal of a block \"FirstOrder\" was previously accessed as \"FirstOrder.inPort.signal[1]\".
//          Now it is accessed as \"FirstOrder.u\". This simplifies the understanding and usage
//          especially for beginners.</li>
// <li> De-vectorized the <b>Modelica.Blocks</b> library. All blocks in the
//          Modelica.Blocks library are now scalar blocks. As a result,
//          the parameters of the Blocks are scalars and no vectors any
//          more. For example, a parameter \"amplitude\" that might had
//          a value of \"{1}\" previously, has now a value of \"1\". This simplifies
//          the understanding and usage especially for beginners.<br>
//          If a vector of blocks is needed, this can be easily
//          accomplished by adding a dimension to the instance. For example
//          \"Constant const[3](k={1,2,3}\" defines three Constant blocks.
//          An additional advantage of the new approach is that
//          the implementation of Modelica.Blocks is much simpler and is easier to
//          understand.
// </li>
// </ul>
//
// <p>
// The discussed changes of Modelica.Blocks are not backward compatible.
// A script to <b>automatically</b> convert models to this new version is
// provided. There might be rare cases, where this script does not convert.
// In this case models have to be manually converted.
// In any case you should make a back-up copy of your model
// before automatic conversion is performed.
// </p>
// <p>
// The following <b>new libraries</b> have been added:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Digital\">Modelica.Electrical.Digital</a></td>
//           <td valign=\"top\">Digital electrical components based on 2-,3-,4-, and 9-valued logic<br>
//                   according to the VHDL standard</td><tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Electrical.Machines\">Modelica.Electrical.Machines</a></td>
//           <td valign=\"top\">Asynchronous, synchronous and DC motor and generator models</td><tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a></td>
//           <td valign=\"top\">Functions operatinng on matrices such as solve() (A*x=b), leastSquares(),<br>
//                   norm(), LU(), QR(),  eigenValues(), singularValues(), exp(), ...</td><tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.StateGraph\">Modelica.StateGraph</a></td>
//           <td valign=\"top\"> Modeling of <b>discrete event</b> and <b>reactive</b> systems in a convenient way using<br>
//                    <b>hierarchical state machines</b> and <b>Modelica</b> as <b>action language</b>. <br>
//                    It is based on JGraphChart and Grafcet and  has a similar modeling power as <br>
//                    StateCharts. It avoids deficiences of usually used action languages. <br>
//                    This library makes the ModelicaAdditions.PetriNets library obsolet.</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Utilities.Files\">Modelica.Utilities.Files</a></td>
//           <td valign=\"top\">Functions to operate on files and directories (copy, move, remove files etc.)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Utilities.Streams\">Modelica.Utilities.Streams</a></td>
//           <td valign=\"top\">Read from files and write to files (print, readLine, readFile, error, ...)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Utilities.Strings\">Modelica.Utilities.Strings</a></td>
//           <td valign=\"top\">Operations on strings (substring, find, replace, sort, scanToken, ...)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Utilities.System\">Modelica.Utilities.System</a></td>
//           <td valign=\"top\">Get/set current directory, get/set environment variable, execute shell command, etc.</td></tr>
// </table>
// <p>
// The following existing libraries outside of the Modelica standard library
// have been improved and added as <b>new libraries</b>
// (models using the previous libraries are automatically converted
// to the new sublibraries inside package Modelica):
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Discrete\">Modelica.Blocks.Discrete</a></td>
//           <td valign=\"top\"> Discrete input/output blocks with fixed sample period<br>
//                    (from ModelicaAdditions.Blocks.Discrete)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Logical\">Modelica.Blocks.Logical</a></td>
//           <td valign=\"top\"> Logical components with Boolean input and output signals<br>
//                    (from ModelicaAdditions.Blocks.Logical)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Nonlinear\">Modelica.Blocks.Nonlinear</a></td>
//           <td valign=\"top\"> Discontinuous or non-differentiable algebraic control blocks such as variable limiter,<br>
//                    fixed, variable and Pade delay etc. (from ModelicaAdditions.Blocks.Nonlinear)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Routing\">Modelica.Blocks.Routing</a></td>
//           <td valign=\"top\"> Blocks to combine and extract signals, such as multiplexer<br>
//                    (from ModelicaAdditions.Blocks.Multiplexer)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Blocks.Tables\">Modelica.Blocks.Tables</a></td>
//           <td valign=\"top\"> One and two-dimensional interpolation in tables. CombiTimeTable is available<br>
//                    in Modelica.Blocks.Sources (from ModelicaAdditions.Tables)</td></tr>
// <tr><td valign=\"top\"><a href=\"Modelica://Modelica.Mechanics.MultiBody\">Modelica.Mechanics.MultiBody</a></td>
//           <td valign=\"top\"> Components to model the movement of 3-dimensional mechanical systems. Contains <br>
//                    body, joint, force and sensor components, analytic handling of kinematic loops,<br>
//                    force elements with mass, series/parallel connection of 3D force elements etc.<br>
//                    (from MultiBody 1.0 where the new signal connectors are used;<br>
//                    makes the ModelicaAdditions.MultiBody library obsolet)</td></tr>
// </table>
// <p>
// As a result, the ModelicaAdditions library is obsolet, because all components
// are either included in the Modelica library or are replaced by much more
// powerful libraries (MultiBody, StateGraph).
// </p>
// <p>
// The following <b>new components</b> have been added to <b>existing</b> libraries.
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Logical.</b></td></tr>
// <tr><td valign=\"top\">Pre</td>
//           <td valign=\"top\">y = pre(u): Breaks algebraic loops by an infinitesimal small <br>
//                   time delay (event iteration continues until u = pre(u))</td></tr>
// <tr><td valign=\"top\">Edge</td>
//           <td valign=\"top\">y = edge(u): Output y is true, if the input u has a rising edge </td></tr>
// <tr><td valign=\"top\">FallingEdge</td>
//           <td valign=\"top\">y = edge(not u): Output y is true, if the input u has a falling edge </td></tr>
// <tr><td valign=\"top\">Change</td>
//           <td valign=\"top\">y = change(u): Output y is true, if the input u has a rising or falling edge </td></tr>
// <tr><td valign=\"top\">GreaterEqual</td>
//           <td valign=\"top\">Output y is true, if input u1 is greater or equal as input u2 </td></tr>
// <tr><td valign=\"top\">Less</td>
//           <td valign=\"top\">Output y is true, if input u1 is less as input u2 </td></tr>
// <tr><td valign=\"top\">LessEqual</td>
//           <td valign=\"top\">Output y is true, if input u1 is less or equal as input u2 </td></tr>
// <tr><td valign=\"top\">Timer</td>
//           <td valign=\"top\">Timer measuring the time from the time instant where the <br>
//                   Boolean input became true </td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\">BooleanToReal</td>
//           <td valign=\"top\">Convert Boolean to Real signal</td></tr>
// <tr><td valign=\"top\">BooleanToInteger</td>
//           <td valign=\"top\">Convert Boolean to Integer signal</td></tr>
// <tr><td valign=\"top\">RealToBoolean</td>
//           <td valign=\"top\">Convert Real to Boolean signal</td></tr>
// <tr><td valign=\"top\">IntegerToBoolean</td>
//           <td valign=\"top\">Convert Integer to Boolean signal</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
// <tr><td valign=\"top\">RealExpression</td>
//           <td valign=\"top\">Set output signal to a time varying Real expression</td></tr>
// <tr><td valign=\"top\">IntegerExpression</td>
//           <td valign=\"top\">Set output signal to a time varying Integer expression</td></tr>
// <tr><td valign=\"top\">BooleanExpression</td>
//           <td valign=\"top\">Set output signal to a time varying Boolean expression</td></tr>
// <tr><td valign=\"top\">BooleanTable</td>
//           <td valign=\"top\">Generate a Boolean output signal based on a vector of time instants</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.</b></td></tr>
// <tr><td valign=\"top\">Frames.from_T2</td>
//           <td valign=\"top\">Return orientation object R from transformation matrix T and its derivative der(T)</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\">LinearSpeedDependentTorque</td>
//           <td valign=\"top\">Linear dependency of torque versus speed (acts as load torque)</td></tr>
// <tr><td valign=\"top\">QuadraticSpeedDependentTorque</td>
//           <td valign=\"top\">Quadratic dependency of torque versus speed (acts as load torque)</td></tr>
// <tr><td valign=\"top\">ConstantTorque</td>
//           <td valign=\"top\">Constant torque, not dependent on speed (acts as load torque)</td></tr>
// <tr><td valign=\"top\">ConstantSpeed</td>
//           <td valign=\"top\">Constant speed, not dependent on torque (acts as load torque)</td></tr>
// <tr><td valign=\"top\">TorqueStep</td>
//           <td valign=\"top\">Constant torque, not dependent on speed (acts as load torque)</td></tr>
// </table>
// <p>
// The following <b>bugs</b> have been <b>corrected</b>:
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.MultiBody.Forces.</b></td></tr>
// <tr><td valign=\"top\">LineForceWithMass<br>
//                   Spring</td>
//           <td valign=\"top\">If mass of the line force or spring component is not zero, the<br>
//                   mass was (implicitly) treated as \"mass*mass\" instead of as \"mass\"</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\">Speed</td>
//           <td valign=\"top\">If parameter exact=<b>false</b>, the filter was wrong<br>
//                   (position was filtered and not the speed input signal)</td></tr>
// </table>
// <p>
// Other changes:
// </p>
// <ul>
// <li> All connectors are now smaller in the diagram layer. This gives
//          a nicer layout when connectors and components are used together
//          in a diagram</li>
// <li> Default instance names are defined for all connectors, according
//          to a new annotation introduced in Modelica 2.1. For example,
//          when dragging connector \"Flange_a\" from the Rotational library to
//          the diagram layer, the default connector instance name is
//          \"flange_a\" and not \"Flange_a1\".</li>
// <li> The Modelica.Mechanics.Rotational connectors are changed from
//          a square to a circle</li>
// <li> The Modelica.Mechanics.Translational connectors are changed from a
//          green to a dark green color in order that connection lines
//          can be better seen, especially when printed.</li>
// <li> The Modelica.Blocks connectors for Real signals are changed from
//          blue to dark blue in order to distinguish them from electrical signals.</li>
// </ul>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_6)
// {"<html>
//
// <p> Added 1 new library (Electrical.MultiPhase), 17 new components,
//         improved 3 existing components
//         in the Modelica.Electrical library and improved 3 types
//         in the Modelica.SIunits library. Furthermore,
//         this User's Guide has been started. The improvements
//         in more detail:
// </p>
// <p>
// <b>New components</b>
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\">SaturatingInductor</td>
//           <td valign=\"top\">Simple model of an inductor with saturation</td></tr>
// <tr><td valign=\"top\">VariableResistor</td>
//           <td valign=\"top\">Ideal linear electrical resistor with variable resistance</td></tr>
// <tr><td valign=\"top\">VariableConductor</td>
//           <td valign=\"top\">Ideal linear electrical conductor with variable conductance</td></tr>
// <tr><td valign=\"top\">VariableCapacitor</td>
//           <td valign=\"top\">Ideal linear electrical capacitor with variable capacitance</td></tr>
// <tr><td valign=\"top\">VariableInductor</td>
//           <td valign=\"top\">Ideal linear electrical inductor with variable inductance</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Semiconductors.</b></td></tr>
// <tr><td valign=\"top\">HeadingDiode</td>
//           <td valign=\"top\">Simple diode with heating port</td></tr>
// <tr><td valign=\"top\">HeadingNMOS</td>
//           <td valign=\"top\">Simple MOS Transistor with heating port</td></tr>
// <tr><td valign=\"top\">HeadingPMOS</td>
//           <td valign=\"top\">Simple PMOS Transistor with heating port</td></tr>
// <tr><td valign=\"top\">HeadingNPN</td>
//           <td valign=\"top\">Simple NPN BJT according to Ebers-Moll with heating port</td></tr>
// <tr><td valign=\"top\">HeadingPNP</td>
//           <td valign=\"top\">Simple PNP BJT according to Ebers-Moll with heating port</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.MultiPhase</b><br>
//           A new library for multi-phase electrical circuits</td></tr>
// </table>
// <p>
// <b>New examples</b>
// </p>
// <p>
// The following new examples have been added to
// Modelica.Electrical.Analog.Examples:
// </p>
// <p>
// CharacteristicThyristors,
// CharacteristicIdealDiodes,
// HeatingNPN_OrGate,
// HeatingMOSInverter,
// HeatingRectifier,
// Rectifier,
// ShowSaturatingInductor
// ShowVariableResistor
// </p>
// <p>
// <b>Improved existing components</b>
// </p>
// <p>In the library Modelica.Electrical.Analog.Ideal,
// a knee voltage has been introduced for the components
// IdealThyristor, IdealGTOThyristor, IdealDiode in order
// that the approximation of these ideal elements is improved
// with not much computational effort.</p>
// <p> In the Modelica.SIunits library, the following changes
//         have been made:</p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\">Inductance</td>
//           <td valign=\"top\">min=0 removed</td></tr>
// <tr><td valign=\"top\">SelfInductance</td>
//           <td valign=\"top\">min=0 added</td></tr>
// <tr><td valign=\"top\">ThermodynamicTemperature</td>
//           <td valign=\"top\">min=0 added</td></tr>
// </table>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_5)
// {"<html>
//
// <p> Added 55 new components. In particular, added new package
//         <b>Thermal.HeatTransfer</b> for modeling of lumped
//         heat transfer, added model <b>LossyGear</b> in Mechanics.Rotational
//         to model gear efficiency and bearing friction according to a new
//         theory in a robust way, added 10 new models in Electrical.Analog and
//         added several other new models and improved existing models.
// </p>
// <p>
// <b>New components</b>
// </p>
// <table border=\"1\" cellspacing=0 cellpadding=2>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.</b></td></tr>
// <tr><td valign=\"top\">Continuous.Der</td><td valign=\"top\">Derivative of input (= analytic differentations)</td></tr>
// <tr><td valign=\"top\"><b><i>Examples</i></b></td><td valign=\"top\">Demonstration examples of the components of this package</td></tr>
// <tr><td valign=\"top\">Nonlinear.VariableLimiter</td><td valign=\"top\">Limit the range of a signal with variable limits</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Interfaces.</b></td></tr>
// <tr><td valign=\"top\">RealPort</td><td valign=\"top\">Real port (both input/output possible)</td></tr>
// <tr><td valign=\"top\">IntegerPort</td><td valign=\"top\">Integer port (both input/output possible)</td></tr>
// <tr><td valign=\"top\">BooleanPort</td><td valign=\"top\">Boolean port (both input/output possible)</td></tr>
// <tr><td valign=\"top\">SIMO</td><td valign=\"top\">Single Input Multiple Output continuous control block</td></tr>
// <tr><td valign=\"top\">IntegerBlockIcon</td><td valign=\"top\">Basic graphical layout of Integer block</td></tr>
// <tr><td valign=\"top\">IntegerMO</td><td valign=\"top\">Multiple Integer Output continuous control block</td></tr>
// <tr><td valign=\"top\">IntegerSignalSource</td><td valign=\"top\">Base class for continuous Integer signal source</td></tr>
// <tr><td valign=\"top\">IntegerMIBooleanMOs</td><td valign=\"top\">Multiple Integer Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
// <tr><td valign=\"top\">BooleanMIMOs</td><td valign=\"top\">Multiple Input Multiple Output continuous control block with same number of inputs and outputs of boolean type</td></tr>
// <tr><td valign=\"top\"><b><i>BusAdaptors</i></b></td><td valign=\"top\">Components to send signals to the bus or receive signals from the bus</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Math.</b></td></tr>
// <tr><td valign=\"top\">RealToInteger</td><td valign=\"top\">Convert real to integer signals</td></tr>
// <tr><td valign=\"top\">IntegerToReal</td><td valign=\"top\">Convert integer to real signals</td></tr>
// <tr><td valign=\"top\">Max</td><td valign=\"top\">Pass through the largest signal</td></tr>
// <tr><td valign=\"top\">Min</td><td valign=\"top\">Pass through the smallest signal</td></tr>
// <tr><td valign=\"top\">Edge</td><td valign=\"top\">Indicates rising edge of boolean signal</td></tr>
// <tr><td valign=\"top\">BooleanChange</td><td valign=\"top\">Indicates boolean signal changing</td></tr>
// <tr><td valign=\"top\">IntegerChange</td><td valign=\"top\">Indicates integer signal changing</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Blocks.Sources.</b></td></tr>
// <tr><td valign=\"top\">IntegerConstant</td><td valign=\"top\">Generate constant signals of type Integer</td></tr>
// <tr><td valign=\"top\">IntegerStep</td><td valign=\"top\">Generate step signals of type Integer</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Basic.</b></td></tr>
// <tr><td valign=\"top\">HeatingResistor</td><td valign=\"top\">Temperature dependent electrical resistor</td></tr>
// <tr><td valign=\"top\">OpAmp</td><td valign=\"top\">Simple nonideal model of an OpAmp with limitation</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Ideal.</b></td></tr>
// <tr><td valign=\"top\">IdealCommutingSwitch</td><td valign=\"top\">Ideal commuting switch</td></tr>
// <tr><td valign=\"top\">IdealIntermediateSwitch</td><td valign=\"top\">Ideal intermediate switch</td></tr>
// <tr><td valign=\"top\">ControlledIdealCommutingSwitch</td><td valign=\"top\">Controlled ideal commuting switch</td></tr>
// <tr><td valign=\"top\">ControlledIdealIntermediateSwitch</td><td valign=\"top\">Controlled ideal intermediate switch</td></tr>
// <tr><td valign=\"top\">IdealOpAmpLimited</td><td valign=\"top\">Ideal operational amplifier with limitation</td></tr>
// <tr><td valign=\"top\">IdealOpeningSwitch</td><td valign=\"top\">Ideal opener</td></tr>
// <tr><td valign=\"top\">IdealClosingSwitch</td><td valign=\"top\">Ideal closer</td></tr>
// <tr><td valign=\"top\">ControlledIdealOpeningSwitch</td><td valign=\"top\">Controlled ideal opener</td></tr>
// <tr><td valign=\"top\">ControlledIdealClosingSwitch</td><td valign=\"top\">Controlled ideal closer</td></tr>
//
// <tr><td colspan=\"2\"><b>Modelica.Electrical.Analog.Lines.</b></td></tr>
// <tr><td valign=\"top\">TLine1</td><td valign=\"top\">Lossless transmission line (Z0, TD)</td></tr>
// <tr><td valign=\"top\">TLine2</td><td valign=\"top\">Lossless transmission line (Z0, F, NL)</td></tr>
// <tr><td valign=\"top\">TLine2</td><td valign=\"top\">Lossless transmission line (Z0, F)</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Icons.</b></td></tr>
// <tr><td valign=\"top\">Function</td><td valign=\"top\">Icon for a function</td></tr>
// <tr><td valign=\"top\">Record</td><td valign=\"top\">Icon for a record</td></tr>
// <tr><td valign=\"top\">Enumeration</td><td valign=\"top\">Icon for an enumeration</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Math.</b></td></tr>
// <tr><td valign=\"top\">tempInterpol2</td><td valign=\"top\">temporary routine for vectorized linear interpolation (will be removed)</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.Mechanics.Rotational.</b></td></tr>
// <tr><td valign=\"top\">Examples.LossyGearDemo1</td><td valign=\"top\">Example to show that gear efficiency may lead to stuck motion</td></tr>
// <tr><td valign=\"top\">Examples.LossyGearDemo2</td><td valign=\"top\">Example to show combination of LossyGear and BearingFriction</td></tr>
// <tr><td valign=\"top\">LossyGear</td><td valign=\"top\">Gear with mesh efficiency and bearing friction (stuck/rolling possible)</td></tr>
// <tr><td valign=\"top\">Gear2</td><td valign=\"top\">Realistic model of a gearbox (based on LossyGear)</td></tr>
// <tr><td colspan=\"2\"><b>Modelica.SIunits.</b></td></tr>
// <tr><td valign=\"top\"><b><i>Conversions</i></b></td><td valign=\"top\">Conversion functions to/from non SI units and type definitions of non SI units</td></tr>
// <tr><td valign=\"top\">EnergyFlowRate</td><td valign=\"top\">Same definition as <i>Power</i></td></tr>
// <tr><td valign=\"top\">EnthalpyFlowRate</td><td valign=\"top\"><tt>Real (final quantity=\"EnthalpyFlowRate\", final unit=\"W\")</tt></td></tr>
// <tr><td colspan=\"2\"><b>Modelica.</b></td></tr>
// <tr><td valign=\"top\"><b><i>Thermal.HeatTransfer</i></b></td><td valign=\"top\">1-dimensional heat transfer with lumped elements</td></tr>
// <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Discrete.</b></td></tr>
// <tr><td valign=\"top\">TriggeredSampler</td><td valign=\"top\">Triggered sampling of continuous signals</td></tr>
// <tr><td valign=\"top\">TriggeredMax</td><td valign=\"top\">Compute maximum, absolute value of continuous signal at trigger instants</td></tr>
// <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.Interfaces.</b></td></tr>
// <tr><td valign=\"top\">BooleanMIRealMOs</td><td valign=\"top\">Multiple Boolean Input Multiple Real Output continuous control block with same number of inputs and outputs</td></tr>
// <tr><td valign=\"top\">RealMIBooleanMOs</td><td valign=\"top\">Multiple Real Input Multiple Boolean Output continuous control block with same number of inputs and outputs</td></tr>
// <tr><td colspan=\"2\"><b>ModelicaAdditions.Blocks.Logical.</b></td></tr>
// <tr><td valign=\"top\">TriggeredTrapezoid</td><td valign=\"top\">Triggered trapezoid generator</td></tr>
// <tr><td valign=\"top\">Hysteresis</td><td valign=\"top\">Transform Real to Boolean with Hysteresis</td></tr>
// <tr><td valign=\"top\">OnOffController</td><td valign=\"top\">On-off controller</td></tr>
// <tr><td valign=\"top\">Compare</td><td valign=\"top\">True, if signal of inPort1 is larger than signal of inPort2</td></tr>
// <tr><td valign=\"top\">ZeroCrossing</td><td valign=\"top\">Trigger zero crossing of input signal</td></tr>
// <tr><td colspan=\"2\"><b>ModelicaAdditions.</b></td></tr>
// <tr><td valign=\"top\">Blocks.Multiplexer.Extractor</td><td valign=\"top\">Extract scalar signal out of signal vector dependent on IntegerRealInput index</td></tr>
// <tr><td valign=\"top\">Tables.CombiTable1Ds</td><td valign=\"top\">Table look-up in one dimension (matrix/file) with only single input</td></tr>
// </table>
// <p>
// <b>Package-specific Changes</b>
// </p>
// <ul>
// <li>All example models made <b>encapsulated</b></li>
// <li>Upper case constants changed to lower case (cf. Modelica.Constants)</li>
// <li>Introduced Modelica.SIunits.Wavelength due to typo \"Wavelenght\"</li>
// <li>Introduced ModelicaAdditions.Blocks.Logical.Interfaces.Comparison due to typo \"Comparision\"</li>
// <li>Changed these components of *.Blocks to <tt>block</tt> class, which have not been already of block type</li>
// <li>Changed *.Interfaces.RelativeSensor to <tt>partial</tt> models</li>
// </ul>
// <p>
// <b>Class-specific Changes</b>
// </p>
// <p>
// <i>Modelica.SIunits</i>
// </p>
// <p>Removed <tt>final</tt> from quantity attribute for <i>Mass</i> and <i>MassFlowRate</i>.</p>
// <p>
// <i>Modelica.Blocks.Math.Sum</i>
// </p>
// <p>Implemented avoiding algorithm section, which would lead to expensive function calls.</p>
// <p><i>Modelica.Blocks.Sources.Step</i></p>
// <pre>
// block Step \"Generate step signals of type Real\"
//         parameter Real height[:]={1} \"Heights of steps\";
// <b> // parameter Real offset[:]={0} \"Offsets of output signals\";
// // parameter SIunits.Time startTime[:]={0} \"Output = offset for time < startTime\";
// // extends Interfaces.MO          (final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));
//         extends Interfaces.SignalSource(final nout=max([size(height, 1); size(offset, 1); size(startTime, 1)]));</b>
// </pre>
// <p><i>Modelica.Blocks.Sources.Exponentials</i></p>
// <p>Replaced usage of built-in function <tt>exp</tt> by Modelica.Math.exp.</p>
// <p><i>Modelica.Blocks.Sources.TimeTable</i></p>
// <p>Interface definition changed from</p>
// <pre>    parameter Real table[:, :]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// <p>to</p>
// <pre>    parameter Real table[:, <b>2</b>]=[0, 0; 1, 1; 2, 4] \"Table matrix (time = first column)\";
// </pre>
// <p>Did the same for subfunction <i>getInterpolationCoefficients</i>.</p>
// <p>Bug in <i>getInterpolationCoefficients</i> for startTime <> 0 fixed:</p>
// <pre>        ...
//                 end if;
//           end if;
//           <b>// Take into account startTime \"a*(time - startTime) + b\"
//           b := b - a*startTime;</b>
//         end getInterpolationCoefficients;
// </pre>
// <p><i>Modelica.Blocks.Sources.BooleanStep</i></p>
// <pre>
// block BooleanStep \"Generate step signals of type Boolean\"
//         parameter SIunits.Time startTime[:]={0} \"Time instants of steps\";
//         <b>parameter Boolean startValue[size(startTime, 1)]=fill(false, size(startTime, 1)) \"Output before startTime\";</b>
//         extends Interfaces.BooleanSignalSource(final nout=size(startTime, 1));
// equation
//         for i in 1:nout loop
// <b>//   outPort.signal[i] = time >= startTime[i];
//           outPort.signal[i] = if time >= startTime[i] then not startValue[i] else startValue[i];</b>
//         end for;
// end BooleanStep;
// </pre>
// <p>
// <i>Modelica.Electrical.Analog</i></p>
// <p>Corrected table of values and default for Beta by dividing them by 1000
// (consistent with the values used in the NAND-example model):
// </p>
// <ul>
// <li>Semiconductors.PMOS</li>
// <li>Semiconductors.NMOS</li>
// </ul>
// <p>Corrected parameter defaults, unit and description for TrapezoidCurrent.
// This makes the parameters consistent with their use in the model.
// Models specifying parameter values are not changed.
// Models not specifying parameter values did not generate trapezoids previously.
// </p>
// <p>Icon layer background changed from transparent to white:</p>
// <ul>
// <li>Basic.Gyrator</li>
// <li>Basic.EMF</li>
// <li>Ideal.Idle</li>
// <li>Ideal.Short</li>
// </ul>
// <p>Basic.Transformer: Replaced invalid escape characters '\\ ' and '\\[newline]' in documentation by '|'.</p>
// <p><i>Modelica.Mechanics.Rotational</i></p>
// <p>Removed arrows and names documentation from flanges in diagram layer</p>
// <p><i>Modelica.Mechanics.Rotational.Interfaces.FrictionBase</i></p>
// <p><i>Modelica.Mechanics.Rotational.Position</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>Modelica.Mechanics.Rotational.RelativeStates</i></p>
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// <p><i>Modelica.Mechanics.Translational.Interfaces.flange_b</i></p>
// <p>Attribute <b>fillColor=7</b> added to Rectangle on Icon layer, i.e. it is now
// filled with white and not transparent any more.</p>
// <p><i>Modelica.Mechanics.Translational.Position</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>Modelica.Mechanics.Translational.RelativeStates</i></p>
// <p>Bug corrected by using modifier <tt>stateSelect = StateSelect.prefer</tt> as implementation</p>
// <p><i>Modelica.Mechanics.Translational.Stop</i></p>
// <p>Use <tt>stateSelect = StateSelect.prefer</tt>.</p>
// <p><i>Modelica.Mechanics.Translational.Examples.PreLoad</i></p>
// <p>Improved documentation and coordinate system used for example.</p>
// <p><i>ModelicaAdditions.Blocks.Nonlinear.PadeDelay</i></p>
// <p>Replaced <tt>reinit</tt> by <tt>initial equation</tt></p>
// <p><i>ModelicaAdditions.HeatFlow1D.Interfaces</i></p>
// <p>Definition of connectors <i>Surface_a</i> and <i>Surface_b</i>:<br>
// <tt>flow SIunits.HeatFlux q;</tt> changed to <tt>flow SIunits.HeatFlowRate q;</tt></p>
// <p><i>MultiBody.Parts.InertialSystem</i></p>
// <p>Icon corrected.</p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ReleaseNotes.Version_1_4)
// {"<html>
//
// <ul>
// <li>Several minor bugs fixed. </li>
// <li>New models:<br>
//         Modelica.Blocks.Interfaces.IntegerRealInput/IntegerRealOutput,<br>
//         Modelica.Blocks.Math.TwoInputs/TwoOutputs<br>
//         Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin,<br>
//         Modelica.Mechanics.Rotational.Move,<br>
//         Modelica.Mechanics.Translational.Move.<br>
//         </li>
// </ul>
// <hr>
// <h4>Version 1.4.1beta1 (February 12, 2001)</h4>
// <p> Adapted to Modelica 1.4</p>
// <hr>
// <h4>Version 1.3.2beta2 (June 20, 2000)</h4>
// <ul>
//         <li>New subpackage Modelica.Mechanics.<b>Translational</b></li>
//         <li>Changes to Modelica.Mechanics.<b>Rotational</b>:<br>
//            New elements:
// <pre>
// IdealGearR2T    Ideal gear transforming rotational in translational motion.
// Position        Forced movement of a flange with a reference angle
//                                    given as input signal
// RelativeStates  Definition of relative state variables
// </pre>
// </li>
//         <li>Changes to Modelica.<b>SIunits</b>:<br>
//           Introduced new types:<br>
//           type Temperature = ThermodynamicTemperature;<br>
//           types DerDensityByEnthalpy, DerDensityByPressure,
//           DerDensityByTemperature, DerEnthalpyByPressure,
//           DerEnergyByDensity, DerEnergyByPressure<br>
//           Attribute \"final\" removed from min and max values
//           in order that these values can still be changed to narrow
//           the allowed range of values.<br>
//           Quantity=\"Stress\" removed from type \"Stress\", in order
//           that a type \"Stress\" can be connected to a type \"Pressure\".</li>
//         <li>Changes to Modelica.<b>Icons</b>:<br>
//            New icons for motors and gearboxes.</li>
//         <li>Changes to Modelica.<b>Blocks.Interfaces</b>:<br>
//            Introduced a replaceable signal type into
//            Blocks.Interfaces.RealInput/RealOutput:
// <pre>
// replaceable type SignalType = Real
// </pre>
//            in order that the type of the signal of an input/output block
//            can be changed to a physical type, for example:
// <pre>
// Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
// </pre>
// </li>
// </ul>
// <hr>
// <h4>Version 1.3.1 (Dec. 13, 1999)</h4>
// <p>
// First official release of the library.
// </p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.ModelicaLicense2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.ModelicaLicense2)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.ModelicaLicense2)
// {"<html>
//
// <p>All files in this directory (Modelica) and in all
// subdirectories, especially all files that build package \"Modelica\" and all
// files in \"Modelica\\C-sources\", \"Modelica\\help\",
// \"Modelica\\Images\" are licensed by the <b><u>Modelica Association</u></b> under the
// <b><u>Modelica License 2</u></b> (with exception of files
// \"Modelica\\C-sources\\win32_dirent.*\").&nbsp;</p>
//
// <p style=\"margin-left: 40px;\"><b>Licensor:</b><br>
// Modelica Association<br>
// (Ideella F&ouml;reningar 822003-8858 in Link&ouml;ping) <br>
// c/o PELAB, IDA, Link&ouml;pings Universitet <br>
// S-58183 Link&ouml;ping <br>
// Sweden<br>
// email: Board@Modelica.org<br>
// web: <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a></p>
//
// <p style=\"margin-left: 40px;\"><b>Copyright notices of the files:</b><br>
// Copyright &copy; 1998-2009,
// ABB, arsenal research, T.&nbsp;B&ouml;drich, DLR, Dynasim, Fraunhofer, Modelon, TU
// Hamburg-Harburg, Politecnico di Milano.<br>
// <br>
// </p>
//
// <p> <a href=\"#ModelicaLicense2\">The
// Modelica License 2</a><br>
// <a href=\"#2.%20Frequently%20Asked%20Questions%7Coutline\">Frequently
// Asked Questions</a><br>
// <br>
// </p>
//
// <hr>
// <h4><a name=\"ModelicaLicense2\"></a>The Modelica License 2</h4>
//
// <p>
// <b>Preamble.</b> The goal of this license is that Modelica related
// model libraries, software, images, documents, data files etc. can be
// used freely in the original or a modified form, in open source and in
// commercial environments (as long as the license conditions below are
// fulfilled, in particular sections 2c) and 2d). The Original Work is
// provided free of charge and the use is completely at your own risk.
// Developers of free Modelica packages are encouraged to utilize this
// license for their work.</p>
//
// <p>
// The Modelica License applies to any Original Work that contains the
// following licensing notice adjacent to the copyright notice(s) for
// this Original Work:</p>
// <p><b>Licensed
// by the Modelica Association under the Modelica License 2</b></p>
//
// <p><b>1. Definitions.</b></p>
// <ol>
//  <li>&ldquo;License&rdquo; is this Modelica License.</li>
//
//  <li>
//  &ldquo;Original Work&rdquo; is any work of authorship, including
//  software, images, documents, data files, that contains the above
//  licensing notice or that is packed together with a licensing notice
//  referencing it.</li>
//
//  <li>
//  &ldquo;Licensor&rdquo; is the provider of the Original Work who has
//  placed this licensing notice adjacent to the copyright notice(s) for
//  the Original Work. The Original Work is either directly provided by
//  the owner of the Original Work, or by a licensee of the owner.</li>
//
//  <li>
//  &ldquo;Derivative Work&rdquo; is any modification of the Original
//  Work which represents, as a whole, an original work of authorship.
//  For the matter of clarity and as examples: </li>
//
//  <ol>
//   <li>
//   Derivative Work shall not include work that remains separable from
//   the Original Work, as well as merely extracting a part of the
//   Original Work without modifying it.</li>
//
//   <li>
//   Derivative Work shall not include (a) fixing of errors and/or (b)
//   adding vendor specific Modelica annotations and/or (c) using a
//   subset of the classes of a Modelica package, and/or (d) using a
//   different representation, e.g., a binary representation.</li>
//
//   <li>
//   Derivative Work shall include classes that are copied from the
//   Original Work where declarations, equations or the documentation
//   are modified.</li>
//
//   <li>
//   Derivative Work shall include executables to simulate the models
//   that are generated by a Modelica translator based on the Original
//   Work (of a Modelica package).</li>
//  </ol>
//
//  <li>
//  &ldquo;Modified Work&rdquo; is any modification of the Original Work
//  with the following exceptions: (a) fixing of errors and/or (b)
//  adding vendor specific Modelica annotations and/or (c) using a
//  subset of the classes of a Modelica package, and/or (d) using a
//  different representation, e.g., a binary representation.</li>
//
//  <li>
//  &quot;Source Code&quot; means the preferred form of the Original
//  Work for making modifications to it and all available documentation
//  describing how to modify the Original Work.</li>
//
//  <li>
//  &ldquo;You&rdquo; means an individual or a legal entity exercising
//  rights under, and complying with all of the terms of, this License.</li>
//
//  <li>
//  &ldquo;Modelica package&rdquo; means any Modelica library that is
//  defined with the<br>&ldquo;<FONT FACE=\"Courier New, monospace\"><FONT SIZE=2 STYLE=\"font-size: 9pt\"><b>package</b></FONT></FONT><FONT FACE=\"Courier New, monospace\"><FONT SIZE=2 STYLE=\"font-size: 9pt\">
//  &lt;Name&gt; ... </FONT></FONT><FONT FACE=\"Courier New, monospace\"><FONT SIZE=2 STYLE=\"font-size: 9pt\"><b>end</b></FONT></FONT><FONT FACE=\"Courier New, monospace\"><FONT SIZE=2 STYLE=\"font-size: 9pt\">
//  &lt;Name&gt;;</FONT></FONT>&ldquo; Modelica language element.</li>
// </ol>
//
// <p>
// <b>2. Grant of Copyright License.</b> Licensor grants You a
// worldwide, royalty-free, non-exclusive, sublicensable license, for
// the duration of the copyright, to do the following:</p>
//
// <ol>
//  <li><p>
//  To reproduce the Original Work in copies, either alone or as part of
//  a collection.</li></p>
//  <li><p>
//  To create Derivative Works according to Section 1d) of this License.</li></p>
//  <li><p>
//  To distribute or communicate to the public copies of the <u>Original
//  Work</u> or a <u>Derivative Work</u> under <u>this License</u>. No
//  fee, neither as a copyright-license fee, nor as a selling fee for
//  the copy as such may be charged under this License. Furthermore, a
//  verbatim copy of this License must be included in any copy of the
//  Original Work or a Derivative Work under this License.<br>      For
//  the matter of clarity, it is permitted A) to distribute or
//  communicate such copies as part of a (possible commercial)
//  collection where other parts are provided under different licenses
//  and a license fee is charged for the other parts only and B) to
//  charge for mere printing and shipping costs.</li></p>
//  <li><p>
//  To distribute or communicate to the public copies of a <u>Derivative
//  Work</u>, alternatively to Section 2c), under <u>any other license</u>
//  of your choice, especially also under a license for
//  commercial/proprietary software, as long as You comply with Sections
//  3, 4 and 8 below. <br>      For the matter of clarity, no
//  restrictions regarding fees, either as to a copyright-license fee or
//  as to a selling fee for the copy as such apply.</li></p>
//  <li><p>
//  To perform the Original Work publicly.</li></p>
//  <li><p>
//  To display the Original Work publicly.</li></p>
// </ol>
//
// <p>
// <b>3. Acceptance.</b> Any use of the Original Work or a
// Derivative Work, or any action according to either Section 2a) to 2f)
// above constitutes Your acceptance of this License.</p>
//
// <p>
// <b>4. Designation of Derivative Works and of Modified Works.
// </b>The identifying designation of Derivative Work and of Modified
// Work must be different to the corresponding identifying designation
// of the Original Work. This means especially that the (root-level)
// name of a Modelica package under this license must be changed if the
// package is modified (besides fixing of errors, adding vendor specific
// Modelica annotations, using a subset of the classes of a Modelica
// package, or using another representation, e.g. a binary
// representation).</p>
//
// <p>
// <b>5. Grant of Patent License.</b>
// Licensor grants You a worldwide, royalty-free, non-exclusive, sublicensable license,
// under patent claims owned by the Licensor or licensed to the Licensor by
// the owners of the Original Work that are embodied in the Original Work
// as furnished by the Licensor, for the duration of the patents,
// to make, use, sell, offer for sale, have made, and import the Original Work
// and Derivative Works under the conditions as given in Section 2.
// For the matter of clarity, the license regarding Derivative Works covers
// patent claims to the extent as they are embodied in the Original Work only.</p>
//
// <p>
// <b>6. Provision of Source Code.</b> Licensor agrees to provide
// You with a copy of the Source Code of the Original Work but reserves
// the right to decide freely on the manner of how the Original Work is
// provided.<br>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For the matter of clarity, Licensor might provide only a binary
// representation of the Original Work. In that case, You may (a) either
// reproduce the Source Code from the binary representation if this is
// possible (e.g., by performing a copy of an encrypted Modelica
// package, if encryption allows the copy operation) or (b) request the
// Source Code from the Licensor who will provide it to You.</p>
//
// <p>
// <b>7. Exclusions from License Grant.</b> Neither the names of
// Licensor, nor the names of any contributors to the Original Work, nor
// any of their trademarks or service marks, may be used to endorse or
// promote products derived from this Original Work without express
// prior permission of the Licensor. Except as otherwise expressly
// stated in this License and in particular in Sections 2 and 5, nothing
// in this License grants any license to Licensor&rsquo;s trademarks,
// copyrights, patents, trade secrets or any other intellectual
// property, and no patent license is granted to make, use, sell, offer
// for sale, have made, or import embodiments of any patent claims.<br>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No license is granted to the trademarks of
// Licensor even if such trademarks are included in the Original Work,
// except as expressly stated in this License. Nothing in this License
// shall be interpreted to prohibit Licensor from licensing under terms
// different from this License any Original Work that Licensor otherwise
// would have a right to license.</p>
//
// <p>
// <b>8. Attribution Rights.</b> You must retain in the Source
// Code of the Original Work and of any Derivative Works that You
// create, all author, copyright, patent, or trademark notices, as well
// as any descriptive text identified therein as an &quot;Attribution
// Notice&quot;. The same applies to the licensing notice of this
// License in the Original Work. For the matter of clarity, &ldquo;author
// notice&rdquo; means the notice that identifies the original
// author(s). <br>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You must cause the Source Code for any Derivative
// Works that You create to carry a prominent Attribution Notice
// reasonably calculated to inform recipients that You have modified the
// Original Work. <br>
// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In case the Original Work or Derivative Work is not provided in
// Source Code, the Attribution Notices shall be appropriately
// displayed, e.g., in the documentation of the Derivative Work.</p>
//
// <p><b>9. Disclaimer
// of Warranty. <br></b><u><b>The Original Work is provided under this
// License on an &quot;as is&quot; basis and without warranty, either
// express or implied, including, without limitation, the warranties of
// non-infringement, merchantability or fitness for a particular
// purpose. The entire risk as to the quality of the Original Work is
// with You.</b></u><b> </b>This disclaimer of warranty constitutes an
// essential part of this License. No license to the Original Work is
// granted by this License except under this disclaimer.</p>
//
// <p>
// <b>10. Limitation of Liability.</b> Under no circumstances and
// under no legal theory, whether in tort (including negligence),
// contract, or otherwise, shall the Licensor, the owner or a licensee
// of the Original Work be liable to anyone for any direct, indirect,
// general, special, incidental, or consequential damages of any
// character arising as a result of this License or the use of the
// Original Work including, without limitation, damages for loss of
// goodwill, work stoppage, computer failure or malfunction, or any and
// all other commercial damages or losses. This limitation of liability
// shall not apply to the extent applicable law prohibits such
// limitation.</p>
//
// <p>
// <b>11. Termination.</b> This License conditions your rights to
// undertake the activities listed in Section 2 and 5, including your
// right to create Derivative Works based upon the Original Work, and
// doing so without observing these terms and conditions is prohibited
// by copyright law and international treaty. Nothing in this License is
// intended to affect copyright exceptions and limitations. This License
// shall terminate immediately and You may no longer exercise any of the
// rights granted to You by this License upon your failure to observe
// the conditions of this license.</p>
//
// <p>
// <b>12. Termination for Patent Action.</b> This License shall
// terminate automatically and You may no longer exercise any of the
// rights granted to You by this License as of the date You commence an
// action, including a cross-claim or counterclaim, against Licensor,
// any owners of the Original Work or any licensee alleging that the
// Original Work infringes a patent. This termination provision shall
// not apply for an action alleging patent infringement through
// combinations of the Original Work under combination with other
// software or hardware.</p>
//
// <p>
// <b>13. Jurisdiction.</b> Any action or suit relating to this
// License may be brought only in the courts of a jurisdiction wherein
// the Licensor resides and under the laws of that jurisdiction
// excluding its conflict-of-law provisions. The application of the
// United Nations Convention on Contracts for the International Sale of
// Goods is expressly excluded. Any use of the Original Work outside the
// scope of this License or after its termination shall be subject to
// the requirements and penalties of copyright or patent law in the
// appropriate jurisdiction. This section shall survive the termination
// of this License.</p>
//
// <p>
// <b>14. Attorneys&rsquo; Fees.</b> In any action to enforce the
// terms of this License or seeking damages relating thereto, the
// prevailing party shall be entitled to recover its costs and expenses,
// including, without limitation, reasonable attorneys' fees and costs
// incurred in connection with such action, including any appeal of such
// action. This section shall survive the termination of this License.</p>
//
// <p>
// <b>15. Miscellaneous.</b>
// </p>
// <ol>
//  <li>If any
//  provision of this License is held to be unenforceable, such
//  provision shall be reformed only to the extent necessary to make it
//  enforceable.</li>
//
//  <li>No verbal
//  ancillary agreements have been made. Changes and additions to this
//  License must appear in writing to be valid. This also applies to
//  changing the clause pertaining to written form.</li>
//
//  <li>You may use the
//  Original Work in all ways not otherwise restricted or conditioned by
//  this License or by law, and Licensor promises not to interfere with
//  or be responsible for such uses by You.</li>
// </ol>
//
// <p>
// <br>
// </p>
//
// <hr>
//
// <h4><a name=\"2. Frequently Asked Questions|outline\"></a>
// Frequently Asked Questions</h4>
// <p>This
// section contains questions/answer to users and/or distributors of
// Modelica packages and/or documents under Modelica License 2. Note,
// the answers to the questions below are not a legal interpretation of
// the Modelica License 2. In case of a conflict, the language of the
// license shall prevail.</p>
//
// <p><br>
// </p>
//
// <p><FONT COLOR=\"#008000\"><FONT SIZE=3><b>Using
// or Distributing a Modelica </b></FONT></FONT><FONT COLOR=\"#008000\"><FONT SIZE=3><u><b>Package</b></u></FONT></FONT><FONT COLOR=\"#008000\"><FONT SIZE=3><b>
// under the Modelica License 2</b></FONT></FONT></p>
//
// <p><b>What are the main
// differences to the previous version of the Modelica License?</b></p>
// <ol>
//  <li><p>
//  Modelica License 1 is unclear whether the licensed Modelica package
//  can be distributed under a different license. Version 2 explicitly
//  allows that &ldquo;Derivative Work&rdquo; can be distributed under
//  any license of Your choice, see examples in Section 1d) as to what
//  qualifies as Derivative Work (so, version 2 is clearer).</p>
//  <li><p>
//  If You modify a Modelica package under Modelica License 2 (besides
//  fixing of errors, adding vendor specific Modelica annotations, using
//  a subset of the classes of a Modelica package, or using another
//  representation, e.g., a binary representation), you must rename the
//  root-level name of the package for your distribution. In version 1
//  you could keep the name (so, version 2 is more restrictive). The
//  reason of this restriction is to reduce the risk that Modelica
//  packages are available that have identical names, but different
//  functionality.</p>
//  <li><p>
//  Modelica License 1 states that &ldquo;It is not allowed to charge a
//  fee for the original version or a modified version of the software,
//  besides a reasonable fee for distribution and support<SPAN LANG=\"en-GB\">&ldquo;.
//  Version 2 has a </SPAN>similar intention for all Original Work under
//  <u>Modelica License 2</u> (to remain free of charge and open source)
//  but states this more clearly as &ldquo;No fee, neither as a
//  copyright-license fee, nor as a selling fee for the copy as such may
//  be charged&rdquo;. Contrary to version 1, Modelica License 2 has no
//  restrictions on fees for Derivative Work that is provided under a
//  different license (so, version 2 is clearer and has fewer
//  restrictions).</p>
//  <li><p>
//  Modelica License 2 introduces several useful provisions for the
//  licensee (articles 5, 6, 12), and for the licensor (articles 7, 12,
//  13, 14) that have no counter part in version 1.</p>
//  <li><p>
//  Modelica License 2 can be applied to all type of work, including
//  documents, images and data files, contrary to version 1 that was
//  dedicated for software only (so, version 2 is more general).</p>
// </ol>
//
// <p><b>Can I distribute a
// Modelica package (under Modelica License 2) as part of my commercial
// Modelica modeling and simulation environment?</b></p>
// <p>Yes,
// according to Section 2c). However, you are not allowed to charge a
// fee for this part of your environment. Of course, you can charge for
// your part of the environment.
// </p>
//
// <p><b>Can I distribute a
// Modelica package (under Modelica License 2) under a different
// license?</b></p>
// <p>No.
// The license of an unmodified Modelica package cannot be changed
// according to Sections 2c) and 2d). This means that you cannot <u>sell</u>
// copies of it, any distribution has to be free of charge.</p>
//
// <p><b>Can I distribute a
// Modelica package (under Modelica License 2) under a different license
// when I first encrypt the package?</b></p>
// <p>No.
// Merely encrypting a package does not qualify for Derivative Work and
// therefore the encrypted package has to stay under Modelica License 2.</p>
//
// <p><b>Can I distribute a
// Modelica package (under Modelica License 2) under a different license
// when I first add classes to the package?</b></p>
// <p>No.
// The package itself remains unmodified, i.e., it is Original Work, and
// therefore the license for this part must remain under Modelica
// License 2. The newly added classes can be, however, under a different
// license.
// </p>
//
// <p><b>Can
// I copy a class out of a Modelica package (under Modelica License 2)
// and include it </b><u><b>unmodified</b></u><b> in a Modelica package
// under a </b><u><b>commercial/proprietary license</b></u><b>?</b></p>
// <p>No,
// according to article 2c). However, you can include model, block,
// function, package, record and connector classes in your Modelica
// package under <u>Modelica License 2</u>. This means that your
// Modelica package could be under a commercial/proprietary license, but
// one or more classes of it are under Modelica License 2.<br>Note, a
// &ldquo;type&rdquo; class (e.g., type Angle = Real(unit=&rdquo;rad&rdquo;))
// can be copied and included unmodified under a commercial/proprietary
// license (for details, see the next question).</p>
//
// <p><b>Can
// I copy a type class or </b><u><b>part</b></u><b> of a model, block,
// function, record, connector class, out of a Modelica package (under
// Modelica License 2) and include it modified or unmodified in a
// Modelica package under a </b><u><b>commercial/proprietary</b></u><b>
// license</b></p>
// <p>Yes,
// according to article 2d), since this will in the end usually qualify
// as Derivative Work. The reasoning is the following: A type class or
// part of another class (e.g., an equation, a declaration, part of a
// class description) cannot be utilized &ldquo;by its own&rdquo;. In
// order to make this &ldquo;usable&rdquo;, you have to add additional
// code in order that the class can be utilized. This is therefore
// usually Derivative Work and Derivative Work can be provided under a
// different license. Note, this only holds, if the additional code
// introduced is sufficient to qualify for Derivative Work. Merely, just
// copying a class and changing, say, one character in the documentation
// of this class would be no Derivative Work and therefore the copied
// code would have to stay under Modelica License 2.</p>
//
// <p><b>Can
// I copy a class out of a Modelica package (under Modelica License 2)
// and include it in </b><u><b>modified </b></u><b>form in a
// </b><u><b>commercial/proprietary</b></u><b> Modelica package?</b></p>
// <p>Yes.
// If the modification can be seen as a &ldquo;Derivative Work&rdquo;,
// you can place it under your commercial/proprietary license. If the
// modification does not qualify as &ldquo;Derivative Work&rdquo; (e.g.,
// bug fixes, vendor specific annotations), it must remain under
// Modelica License 2. This means that your Modelica package could be
// under a commercial/proprietary license, but one or more parts of it
// are under Modelica License 2.</p>
//
// <p><b>Can I distribute a
// &ldquo;save total model&rdquo; under my commercial/proprietary
// license, even if classes under Modelica License 2 are included?</b></p>
// <p>Your
// classes of the &ldquo;save total model&rdquo; can be distributed
// under your commercial/proprietary license, but the classes under
// Modelica License 2 must remain under Modelica License 2. This means
// you can distribute a &ldquo;save total model&rdquo;, but some parts
// might be under Modelica License 2.</p>
//
// <p><b>Can I distribute a
// Modelica package (under Modelica License 2) in encrypted form?</b></p>
// <p>Yes.
// Note, if the encryption does not allow &ldquo;copying&rdquo; of
// classes (in to unencrypted Modelica source code), you have to send
// the Modelica source code of this package to your customer, if he/she
// wishes it, according to article&nbsp;6.</p>
//
// <p><b>Can I distribute an
// executable under my commercial/proprietary license, if the model from
// which the executable is generated uses models from a Modelica package
// under Modelica License 2?</b></p>
// <p>Yes,
// according to article 2d), since this is seen as Derivative Work. The
// reasoning is the following: An executable allows the simulation of a
// concrete model, whereas models from a Modelica package (without
// pre-processing, translation, tool run-time library) are not able to
// be simulated without tool support. By the processing of the tool and
// by its run-time libraries, significant new functionality is added (a
// model can be simulated whereas previously it could not be simulated)
// and functionality available in the package is removed (e.g., to build
// up a new model by dragging components of the package is no longer
// possible with the executable).</p>
//
// <p><b>Is my modification to
// a Modelica package (under Modelica License 2) a Derivative Work?</b></p>
// <p>It
// is not possible to give a general answer to it. To be regarded as &quot;an
// original work of authorship&quot;, a derivative work must be
// different enough from the original or must contain a substantial
// amount of new material. Making minor changes or additions of little
// substance to a preexisting work will not qualify the work as a new
// version for such purposes.
// </p>
//
// <p><br>
// </p>
// <p><FONT COLOR=\"#008000\"><FONT SIZE=3><b>Using
// or Distributing a Modelica </b></FONT></FONT><FONT COLOR=\"#008000\"><FONT SIZE=3><u><b>Document</b></u></FONT></FONT><FONT COLOR=\"#008000\"><FONT SIZE=3><b>
// under the Modelica License 2</b></FONT></FONT></p>
//
// <p>This
// section is devoted especially for the following applications:</p>
// <ol>
//  <li><p>
//  A Modelica tool extracts information out of a Modelica package and
//  presents the result in form of a &ldquo;manual&rdquo; for this
//  package in, e.g., html, doc, or pdf format.</p>
//  <li><p>
//  The Modelica language specification is a document defining the
//  Modelica language. It will be licensed under Modelica License 2.</p>
//  <li><p>
//  Someone writes a book about the Modelica language and/or Modelica
//  packages and uses information which is available in the Modelica
//  language specification and/or the corresponding Modelica package.</p>
// </ol>
//
// <p><b>Can I sell a manual
// that was basically derived by extracting information automatically
// from a Modelica package under Modelica License 2 (e.g., a &ldquo;reference
// guide&rdquo; of the Modelica Standard Library):</b></p>
// <p>Yes.
// Extracting information from a Modelica package, and providing it in a
// human readable, suitable format, like html, doc or pdf format, where
// the content is significantly modified (e.g. tables with interface
// information are constructed from the declarations of the public
// variables) qualifies as Derivative Work and there are no restrictions
// to charge a fee for Derivative Work under alternative 2d).</p>
//
// <p><b>Can
// I copy a text passage out of a Modelica document (under Modelica
// License 2) and use it </b><u><b>unmodified</b></u><b> in my document
// (e.g. the Modelica syntax description in the Modelica Specification)?</b></p>
// <p>Yes.
// In case you distribute your document, the copied parts are still
// under Modelica License 2 and you are not allowed to charge a license
// fee for this part. You can, of course, charge a fee for the rest of
// your document.</p>
//
// <p><b>Can
// I copy a text passage out of a Modelica document (under Modelica
// License 2) and use it in </b><u><b>modified</b></u><b> form in my
// document?</b></p>
// <p>Yes,
// the creation of Derivative Works is allowed. In case the content is
// significantly modified this qualifies as Derivative Work and there
// are no restrictions to charge a fee for Derivative Work under
// alternative 2d).</p>
//
// <p><b>Can I sell a printed
// version of a Modelica document (under Modelica License 2), e.g., the
// Modelica Language Specification?</b></p>
// <p>No,
// if you are not the copyright-holder, since article 2c) does not allow
// a selling fee for a (in this case physical) copy. However, mere
// printing and shipping costs may be recovered.</p>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// Evaluating: getIconAnnotation(Modelica.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDiagramAnnotation(Modelica.UsersGuide.Contact)
// {}
// Evaluating: getErrorString()
// ""
// Evaluating: getDocumentationAnnotation(Modelica.UsersGuide.Contact)
// {"<html>
//
// <dl>
// <dt>The Modelica Standard Library (this Modelica package)
//  is developed by many people from different organizations (see list below).
//  It is licensed under the
//  <a href=\"Modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica License 2</a>
//  by:<br>&nbsp;</dt>
// <dd>Modelica Association<br>
//  (Ideella F&ouml;reningar 822003-8858 in Link&ouml;ping) <br>
//  c/o PELAB, IDA, Link&ouml;pings Universitet<br>
//  S-58183 Link&ouml;ping<br>
//  Sweden<br>
//  email: <a href=\"mailto:Board@Modelica.org\">Board@Modelica.org</a><br>
//  web: <a href=\"http://www.Modelica.org\">http://www.Modelica.org</a><br>&nbsp;<br>&nbsp;</dd>
// </dl>
//
// <dl>
// <dt>The development of this Modelica package is organized by<br>&nbsp;</dt>
// <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
//  Deutsches Zentrum f&uuml;r Luft und Raumfahrt e.V. (DLR)<br>
//  Institut f&uuml;r Robotik und Mechatronik<br>
//  Abteilung f&uuml;r Systemdynamik und Regelungstechnik<br>
//  Postfach 1116<br>
//  D-82230 Wessling<br>
//  Germany<br>
//  email: <A HREF=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</A><br></dd>
// </dl>
//
// <p>
// Since end of 2007, the development of the sublibraries of package Modelica
// is organized by personal and/or organizational <b>library officers</b> assigned by the
// Modelica Association. They are responsible for the maintenance and
// for the further organization of the development. Other persons may
// also contribute, but the final decision for library improvements and/or changes
// is performed by the responsible library officer(s). In order that a new
// sublibrary or a new version of a sublibrary is ready to be released,
// the responsible library officers report the changes to the members of
// the Modelica Association and the library is made available for beta testing to
// interested parties before a final decision. A new release of a sublibrary
// is formally decided by voting of the Modelica Association members.
// </p>
//
// <p>
// The following library officers are currently assigned:
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><b>Sublibraries</b> </td>
//    <td valign=\"top\"><b>Library officers</b></td>
// </tr>
//
// <tr><td valign=\"top\"> Blocks <br> Constants </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//         (Martin Otter)</td>
// </tr>
//
// <tr><td valign=\"top\"> Electrical.Analog, <br> Electrical.Digital </td>
//    <td valign=\"top\"> Fraunhofer Institute for Integrated Circuits, Dresden, Germany<br>
//       (Christoph Clauss)</td>
// </tr>
//
// <tr><td valign=\"top\"> Electrical.Machines<br>
//       Electrical.MultiPhase </td>
//    <td valign=\"top\"> Anton Haumer, Consultant, St.Andrae-Woerdern, Austria, and<br>
//       arsenal research, Vienna, Austria (Christian Kral)</td>
// </tr>
//
// <tr><td valign=\"top\"> Magnetic.FluxTubes </td>
//    <td valign=\"top\"> Thomas B&ouml;drich, Dresden, Germany<br>
//                                (Dresden University of Technology,<br>
//                                Institute of Electromechanical and Electronic Design)
// </td>
// </tr>
//
// <tr><td valign=\"top\"> Fluid </td>
//    <td valign=\"top\"> Politecnico di Milano (Francesco Casella), and<br>
//                             R&uuml;diger Franke (ABB)</td>
// </tr>
//
// <tr><td valign=\"top\"> Icons </td>
//    <td valign=\"top\"> Modelon AB, Lund, Sweden (Johan Andreasson) </td>
// </tr>
//
// <tr><td valign=\"top\"> Math </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter)</td>
// </tr>
//
// <tr><td valign=\"top\"> Mechanics.MultiBody </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter),<br>
//        Modelon AB, Lund, Sweden (Johan Andreasson) </td>
// </tr>
//
// <tr><td valign=\"top\"> Mechanics.Rotational </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter)<br>
//       Anton Haumer, Consultant, St.Andrae-Woerdern, Austria,<br>
//       arsenal research, Vienna, Austria (Christian Kral),<br>
//       Modelon AB, Lund, Sweden (Johan Andreasson)</td>
// </tr>
//
// <tr><td valign=\"top\"> Mechanics.Translational </td>
//    <td valign=\"top\"> Anton Haumer, Consultant, St.Andrae-Woerdern, Austria,<br>
//       arsenal research, Vienna, Austria (Christian Kral), <br>
//       DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter)<br>
//        Modelon AB, Lund, Sweden (Johan Andreasson)</td>
// </tr>
//
//
// <tr><td valign=\"top\"> Media </td>
//    <td valign=\"top\"> Modelon AB, Lund, Sweden (Hubertus Tummescheit) </td>
// </tr>
//
// <tr><td valign=\"top\"> SIunits <br>
//       StateGraph </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter)</td>
// </tr>
//
// <tr><td valign=\"top\"> Thermal.FluidHeatFlow <br>
//       Thermal.HeatTransfer </td>
//    <td valign=\"top\"> Anton Haumer, Consultant, St.Andrae-Woerdern, Austria, and<br>
//       arsenal research, Vienna, Austria (Christian Kral)</td>
//
// <tr><td valign=\"top\"> Utilities </td>
//    <td valign=\"top\"> DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany<br>
//       (Martin Otter)<br>
//       Dynasim AB, Lund, Sweden (Hans Olsson)</td>
// </tr>
// </table>
//
//
// <p>
// The following people have directly contributed to the implementation
// of the Modelica package (many more people have contributed to the design):
// </p>
//
// <table border=1 cellspacing=0 cellpadding=2>
// <tr><td valign=\"top\"><b>Peter Beater</b> </td
//    <td valign=\"top\"> University of Paderborn, Germany</td>
//    <td valign=\"top\"> Modelica.Mechanics.Translational </td>
// </tr>
//
// <tr><td valign=\"top\"><b>Thomas B&ouml;drich</b> </td
//    <td valign=\"top\"> Dresden University of Technology, Germany</td>
//    <td valign=\"top\"> Modelica.Magnetic.FluxTubes </td>
//
//
// <tr><td valign=\"top\"><b>Dag Br&uuml;ck</b> </td
//    <td valign=\"top\"> Dynasim AB, Lund, Sweden</td>
//    <td valign=\"top\"> Modelica.Utilities</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Francesco Casella</b> </td
//    <td valign=\"top\"> Politecnico di Milano, Milano, Italy</td>
//    <td valign=\"top\"> Modelica.Fluid<br>
//                             Modelica.Media</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Christoph Clauss</b> </td
//    <td valign=\"top\"> Fraunhofer Institute for Integrated Circuits,<br> Dresden, Germany</td>
//    <td valign=\"top\"> Modelica.Electrical.Analog<br>
//      Modelica.Electrical.Digital</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Jonas Eborn</b> </td
//    <td valign=\"top\"> Modelon AB, Lund, Sweden</td>
//    <td valign=\"top\"> Modelica.Media</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Hilding Elmqvist</b> </td
//    <td valign=\"top\"> Dynasim AB, Lund, Sweden</td>
//    <td valign=\"top\"> Modelica.Mechanics.MultiBody<br>
//                    Modelica.Fluid<br>
//      Modelica.Media<br>
//      Modelica.StateGraph<br>
//      Modelica.Utilities<br>
//      Conversion from 1.6 to 2.0</td>
// </tr>
//
// <tr><td valign=\"top\"><b>R&uuml;diger Franke</b> </td
//    <td valign=\"top\"> ABB Corporate Research,<br>Ladenburg, German</td>
//    <td valign=\"top\"> Modelica.Fluid<br>
//                             Modelica.Media</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Manuel Gr&auml;ber</b> </td
//    <td valign=\"top\"> Institut f&uuml;r Thermodynamik, <br>
//      Technische Universit&auml;t Braunschweig, <br>
//      Germany</td>
//    <td valign=\"top\"> Modelica.Fluid</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Anton Haumer</b> </td
//    <td valign=\"top\"> Consultant, St.Andrae-Woerdern,<br>Austria</td>
//    <td valign=\"top\"> Modelica.Electrical.Machines<br>
//      Modelica.Electrical.Multiphase<br>
//      Modelica.Mechanics.Rotational<br>
//      Modelica.Mechanics.Translational<br>
//      Modelica.Thermal.FluidHeatFlow<br>
//      Modelica.Thermal.HeatTransfer<br>
//      Conversion from 1.6 to 2.0<br>
//      Conversion from 2.2 to 3.0</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Hans-Dieter Joos</b> </td
//    <td valign=\"top\"> Institute of Robotics and Mechatronics<br>
//      DLR, German Aerospace Center, <br>
//      Oberpfaffenhofen, Germany</td>
//    <td valign=\"top\"> Modelica.Math.Matrices</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Christian Kral</b> </td
//    <td valign=\"top\"> arsenal research, Vienna, Austria</td>
//    <td valign=\"top\"> Modelica.Electrical.Machines<br>
//      Modelica.Thermal.FluidHeatFlow</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Sven Erik Mattsson</b> </td
//    <td valign=\"top\"> Dynasim AB, Lund, Sweden</td>
//    <td valign=\"top\"> Modelica.Mechanics.MultiBody</td>
// </tr>
// <tr><td valign=\"top\"><b>Hans Olsson</b> </td
//    <td valign=\"top\"> Dynasim AB, Lund, Sweden</td>
//    <td valign=\"top\"> Modelica.Blocks<br>
//      Modelica.Math.Matrices<br>
//      Modelica.Utilities<br>
//      Conversion from 1.6 to 2.0<br>
//      Conversion from 2.2 to 3.0</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Martin Otter</b> </td
//    <td valign=\"top\"> Institute of Robotics and Mechatronics<br>
//      DLR, German Aerospace Center, <br>
//      Oberpfaffenhofen, Germany</td>
//    <td valign=\"top\"> Modelica.Blocks<br>
//                    Modelica.Fluid<br>
//      Modelica.Mechanics.MultiBody<br>
//      Modelica.Mechanics.Rotational<br>
//      Modelica.Mechanics.Translational<br>
//      Modelica.Math<br>
//      Modelica.Media<br>
//      Modelica.SIunits<br>
//      Modelica.StateGraph<br>
//      Modelica.Thermal.HeatTransfer<br>
//      Modelica.Utilities<br>
//      ModelicaReference<br>
//      Conversion from 1.6 to 2.0<br>
//      Conversion from 2.2 to 3.0</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Katrin Pr&ouml;l&szlig;</b> </td
//    <td valign=\"top\"> Modelon AB, Lund, Sweden<br>
//                             until 2008:<br>
//                             Department of Technical Thermodynamics,<br>
//      Technical University Hamburg-Harburg,<br>Germany</td>
//    <td valign=\"top\"> Modelica.Fluid<br>
//                             Modelica.Media</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Christoph C. Richter</b> </td
//    <td valign=\"top\"> Institut f&uuml;r Thermodynamik, <br>
//      Technische Universit&auml;t Braunschweig, <br>
//      Germany</td>
//    <td valign=\"top\"> Modelica.Fluid<br>
//                             Modelica.Media</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Andr&eacute; Schneider</b> </td
//    <td valign=\"top\"> Fraunhofer Institute for Integrated Circuits,<br> Dresden, Germany</td>
//    <td valign=\"top\"> Modelica.Electrical.Analog<br>
//      Modelica.Electrical.Digital</td>
// </tr>
// <tr><td valign=\"top\"><b>Christian Schweiger</b> </td
//    <td valign=\"top\"> Until 2006:<br>
//      Institute of Robotics and Mechatronics,<br>
//      DLR, German Aerospace Center,<br>
//      Oberpfaffenhofen, Germany</td>
//    <td valign=\"top\"> Modelica.Mechanics.Rotational<br>
//      ModelicaReference<br>
//      Conversion from 1.6 to 2.0</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Michael Sielemann</b> </td
//    <td valign=\"top\"> Institute of Robotics and Mechatronics<br>
//      DLR, German Aerospace Center, <br>
//      Oberpfaffenhofen, Germany</td>
//    <td valign=\"top\"> Modelica.Fluid</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Michael Tiller</b> </td
//    <td valign=\"top\"> Emmeskay, Inc., Dearborn, MI, U.S.A, <br>
//      (previously Ford Motor Company, Dearborn) </td>
//    <td valign=\"top\"> Modelica.Media<br>
//      Modelica.Thermal.HeatTransfer</td>
// </tr>
// <tr><td valign=\"top\"><b>Hubertus Tummescheit</b> </td
//    <td valign=\"top\"> Modelon AB, Lund, Sweden </td>
//    <td valign=\"top\"> Modelica.Media<br>
//      Modelica.Thermal.HeatTransfer</td>
// </tr>
// <tr><td valign=\"top\"><b>Nico Walter</b> </td
//    <td valign=\"top\"> Master thesis at HTWK Leipzig<br>
//      (Prof. R. M&uuml;ller) and<br>
//      DLR Oberpfaffenhofen, Germany</td>
//    <td valign=\"top\"> Modelica.Math.Matrices</td>
// </tr>
//
// <tr><td valign=\"top\"><b>Manuel Wetter</b> </td
//    <td valign=\"top\"> Lawrence Berkeley National Laboratory; U.S.A</td>
//    <td valign=\"top\"> Modelica.Fluid</td>
// </tr>
// </table>
// </html>
// ","",""}
// Evaluating: getErrorString()
// ""
// endResult
