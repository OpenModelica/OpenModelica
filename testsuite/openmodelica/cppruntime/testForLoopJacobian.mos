// name:     testForLoopJacobian
// keywords: array equations, for loops, symbolic jacobian
// status: correct
// teardown_command: rm -f *testForLoopJacobian.Example*

loadFile("testForLoopJacobian.mo"); getErrorString();
setCommandLineOptions("--simCodeTarget=Cpp"); getErrorString();
setCommandLineOptions("--generateSymbolicJacobian"); getErrorString();
setCommandLineOptions("-d=symjacdump"); getErrorString();
setCommandLineOptions("-d=newInst"); getErrorString();
setCommandLineOptions("-d=-nfScalarize"); getErrorString();
simulate(testForLoopJacobian.Example); getErrorString();


// Result:
// true
// ""
// true
// ""
// true
// ""
// true
// ""
// true
// ""
// true
// ""
// Create symbolic Jacobians from:
// Independent Variables
// ========================================
// 1: a.x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 2: x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// Dependent Variables
// ========================================
// 1: a.x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 2: x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// Basic equation system:
// differentiated equations
// ========================================
// 1/1 (10): for $i in 1 : 10 loop
//     0.0 = der(a[$i].x) + a[$i].amp * a[$i].x; end for;
// 2/11 (10): for i in 1 : 10 loop
//     0.0 = der(x[i]) + /*Real*/(i) * x[i]; end for;
// related variables
// ========================================
// 1: a.x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 2: x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// known variables
// ========================================
// 1: a.amp:PARAM()  = 1.0:10.0  type: Real[10] [10]
// 2: n:PARAM(final = true )  = 10  type: Integer
// Symbolic Jacobian:
//
// unknown partition
// ========================================
//
// Variables (2)
// ========================================
// 1: $DER.a.x.$pDERA.dummyVarA:STATE_DER(start = 1.0 fixed = true )  type: Real[10] [10] unreplaceable
// 2: $DER.x.$pDERA.dummyVarA:STATE_DER(start = 1.0 fixed = true )  type: Real[10] [10] unreplaceable
//
//
// Equations (2, 2)
// ========================================
// 1/1 (10): for $i in 1 : 10 loop
//     0.0 = $DER.a[$i].x.$pDERA.dummyVarA + a[$i].amp * a[$i].x.SeedA; end for;   [dynamic |0|0|0|0|]
// 2/11 (10): for i in 1 : 10 loop
//     0.0 = $DER.x.$pDERA.dummyVarA[i] + /*Real*/(i) * x.SeedA[i]; end for;   [dynamic |0|0|0|0|]
//
//
// no matching
//
//
//
// BackendDAEType: jacobian
//
//
// Known variables only depending on parameters and constants - globalKnownVars (6)
// ========================================
// 1: input a.x.SeedA:STATE_DER()  type: Real unreplaceable
// 2: input x.SeedA:STATE_DER()  type: Real[10] unreplaceable
// 3: a.x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 4: x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 5: a.amp:PARAM()  = 1.0:10.0  type: Real[10] [10]
// 6: n:PARAM(final = true )  = 10  type: Integer
//
// Symbolic Jacobian:
//
// unknown partition
// ========================================
//
// Variables (2)
// ========================================
// 1: $DER.a.x.$pDERA.dummyVarA:STATE_DER(start = 1.0 fixed = true )  type: Real[10] [10] unreplaceable
// 2: $DER.x.$pDERA.dummyVarA:STATE_DER(start = 1.0 fixed = true )  type: Real[10] [10] unreplaceable
//
//
// Equations (2, 2)
// ========================================
// 1/1 (10): for $i in 1 : 10 loop
//     0.0 = $DER.a[$i].x.$pDERA.dummyVarA + a[$i].amp * a[$i].x.SeedA; end for;   [dynamic |0|0|0|0|]
// 2/11 (10): for i in 1 : 10 loop
//     0.0 = $DER.x.$pDERA.dummyVarA[i] + /*Real*/(i) * x.SeedA[i]; end for;   [dynamic |0|0|0|0|]
//
//
// Matching
// ========================================
// 2 variables and equations
// var 1 is solved in eqn 1
// var 2 is solved in eqn 2
//
//
// StrongComponents
// ========================================
// {2:2}
// {1:1}
//
//
//
// BackendDAEType: jacobian
//
//
// Known variables only depending on parameters and constants - globalKnownVars (6)
// ========================================
// 1: n:PARAM(final = true )  = 10  type: Integer
// 2: a.amp:PARAM()  = 1.0:10.0  type: Real[10] [10]
// 3: x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 4: a.x:STATE(1)(start = 1.0 fixed = true )  type: Real[10] [10]
// 5: input x.SeedA:STATE_DER()  type: Real[10] unreplaceable
// 6: input a.x.SeedA:STATE_DER()  type: Real unreplaceable
//
// record SimulationResult
//     resultFile = "testForLoopJacobian.Example_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'testForLoopJacobian.Example', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = ""
// end SimulationResult;
// ""
// endResult
