// name: slice_for
// keywords: NewBackend, algebraic loop, slice
// status: correct
// cflags: --newBackend

loadString("
model slice_for
  Real x[4];
  Real y[3];
equation
  x[1] = 1;
  for i in 1:3 loop
    y[i] = x[i] + x[i+1];
    y[4-i] + x[i+1] = 1;
  end for;
end slice_for;
"); getErrorString();

setCommandLineOptions("-d=dumpSimCode"); getErrorString();
simulate(slice_for); getErrorString();

// Result:
// true
// ""
// true
// ""
// ###########################
//
//     SimCode (slice_for)
//
// ###########################
// ============
//   SimVars
// ============
// Algebraic Variables (7)
// *************************
//   (0)[ALGB] (1) Real x[1]
//   (1)[ALGB] (1) Real x[2]
//   (2)[ALGB] (1) Real x[3]
//   (3)[ALGB] (1) Real x[4]
//   (4)[ALGB] (1) Real y[1]
//   (5)[ALGB] (1) Real y[2]
//   (6)[ALGB] (1) Real y[3]
//
// Residual Variables (6)
// ************************
//   (0)[RES-] (1) Real $RES_SIM_0[1]
//   (1)[RES-] (1) Real $RES_SIM_0[2]
//   (2)[RES-] (1) Real $RES_SIM_0[3]
//   (3)[RES-] (1) Real $RES_SIM_2[1]
//   (4)[RES-] (1) Real $RES_SIM_2[2]
//   (5)[RES-] (1) Real $RES_SIM_2[3]
//
// Initial Partition
// -------------------
//   (4) x[1] := 1.0
//   (3) Nonlinear System (size = 6, homotopy = false, mixed = false, torn = true)
//   --Iteration Vars:{x[2], x[3], x[4], y[1], y[2], y[3]}
//   --(1) For-Loop-Residual:
//   --for {$i1 in 1:3} loop
//   --  0 = (x[$i1] + x[1 + $i1]) - y[$i1];
//   --end for;
//   --(2) For-Loop-Residual:
//   --for {$i1 in 1:3} loop
//   --  0 = 1.0 - (y[4 - $i1] + x[1 + $i1]);
//   --end for;
//
// Algebraic Partition 1
// -----------------------
//   (8) Alias of 4
//   (7) Nonlinear System (size = 6, homotopy = false, mixed = false, torn = true)
//   --Iteration Vars:{x[2], x[3], x[4], y[1], y[2], y[3]}
//   --(5) For-Loop-Residual:
//   --for {$i1 in 1:3} loop
//   --  0 = (x[$i1] + x[1 + $i1]) - y[$i1];
//   --end for;
//   --(6) For-Loop-Residual:
//   --for {$i1 in 1:3} loop
//   --  0 = 1.0 - (y[4 - $i1] + x[1 + $i1]);
//   --end for;
//
// Event Partition
// -----------------
//
// ======================================================
//   [EMPTY] SimCode Jacobian A(idx = 0, partition = 0)
// ======================================================
//
// ======================================================
//   [EMPTY] SimCode Jacobian B(idx = 2, partition = 0)
// ======================================================
//
// ======================================================
//   [EMPTY] SimCode Jacobian C(idx = 3, partition = 0)
// ======================================================
//
// ======================================================
//   [EMPTY] SimCode Jacobian D(idx = 4, partition = 0)
// ======================================================
//
// ======================================================
//   [EMPTY] SimCode Jacobian F(idx = 5, partition = 0)
// ======================================================
//
// ======================================================
//   [EMPTY] SimCode Jacobian H(idx = 6, partition = 0)
// ======================================================
//
// ========================================================
//   [EMPTY] SimCode Jacobian ADJ(idx = 1, partition = 0)
// ========================================================
//
//
//
// *********************
// * SimCode Equations *
// *********************
//
//
// allEquations:
// ========================================
//
// 8: alias of 4
// 7:  (NONLINEAR) index:1 jacobian: false
// crefs: x[2] , x[3] , x[4] , y[1] , y[2] , y[3]
// 	5: x[$i1] + x[1 + $i1] - y[$i1] (FOR_RESIDUAL)
// 	6: 1.0 - (y[4 - $i1] + x[1 + $i1]) (FOR_RESIDUAL)
//
// ========================================
//
//
//
// odeEquations (0 systems):
// ========================================
// ========================================
//
//
//
// algebraicEquations (1 systems):
// ========================================
// 8: alias of 4
// 7:  (NONLINEAR) index:1 jacobian: false
// crefs: x[2] , x[3] , x[4] , y[1] , y[2] , y[3]
// 	5: x[$i1] + x[1 + $i1] - y[$i1] (FOR_RESIDUAL)
// 	6: 1.0 - (y[4 - $i1] + x[1 + $i1]) (FOR_RESIDUAL)
//
// ========================================
//
//
// clockPartitions (0 systems):
//
// ========================================
//
//
//
// initialEquations: (2)
// ========================================
// 4: x[1]=1.0 [Real]
// 3:  (NONLINEAR) index:0 jacobian: false
// crefs: x[2] , x[3] , x[4] , y[1] , y[2] , y[3]
// 	1: x[$i1] + x[1 + $i1] - y[$i1] (FOR_RESIDUAL)
// 	2: 1.0 - (y[4 - $i1] + x[1 + $i1]) (FOR_RESIDUAL)
//
// ========================================
//
//
//
// initialEquations_lambda0: (0)
// ========================================
//
// removedInitialEquations:
// ========================================
//
// startValueEquations:
// ========================================
//
// nominalValueEquations:
// ========================================
//
// minValueEquations:
// ========================================
//
// maxValueEquations:
// ========================================
//
// parameterEquations:
// ========================================
//
// removedEquations:
// ========================================
//
// algorithmAndEquationAsserts:
// ========================================
//
// equationsForZeroCrossings:
// ========================================
//
// generic calls:
// ========================================
//
// jacobianEquations:
// ========================================
//
// jacobianMatrices:
// ========================================
// 	Jacobian idx: 0
//
// 	Jacobian idx: 2
//
// 	Jacobian idx: 3
//
// 	Jacobian idx: 4
//
// 	Jacobian idx: 5
//
// 	Jacobian idx: 6
//
// 	Jacobian idx: 1
//
//
// modelInfo:
// ========================================
// algVars (7)
// ----------------------
// index:0: x[1] (no alias)  initial: 	arrCref:x index:(1) []
// index:1: x[2] (no alias)  initial: 	no arrCref index:(2) []
// index:2: x[3] (no alias)  initial: 	no arrCref index:(3) []
// index:3: x[4] (no alias)  initial: 	no arrCref index:(4) []
// index:4: y[1] (no alias)  initial: 	arrCref:y index:(5) []
// index:5: y[2] (no alias)  initial: 	no arrCref index:(6) []
// index:6: y[3] (no alias)  initial: 	no arrCref index:(7) []
// functions:
// -----------
//
// record SimulationResult
//     resultFile = "slice_for_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-6, method = 'dassl', fileNamePrefix = 'slice_for', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = "LOG_SUCCESS       | info    | The initialization finished successfully without homotopy method.
// LOG_SUCCESS       | info    | The simulation finished successfully.
// "
// end SimulationResult;
// ""
// endResult
