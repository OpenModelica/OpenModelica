// name: simple_nested_for
// keywords: NewBackend
// status: correct

loadString("
model simple_nested_for1
  Real x[10,10];
equation
  for i in 1:10 loop
    for j in 1:10 loop
      x[i,j] = i*sin(j*time);
    end for;
  end for;
end simple_nested_for1;

model simple_nested_for2
  parameter Integer s = 10;
  Real x[s,s];
  Real y[s,s];
equation
  for i in 1:s loop
    for j in 1:s loop
      x[i,j] = i*sin(j*time);
      y[j,i] = j + cos(time)^i;
    end for;
  end for;
end simple_nested_for2;

model simple_nested_for3
  parameter Integer s = 10;
  Real x[s,s];
  Real y[s];
equation
  for i in 1:s loop
    y[i] = i + cos(time);
    for j in 1:s loop
      x[i,j] = i*sin(j*time);
    end for;
  end for;
end simple_nested_for3;

model simple_nested_for4
  parameter Integer s = 10;
  Real x[s+1,s];
equation
  for i in 1:s, j in 1:s loop
    x[i,j] = x[i+1,j] + i*sin(j*time);
  end for;
  for i in 1:s loop
    x[s+1,i] = i*cos(time);
  end for;
end simple_nested_for4;

model simple_nested_for5
  Real x[4,3];
equation
  for i in 1:3, j in 1:3 loop
    x[i,j] = x[i+1,j] + i*sin(j*time);
  end for;
  for i in 1:3 loop
    x[4,i] = i*cos(time);
  end for;
end simple_nested_for5;

"); getErrorString();

setCommandLineOptions("--newBackend -d=bltdump,dumpSimCode");
simulate(simple_nested_for5); getErrorString();
val(x[2,1], 0.5);

// Result:
// true
// ""
// true
// ################################################################################
//
// 	[ODE] Differential-Algebraic: (Causalize)
//
// ################################################################################
//
// ========================================
// CONTINUOUS ODE System
// ========================================
//
// BLOCK 1: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[4, i]
// ### Equation:
// 	[FOR-] for i in 1:2 loop
// 	[----]   [SCAL] x[4, i] = CAST(Real, i) * cos(time)
// 	[----] end for;
//     with slices: {0, 1}
//
// BLOCK 2: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[i, j]
// ### Equation:
// 	[FOR-] for {i in 1:3, j in 1:2} loop
// 	[----]   [SCAL] x[i, j] = x[i + 1, j] + CAST(Real, i) * sin(CAST(Real, j) * time)
// 	[----] end for;
//     with slices: {4, 2, 0, 5, 3, 1}
//
// ========================================
// AdjacencyMatrix
// ========================================
//
// Normal Adjacency Matrix (row = equation)
// ****************************************
// 	(1)	{7}
// 	(2)	{8}
// 	(3)	{3, 1}
// 	(4)	{4, 2}
// 	(5)	{5, 3}
// 	(6)	{6, 4}
// 	(7)	{7, 5}
// 	(8)	{8, 6}
//
// Transposed Adjacency Matrix (row = variable)
// ****************************************
// 	(1)	{3}
// 	(2)	{4}
// 	(3)	{5, 3}
// 	(4)	{6, 4}
// 	(5)	{7, 5}
// 	(6)	{8, 6}
// 	(7)	{7, 1}
// 	(8)	{8, 2}
//
// Equation Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 2
// (2)	3 | 6
// Variable Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 8
//
// ========================================
// Scalar Matching
// ========================================
//
// variable to equation
// ****************************************
// 	var 1 --> eqn 3
// 	var 2 --> eqn 4
// 	var 3 --> eqn 5
// 	var 4 --> eqn 6
// 	var 5 --> eqn 7
// 	var 6 --> eqn 8
// 	var 7 --> eqn 1
// 	var 8 --> eqn 2
//
// equation to variable
// ****************************************
// 	eqn 1 --> var 7
// 	eqn 2 --> var 8
// 	eqn 3 --> var 1
// 	eqn 4 --> var 2
// 	eqn 5 --> var 3
// 	eqn 6 --> var 4
// 	eqn 7 --> var 5
// 	eqn 8 --> var 6
//
//
// ################################################################################
//
// 	[ODE] Differential-Algebraic: (Causalize)
//
// ################################################################################
//
// ========================================
// CONTINUOUS ODE System
// ========================================
//
// BLOCK 1: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[4, i]
// ### Equation:
// 	[FOR-] for i in 1:2 loop
// 	[----]   [SCAL] x[4, i] = CAST(Real, i) * cos(time)
// 	[----] end for;
//     with slices: {0, 1}
//
// BLOCK 2: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[i, j]
// ### Equation:
// 	[FOR-] for {i in 1:3, j in 1:2} loop
// 	[----]   [SCAL] x[i, j] = x[i + 1, j] + CAST(Real, i) * sin(CAST(Real, j) * time)
// 	[----] end for;
//     with slices: {4, 2, 0, 5, 3, 1}
//
// ========================================
// AdjacencyMatrix
// ========================================
//
// Normal Adjacency Matrix (row = equation)
// ****************************************
// 	(1)	{7}
// 	(2)	{8}
// 	(3)	{3, 1}
// 	(4)	{4, 2}
// 	(5)	{5, 3}
// 	(6)	{6, 4}
// 	(7)	{7, 5}
// 	(8)	{8, 6}
//
// Transposed Adjacency Matrix (row = variable)
// ****************************************
// 	(1)	{3}
// 	(2)	{4}
// 	(3)	{5, 3}
// 	(4)	{6, 4}
// 	(5)	{7, 5}
// 	(6)	{8, 6}
// 	(7)	{7, 1}
// 	(8)	{8, 2}
//
// Equation Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 2
// (2)	3 | 6
// Variable Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 8
//
// ========================================
// Scalar Matching
// ========================================
//
// variable to equation
// ****************************************
// 	var 1 --> eqn 3
// 	var 2 --> eqn 4
// 	var 3 --> eqn 5
// 	var 4 --> eqn 6
// 	var 5 --> eqn 7
// 	var 6 --> eqn 8
// 	var 7 --> eqn 1
// 	var 8 --> eqn 2
//
// equation to variable
// ****************************************
// 	eqn 1 --> var 7
// 	eqn 2 --> var 8
// 	eqn 3 --> var 1
// 	eqn 4 --> var 2
// 	eqn 5 --> var 3
// 	eqn 6 --> var 4
// 	eqn 7 --> var 5
// 	eqn 8 --> var 6
//
//
// ################################################################################
//
// 	[INI] Initialization: (Causalize)
//
// ################################################################################
//
// ========================================
// CONTINUOUS INI System
// ========================================
//
// BLOCK 1: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[4, i]
// ### Equation:
// 	[FOR-] for i in 1:2 loop
// 	[----]   [SCAL] x[4, i] = CAST(Real, i) * cos(time)
// 	[----] end for;
//     with slices: {0, 1}
//
// BLOCK 2: Sliced Equation
// ----------------------------------------
// ### Variable:
// 	x[i, j]
// ### Equation:
// 	[FOR-] for {i in 1:3, j in 1:2} loop
// 	[----]   [SCAL] x[i, j] = x[i + 1, j] + CAST(Real, i) * sin(CAST(Real, j) * time)
// 	[----] end for;
//     with slices: {4, 2, 0, 5, 3, 1}
//
// ========================================
// AdjacencyMatrix
// ========================================
//
// Normal Adjacency Matrix (row = equation)
// ****************************************
// 	(1)	{3, 1}
// 	(2)	{4, 2}
// 	(3)	{5, 3}
// 	(4)	{6, 4}
// 	(5)	{7, 5}
// 	(6)	{8, 6}
// 	(7)	{7}
// 	(8)	{8}
//
// Transposed Adjacency Matrix (row = variable)
// ****************************************
// 	(1)	{1}
// 	(2)	{2}
// 	(3)	{3, 1}
// 	(4)	{4, 2}
// 	(5)	{5, 3}
// 	(6)	{6, 4}
// 	(7)	{7, 5}
// 	(8)	{8, 6}
//
// Equation Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 6
// (2)	7 | 2
// Variable Index Mapping (ARR) -> START | SIZE
// ****************************************
// (1)	1 | 8
//
// ========================================
// Scalar Matching
// ========================================
//
// variable to equation
// ****************************************
// 	var 1 --> eqn 1
// 	var 2 --> eqn 2
// 	var 3 --> eqn 3
// 	var 4 --> eqn 4
// 	var 5 --> eqn 5
// 	var 6 --> eqn 6
// 	var 7 --> eqn 7
// 	var 8 --> eqn 8
//
// equation to variable
// ****************************************
// 	eqn 1 --> var 1
// 	eqn 2 --> var 2
// 	eqn 3 --> var 3
// 	eqn 4 --> var 4
// 	eqn 5 --> var 5
// 	eqn 6 --> var 6
// 	eqn 7 --> var 7
// 	eqn 8 --> var 8
//
//
// ################################################################################
//
// 	SimCode (simple_nested_for5)
//
// ################################################################################
// ========================================
// SimVars
// ========================================
// Algebraic Variables (8)
// ****************************************
//   (0)[ALGB] x[1, 1]
//   (1)[ALGB] x[1, 2]
//   (2)[ALGB] x[2, 1]
//   (3)[ALGB] x[2, 2]
//   (4)[ALGB] x[3, 1]
//   (5)[ALGB] x[3, 2]
//   (6)[ALGB] x[4, 1]
//   (7)[ALGB] x[4, 2]
//
// INIT
// ----------------------------------------
//   (1) Algorithm
//   for i in 1:2 loop
//     x[4, i] := CAST(Real, i) * cos(time);
//   end for;
//
//   (2) Algorithm
//   for i in 3:(-1):1 loop
//     for j in 1:2 loop
//       x[i, j] := x[1 + i, j] + CAST(Real, i) * sin(CAST(Real, j) * time);
//     end for;
//   end for;
//
//
// Algebraic Partition 1
// ----------------------------------------
//   (3) Algorithm
//   for i in 1:2 loop
//     x[4, i] := CAST(Real, i) * cos(time);
//   end for;
//
//   (4) Algorithm
//   for i in 3:(-1):1 loop
//     for j in 1:2 loop
//       x[i, j] := x[1 + i, j] + CAST(Real, i) * sin(CAST(Real, j) * time);
//     end for;
//   end for;
//
//
// ========================================
// [EMPTY] SimCode Jacobian A(idx = 0, partition = 0)
// ========================================
//
// ========================================
// [EMPTY] SimCode Jacobian B(idx = 1, partition = 0)
// ========================================
//
// ========================================
// [EMPTY] SimCode Jacobian C(idx = 2, partition = 0)
// ========================================
//
// ========================================
// [EMPTY] SimCode Jacobian D(idx = 3, partition = 0)
// ========================================
//
// ========================================
// [EMPTY] SimCode Jacobian F(idx = 4, partition = 0)
// ========================================
//
//
//
// *********************
// * SimCode Equations *
// *********************
//
//
// allEquations:
// ========================================
//
// 3:   for i/* iter index 0 */ in 1:2 loop
//     x[4,i] := /*Real*/(i) * cos(time);
//   end for;
//
// 4:   for i/* iter index 0 */ in 3:-1:1 loop
//     for j/* iter index 0 */ in 1:2 loop
//       x[i,j] := x[1 + i,j] + /*Real*/(i) * sin(/*Real*/(j) * time);
//     end for;
//   end for;
//
// ========================================
//
//
//
// odeEquations (0 systems):
// ========================================
// ========================================
//
//
//
// algebraicEquations (1 systems):
// ========================================
// 3:   for i/* iter index 0 */ in 1:2 loop
//     x[4,i] := /*Real*/(i) * cos(time);
//   end for;
//
// 4:   for i/* iter index 0 */ in 3:-1:1 loop
//     for j/* iter index 0 */ in 1:2 loop
//       x[i,j] := x[1 + i,j] + /*Real*/(i) * sin(/*Real*/(j) * time);
//     end for;
//   end for;
//
// ========================================
//
//
// clockPartitions (0 systems):
//
// ========================================
//
//
//
// initialEquations: (2)
// ========================================
// 1:   for i/* iter index 0 */ in 1:2 loop
//     x[4,i] := /*Real*/(i) * cos(time);
//   end for;
//
// 2:   for i/* iter index 0 */ in 3:-1:1 loop
//     for j/* iter index 0 */ in 1:2 loop
//       x[i,j] := x[1 + i,j] + /*Real*/(i) * sin(/*Real*/(j) * time);
//     end for;
//   end for;
//
// ========================================
//
//
//
// initialEquations_lambda0: (0)
// ========================================
//
// removedInitialEquations:
// ========================================
//
// startValueEquations:
// ========================================
//
// nominalValueEquations:
// ========================================
//
// minValueEquations:
// ========================================
//
// maxValueEquations:
// ========================================
//
// parameterEquations:
// ========================================
//
// removedEquations:
// ========================================
//
// algorithmAndEquationAsserts:
// ========================================
//
// equationsForZeroCrossings:
// ========================================
//
// jacobianEquations:
// ========================================
//
// jacobianMatrices:
// ========================================
// 	Jacobian idx: 0
//
// 	Jacobian idx: 1
//
// 	Jacobian idx: 2
//
// 	Jacobian idx: 3
//
// 	Jacobian idx: 4
//
//
// modelInfo:
// ========================================
// algVars (8)
// ----------------------
// index:0: x[1,1] (no alias)  initial: 	arrCref:x index:(1) []
// index:1: x[1,2] (no alias)  initial: 	no arrCref index:(2) []
// index:2: x[2,1] (no alias)  initial: 	no arrCref index:(3) []
// index:3: x[2,2] (no alias)  initial: 	no arrCref index:(4) []
// index:4: x[3,1] (no alias)  initial: 	no arrCref index:(5) []
// index:5: x[3,2] (no alias)  initial: 	no arrCref index:(6) []
// index:6: x[4,1] (no alias)  initial: 	no arrCref index:(7) []
// index:7: x[4,2] (no alias)  initial: 	no arrCref index:(8) []
// functions:
// -----------
//
// record SimulationResult
//     resultFile = "simple_nested_for5_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'simple_nested_for5', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = "LOG_SUCCESS       | info    | The initialization finished successfully without homotopy method.
// LOG_SUCCESS       | info    | The simulation finished successfully.
// "
// end SimulationResult;
// ""
// 3.274710254911388
// endResult
