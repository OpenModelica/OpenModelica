
//name:        Simulate Modelica.Electrical.MultiPhase.Examples [version 3.1]
//keyword:     instantiating/check/simulate MSL 3.1 Modelica.Electrical.MultiPhase.Examples
// cflags: -d=-newInst
//status:      correct

//
// instantiate/check/simulate model example
//

loadModel(Modelica,{"3.1"}); getErrorString();

// Modelica.Electrical.MultiPhase.Examples
instantiateModel(Modelica.Electrical.MultiPhase.Examples.TransformerYY);  getErrorString(); 
checkModel(Modelica.Electrical.MultiPhase.Examples.TransformerYY);  getErrorString(); 
simulate(Modelica.Electrical.MultiPhase.Examples.TransformerYY);  getErrorString(); 


instantiateModel(Modelica.Electrical.MultiPhase.Examples.TransformerYD);  getErrorString(); 
checkModel(Modelica.Electrical.MultiPhase.Examples.TransformerYD);  getErrorString(); 
simulate(Modelica.Electrical.MultiPhase.Examples.TransformerYD);  getErrorString(); 


instantiateModel(Modelica.Electrical.MultiPhase.Examples.Rectifier);  getErrorString(); 
checkModel(Modelica.Electrical.MultiPhase.Examples.Rectifier);  getErrorString(); 
simulate(Modelica.Electrical.MultiPhase.Examples.Rectifier);  getErrorString(); 


system("rm -f *.c *.dll *.log *.makefile *.cpp *.exe *.h *.libs *_init.xml *_init.txt *_res.mat");


// Result:
// true
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.MultiPhase.Examples.TransformerYY
//   parameter Integer m = 3 \"Number of phases\";
//   parameter Real V(quantity = \"ElectricPotential\", unit = \"V\") = 1.0 \"Amplitude of Star-Voltage\";
//   parameter Real f(quantity = \"Frequency\", unit = \"Hz\") = 5.0 \"Frequency\";
//   parameter Real LT(quantity = \"Inductance\", unit = \"H\") = 0.003 \"Transformer stray inductance\";
//   parameter Real RT(quantity = \"Resistance\", unit = \"Ohm\") = 0.05 \"Transformer resistance\";
//   parameter Real RL(quantity = \"Resistance\", unit = \"Ohm\") = 1.0 \"Load Resistance\";
//   parameter Integer sineVoltage.m(min = 1) = m \"number of phases\";
//   Real sineVoltage.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.V[1](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[2](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[3](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.freqHz[1](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[2](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[3](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   Real sineVoltage.sineVoltage[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[1] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[1] \"Time offset\";
//   output Real sineVoltage.sineVoltage[1].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[1].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[1].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[1].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[1] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[1] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[1] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[2] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[2] \"Time offset\";
//   output Real sineVoltage.sineVoltage[2].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[2].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[2].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[2].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[2] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[2] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[2] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[3] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[3] \"Time offset\";
//   output Real sineVoltage.sineVoltage[3].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[3].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[3].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[3].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[3] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[3] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[3] \"Frequency of sine wave\";
//   parameter Real sineVoltage.phase[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -6.28318530717959 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -12.5663706143592 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.offset[1](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[2](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[3](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.startTime[1](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[2](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[3](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Integer starS.m(min = 1) = m \"number of phases\";
//   parameter Integer starS.plug_p.m(min = 1) = starS.m \"number of phases\";
//   Real starS.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundS.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundS.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.m(min = 1) = m \"number of phases\";
//   Real idealTransformer.v1[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v1[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v1[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v2[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.v2[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.v2[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.i1[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i1[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i1[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i2[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   Real idealTransformer.i2[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   Real idealTransformer.i2[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   parameter Integer idealTransformer.plug_p1.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_p1.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p1.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p1.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_p2.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_p2.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p2.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p2.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_n1.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_n1.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n1.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n1.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_n2.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_n2.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n2.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n2.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.n[1](start = 1.0) \"Turns ratio\";
//   parameter Real idealTransformer.n[2](start = 1.0) \"Turns ratio\";
//   parameter Real idealTransformer.n[3](start = 1.0) \"Turns ratio\";
//   parameter Boolean idealTransformer.considerMagnetization = false;
//   parameter Real idealTransformer.Lm1[1](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   parameter Real idealTransformer.Lm1[2](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   parameter Real idealTransformer.Lm1[3](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   Real idealTransformer.idealTransformer[1].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[1].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[1].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[1].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[1].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[1].n(start = 1.0) = idealTransformer.n[1] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[1].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[1].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[1] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[1].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[1].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   Real idealTransformer.idealTransformer[2].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[2].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[2].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[2].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[2].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[2].n(start = 1.0) = idealTransformer.n[2] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[2].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[2].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[2] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[2].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[2].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   Real idealTransformer.idealTransformer[3].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[3].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[3].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[3].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[3].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[3].n(start = 1.0) = idealTransformer.n[3] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[3].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[3].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[3] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[3].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[3].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   parameter Integer starT1.m(min = 1) = m \"number of phases\";
//   parameter Integer starT1.plug_p.m(min = 1) = starT1.m \"number of phases\";
//   Real starT1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT1.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT1.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer starT2.m(min = 1) = m \"number of phases\";
//   parameter Integer starT2.plug_p.m(min = 1) = starT2.m \"number of phases\";
//   Real starT2.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT2.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT2.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT2.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT2.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT2.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT2.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT2.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundT2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundT2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.m(min = 1) = m \"number of phases\";
//   Real transformerR.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerR.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerR.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer transformerR.plug_p.m(min = 1) = transformerR.m \"number of phases\";
//   Real transformerR.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.plug_n.m(min = 1) = transformerR.m \"number of phases\";
//   Real transformerR.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.mh(min = 1) = transformerR.m \"Number of heatPorts=number of phases\";
//   parameter Boolean transformerR.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real transformerR.R[1](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT \"Resistances R_ref at temperatures T_ref\";
//   parameter Real transformerR.R[2](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT \"Resistances R_ref at temperatures T_ref\";
//   parameter Real transformerR.R[3](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT \"Resistances R_ref at temperatures T_ref\";
//   Real transformerR.resistor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[1].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[1] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[1].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[1] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[1].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[1] \"Reference temperature\";
//   parameter Real transformerR.resistor[1].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[1] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[1].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[2].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[2] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[2].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[2] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[2].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[2] \"Reference temperature\";
//   parameter Real transformerR.resistor[2].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[2] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[2].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[3].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[3] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[3].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[3] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[3].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[3] \"Reference temperature\";
//   parameter Real transformerR.resistor[3].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[3] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[3].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   parameter Real transformerR.T_ref[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.T_ref[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.T_ref[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.alpha[1](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.alpha[2](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.alpha[3](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[1] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real transformerR.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[2] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real transformerR.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[3] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer transformerL.m(min = 1) = m \"number of phases\";
//   Real transformerL.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerL.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerL.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer transformerL.plug_p.m(min = 1) = transformerL.m \"number of phases\";
//   Real transformerL.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerL.plug_n.m(min = 1) = transformerL.m \"number of phases\";
//   Real transformerL.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.L[1](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT \"Inductance\";
//   parameter Real transformerL.L[2](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT \"Inductance\";
//   parameter Real transformerL.L[3](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT \"Inductance\";
//   Real transformerL.inductor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[1].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[1] \"Inductance\";
//   Real transformerL.inductor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[2].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[2] \"Inductance\";
//   Real transformerL.inductor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[3].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[3] \"Inductance\";
//   parameter Integer loadR.m(min = 1) = m \"number of phases\";
//   Real loadR.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real loadR.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real loadR.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer loadR.plug_p.m(min = 1) = loadR.m \"number of phases\";
//   Real loadR.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer loadR.plug_n.m(min = 1) = loadR.m \"number of phases\";
//   Real loadR.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer loadR.mh(min = 1) = loadR.m \"Number of heatPorts=number of phases\";
//   parameter Boolean loadR.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real loadR.R[1](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   parameter Real loadR.R[2](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   parameter Real loadR.R[3](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   Real loadR.resistor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[1].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[1] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[1].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[1] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[1].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[1] \"Reference temperature\";
//   parameter Real loadR.resistor[1].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[1] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[1].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[2].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[2] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[2].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[2] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[2].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[2] \"Reference temperature\";
//   parameter Real loadR.resistor[2].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[2] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[2].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[3].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[3] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[3].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[3] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[3].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[3] \"Reference temperature\";
//   parameter Real loadR.resistor[3].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[3] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[3].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   parameter Real loadR.T_ref[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.T_ref[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.T_ref[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.alpha[1](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.alpha[2](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.alpha[3](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[1] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real loadR.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[2] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real loadR.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[3] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer starL.m(min = 1) = m \"number of phases\";
//   parameter Integer starL.plug_p.m(min = 1) = starL.m \"number of phases\";
//   Real starL.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundT1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundT1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
// equation
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   groundS.p.v = 0.0;
//   idealTransformer.idealTransformer[1].im1 = idealTransformer.idealTransformer[1].i1 + idealTransformer.idealTransformer[1].i2 / idealTransformer.idealTransformer[1].n;
//   idealTransformer.idealTransformer[1].psim1 = 0.0;
//   idealTransformer.idealTransformer[1].im1 = 0.0;
//   idealTransformer.idealTransformer[1].v1 = idealTransformer.idealTransformer[1].n * idealTransformer.idealTransformer[1].v2;
//   idealTransformer.idealTransformer[1].v1 = idealTransformer.idealTransformer[1].p1.v - idealTransformer.idealTransformer[1].n1.v;
//   idealTransformer.idealTransformer[1].v2 = idealTransformer.idealTransformer[1].p2.v - idealTransformer.idealTransformer[1].n2.v;
//   0.0 = idealTransformer.idealTransformer[1].p1.i + idealTransformer.idealTransformer[1].n1.i;
//   0.0 = idealTransformer.idealTransformer[1].p2.i + idealTransformer.idealTransformer[1].n2.i;
//   idealTransformer.idealTransformer[1].i1 = idealTransformer.idealTransformer[1].p1.i;
//   idealTransformer.idealTransformer[1].i2 = idealTransformer.idealTransformer[1].p2.i;
//   idealTransformer.idealTransformer[2].im1 = idealTransformer.idealTransformer[2].i1 + idealTransformer.idealTransformer[2].i2 / idealTransformer.idealTransformer[2].n;
//   idealTransformer.idealTransformer[2].psim1 = 0.0;
//   idealTransformer.idealTransformer[2].im1 = 0.0;
//   idealTransformer.idealTransformer[2].v1 = idealTransformer.idealTransformer[2].n * idealTransformer.idealTransformer[2].v2;
//   idealTransformer.idealTransformer[2].v1 = idealTransformer.idealTransformer[2].p1.v - idealTransformer.idealTransformer[2].n1.v;
//   idealTransformer.idealTransformer[2].v2 = idealTransformer.idealTransformer[2].p2.v - idealTransformer.idealTransformer[2].n2.v;
//   0.0 = idealTransformer.idealTransformer[2].p1.i + idealTransformer.idealTransformer[2].n1.i;
//   0.0 = idealTransformer.idealTransformer[2].p2.i + idealTransformer.idealTransformer[2].n2.i;
//   idealTransformer.idealTransformer[2].i1 = idealTransformer.idealTransformer[2].p1.i;
//   idealTransformer.idealTransformer[2].i2 = idealTransformer.idealTransformer[2].p2.i;
//   idealTransformer.idealTransformer[3].im1 = idealTransformer.idealTransformer[3].i1 + idealTransformer.idealTransformer[3].i2 / idealTransformer.idealTransformer[3].n;
//   idealTransformer.idealTransformer[3].psim1 = 0.0;
//   idealTransformer.idealTransformer[3].im1 = 0.0;
//   idealTransformer.idealTransformer[3].v1 = idealTransformer.idealTransformer[3].n * idealTransformer.idealTransformer[3].v2;
//   idealTransformer.idealTransformer[3].v1 = idealTransformer.idealTransformer[3].p1.v - idealTransformer.idealTransformer[3].n1.v;
//   idealTransformer.idealTransformer[3].v2 = idealTransformer.idealTransformer[3].p2.v - idealTransformer.idealTransformer[3].n2.v;
//   0.0 = idealTransformer.idealTransformer[3].p1.i + idealTransformer.idealTransformer[3].n1.i;
//   0.0 = idealTransformer.idealTransformer[3].p2.i + idealTransformer.idealTransformer[3].n2.i;
//   idealTransformer.idealTransformer[3].i1 = idealTransformer.idealTransformer[3].p1.i;
//   idealTransformer.idealTransformer[3].i2 = idealTransformer.idealTransformer[3].p2.i;
//   idealTransformer.v1[1] = idealTransformer.plug_p1.pin[1].v - idealTransformer.plug_n1.pin[1].v;
//   idealTransformer.v1[2] = idealTransformer.plug_p1.pin[2].v - idealTransformer.plug_n1.pin[2].v;
//   idealTransformer.v1[3] = idealTransformer.plug_p1.pin[3].v - idealTransformer.plug_n1.pin[3].v;
//   idealTransformer.v2[1] = idealTransformer.plug_p2.pin[1].v - idealTransformer.plug_n2.pin[1].v;
//   idealTransformer.v2[2] = idealTransformer.plug_p2.pin[2].v - idealTransformer.plug_n2.pin[2].v;
//   idealTransformer.v2[3] = idealTransformer.plug_p2.pin[3].v - idealTransformer.plug_n2.pin[3].v;
//   idealTransformer.i1[1] = idealTransformer.plug_p1.pin[1].i;
//   idealTransformer.i1[2] = idealTransformer.plug_p1.pin[2].i;
//   idealTransformer.i1[3] = idealTransformer.plug_p1.pin[3].i;
//   idealTransformer.i2[1] = idealTransformer.plug_p2.pin[1].i;
//   idealTransformer.i2[2] = idealTransformer.plug_p2.pin[2].i;
//   idealTransformer.i2[3] = idealTransformer.plug_p2.pin[3].i;
//   groundT2.p.v = 0.0;
//   assert(1.0 + transformerR.resistor[1].alpha * (transformerR.resistor[1].T_heatPort - transformerR.resistor[1].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[1].R_actual = transformerR.resistor[1].R * (1.0 + transformerR.resistor[1].alpha * (transformerR.resistor[1].T_heatPort - transformerR.resistor[1].T_ref));
//   transformerR.resistor[1].v = transformerR.resistor[1].R_actual * transformerR.resistor[1].i;
//   transformerR.resistor[1].LossPower = transformerR.resistor[1].v * transformerR.resistor[1].i;
//   transformerR.resistor[1].i = transformerR.resistor[1].p.i;
//   0.0 = transformerR.resistor[1].p.i + transformerR.resistor[1].n.i;
//   transformerR.resistor[1].v = transformerR.resistor[1].p.v - transformerR.resistor[1].n.v;
//   transformerR.resistor[1].T_heatPort = transformerR.resistor[1].T;
//   assert(1.0 + transformerR.resistor[2].alpha * (transformerR.resistor[2].T_heatPort - transformerR.resistor[2].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[2].R_actual = transformerR.resistor[2].R * (1.0 + transformerR.resistor[2].alpha * (transformerR.resistor[2].T_heatPort - transformerR.resistor[2].T_ref));
//   transformerR.resistor[2].v = transformerR.resistor[2].R_actual * transformerR.resistor[2].i;
//   transformerR.resistor[2].LossPower = transformerR.resistor[2].v * transformerR.resistor[2].i;
//   transformerR.resistor[2].i = transformerR.resistor[2].p.i;
//   0.0 = transformerR.resistor[2].p.i + transformerR.resistor[2].n.i;
//   transformerR.resistor[2].v = transformerR.resistor[2].p.v - transformerR.resistor[2].n.v;
//   transformerR.resistor[2].T_heatPort = transformerR.resistor[2].T;
//   assert(1.0 + transformerR.resistor[3].alpha * (transformerR.resistor[3].T_heatPort - transformerR.resistor[3].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[3].R_actual = transformerR.resistor[3].R * (1.0 + transformerR.resistor[3].alpha * (transformerR.resistor[3].T_heatPort - transformerR.resistor[3].T_ref));
//   transformerR.resistor[3].v = transformerR.resistor[3].R_actual * transformerR.resistor[3].i;
//   transformerR.resistor[3].LossPower = transformerR.resistor[3].v * transformerR.resistor[3].i;
//   transformerR.resistor[3].i = transformerR.resistor[3].p.i;
//   0.0 = transformerR.resistor[3].p.i + transformerR.resistor[3].n.i;
//   transformerR.resistor[3].v = transformerR.resistor[3].p.v - transformerR.resistor[3].n.v;
//   transformerR.resistor[3].T_heatPort = transformerR.resistor[3].T;
//   transformerR.v[1] = transformerR.plug_p.pin[1].v - transformerR.plug_n.pin[1].v;
//   transformerR.v[2] = transformerR.plug_p.pin[2].v - transformerR.plug_n.pin[2].v;
//   transformerR.v[3] = transformerR.plug_p.pin[3].v - transformerR.plug_n.pin[3].v;
//   transformerR.i[1] = transformerR.plug_p.pin[1].i;
//   transformerR.i[2] = transformerR.plug_p.pin[2].i;
//   transformerR.i[3] = transformerR.plug_p.pin[3].i;
//   transformerL.inductor[1].L * der(transformerL.inductor[1].i) = transformerL.inductor[1].v;
//   transformerL.inductor[1].v = transformerL.inductor[1].p.v - transformerL.inductor[1].n.v;
//   0.0 = transformerL.inductor[1].p.i + transformerL.inductor[1].n.i;
//   transformerL.inductor[1].i = transformerL.inductor[1].p.i;
//   transformerL.inductor[2].L * der(transformerL.inductor[2].i) = transformerL.inductor[2].v;
//   transformerL.inductor[2].v = transformerL.inductor[2].p.v - transformerL.inductor[2].n.v;
//   0.0 = transformerL.inductor[2].p.i + transformerL.inductor[2].n.i;
//   transformerL.inductor[2].i = transformerL.inductor[2].p.i;
//   transformerL.inductor[3].L * der(transformerL.inductor[3].i) = transformerL.inductor[3].v;
//   transformerL.inductor[3].v = transformerL.inductor[3].p.v - transformerL.inductor[3].n.v;
//   0.0 = transformerL.inductor[3].p.i + transformerL.inductor[3].n.i;
//   transformerL.inductor[3].i = transformerL.inductor[3].p.i;
//   transformerL.v[1] = transformerL.plug_p.pin[1].v - transformerL.plug_n.pin[1].v;
//   transformerL.v[2] = transformerL.plug_p.pin[2].v - transformerL.plug_n.pin[2].v;
//   transformerL.v[3] = transformerL.plug_p.pin[3].v - transformerL.plug_n.pin[3].v;
//   transformerL.i[1] = transformerL.plug_p.pin[1].i;
//   transformerL.i[2] = transformerL.plug_p.pin[2].i;
//   transformerL.i[3] = transformerL.plug_p.pin[3].i;
//   assert(1.0 + loadR.resistor[1].alpha * (loadR.resistor[1].T_heatPort - loadR.resistor[1].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[1].R_actual = loadR.resistor[1].R * (1.0 + loadR.resistor[1].alpha * (loadR.resistor[1].T_heatPort - loadR.resistor[1].T_ref));
//   loadR.resistor[1].v = loadR.resistor[1].R_actual * loadR.resistor[1].i;
//   loadR.resistor[1].LossPower = loadR.resistor[1].v * loadR.resistor[1].i;
//   loadR.resistor[1].i = loadR.resistor[1].p.i;
//   0.0 = loadR.resistor[1].p.i + loadR.resistor[1].n.i;
//   loadR.resistor[1].v = loadR.resistor[1].p.v - loadR.resistor[1].n.v;
//   loadR.resistor[1].T_heatPort = loadR.resistor[1].T;
//   assert(1.0 + loadR.resistor[2].alpha * (loadR.resistor[2].T_heatPort - loadR.resistor[2].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[2].R_actual = loadR.resistor[2].R * (1.0 + loadR.resistor[2].alpha * (loadR.resistor[2].T_heatPort - loadR.resistor[2].T_ref));
//   loadR.resistor[2].v = loadR.resistor[2].R_actual * loadR.resistor[2].i;
//   loadR.resistor[2].LossPower = loadR.resistor[2].v * loadR.resistor[2].i;
//   loadR.resistor[2].i = loadR.resistor[2].p.i;
//   0.0 = loadR.resistor[2].p.i + loadR.resistor[2].n.i;
//   loadR.resistor[2].v = loadR.resistor[2].p.v - loadR.resistor[2].n.v;
//   loadR.resistor[2].T_heatPort = loadR.resistor[2].T;
//   assert(1.0 + loadR.resistor[3].alpha * (loadR.resistor[3].T_heatPort - loadR.resistor[3].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[3].R_actual = loadR.resistor[3].R * (1.0 + loadR.resistor[3].alpha * (loadR.resistor[3].T_heatPort - loadR.resistor[3].T_ref));
//   loadR.resistor[3].v = loadR.resistor[3].R_actual * loadR.resistor[3].i;
//   loadR.resistor[3].LossPower = loadR.resistor[3].v * loadR.resistor[3].i;
//   loadR.resistor[3].i = loadR.resistor[3].p.i;
//   0.0 = loadR.resistor[3].p.i + loadR.resistor[3].n.i;
//   loadR.resistor[3].v = loadR.resistor[3].p.v - loadR.resistor[3].n.v;
//   loadR.resistor[3].T_heatPort = loadR.resistor[3].T;
//   loadR.v[1] = loadR.plug_p.pin[1].v - loadR.plug_n.pin[1].v;
//   loadR.v[2] = loadR.plug_p.pin[2].v - loadR.plug_n.pin[2].v;
//   loadR.v[3] = loadR.plug_p.pin[3].v - loadR.plug_n.pin[3].v;
//   loadR.i[1] = loadR.plug_p.pin[1].i;
//   loadR.i[2] = loadR.plug_p.pin[2].i;
//   loadR.i[3] = loadR.plug_p.pin[3].i;
//   groundT1.p.v = 0.0;
//   assert(starS.plug_p.m == sineVoltage.plug_n.m,\"automatically generated from connect\");
//   assert(sineVoltage.plug_p.m == idealTransformer.plug_p1.m,\"automatically generated from connect\");
//   assert(idealTransformer.plug_n1.m == starT1.plug_p.m,\"automatically generated from connect\");
//   assert(starT2.plug_p.m == idealTransformer.plug_n2.m,\"automatically generated from connect\");
//   assert(idealTransformer.plug_p2.m == transformerR.plug_p.m,\"automatically generated from connect\");
//   assert(transformerR.plug_n.m == transformerL.plug_p.m,\"automatically generated from connect\");
//   assert(transformerL.plug_n.m == loadR.plug_p.m,\"automatically generated from connect\");
//   assert(loadR.plug_n.m == starL.plug_p.m,\"automatically generated from connect\");
//   loadR.plug_n.pin[3].i + starL.plug_p.pin[3].i = 0.0;
//   loadR.plug_n.pin[3].v = starL.plug_p.pin[3].v;
//   loadR.plug_n.pin[2].i + starL.plug_p.pin[2].i = 0.0;
//   loadR.plug_n.pin[2].v = starL.plug_p.pin[2].v;
//   loadR.plug_n.pin[1].i + starL.plug_p.pin[1].i = 0.0;
//   loadR.plug_n.pin[1].v = starL.plug_p.pin[1].v;
//   transformerL.plug_n.pin[3].i + loadR.plug_p.pin[3].i = 0.0;
//   loadR.plug_p.pin[3].v = transformerL.plug_n.pin[3].v;
//   transformerL.plug_n.pin[2].i + loadR.plug_p.pin[2].i = 0.0;
//   loadR.plug_p.pin[2].v = transformerL.plug_n.pin[2].v;
//   transformerL.plug_n.pin[1].i + loadR.plug_p.pin[1].i = 0.0;
//   loadR.plug_p.pin[1].v = transformerL.plug_n.pin[1].v;
//   transformerR.plug_n.pin[3].i + transformerL.plug_p.pin[3].i = 0.0;
//   transformerL.plug_p.pin[3].v = transformerR.plug_n.pin[3].v;
//   transformerR.plug_n.pin[2].i + transformerL.plug_p.pin[2].i = 0.0;
//   transformerL.plug_p.pin[2].v = transformerR.plug_n.pin[2].v;
//   transformerR.plug_n.pin[1].i + transformerL.plug_p.pin[1].i = 0.0;
//   transformerL.plug_p.pin[1].v = transformerR.plug_n.pin[1].v;
//   idealTransformer.plug_p2.pin[3].i + transformerR.plug_p.pin[3].i = 0.0;
//   idealTransformer.plug_p2.pin[3].v = transformerR.plug_p.pin[3].v;
//   idealTransformer.plug_p2.pin[2].i + transformerR.plug_p.pin[2].i = 0.0;
//   idealTransformer.plug_p2.pin[2].v = transformerR.plug_p.pin[2].v;
//   idealTransformer.plug_p2.pin[1].i + transformerR.plug_p.pin[1].i = 0.0;
//   idealTransformer.plug_p2.pin[1].v = transformerR.plug_p.pin[1].v;
//   starT2.plug_p.pin[3].i + idealTransformer.plug_n2.pin[3].i = 0.0;
//   idealTransformer.plug_n2.pin[3].v = starT2.plug_p.pin[3].v;
//   starT2.plug_p.pin[2].i + idealTransformer.plug_n2.pin[2].i = 0.0;
//   idealTransformer.plug_n2.pin[2].v = starT2.plug_p.pin[2].v;
//   starT2.plug_p.pin[1].i + idealTransformer.plug_n2.pin[1].i = 0.0;
//   idealTransformer.plug_n2.pin[1].v = starT2.plug_p.pin[1].v;
//   idealTransformer.plug_n1.pin[3].i + starT1.plug_p.pin[3].i = 0.0;
//   idealTransformer.plug_n1.pin[3].v = starT1.plug_p.pin[3].v;
//   idealTransformer.plug_n1.pin[2].i + starT1.plug_p.pin[2].i = 0.0;
//   idealTransformer.plug_n1.pin[2].v = starT1.plug_p.pin[2].v;
//   idealTransformer.plug_n1.pin[1].i + starT1.plug_p.pin[1].i = 0.0;
//   idealTransformer.plug_n1.pin[1].v = starT1.plug_p.pin[1].v;
//   sineVoltage.plug_p.pin[3].i + idealTransformer.plug_p1.pin[3].i = 0.0;
//   idealTransformer.plug_p1.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + idealTransformer.plug_p1.pin[2].i = 0.0;
//   idealTransformer.plug_p1.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + idealTransformer.plug_p1.pin[1].i = 0.0;
//   idealTransformer.plug_p1.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   starS.plug_p.pin[3].i + sineVoltage.plug_n.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = starS.plug_p.pin[3].v;
//   starS.plug_p.pin[2].i + sineVoltage.plug_n.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = starS.plug_p.pin[2].v;
//   starS.plug_p.pin[1].i + sineVoltage.plug_n.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = starS.plug_p.pin[1].v;
//   starT2.pin_n.i + groundT2.p.i = 0.0;
//   groundT2.p.v = starT2.pin_n.v;
//   starT1.pin_n.i + groundT1.p.i = 0.0;
//   groundT1.p.v = starT1.pin_n.v;
//   starS.pin_n.i + groundS.p.i = 0.0;
//   groundS.p.v = starS.pin_n.v;
//   (-starL.plug_p.pin[3].i) + ((-starL.plug_p.pin[2].i) + ((-starL.plug_p.pin[1].i) + (-starL.pin_n.i))) = 0.0;
//   starL.pin_n.v = starL.plug_p.pin[1].v;
//   starL.pin_n.v = starL.plug_p.pin[2].v;
//   starL.pin_n.v = starL.plug_p.pin[3].v;
//   starL.pin_n.i = 0.0;
//   loadR.resistor[3].n.i + (-loadR.plug_n.pin[3].i) = 0.0;
//   loadR.plug_n.pin[3].v = loadR.resistor[3].n.v;
//   loadR.resistor[2].n.i + (-loadR.plug_n.pin[2].i) = 0.0;
//   loadR.plug_n.pin[2].v = loadR.resistor[2].n.v;
//   loadR.resistor[1].n.i + (-loadR.plug_n.pin[1].i) = 0.0;
//   loadR.plug_n.pin[1].v = loadR.resistor[1].n.v;
//   loadR.resistor[3].p.i + (-loadR.plug_p.pin[3].i) = 0.0;
//   loadR.plug_p.pin[3].v = loadR.resistor[3].p.v;
//   loadR.resistor[2].p.i + (-loadR.plug_p.pin[2].i) = 0.0;
//   loadR.plug_p.pin[2].v = loadR.resistor[2].p.v;
//   loadR.resistor[1].p.i + (-loadR.plug_p.pin[1].i) = 0.0;
//   loadR.plug_p.pin[1].v = loadR.resistor[1].p.v;
//   transformerL.inductor[3].n.i + (-transformerL.plug_n.pin[3].i) = 0.0;
//   transformerL.inductor[3].n.v = transformerL.plug_n.pin[3].v;
//   transformerL.inductor[2].n.i + (-transformerL.plug_n.pin[2].i) = 0.0;
//   transformerL.inductor[2].n.v = transformerL.plug_n.pin[2].v;
//   transformerL.inductor[1].n.i + (-transformerL.plug_n.pin[1].i) = 0.0;
//   transformerL.inductor[1].n.v = transformerL.plug_n.pin[1].v;
//   transformerL.inductor[3].p.i + (-transformerL.plug_p.pin[3].i) = 0.0;
//   transformerL.inductor[3].p.v = transformerL.plug_p.pin[3].v;
//   transformerL.inductor[2].p.i + (-transformerL.plug_p.pin[2].i) = 0.0;
//   transformerL.inductor[2].p.v = transformerL.plug_p.pin[2].v;
//   transformerL.inductor[1].p.i + (-transformerL.plug_p.pin[1].i) = 0.0;
//   transformerL.inductor[1].p.v = transformerL.plug_p.pin[1].v;
//   transformerR.resistor[3].n.i + (-transformerR.plug_n.pin[3].i) = 0.0;
//   transformerR.plug_n.pin[3].v = transformerR.resistor[3].n.v;
//   transformerR.resistor[2].n.i + (-transformerR.plug_n.pin[2].i) = 0.0;
//   transformerR.plug_n.pin[2].v = transformerR.resistor[2].n.v;
//   transformerR.resistor[1].n.i + (-transformerR.plug_n.pin[1].i) = 0.0;
//   transformerR.plug_n.pin[1].v = transformerR.resistor[1].n.v;
//   transformerR.resistor[3].p.i + (-transformerR.plug_p.pin[3].i) = 0.0;
//   transformerR.plug_p.pin[3].v = transformerR.resistor[3].p.v;
//   transformerR.resistor[2].p.i + (-transformerR.plug_p.pin[2].i) = 0.0;
//   transformerR.plug_p.pin[2].v = transformerR.resistor[2].p.v;
//   transformerR.resistor[1].p.i + (-transformerR.plug_p.pin[1].i) = 0.0;
//   transformerR.plug_p.pin[1].v = transformerR.resistor[1].p.v;
//   (-starT2.plug_p.pin[3].i) + ((-starT2.plug_p.pin[2].i) + ((-starT2.plug_p.pin[1].i) + (-starT2.pin_n.i))) = 0.0;
//   starT2.pin_n.v = starT2.plug_p.pin[1].v;
//   starT2.pin_n.v = starT2.plug_p.pin[2].v;
//   starT2.pin_n.v = starT2.plug_p.pin[3].v;
//   (-starT1.plug_p.pin[3].i) + ((-starT1.plug_p.pin[2].i) + ((-starT1.plug_p.pin[1].i) + (-starT1.pin_n.i))) = 0.0;
//   starT1.pin_n.v = starT1.plug_p.pin[1].v;
//   starT1.pin_n.v = starT1.plug_p.pin[2].v;
//   starT1.pin_n.v = starT1.plug_p.pin[3].v;
//   (-idealTransformer.plug_n2.pin[3].i) + idealTransformer.idealTransformer[3].n2.i = 0.0;
//   idealTransformer.idealTransformer[3].n2.v = idealTransformer.plug_n2.pin[3].v;
//   (-idealTransformer.plug_n2.pin[2].i) + idealTransformer.idealTransformer[2].n2.i = 0.0;
//   idealTransformer.idealTransformer[2].n2.v = idealTransformer.plug_n2.pin[2].v;
//   (-idealTransformer.plug_n2.pin[1].i) + idealTransformer.idealTransformer[1].n2.i = 0.0;
//   idealTransformer.idealTransformer[1].n2.v = idealTransformer.plug_n2.pin[1].v;
//   (-idealTransformer.plug_n1.pin[3].i) + idealTransformer.idealTransformer[3].n1.i = 0.0;
//   idealTransformer.idealTransformer[3].n1.v = idealTransformer.plug_n1.pin[3].v;
//   (-idealTransformer.plug_n1.pin[2].i) + idealTransformer.idealTransformer[2].n1.i = 0.0;
//   idealTransformer.idealTransformer[2].n1.v = idealTransformer.plug_n1.pin[2].v;
//   (-idealTransformer.plug_n1.pin[1].i) + idealTransformer.idealTransformer[1].n1.i = 0.0;
//   idealTransformer.idealTransformer[1].n1.v = idealTransformer.plug_n1.pin[1].v;
//   (-idealTransformer.plug_p2.pin[3].i) + idealTransformer.idealTransformer[3].p2.i = 0.0;
//   idealTransformer.idealTransformer[3].p2.v = idealTransformer.plug_p2.pin[3].v;
//   (-idealTransformer.plug_p2.pin[2].i) + idealTransformer.idealTransformer[2].p2.i = 0.0;
//   idealTransformer.idealTransformer[2].p2.v = idealTransformer.plug_p2.pin[2].v;
//   (-idealTransformer.plug_p2.pin[1].i) + idealTransformer.idealTransformer[1].p2.i = 0.0;
//   idealTransformer.idealTransformer[1].p2.v = idealTransformer.plug_p2.pin[1].v;
//   (-idealTransformer.plug_p1.pin[3].i) + idealTransformer.idealTransformer[3].p1.i = 0.0;
//   idealTransformer.idealTransformer[3].p1.v = idealTransformer.plug_p1.pin[3].v;
//   (-idealTransformer.plug_p1.pin[2].i) + idealTransformer.idealTransformer[2].p1.i = 0.0;
//   idealTransformer.idealTransformer[2].p1.v = idealTransformer.plug_p1.pin[2].v;
//   (-idealTransformer.plug_p1.pin[1].i) + idealTransformer.idealTransformer[1].p1.i = 0.0;
//   idealTransformer.idealTransformer[1].p1.v = idealTransformer.plug_p1.pin[1].v;
//   (-starS.plug_p.pin[3].i) + ((-starS.plug_p.pin[2].i) + ((-starS.plug_p.pin[1].i) + (-starS.pin_n.i))) = 0.0;
//   starS.pin_n.v = starS.plug_p.pin[1].v;
//   starS.pin_n.v = starS.plug_p.pin[2].v;
//   starS.pin_n.v = starS.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
// end Modelica.Electrical.MultiPhase.Examples.TransformerYY;
// "
// ""
// "Check of Modelica.Electrical.MultiPhase.Examples.TransformerYY completed successfully.
// 
// 
// Class Modelica.Electrical.MultiPhase.Examples.TransformerYY has 281 equation(s) and 281 variable(s).
// 235 of these are trivial equation(s).
// "
// ""
// record SimulationResult
//     resultFile = "Modelica.Electrical.MultiPhase.Examples.TransformerYY_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'Modelica.Electrical.MultiPhase.Examples.TransformerYY', storeInTemp = false, noClean = false, options = '', outputFormat = 'mat', variableFilter = '.*', cflags = ''",
//     messages = ""
// end SimulationResult;
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.cos
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.cos;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.MultiPhase.Examples.TransformerYD
//   parameter Integer m = 3 \"Number of phases\";
//   parameter Real V(quantity = \"ElectricPotential\", unit = \"V\") = 1.0 \"Amplitude of Star-Voltage\";
//   parameter Real f(quantity = \"Frequency\", unit = \"Hz\") = 5.0 \"Frequency\";
//   parameter Real LT(quantity = \"Inductance\", unit = \"H\") = 0.003 \"Transformer stray inductance\";
//   parameter Real RT(quantity = \"Resistance\", unit = \"Ohm\") = 0.05 \"Transformer resistance\";
//   parameter Real RL(quantity = \"Resistance\", unit = \"Ohm\") = 1.0 \"Load Resistance\";
//   parameter Integer sineVoltage.m(min = 1) = m \"number of phases\";
//   Real sineVoltage.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.V[1](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[2](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[3](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.freqHz[1](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[2](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[3](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   Real sineVoltage.sineVoltage[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[1] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[1] \"Time offset\";
//   output Real sineVoltage.sineVoltage[1].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[1].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[1].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[1].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[1] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[1] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[1] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[2] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[2] \"Time offset\";
//   output Real sineVoltage.sineVoltage[2].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[2].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[2].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[2].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[2] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[2] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[2] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[3] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[3] \"Time offset\";
//   output Real sineVoltage.sineVoltage[3].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[3].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[3].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[3].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[3] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[3] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[3] \"Frequency of sine wave\";
//   parameter Real sineVoltage.phase[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -6.28318530717959 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -12.5663706143592 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.offset[1](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[2](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[3](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.startTime[1](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[2](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[3](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Integer starS.m(min = 1) = m \"number of phases\";
//   parameter Integer starS.plug_p.m(min = 1) = starS.m \"number of phases\";
//   Real starS.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundS.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundS.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.m(min = 1) = m \"number of phases\";
//   Real idealTransformer.v1[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v1[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v1[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the left port\";
//   Real idealTransformer.v2[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.v2[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.v2[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops over the right port\";
//   Real idealTransformer.i1[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i1[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i1[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the left port\";
//   Real idealTransformer.i2[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   Real idealTransformer.i2[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   Real idealTransformer.i2[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into positive plug of the right port\";
//   parameter Integer idealTransformer.plug_p1.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_p1.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p1.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p1.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p1.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_p2.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_p2.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p2.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_p2.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_p2.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_n1.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_n1.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n1.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n1.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n1.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealTransformer.plug_n2.m(min = 1) = idealTransformer.m \"number of phases\";
//   Real idealTransformer.plug_n2.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n2.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.plug_n2.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.plug_n2.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.n[1](start = 1.0) = nT \"Turns ratio\";
//   parameter Real idealTransformer.n[2](start = 1.0) = nT \"Turns ratio\";
//   parameter Real idealTransformer.n[3](start = 1.0) = nT \"Turns ratio\";
//   parameter Boolean idealTransformer.considerMagnetization = false;
//   parameter Real idealTransformer.Lm1[1](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   parameter Real idealTransformer.Lm1[2](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   parameter Real idealTransformer.Lm1[3](quantity = \"Inductance\", unit = \"H\", start = 1.0) \"Magnetization inductances w.r.t. primary side\";
//   Real idealTransformer.idealTransformer[1].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[1].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[1].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[1].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[1].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[1].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[1].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[1].n(start = 1.0) = idealTransformer.n[1] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[1].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[1].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[1] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[1].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[1].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   Real idealTransformer.idealTransformer[2].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[2].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[2].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[2].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[2].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[2].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[2].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[2].n(start = 1.0) = idealTransformer.n[2] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[2].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[2].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[2] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[2].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[2].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   Real idealTransformer.idealTransformer[3].v1(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the left port\";
//   Real idealTransformer.idealTransformer[3].v2(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop over the right port\";
//   Real idealTransformer.idealTransformer[3].i1(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the left port\";
//   Real idealTransformer.idealTransformer[3].i2(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pos. to neg. pin of the right port\";
//   Real idealTransformer.idealTransformer[3].p1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].p1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].n1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].n1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].p2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].p2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealTransformer.idealTransformer[3].n2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealTransformer.idealTransformer[3].n2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real idealTransformer.idealTransformer[3].n(start = 1.0) = idealTransformer.n[3] \"Turns ratio primary:secondary voltage\";
//   parameter Boolean idealTransformer.idealTransformer[3].considerMagnetization = idealTransformer.considerMagnetization;
//   parameter Real idealTransformer.idealTransformer[3].Lm1(quantity = \"Inductance\", unit = \"H\", start = 1.0) = idealTransformer.Lm1[3] \"Magnetization inductance w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[3].im1(quantity = \"ElectricCurrent\", unit = \"A\") \"Magnetization current w.r.t. primary side\";
//   protected Real idealTransformer.idealTransformer[3].psim1(quantity = \"MagneticFlux\", unit = \"Wb\") \"Magnetic flux w.r.t primary side\";
//   parameter Integer starT.m(min = 1) = m \"number of phases\";
//   parameter Integer starT.plug_p.m(min = 1) = starT.m \"number of phases\";
//   Real starT.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starT.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starT.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer deltaT2.m(min = 2) = m \"number of phases\";
//   parameter Integer deltaT2.plug_p.m(min = 1) = deltaT2.m \"number of phases\";
//   Real deltaT2.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real deltaT2.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real deltaT2.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer deltaT2.plug_n.m(min = 1) = deltaT2.m \"number of phases\";
//   Real deltaT2.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real deltaT2.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real deltaT2.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real deltaT2.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundT.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundT.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.m(min = 1) = m \"number of phases\";
//   Real transformerR.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerR.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerR.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerR.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer transformerR.plug_p.m(min = 1) = transformerR.m \"number of phases\";
//   Real transformerR.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.plug_n.m(min = 1) = transformerR.m \"number of phases\";
//   Real transformerR.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerR.mh(min = 1) = transformerR.m \"Number of heatPorts=number of phases\";
//   parameter Boolean transformerR.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real transformerR.R[1](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT * nT ^ -2.0 \"Resistances R_ref at temperatures T_ref\";
//   parameter Real transformerR.R[2](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT * nT ^ -2.0 \"Resistances R_ref at temperatures T_ref\";
//   parameter Real transformerR.R[3](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RT * nT ^ -2.0 \"Resistances R_ref at temperatures T_ref\";
//   Real transformerR.resistor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[1].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[1] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[1].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[1] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[1].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[1] \"Reference temperature\";
//   parameter Real transformerR.resistor[1].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[1] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[1].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[2].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[2] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[2].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[2] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[2].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[2] \"Reference temperature\";
//   parameter Real transformerR.resistor[2].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[2] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[2].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerR.resistor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerR.resistor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerR.resistor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerR.resistor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean transformerR.resistor[3].useHeatPort = transformerR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real transformerR.resistor[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T[3] \"Fixed device temperature if useHeatPort = false\";
//   Real transformerR.resistor[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real transformerR.resistor[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real transformerR.resistor[3].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = transformerR.R[3] \"Resistance at temperature T_ref\";
//   parameter Real transformerR.resistor[3].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[3] \"Reference temperature\";
//   parameter Real transformerR.resistor[3].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = transformerR.alpha[3] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real transformerR.resistor[3].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   parameter Real transformerR.T_ref[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.T_ref[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.T_ref[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real transformerR.alpha[1](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.alpha[2](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.alpha[3](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real transformerR.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[1] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real transformerR.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[2] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real transformerR.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = transformerR.T_ref[3] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer transformerL.m(min = 1) = m \"number of phases\";
//   Real transformerL.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real transformerL.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerL.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real transformerL.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer transformerL.plug_p.m(min = 1) = transformerL.m \"number of phases\";
//   Real transformerL.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer transformerL.plug_n.m(min = 1) = transformerL.m \"number of phases\";
//   Real transformerL.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.L[1](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT * nT ^ -2.0 \"Inductance\";
//   parameter Real transformerL.L[2](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT * nT ^ -2.0 \"Inductance\";
//   parameter Real transformerL.L[3](quantity = \"Inductance\", unit = \"H\", start = 1.0) = LT * nT ^ -2.0 \"Inductance\";
//   Real transformerL.inductor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[1].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[1] \"Inductance\";
//   Real transformerL.inductor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[2].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[2] \"Inductance\";
//   Real transformerL.inductor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real transformerL.inductor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real transformerL.inductor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real transformerL.inductor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real transformerL.inductor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real transformerL.inductor[3].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = transformerL.L[3] \"Inductance\";
//   parameter Integer loadR.m(min = 1) = m \"number of phases\";
//   Real loadR.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real loadR.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real loadR.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real loadR.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer loadR.plug_p.m(min = 1) = loadR.m \"number of phases\";
//   Real loadR.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer loadR.plug_n.m(min = 1) = loadR.m \"number of phases\";
//   Real loadR.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer loadR.mh(min = 1) = loadR.m \"Number of heatPorts=number of phases\";
//   parameter Boolean loadR.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real loadR.R[1](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   parameter Real loadR.R[2](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   parameter Real loadR.R[3](quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistances R_ref at temperatures T_ref\";
//   Real loadR.resistor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[1].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[1] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[1].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[1] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[1].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[1] \"Reference temperature\";
//   parameter Real loadR.resistor[1].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[1] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[1].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[2].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[2] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[2].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[2] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[2].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[2] \"Reference temperature\";
//   parameter Real loadR.resistor[2].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[2] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[2].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.resistor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.resistor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.resistor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.resistor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.resistor[3].useHeatPort = loadR.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real loadR.resistor[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T[3] \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.resistor[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.resistor[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.resistor[3].R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = loadR.R[3] \"Resistance at temperature T_ref\";
//   parameter Real loadR.resistor[3].T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[3] \"Reference temperature\";
//   parameter Real loadR.resistor[3].alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = loadR.alpha[3] \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.resistor[3].R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   parameter Real loadR.T_ref[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.T_ref[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.T_ref[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperatures\";
//   parameter Real loadR.alpha[1](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.alpha[2](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.alpha[3](quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficients of resistances at reference temperatures\";
//   parameter Real loadR.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[1] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real loadR.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[2] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real loadR.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref[3] \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer starL.m(min = 1) = m \"number of phases\";
//   parameter Integer starL.plug_p.m(min = 1) = starL.m \"number of phases\";
//   Real starL.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starL.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starL.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real groundL.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundL.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real nT = 1.0 / sqrt((1.0 - cos(6.28318530717959 / Real(m))) ^ 2.0 + sin(6.28318530717959 / Real(m)) ^ 2.0) \"Transformer ratio\";
// equation
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   groundS.p.v = 0.0;
//   idealTransformer.idealTransformer[1].im1 = idealTransformer.idealTransformer[1].i1 + idealTransformer.idealTransformer[1].i2 / idealTransformer.idealTransformer[1].n;
//   idealTransformer.idealTransformer[1].psim1 = 0.0;
//   idealTransformer.idealTransformer[1].im1 = 0.0;
//   idealTransformer.idealTransformer[1].v1 = idealTransformer.idealTransformer[1].n * idealTransformer.idealTransformer[1].v2;
//   idealTransformer.idealTransformer[1].v1 = idealTransformer.idealTransformer[1].p1.v - idealTransformer.idealTransformer[1].n1.v;
//   idealTransformer.idealTransformer[1].v2 = idealTransformer.idealTransformer[1].p2.v - idealTransformer.idealTransformer[1].n2.v;
//   0.0 = idealTransformer.idealTransformer[1].p1.i + idealTransformer.idealTransformer[1].n1.i;
//   0.0 = idealTransformer.idealTransformer[1].p2.i + idealTransformer.idealTransformer[1].n2.i;
//   idealTransformer.idealTransformer[1].i1 = idealTransformer.idealTransformer[1].p1.i;
//   idealTransformer.idealTransformer[1].i2 = idealTransformer.idealTransformer[1].p2.i;
//   idealTransformer.idealTransformer[2].im1 = idealTransformer.idealTransformer[2].i1 + idealTransformer.idealTransformer[2].i2 / idealTransformer.idealTransformer[2].n;
//   idealTransformer.idealTransformer[2].psim1 = 0.0;
//   idealTransformer.idealTransformer[2].im1 = 0.0;
//   idealTransformer.idealTransformer[2].v1 = idealTransformer.idealTransformer[2].n * idealTransformer.idealTransformer[2].v2;
//   idealTransformer.idealTransformer[2].v1 = idealTransformer.idealTransformer[2].p1.v - idealTransformer.idealTransformer[2].n1.v;
//   idealTransformer.idealTransformer[2].v2 = idealTransformer.idealTransformer[2].p2.v - idealTransformer.idealTransformer[2].n2.v;
//   0.0 = idealTransformer.idealTransformer[2].p1.i + idealTransformer.idealTransformer[2].n1.i;
//   0.0 = idealTransformer.idealTransformer[2].p2.i + idealTransformer.idealTransformer[2].n2.i;
//   idealTransformer.idealTransformer[2].i1 = idealTransformer.idealTransformer[2].p1.i;
//   idealTransformer.idealTransformer[2].i2 = idealTransformer.idealTransformer[2].p2.i;
//   idealTransformer.idealTransformer[3].im1 = idealTransformer.idealTransformer[3].i1 + idealTransformer.idealTransformer[3].i2 / idealTransformer.idealTransformer[3].n;
//   idealTransformer.idealTransformer[3].psim1 = 0.0;
//   idealTransformer.idealTransformer[3].im1 = 0.0;
//   idealTransformer.idealTransformer[3].v1 = idealTransformer.idealTransformer[3].n * idealTransformer.idealTransformer[3].v2;
//   idealTransformer.idealTransformer[3].v1 = idealTransformer.idealTransformer[3].p1.v - idealTransformer.idealTransformer[3].n1.v;
//   idealTransformer.idealTransformer[3].v2 = idealTransformer.idealTransformer[3].p2.v - idealTransformer.idealTransformer[3].n2.v;
//   0.0 = idealTransformer.idealTransformer[3].p1.i + idealTransformer.idealTransformer[3].n1.i;
//   0.0 = idealTransformer.idealTransformer[3].p2.i + idealTransformer.idealTransformer[3].n2.i;
//   idealTransformer.idealTransformer[3].i1 = idealTransformer.idealTransformer[3].p1.i;
//   idealTransformer.idealTransformer[3].i2 = idealTransformer.idealTransformer[3].p2.i;
//   idealTransformer.v1[1] = idealTransformer.plug_p1.pin[1].v - idealTransformer.plug_n1.pin[1].v;
//   idealTransformer.v1[2] = idealTransformer.plug_p1.pin[2].v - idealTransformer.plug_n1.pin[2].v;
//   idealTransformer.v1[3] = idealTransformer.plug_p1.pin[3].v - idealTransformer.plug_n1.pin[3].v;
//   idealTransformer.v2[1] = idealTransformer.plug_p2.pin[1].v - idealTransformer.plug_n2.pin[1].v;
//   idealTransformer.v2[2] = idealTransformer.plug_p2.pin[2].v - idealTransformer.plug_n2.pin[2].v;
//   idealTransformer.v2[3] = idealTransformer.plug_p2.pin[3].v - idealTransformer.plug_n2.pin[3].v;
//   idealTransformer.i1[1] = idealTransformer.plug_p1.pin[1].i;
//   idealTransformer.i1[2] = idealTransformer.plug_p1.pin[2].i;
//   idealTransformer.i1[3] = idealTransformer.plug_p1.pin[3].i;
//   idealTransformer.i2[1] = idealTransformer.plug_p2.pin[1].i;
//   idealTransformer.i2[2] = idealTransformer.plug_p2.pin[2].i;
//   idealTransformer.i2[3] = idealTransformer.plug_p2.pin[3].i;
//   groundT.p.v = 0.0;
//   assert(1.0 + transformerR.resistor[1].alpha * (transformerR.resistor[1].T_heatPort - transformerR.resistor[1].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[1].R_actual = transformerR.resistor[1].R * (1.0 + transformerR.resistor[1].alpha * (transformerR.resistor[1].T_heatPort - transformerR.resistor[1].T_ref));
//   transformerR.resistor[1].v = transformerR.resistor[1].R_actual * transformerR.resistor[1].i;
//   transformerR.resistor[1].LossPower = transformerR.resistor[1].v * transformerR.resistor[1].i;
//   transformerR.resistor[1].i = transformerR.resistor[1].p.i;
//   0.0 = transformerR.resistor[1].p.i + transformerR.resistor[1].n.i;
//   transformerR.resistor[1].v = transformerR.resistor[1].p.v - transformerR.resistor[1].n.v;
//   transformerR.resistor[1].T_heatPort = transformerR.resistor[1].T;
//   assert(1.0 + transformerR.resistor[2].alpha * (transformerR.resistor[2].T_heatPort - transformerR.resistor[2].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[2].R_actual = transformerR.resistor[2].R * (1.0 + transformerR.resistor[2].alpha * (transformerR.resistor[2].T_heatPort - transformerR.resistor[2].T_ref));
//   transformerR.resistor[2].v = transformerR.resistor[2].R_actual * transformerR.resistor[2].i;
//   transformerR.resistor[2].LossPower = transformerR.resistor[2].v * transformerR.resistor[2].i;
//   transformerR.resistor[2].i = transformerR.resistor[2].p.i;
//   0.0 = transformerR.resistor[2].p.i + transformerR.resistor[2].n.i;
//   transformerR.resistor[2].v = transformerR.resistor[2].p.v - transformerR.resistor[2].n.v;
//   transformerR.resistor[2].T_heatPort = transformerR.resistor[2].T;
//   assert(1.0 + transformerR.resistor[3].alpha * (transformerR.resistor[3].T_heatPort - transformerR.resistor[3].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   transformerR.resistor[3].R_actual = transformerR.resistor[3].R * (1.0 + transformerR.resistor[3].alpha * (transformerR.resistor[3].T_heatPort - transformerR.resistor[3].T_ref));
//   transformerR.resistor[3].v = transformerR.resistor[3].R_actual * transformerR.resistor[3].i;
//   transformerR.resistor[3].LossPower = transformerR.resistor[3].v * transformerR.resistor[3].i;
//   transformerR.resistor[3].i = transformerR.resistor[3].p.i;
//   0.0 = transformerR.resistor[3].p.i + transformerR.resistor[3].n.i;
//   transformerR.resistor[3].v = transformerR.resistor[3].p.v - transformerR.resistor[3].n.v;
//   transformerR.resistor[3].T_heatPort = transformerR.resistor[3].T;
//   transformerR.v[1] = transformerR.plug_p.pin[1].v - transformerR.plug_n.pin[1].v;
//   transformerR.v[2] = transformerR.plug_p.pin[2].v - transformerR.plug_n.pin[2].v;
//   transformerR.v[3] = transformerR.plug_p.pin[3].v - transformerR.plug_n.pin[3].v;
//   transformerR.i[1] = transformerR.plug_p.pin[1].i;
//   transformerR.i[2] = transformerR.plug_p.pin[2].i;
//   transformerR.i[3] = transformerR.plug_p.pin[3].i;
//   transformerL.inductor[1].L * der(transformerL.inductor[1].i) = transformerL.inductor[1].v;
//   transformerL.inductor[1].v = transformerL.inductor[1].p.v - transformerL.inductor[1].n.v;
//   0.0 = transformerL.inductor[1].p.i + transformerL.inductor[1].n.i;
//   transformerL.inductor[1].i = transformerL.inductor[1].p.i;
//   transformerL.inductor[2].L * der(transformerL.inductor[2].i) = transformerL.inductor[2].v;
//   transformerL.inductor[2].v = transformerL.inductor[2].p.v - transformerL.inductor[2].n.v;
//   0.0 = transformerL.inductor[2].p.i + transformerL.inductor[2].n.i;
//   transformerL.inductor[2].i = transformerL.inductor[2].p.i;
//   transformerL.inductor[3].L * der(transformerL.inductor[3].i) = transformerL.inductor[3].v;
//   transformerL.inductor[3].v = transformerL.inductor[3].p.v - transformerL.inductor[3].n.v;
//   0.0 = transformerL.inductor[3].p.i + transformerL.inductor[3].n.i;
//   transformerL.inductor[3].i = transformerL.inductor[3].p.i;
//   transformerL.v[1] = transformerL.plug_p.pin[1].v - transformerL.plug_n.pin[1].v;
//   transformerL.v[2] = transformerL.plug_p.pin[2].v - transformerL.plug_n.pin[2].v;
//   transformerL.v[3] = transformerL.plug_p.pin[3].v - transformerL.plug_n.pin[3].v;
//   transformerL.i[1] = transformerL.plug_p.pin[1].i;
//   transformerL.i[2] = transformerL.plug_p.pin[2].i;
//   transformerL.i[3] = transformerL.plug_p.pin[3].i;
//   assert(1.0 + loadR.resistor[1].alpha * (loadR.resistor[1].T_heatPort - loadR.resistor[1].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[1].R_actual = loadR.resistor[1].R * (1.0 + loadR.resistor[1].alpha * (loadR.resistor[1].T_heatPort - loadR.resistor[1].T_ref));
//   loadR.resistor[1].v = loadR.resistor[1].R_actual * loadR.resistor[1].i;
//   loadR.resistor[1].LossPower = loadR.resistor[1].v * loadR.resistor[1].i;
//   loadR.resistor[1].i = loadR.resistor[1].p.i;
//   0.0 = loadR.resistor[1].p.i + loadR.resistor[1].n.i;
//   loadR.resistor[1].v = loadR.resistor[1].p.v - loadR.resistor[1].n.v;
//   loadR.resistor[1].T_heatPort = loadR.resistor[1].T;
//   assert(1.0 + loadR.resistor[2].alpha * (loadR.resistor[2].T_heatPort - loadR.resistor[2].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[2].R_actual = loadR.resistor[2].R * (1.0 + loadR.resistor[2].alpha * (loadR.resistor[2].T_heatPort - loadR.resistor[2].T_ref));
//   loadR.resistor[2].v = loadR.resistor[2].R_actual * loadR.resistor[2].i;
//   loadR.resistor[2].LossPower = loadR.resistor[2].v * loadR.resistor[2].i;
//   loadR.resistor[2].i = loadR.resistor[2].p.i;
//   0.0 = loadR.resistor[2].p.i + loadR.resistor[2].n.i;
//   loadR.resistor[2].v = loadR.resistor[2].p.v - loadR.resistor[2].n.v;
//   loadR.resistor[2].T_heatPort = loadR.resistor[2].T;
//   assert(1.0 + loadR.resistor[3].alpha * (loadR.resistor[3].T_heatPort - loadR.resistor[3].T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.resistor[3].R_actual = loadR.resistor[3].R * (1.0 + loadR.resistor[3].alpha * (loadR.resistor[3].T_heatPort - loadR.resistor[3].T_ref));
//   loadR.resistor[3].v = loadR.resistor[3].R_actual * loadR.resistor[3].i;
//   loadR.resistor[3].LossPower = loadR.resistor[3].v * loadR.resistor[3].i;
//   loadR.resistor[3].i = loadR.resistor[3].p.i;
//   0.0 = loadR.resistor[3].p.i + loadR.resistor[3].n.i;
//   loadR.resistor[3].v = loadR.resistor[3].p.v - loadR.resistor[3].n.v;
//   loadR.resistor[3].T_heatPort = loadR.resistor[3].T;
//   loadR.v[1] = loadR.plug_p.pin[1].v - loadR.plug_n.pin[1].v;
//   loadR.v[2] = loadR.plug_p.pin[2].v - loadR.plug_n.pin[2].v;
//   loadR.v[3] = loadR.plug_p.pin[3].v - loadR.plug_n.pin[3].v;
//   loadR.i[1] = loadR.plug_p.pin[1].i;
//   loadR.i[2] = loadR.plug_p.pin[2].i;
//   loadR.i[3] = loadR.plug_p.pin[3].i;
//   groundL.p.v = 0.0;
//   assert(starS.plug_p.m == sineVoltage.plug_n.m,\"automatically generated from connect\");
//   assert(sineVoltage.plug_p.m == idealTransformer.plug_p1.m,\"automatically generated from connect\");
//   assert(idealTransformer.plug_n1.m == starT.plug_p.m,\"automatically generated from connect\");
//   assert(idealTransformer.plug_p2.m == transformerR.plug_p.m,\"automatically generated from connect\");
//   assert(transformerR.plug_n.m == transformerL.plug_p.m,\"automatically generated from connect\");
//   assert(transformerL.plug_n.m == deltaT2.plug_p.m,\"automatically generated from connect\");
//   assert(deltaT2.plug_n.m == idealTransformer.plug_n2.m,\"automatically generated from connect\");
//   assert(deltaT2.plug_p.m == loadR.plug_p.m,\"automatically generated from connect\");
//   assert(loadR.plug_n.m == starL.plug_p.m,\"automatically generated from connect\");
//   starL.pin_n.i + groundL.p.i = 0.0;
//   groundL.p.v = starL.pin_n.v;
//   loadR.plug_n.pin[3].i + starL.plug_p.pin[3].i = 0.0;
//   loadR.plug_n.pin[3].v = starL.plug_p.pin[3].v;
//   loadR.plug_n.pin[2].i + starL.plug_p.pin[2].i = 0.0;
//   loadR.plug_n.pin[2].v = starL.plug_p.pin[2].v;
//   loadR.plug_n.pin[1].i + starL.plug_p.pin[1].i = 0.0;
//   loadR.plug_n.pin[1].v = starL.plug_p.pin[1].v;
//   transformerL.plug_n.pin[3].i + (deltaT2.plug_p.pin[3].i + loadR.plug_p.pin[3].i) = 0.0;
//   deltaT2.plug_p.pin[3].v = loadR.plug_p.pin[3].v;
//   deltaT2.plug_p.pin[3].v = transformerL.plug_n.pin[3].v;
//   transformerL.plug_n.pin[2].i + (deltaT2.plug_p.pin[2].i + loadR.plug_p.pin[2].i) = 0.0;
//   deltaT2.plug_p.pin[2].v = loadR.plug_p.pin[2].v;
//   deltaT2.plug_p.pin[2].v = transformerL.plug_n.pin[2].v;
//   transformerL.plug_n.pin[1].i + (deltaT2.plug_p.pin[1].i + loadR.plug_p.pin[1].i) = 0.0;
//   deltaT2.plug_p.pin[1].v = loadR.plug_p.pin[1].v;
//   deltaT2.plug_p.pin[1].v = transformerL.plug_n.pin[1].v;
//   deltaT2.plug_n.pin[3].i + idealTransformer.plug_n2.pin[3].i = 0.0;
//   deltaT2.plug_n.pin[3].v = idealTransformer.plug_n2.pin[3].v;
//   deltaT2.plug_n.pin[2].i + idealTransformer.plug_n2.pin[2].i = 0.0;
//   deltaT2.plug_n.pin[2].v = idealTransformer.plug_n2.pin[2].v;
//   deltaT2.plug_n.pin[1].i + idealTransformer.plug_n2.pin[1].i = 0.0;
//   deltaT2.plug_n.pin[1].v = idealTransformer.plug_n2.pin[1].v;
//   transformerR.plug_n.pin[3].i + transformerL.plug_p.pin[3].i = 0.0;
//   transformerL.plug_p.pin[3].v = transformerR.plug_n.pin[3].v;
//   transformerR.plug_n.pin[2].i + transformerL.plug_p.pin[2].i = 0.0;
//   transformerL.plug_p.pin[2].v = transformerR.plug_n.pin[2].v;
//   transformerR.plug_n.pin[1].i + transformerL.plug_p.pin[1].i = 0.0;
//   transformerL.plug_p.pin[1].v = transformerR.plug_n.pin[1].v;
//   idealTransformer.plug_p2.pin[3].i + transformerR.plug_p.pin[3].i = 0.0;
//   idealTransformer.plug_p2.pin[3].v = transformerR.plug_p.pin[3].v;
//   idealTransformer.plug_p2.pin[2].i + transformerR.plug_p.pin[2].i = 0.0;
//   idealTransformer.plug_p2.pin[2].v = transformerR.plug_p.pin[2].v;
//   idealTransformer.plug_p2.pin[1].i + transformerR.plug_p.pin[1].i = 0.0;
//   idealTransformer.plug_p2.pin[1].v = transformerR.plug_p.pin[1].v;
//   idealTransformer.plug_n1.pin[3].i + starT.plug_p.pin[3].i = 0.0;
//   idealTransformer.plug_n1.pin[3].v = starT.plug_p.pin[3].v;
//   idealTransformer.plug_n1.pin[2].i + starT.plug_p.pin[2].i = 0.0;
//   idealTransformer.plug_n1.pin[2].v = starT.plug_p.pin[2].v;
//   idealTransformer.plug_n1.pin[1].i + starT.plug_p.pin[1].i = 0.0;
//   idealTransformer.plug_n1.pin[1].v = starT.plug_p.pin[1].v;
//   sineVoltage.plug_p.pin[3].i + idealTransformer.plug_p1.pin[3].i = 0.0;
//   idealTransformer.plug_p1.pin[3].v = sineVoltage.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + idealTransformer.plug_p1.pin[2].i = 0.0;
//   idealTransformer.plug_p1.pin[2].v = sineVoltage.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + idealTransformer.plug_p1.pin[1].i = 0.0;
//   idealTransformer.plug_p1.pin[1].v = sineVoltage.plug_p.pin[1].v;
//   starS.plug_p.pin[3].i + sineVoltage.plug_n.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = starS.plug_p.pin[3].v;
//   starS.plug_p.pin[2].i + sineVoltage.plug_n.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = starS.plug_p.pin[2].v;
//   starS.plug_p.pin[1].i + sineVoltage.plug_n.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = starS.plug_p.pin[1].v;
//   groundT.p.i + starT.pin_n.i = 0.0;
//   groundT.p.v = starT.pin_n.v;
//   groundS.p.i + starS.pin_n.i = 0.0;
//   groundS.p.v = starS.pin_n.v;
//   (-starL.plug_p.pin[3].i) + ((-starL.plug_p.pin[2].i) + ((-starL.plug_p.pin[1].i) + (-starL.pin_n.i))) = 0.0;
//   starL.pin_n.v = starL.plug_p.pin[1].v;
//   starL.pin_n.v = starL.plug_p.pin[2].v;
//   starL.pin_n.v = starL.plug_p.pin[3].v;
//   loadR.resistor[3].n.i + (-loadR.plug_n.pin[3].i) = 0.0;
//   loadR.plug_n.pin[3].v = loadR.resistor[3].n.v;
//   loadR.resistor[2].n.i + (-loadR.plug_n.pin[2].i) = 0.0;
//   loadR.plug_n.pin[2].v = loadR.resistor[2].n.v;
//   loadR.resistor[1].n.i + (-loadR.plug_n.pin[1].i) = 0.0;
//   loadR.plug_n.pin[1].v = loadR.resistor[1].n.v;
//   loadR.resistor[3].p.i + (-loadR.plug_p.pin[3].i) = 0.0;
//   loadR.plug_p.pin[3].v = loadR.resistor[3].p.v;
//   loadR.resistor[2].p.i + (-loadR.plug_p.pin[2].i) = 0.0;
//   loadR.plug_p.pin[2].v = loadR.resistor[2].p.v;
//   loadR.resistor[1].p.i + (-loadR.plug_p.pin[1].i) = 0.0;
//   loadR.plug_p.pin[1].v = loadR.resistor[1].p.v;
//   transformerL.inductor[3].n.i + (-transformerL.plug_n.pin[3].i) = 0.0;
//   transformerL.inductor[3].n.v = transformerL.plug_n.pin[3].v;
//   transformerL.inductor[2].n.i + (-transformerL.plug_n.pin[2].i) = 0.0;
//   transformerL.inductor[2].n.v = transformerL.plug_n.pin[2].v;
//   transformerL.inductor[1].n.i + (-transformerL.plug_n.pin[1].i) = 0.0;
//   transformerL.inductor[1].n.v = transformerL.plug_n.pin[1].v;
//   transformerL.inductor[3].p.i + (-transformerL.plug_p.pin[3].i) = 0.0;
//   transformerL.inductor[3].p.v = transformerL.plug_p.pin[3].v;
//   transformerL.inductor[2].p.i + (-transformerL.plug_p.pin[2].i) = 0.0;
//   transformerL.inductor[2].p.v = transformerL.plug_p.pin[2].v;
//   transformerL.inductor[1].p.i + (-transformerL.plug_p.pin[1].i) = 0.0;
//   transformerL.inductor[1].p.v = transformerL.plug_p.pin[1].v;
//   transformerR.resistor[3].n.i + (-transformerR.plug_n.pin[3].i) = 0.0;
//   transformerR.plug_n.pin[3].v = transformerR.resistor[3].n.v;
//   transformerR.resistor[2].n.i + (-transformerR.plug_n.pin[2].i) = 0.0;
//   transformerR.plug_n.pin[2].v = transformerR.resistor[2].n.v;
//   transformerR.resistor[1].n.i + (-transformerR.plug_n.pin[1].i) = 0.0;
//   transformerR.plug_n.pin[1].v = transformerR.resistor[1].n.v;
//   transformerR.resistor[3].p.i + (-transformerR.plug_p.pin[3].i) = 0.0;
//   transformerR.plug_p.pin[3].v = transformerR.resistor[3].p.v;
//   transformerR.resistor[2].p.i + (-transformerR.plug_p.pin[2].i) = 0.0;
//   transformerR.plug_p.pin[2].v = transformerR.resistor[2].p.v;
//   transformerR.resistor[1].p.i + (-transformerR.plug_p.pin[1].i) = 0.0;
//   transformerR.plug_p.pin[1].v = transformerR.resistor[1].p.v;
//   (-deltaT2.plug_n.pin[3].i) + (-deltaT2.plug_p.pin[1].i) = 0.0;
//   deltaT2.plug_n.pin[3].v = deltaT2.plug_p.pin[1].v;
//   (-deltaT2.plug_n.pin[2].i) + (-deltaT2.plug_p.pin[3].i) = 0.0;
//   deltaT2.plug_n.pin[2].v = deltaT2.plug_p.pin[3].v;
//   (-deltaT2.plug_n.pin[1].i) + (-deltaT2.plug_p.pin[2].i) = 0.0;
//   deltaT2.plug_n.pin[1].v = deltaT2.plug_p.pin[2].v;
//   (-starT.plug_p.pin[3].i) + ((-starT.plug_p.pin[2].i) + ((-starT.plug_p.pin[1].i) + (-starT.pin_n.i))) = 0.0;
//   starT.pin_n.v = starT.plug_p.pin[1].v;
//   starT.pin_n.v = starT.plug_p.pin[2].v;
//   starT.pin_n.v = starT.plug_p.pin[3].v;
//   (-idealTransformer.plug_n2.pin[3].i) + idealTransformer.idealTransformer[3].n2.i = 0.0;
//   idealTransformer.idealTransformer[3].n2.v = idealTransformer.plug_n2.pin[3].v;
//   (-idealTransformer.plug_n2.pin[2].i) + idealTransformer.idealTransformer[2].n2.i = 0.0;
//   idealTransformer.idealTransformer[2].n2.v = idealTransformer.plug_n2.pin[2].v;
//   (-idealTransformer.plug_n2.pin[1].i) + idealTransformer.idealTransformer[1].n2.i = 0.0;
//   idealTransformer.idealTransformer[1].n2.v = idealTransformer.plug_n2.pin[1].v;
//   (-idealTransformer.plug_n1.pin[3].i) + idealTransformer.idealTransformer[3].n1.i = 0.0;
//   idealTransformer.idealTransformer[3].n1.v = idealTransformer.plug_n1.pin[3].v;
//   (-idealTransformer.plug_n1.pin[2].i) + idealTransformer.idealTransformer[2].n1.i = 0.0;
//   idealTransformer.idealTransformer[2].n1.v = idealTransformer.plug_n1.pin[2].v;
//   (-idealTransformer.plug_n1.pin[1].i) + idealTransformer.idealTransformer[1].n1.i = 0.0;
//   idealTransformer.idealTransformer[1].n1.v = idealTransformer.plug_n1.pin[1].v;
//   (-idealTransformer.plug_p2.pin[3].i) + idealTransformer.idealTransformer[3].p2.i = 0.0;
//   idealTransformer.idealTransformer[3].p2.v = idealTransformer.plug_p2.pin[3].v;
//   (-idealTransformer.plug_p2.pin[2].i) + idealTransformer.idealTransformer[2].p2.i = 0.0;
//   idealTransformer.idealTransformer[2].p2.v = idealTransformer.plug_p2.pin[2].v;
//   (-idealTransformer.plug_p2.pin[1].i) + idealTransformer.idealTransformer[1].p2.i = 0.0;
//   idealTransformer.idealTransformer[1].p2.v = idealTransformer.plug_p2.pin[1].v;
//   (-idealTransformer.plug_p1.pin[3].i) + idealTransformer.idealTransformer[3].p1.i = 0.0;
//   idealTransformer.idealTransformer[3].p1.v = idealTransformer.plug_p1.pin[3].v;
//   (-idealTransformer.plug_p1.pin[2].i) + idealTransformer.idealTransformer[2].p1.i = 0.0;
//   idealTransformer.idealTransformer[2].p1.v = idealTransformer.plug_p1.pin[2].v;
//   (-idealTransformer.plug_p1.pin[1].i) + idealTransformer.idealTransformer[1].p1.i = 0.0;
//   idealTransformer.idealTransformer[1].p1.v = idealTransformer.plug_p1.pin[1].v;
//   (-starS.plug_p.pin[3].i) + ((-starS.plug_p.pin[2].i) + ((-starS.plug_p.pin[1].i) + (-starS.pin_n.i))) = 0.0;
//   starS.pin_n.v = starS.plug_p.pin[1].v;
//   starS.pin_n.v = starS.plug_p.pin[2].v;
//   starS.pin_n.v = starS.plug_p.pin[3].v;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
// end Modelica.Electrical.MultiPhase.Examples.TransformerYD;
// "
// ""
// "Check of Modelica.Electrical.MultiPhase.Examples.TransformerYD completed successfully.
// 
// 
// Class Modelica.Electrical.MultiPhase.Examples.TransformerYD has 285 equation(s) and 285 variable(s).
// 237 of these are trivial equation(s).
// "
// ""
// record SimulationResult
//     resultFile = "Modelica.Electrical.MultiPhase.Examples.TransformerYD_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'Modelica.Electrical.MultiPhase.Examples.TransformerYD', storeInTemp = false, noClean = false, options = '', outputFormat = 'mat', variableFilter = '.*', cflags = ''",
//     messages = ""
// end SimulationResult;
// ""
// "function Modelica.Math.asin
//   input Real u;
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
// 
// external \"C\";
// end Modelica.Math.asin;
// 
// function Modelica.Math.sin
//   input Real u(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real y;
// 
// external \"C\";
// end Modelica.Math.sin;
// 
// class Modelica.Electrical.MultiPhase.Examples.Rectifier
//   parameter Integer m = 3 \"Number of phases\";
//   parameter Real V(quantity = \"ElectricPotential\", unit = \"V\") = 1.0 \"Amplitude of Star-Voltage\";
//   parameter Real f(quantity = \"Frequency\", unit = \"Hz\") = 5.0 \"Frequency\";
//   parameter Real L(quantity = \"Inductance\", unit = \"H\") = 0.001 \"Line Inductance\";
//   parameter Real RL(quantity = \"Resistance\", unit = \"Ohm\") = 2.0 \"Load Resistance\";
//   parameter Real C(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.05 \"Total DC-Capacitance\";
//   parameter Real RE(quantity = \"Resistance\", unit = \"Ohm\") = 1000000.0 \"Earthing Resistance\";
//   parameter Integer sineVoltage.m(min = 1) = m \"number of phases\";
//   Real sineVoltage.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real sineVoltage.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real sineVoltage.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer sineVoltage.plug_p.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer sineVoltage.plug_n.m(min = 1) = sineVoltage.m \"number of phases\";
//   Real sineVoltage.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.V[1](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[2](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.V[3](quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = V \"Amplitudes of sine waves\";
//   parameter Real sineVoltage.freqHz[1](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[2](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   parameter Real sineVoltage.freqHz[3](quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = f \"Frequencies of sine waves\";
//   Real sineVoltage.sineVoltage[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[1].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[1] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[1].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[1] \"Time offset\";
//   output Real sineVoltage.sineVoltage[1].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.amplitude = sineVoltage.sineVoltage[1].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[1].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[1].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.offset = sineVoltage.sineVoltage[1].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[1].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[1].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[1].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[1].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[1] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[1] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[1].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[1] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[2].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[2] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[2].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[2] \"Time offset\";
//   output Real sineVoltage.sineVoltage[2].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.amplitude = sineVoltage.sineVoltage[2].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[2].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[2].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.offset = sineVoltage.sineVoltage[2].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[2].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[2].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[2].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[2].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[2] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[2] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[2].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[2] \"Frequency of sine wave\";
//   Real sineVoltage.sineVoltage[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real sineVoltage.sineVoltage[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real sineVoltage.sineVoltage[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real sineVoltage.sineVoltage[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real sineVoltage.sineVoltage[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real sineVoltage.sineVoltage[3].offset(quantity = \"ElectricPotential\", unit = \"V\") = sineVoltage.offset[3] \"Voltage offset\";
//   parameter Real sineVoltage.sineVoltage[3].startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.startTime[3] \"Time offset\";
//   output Real sineVoltage.sineVoltage[3].signalSource.y \"Connector of Real output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.amplitude = sineVoltage.sineVoltage[3].V \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.sineVoltage[3].freqHz \"Frequency of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.sineVoltage[3].phase \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.offset = sineVoltage.sineVoltage[3].offset \"Offset of output signal\";
//   parameter Real sineVoltage.sineVoltage[3].signalSource.startTime(quantity = \"Time\", unit = \"s\") = sineVoltage.sineVoltage[3].startTime \"Output = offset for time < startTime\";
//   protected constant Real sineVoltage.sineVoltage[3].signalSource.pi = 3.14159265358979;
//   parameter Real sineVoltage.sineVoltage[3].V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = sineVoltage.V[3] \"Amplitude of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].phase(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = sineVoltage.phase[3] \"Phase of sine wave\";
//   parameter Real sineVoltage.sineVoltage[3].freqHz(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = sineVoltage.freqHz[3] \"Frequency of sine wave\";
//   parameter Real sineVoltage.phase[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -6.28318530717959 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.phase[3](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = -12.5663706143592 / Real(sineVoltage.m) \"Phases of sine waves\";
//   parameter Real sineVoltage.offset[1](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[2](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.offset[3](quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Voltage offsets\";
//   parameter Real sineVoltage.startTime[1](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[2](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Real sineVoltage.startTime[3](quantity = \"Time\", unit = \"s\") = 0.0 \"Time offsets\";
//   parameter Integer starS.m(min = 1) = m \"number of phases\";
//   parameter Integer starS.plug_p.m(min = 1) = starS.m \"number of phases\";
//   Real starS.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real starS.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real starS.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer supplyL.m(min = 1) = m \"number of phases\";
//   Real supplyL.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real supplyL.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real supplyL.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real supplyL.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real supplyL.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real supplyL.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer supplyL.plug_p.m(min = 1) = supplyL.m \"number of phases\";
//   Real supplyL.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer supplyL.plug_n.m(min = 1) = supplyL.m \"number of phases\";
//   Real supplyL.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real supplyL.L[1](quantity = \"Inductance\", unit = \"H\", start = 1.0) = L \"Inductance\";
//   parameter Real supplyL.L[2](quantity = \"Inductance\", unit = \"H\", start = 1.0) = L \"Inductance\";
//   parameter Real supplyL.L[3](quantity = \"Inductance\", unit = \"H\", start = 1.0) = L \"Inductance\";
//   Real supplyL.inductor[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real supplyL.inductor[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real supplyL.inductor[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.inductor[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real supplyL.inductor[1].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = supplyL.L[1] \"Inductance\";
//   Real supplyL.inductor[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real supplyL.inductor[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real supplyL.inductor[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.inductor[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real supplyL.inductor[2].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = supplyL.L[2] \"Inductance\";
//   Real supplyL.inductor[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real supplyL.inductor[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real supplyL.inductor[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real supplyL.inductor[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real supplyL.inductor[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real supplyL.inductor[3].L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = supplyL.L[3] \"Inductance\";
//   parameter Integer idealDiode1.m(min = 1) = m \"number of phases\";
//   Real idealDiode1.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode1.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode1.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode1.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real idealDiode1.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real idealDiode1.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer idealDiode1.plug_p.m(min = 1) = idealDiode1.m \"number of phases\";
//   Real idealDiode1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealDiode1.plug_n.m(min = 1) = idealDiode1.m \"number of phases\";
//   Real idealDiode1.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealDiode1.mh(min = 1) = idealDiode1.m \"Number of heatPorts=number of phases\";
//   parameter Boolean idealDiode1.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real idealDiode1.Ron[1](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode1.Ron[2](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode1.Ron[3](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode1.Goff[1](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode1.Goff[2](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode1.Goff[3](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode1.Vknee[1](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   parameter Real idealDiode1.Vknee[2](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   parameter Real idealDiode1.Vknee[3](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   Real idealDiode1.idealDiode[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode1.idealDiode[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode1.idealDiode[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.idealDiode[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode1.idealDiode[1].useHeatPort = idealDiode1.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode1.idealDiode[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode1.idealDiode[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode1.idealDiode[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode1.idealDiode[1].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode1.Ron[1] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode1.idealDiode[1].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode1.Goff[1] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode1.idealDiode[1].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode1.Vknee[1] \"Forward threshold voltage\";
//   Boolean idealDiode1.idealDiode[1].off(start = true) \"Switching state\";
//   protected Real idealDiode1.idealDiode[1].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode1.idealDiode[1].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode1.idealDiode[1].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   Real idealDiode1.idealDiode[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode1.idealDiode[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode1.idealDiode[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.idealDiode[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode1.idealDiode[2].useHeatPort = idealDiode1.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode1.idealDiode[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode1.idealDiode[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode1.idealDiode[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode1.idealDiode[2].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode1.Ron[2] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode1.idealDiode[2].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode1.Goff[2] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode1.idealDiode[2].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode1.Vknee[2] \"Forward threshold voltage\";
//   Boolean idealDiode1.idealDiode[2].off(start = true) \"Switching state\";
//   protected Real idealDiode1.idealDiode[2].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode1.idealDiode[2].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode1.idealDiode[2].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   Real idealDiode1.idealDiode[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode1.idealDiode[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode1.idealDiode[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode1.idealDiode[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode1.idealDiode[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode1.idealDiode[3].useHeatPort = idealDiode1.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode1.idealDiode[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode1.idealDiode[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode1.idealDiode[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode1.idealDiode[3].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode1.Ron[3] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode1.idealDiode[3].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode1.Goff[3] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode1.idealDiode[3].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode1.Vknee[3] \"Forward threshold voltage\";
//   Boolean idealDiode1.idealDiode[3].off(start = true) \"Switching state\";
//   protected Real idealDiode1.idealDiode[3].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode1.idealDiode[3].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode1.idealDiode[3].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   parameter Real idealDiode1.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real idealDiode1.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real idealDiode1.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer star1.m(min = 1) = m \"number of phases\";
//   parameter Integer star1.plug_p.m(min = 1) = star1.m \"number of phases\";
//   Real star1.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star1.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star1.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star1.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star1.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star1.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star1.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star1.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealDiode2.m(min = 1) = m \"number of phases\";
//   Real idealDiode2.v[1](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode2.v[2](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode2.v[3](quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drops between the two plugs\";
//   Real idealDiode2.i[1](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real idealDiode2.i[2](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   Real idealDiode2.i[3](quantity = \"ElectricCurrent\", unit = \"A\") \"Currents flowing into positive plugs\";
//   parameter Integer idealDiode2.plug_p.m(min = 1) = idealDiode2.m \"number of phases\";
//   Real idealDiode2.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealDiode2.plug_n.m(min = 1) = idealDiode2.m \"number of phases\";
//   Real idealDiode2.plug_n.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_n.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.plug_n.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_n.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.plug_n.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.plug_n.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Integer idealDiode2.mh(min = 1) = idealDiode2.m \"Number of heatPorts=number of phases\";
//   parameter Boolean idealDiode2.useHeatPort = false \"=true, if all HeatPorts are enabled\";
//   parameter Real idealDiode2.Ron[1](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode2.Ron[2](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode2.Ron[3](quantity = \"Resistance\", unit = \"Ohm\", min = 0.0, start = 1e-05) \"Closed diode resistance\";
//   parameter Real idealDiode2.Goff[1](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode2.Goff[2](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode2.Goff[3](quantity = \"Conductance\", unit = \"S\", min = 0.0, start = 1e-05) \"Opened diode conductance\";
//   parameter Real idealDiode2.Vknee[1](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   parameter Real idealDiode2.Vknee[2](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   parameter Real idealDiode2.Vknee[3](quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) \"Treshold voltage\";
//   Real idealDiode2.idealDiode[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode2.idealDiode[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode2.idealDiode[1].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[1].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.idealDiode[1].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[1].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode2.idealDiode[1].useHeatPort = idealDiode2.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode2.idealDiode[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode2.idealDiode[1].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode2.idealDiode[1].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode2.idealDiode[1].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode2.Ron[1] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode2.idealDiode[1].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode2.Goff[1] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode2.idealDiode[1].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode2.Vknee[1] \"Forward threshold voltage\";
//   Boolean idealDiode2.idealDiode[1].off(start = true) \"Switching state\";
//   protected Real idealDiode2.idealDiode[1].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode2.idealDiode[1].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode2.idealDiode[1].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   Real idealDiode2.idealDiode[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode2.idealDiode[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode2.idealDiode[2].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[2].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.idealDiode[2].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[2].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode2.idealDiode[2].useHeatPort = idealDiode2.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode2.idealDiode[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode2.idealDiode[2].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode2.idealDiode[2].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode2.idealDiode[2].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode2.Ron[2] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode2.idealDiode[2].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode2.Goff[2] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode2.idealDiode[2].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode2.Vknee[2] \"Forward threshold voltage\";
//   Boolean idealDiode2.idealDiode[2].off(start = true) \"Switching state\";
//   protected Real idealDiode2.idealDiode[2].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode2.idealDiode[2].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode2.idealDiode[2].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   Real idealDiode2.idealDiode[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real idealDiode2.idealDiode[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real idealDiode2.idealDiode[3].p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[3].p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real idealDiode2.idealDiode[3].n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real idealDiode2.idealDiode[3].n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean idealDiode2.idealDiode[3].useHeatPort = idealDiode2.useHeatPort \"=true, if HeatPort is enabled\";
//   parameter Real idealDiode2.idealDiode[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperature if useHeatPort = false\";
//   Real idealDiode2.idealDiode[3].LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real idealDiode2.idealDiode[3].T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real idealDiode2.idealDiode[3].Ron(quantity = \"Resistance\", unit = \"Ohm\", min = 0.0) = idealDiode2.Ron[3] \"Forward state-on differential resistance (closed diode resistance)\";
//   parameter Real idealDiode2.idealDiode[3].Goff(quantity = \"Conductance\", unit = \"S\", min = 0.0) = idealDiode2.Goff[3] \"Backward state-off conductance (opened diode conductance)\";
//   parameter Real idealDiode2.idealDiode[3].Vknee(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0, start = 0.0) = idealDiode2.Vknee[3] \"Forward threshold voltage\";
//   Boolean idealDiode2.idealDiode[3].off(start = true) \"Switching state\";
//   protected Real idealDiode2.idealDiode[3].s(unit = \"1\") \"Auxiliary variable: if on then current, if opened then voltage\";
//   protected constant Real idealDiode2.idealDiode[3].unitVoltage(quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   protected constant Real idealDiode2.idealDiode[3].unitCurrent(quantity = \"ElectricCurrent\", unit = \"A\") = 1.0;
//   parameter Real idealDiode2.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real idealDiode2.T[2](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Real idealDiode2.T[3](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 293.15 \"Fixed device temperatures if useHeatPort = false\";
//   parameter Integer star2.m(min = 1) = m \"number of phases\";
//   parameter Integer star2.plug_p.m(min = 1) = star2.m \"number of phases\";
//   Real star2.plug_p.pin[1].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star2.plug_p.pin[1].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star2.plug_p.pin[2].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star2.plug_p.pin[2].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star2.plug_p.pin[3].v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star2.plug_p.pin[3].i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real star2.pin_n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real star2.pin_n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real loadR.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real loadR.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real loadR.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real loadR.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Boolean loadR.useHeatPort = false \"=true, if HeatPort is enabled\";
//   parameter Real loadR.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = loadR.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real loadR.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via HeatPort\";
//   Real loadR.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) \"Temperature of HeatPort\";
//   parameter Real loadR.R(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = RL \"Resistance at temperature T_ref\";
//   parameter Real loadR.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0) = 300.15 \"Reference temperature\";
//   parameter Real loadR.alpha(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real loadR.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";
//   Real cDC1.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real cDC1.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real cDC1.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real cDC1.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real cDC1.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real cDC1.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real cDC1.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = 2.0 * C \"Capacitance\";
//   Real cDC2.v(quantity = \"ElectricPotential\", unit = \"V\") \"Voltage drop between the two pins (= p.v - n.v)\";
//   Real cDC2.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing from pin p to pin n\";
//   Real cDC2.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real cDC2.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real cDC2.n.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real cDC2.n.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   parameter Real cDC2.C(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 1.0) = 2.0 * C \"Capacitance\";
//   Real groundDC.p.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real groundDC.p.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
// equation
//   sineVoltage.sineVoltage[1].signalSource.y = sineVoltage.sineVoltage[1].signalSource.offset + (if time < sineVoltage.sineVoltage[1].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[1].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[1].signalSource.freqHz * (time - sineVoltage.sineVoltage[1].signalSource.startTime)) + sineVoltage.sineVoltage[1].signalSource.phase));
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].signalSource.y;
//   sineVoltage.sineVoltage[1].v = sineVoltage.sineVoltage[1].p.v - sineVoltage.sineVoltage[1].n.v;
//   0.0 = sineVoltage.sineVoltage[1].p.i + sineVoltage.sineVoltage[1].n.i;
//   sineVoltage.sineVoltage[1].i = sineVoltage.sineVoltage[1].p.i;
//   sineVoltage.sineVoltage[2].signalSource.y = sineVoltage.sineVoltage[2].signalSource.offset + (if time < sineVoltage.sineVoltage[2].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[2].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[2].signalSource.freqHz * (time - sineVoltage.sineVoltage[2].signalSource.startTime)) + sineVoltage.sineVoltage[2].signalSource.phase));
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].signalSource.y;
//   sineVoltage.sineVoltage[2].v = sineVoltage.sineVoltage[2].p.v - sineVoltage.sineVoltage[2].n.v;
//   0.0 = sineVoltage.sineVoltage[2].p.i + sineVoltage.sineVoltage[2].n.i;
//   sineVoltage.sineVoltage[2].i = sineVoltage.sineVoltage[2].p.i;
//   sineVoltage.sineVoltage[3].signalSource.y = sineVoltage.sineVoltage[3].signalSource.offset + (if time < sineVoltage.sineVoltage[3].signalSource.startTime then 0.0 else sineVoltage.sineVoltage[3].signalSource.amplitude * sin(6.28318530717959 * (sineVoltage.sineVoltage[3].signalSource.freqHz * (time - sineVoltage.sineVoltage[3].signalSource.startTime)) + sineVoltage.sineVoltage[3].signalSource.phase));
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].signalSource.y;
//   sineVoltage.sineVoltage[3].v = sineVoltage.sineVoltage[3].p.v - sineVoltage.sineVoltage[3].n.v;
//   0.0 = sineVoltage.sineVoltage[3].p.i + sineVoltage.sineVoltage[3].n.i;
//   sineVoltage.sineVoltage[3].i = sineVoltage.sineVoltage[3].p.i;
//   sineVoltage.v[1] = sineVoltage.plug_p.pin[1].v - sineVoltage.plug_n.pin[1].v;
//   sineVoltage.v[2] = sineVoltage.plug_p.pin[2].v - sineVoltage.plug_n.pin[2].v;
//   sineVoltage.v[3] = sineVoltage.plug_p.pin[3].v - sineVoltage.plug_n.pin[3].v;
//   sineVoltage.i[1] = sineVoltage.plug_p.pin[1].i;
//   sineVoltage.i[2] = sineVoltage.plug_p.pin[2].i;
//   sineVoltage.i[3] = sineVoltage.plug_p.pin[3].i;
//   supplyL.inductor[1].L * der(supplyL.inductor[1].i) = supplyL.inductor[1].v;
//   supplyL.inductor[1].v = supplyL.inductor[1].p.v - supplyL.inductor[1].n.v;
//   0.0 = supplyL.inductor[1].p.i + supplyL.inductor[1].n.i;
//   supplyL.inductor[1].i = supplyL.inductor[1].p.i;
//   supplyL.inductor[2].L * der(supplyL.inductor[2].i) = supplyL.inductor[2].v;
//   supplyL.inductor[2].v = supplyL.inductor[2].p.v - supplyL.inductor[2].n.v;
//   0.0 = supplyL.inductor[2].p.i + supplyL.inductor[2].n.i;
//   supplyL.inductor[2].i = supplyL.inductor[2].p.i;
//   supplyL.inductor[3].L * der(supplyL.inductor[3].i) = supplyL.inductor[3].v;
//   supplyL.inductor[3].v = supplyL.inductor[3].p.v - supplyL.inductor[3].n.v;
//   0.0 = supplyL.inductor[3].p.i + supplyL.inductor[3].n.i;
//   supplyL.inductor[3].i = supplyL.inductor[3].p.i;
//   supplyL.v[1] = supplyL.plug_p.pin[1].v - supplyL.plug_n.pin[1].v;
//   supplyL.v[2] = supplyL.plug_p.pin[2].v - supplyL.plug_n.pin[2].v;
//   supplyL.v[3] = supplyL.plug_p.pin[3].v - supplyL.plug_n.pin[3].v;
//   supplyL.i[1] = supplyL.plug_p.pin[1].i;
//   supplyL.i[2] = supplyL.plug_p.pin[2].i;
//   supplyL.i[3] = supplyL.plug_p.pin[3].i;
//   idealDiode1.idealDiode[1].off = idealDiode1.idealDiode[1].s < 0.0;
//   idealDiode1.idealDiode[1].v = idealDiode1.idealDiode[1].s * (if idealDiode1.idealDiode[1].off then 1.0 else idealDiode1.idealDiode[1].Ron) + idealDiode1.idealDiode[1].Vknee;
//   idealDiode1.idealDiode[1].i = idealDiode1.idealDiode[1].s * (if idealDiode1.idealDiode[1].off then idealDiode1.idealDiode[1].Goff else 1.0) + idealDiode1.idealDiode[1].Goff * idealDiode1.idealDiode[1].Vknee;
//   idealDiode1.idealDiode[1].LossPower = idealDiode1.idealDiode[1].v * idealDiode1.idealDiode[1].i;
//   idealDiode1.idealDiode[1].i = idealDiode1.idealDiode[1].p.i;
//   0.0 = idealDiode1.idealDiode[1].p.i + idealDiode1.idealDiode[1].n.i;
//   idealDiode1.idealDiode[1].v = idealDiode1.idealDiode[1].p.v - idealDiode1.idealDiode[1].n.v;
//   idealDiode1.idealDiode[1].T_heatPort = idealDiode1.idealDiode[1].T;
//   idealDiode1.idealDiode[2].off = idealDiode1.idealDiode[2].s < 0.0;
//   idealDiode1.idealDiode[2].v = idealDiode1.idealDiode[2].s * (if idealDiode1.idealDiode[2].off then 1.0 else idealDiode1.idealDiode[2].Ron) + idealDiode1.idealDiode[2].Vknee;
//   idealDiode1.idealDiode[2].i = idealDiode1.idealDiode[2].s * (if idealDiode1.idealDiode[2].off then idealDiode1.idealDiode[2].Goff else 1.0) + idealDiode1.idealDiode[2].Goff * idealDiode1.idealDiode[2].Vknee;
//   idealDiode1.idealDiode[2].LossPower = idealDiode1.idealDiode[2].v * idealDiode1.idealDiode[2].i;
//   idealDiode1.idealDiode[2].i = idealDiode1.idealDiode[2].p.i;
//   0.0 = idealDiode1.idealDiode[2].p.i + idealDiode1.idealDiode[2].n.i;
//   idealDiode1.idealDiode[2].v = idealDiode1.idealDiode[2].p.v - idealDiode1.idealDiode[2].n.v;
//   idealDiode1.idealDiode[2].T_heatPort = idealDiode1.idealDiode[2].T;
//   idealDiode1.idealDiode[3].off = idealDiode1.idealDiode[3].s < 0.0;
//   idealDiode1.idealDiode[3].v = idealDiode1.idealDiode[3].s * (if idealDiode1.idealDiode[3].off then 1.0 else idealDiode1.idealDiode[3].Ron) + idealDiode1.idealDiode[3].Vknee;
//   idealDiode1.idealDiode[3].i = idealDiode1.idealDiode[3].s * (if idealDiode1.idealDiode[3].off then idealDiode1.idealDiode[3].Goff else 1.0) + idealDiode1.idealDiode[3].Goff * idealDiode1.idealDiode[3].Vknee;
//   idealDiode1.idealDiode[3].LossPower = idealDiode1.idealDiode[3].v * idealDiode1.idealDiode[3].i;
//   idealDiode1.idealDiode[3].i = idealDiode1.idealDiode[3].p.i;
//   0.0 = idealDiode1.idealDiode[3].p.i + idealDiode1.idealDiode[3].n.i;
//   idealDiode1.idealDiode[3].v = idealDiode1.idealDiode[3].p.v - idealDiode1.idealDiode[3].n.v;
//   idealDiode1.idealDiode[3].T_heatPort = idealDiode1.idealDiode[3].T;
//   idealDiode1.v[1] = idealDiode1.plug_p.pin[1].v - idealDiode1.plug_n.pin[1].v;
//   idealDiode1.v[2] = idealDiode1.plug_p.pin[2].v - idealDiode1.plug_n.pin[2].v;
//   idealDiode1.v[3] = idealDiode1.plug_p.pin[3].v - idealDiode1.plug_n.pin[3].v;
//   idealDiode1.i[1] = idealDiode1.plug_p.pin[1].i;
//   idealDiode1.i[2] = idealDiode1.plug_p.pin[2].i;
//   idealDiode1.i[3] = idealDiode1.plug_p.pin[3].i;
//   idealDiode2.idealDiode[1].off = idealDiode2.idealDiode[1].s < 0.0;
//   idealDiode2.idealDiode[1].v = idealDiode2.idealDiode[1].s * (if idealDiode2.idealDiode[1].off then 1.0 else idealDiode2.idealDiode[1].Ron) + idealDiode2.idealDiode[1].Vknee;
//   idealDiode2.idealDiode[1].i = idealDiode2.idealDiode[1].s * (if idealDiode2.idealDiode[1].off then idealDiode2.idealDiode[1].Goff else 1.0) + idealDiode2.idealDiode[1].Goff * idealDiode2.idealDiode[1].Vknee;
//   idealDiode2.idealDiode[1].LossPower = idealDiode2.idealDiode[1].v * idealDiode2.idealDiode[1].i;
//   idealDiode2.idealDiode[1].i = idealDiode2.idealDiode[1].p.i;
//   0.0 = idealDiode2.idealDiode[1].p.i + idealDiode2.idealDiode[1].n.i;
//   idealDiode2.idealDiode[1].v = idealDiode2.idealDiode[1].p.v - idealDiode2.idealDiode[1].n.v;
//   idealDiode2.idealDiode[1].T_heatPort = idealDiode2.idealDiode[1].T;
//   idealDiode2.idealDiode[2].off = idealDiode2.idealDiode[2].s < 0.0;
//   idealDiode2.idealDiode[2].v = idealDiode2.idealDiode[2].s * (if idealDiode2.idealDiode[2].off then 1.0 else idealDiode2.idealDiode[2].Ron) + idealDiode2.idealDiode[2].Vknee;
//   idealDiode2.idealDiode[2].i = idealDiode2.idealDiode[2].s * (if idealDiode2.idealDiode[2].off then idealDiode2.idealDiode[2].Goff else 1.0) + idealDiode2.idealDiode[2].Goff * idealDiode2.idealDiode[2].Vknee;
//   idealDiode2.idealDiode[2].LossPower = idealDiode2.idealDiode[2].v * idealDiode2.idealDiode[2].i;
//   idealDiode2.idealDiode[2].i = idealDiode2.idealDiode[2].p.i;
//   0.0 = idealDiode2.idealDiode[2].p.i + idealDiode2.idealDiode[2].n.i;
//   idealDiode2.idealDiode[2].v = idealDiode2.idealDiode[2].p.v - idealDiode2.idealDiode[2].n.v;
//   idealDiode2.idealDiode[2].T_heatPort = idealDiode2.idealDiode[2].T;
//   idealDiode2.idealDiode[3].off = idealDiode2.idealDiode[3].s < 0.0;
//   idealDiode2.idealDiode[3].v = idealDiode2.idealDiode[3].s * (if idealDiode2.idealDiode[3].off then 1.0 else idealDiode2.idealDiode[3].Ron) + idealDiode2.idealDiode[3].Vknee;
//   idealDiode2.idealDiode[3].i = idealDiode2.idealDiode[3].s * (if idealDiode2.idealDiode[3].off then idealDiode2.idealDiode[3].Goff else 1.0) + idealDiode2.idealDiode[3].Goff * idealDiode2.idealDiode[3].Vknee;
//   idealDiode2.idealDiode[3].LossPower = idealDiode2.idealDiode[3].v * idealDiode2.idealDiode[3].i;
//   idealDiode2.idealDiode[3].i = idealDiode2.idealDiode[3].p.i;
//   0.0 = idealDiode2.idealDiode[3].p.i + idealDiode2.idealDiode[3].n.i;
//   idealDiode2.idealDiode[3].v = idealDiode2.idealDiode[3].p.v - idealDiode2.idealDiode[3].n.v;
//   idealDiode2.idealDiode[3].T_heatPort = idealDiode2.idealDiode[3].T;
//   idealDiode2.v[1] = idealDiode2.plug_p.pin[1].v - idealDiode2.plug_n.pin[1].v;
//   idealDiode2.v[2] = idealDiode2.plug_p.pin[2].v - idealDiode2.plug_n.pin[2].v;
//   idealDiode2.v[3] = idealDiode2.plug_p.pin[3].v - idealDiode2.plug_n.pin[3].v;
//   idealDiode2.i[1] = idealDiode2.plug_p.pin[1].i;
//   idealDiode2.i[2] = idealDiode2.plug_p.pin[2].i;
//   idealDiode2.i[3] = idealDiode2.plug_p.pin[3].i;
//   assert(1.0 + loadR.alpha * (loadR.T_heatPort - loadR.T_ref) >= 1e-15,\"Temperature outside scope of model!\");
//   loadR.R_actual = loadR.R * (1.0 + loadR.alpha * (loadR.T_heatPort - loadR.T_ref));
//   loadR.v = loadR.R_actual * loadR.i;
//   loadR.LossPower = loadR.v * loadR.i;
//   loadR.i = loadR.p.i;
//   0.0 = loadR.p.i + loadR.n.i;
//   loadR.v = loadR.p.v - loadR.n.v;
//   loadR.T_heatPort = loadR.T;
//   cDC1.i = cDC1.C * der(cDC1.v);
//   cDC1.v = cDC1.p.v - cDC1.n.v;
//   0.0 = cDC1.p.i + cDC1.n.i;
//   cDC1.i = cDC1.p.i;
//   cDC2.i = cDC2.C * der(cDC2.v);
//   cDC2.v = cDC2.p.v - cDC2.n.v;
//   0.0 = cDC2.p.i + cDC2.n.i;
//   cDC2.i = cDC2.p.i;
//   groundDC.p.v = 0.0;
//   assert(starS.plug_p.m == sineVoltage.plug_n.m,\"automatically generated from connect\");
//   assert(sineVoltage.plug_p.m == supplyL.plug_p.m,\"automatically generated from connect\");
//   assert(idealDiode1.plug_p.m == supplyL.plug_n.m,\"automatically generated from connect\");
//   assert(idealDiode2.plug_n.m == supplyL.plug_n.m,\"automatically generated from connect\");
//   assert(idealDiode1.plug_n.m == star1.plug_p.m,\"automatically generated from connect\");
//   assert(idealDiode2.plug_p.m == star2.plug_p.m,\"automatically generated from connect\");
//   star1.pin_n.i + (loadR.p.i + cDC1.p.i) = 0.0;
//   cDC1.p.v = loadR.p.v;
//   cDC1.p.v = star1.pin_n.v;
//   star2.pin_n.i + (loadR.n.i + cDC2.n.i) = 0.0;
//   cDC2.n.v = loadR.n.v;
//   cDC2.n.v = star2.pin_n.v;
//   idealDiode2.plug_p.pin[3].i + star2.plug_p.pin[3].i = 0.0;
//   idealDiode2.plug_p.pin[3].v = star2.plug_p.pin[3].v;
//   idealDiode2.plug_p.pin[2].i + star2.plug_p.pin[2].i = 0.0;
//   idealDiode2.plug_p.pin[2].v = star2.plug_p.pin[2].v;
//   idealDiode2.plug_p.pin[1].i + star2.plug_p.pin[1].i = 0.0;
//   idealDiode2.plug_p.pin[1].v = star2.plug_p.pin[1].v;
//   idealDiode1.plug_n.pin[3].i + star1.plug_p.pin[3].i = 0.0;
//   idealDiode1.plug_n.pin[3].v = star1.plug_p.pin[3].v;
//   idealDiode1.plug_n.pin[2].i + star1.plug_p.pin[2].i = 0.0;
//   idealDiode1.plug_n.pin[2].v = star1.plug_p.pin[2].v;
//   idealDiode1.plug_n.pin[1].i + star1.plug_p.pin[1].i = 0.0;
//   idealDiode1.plug_n.pin[1].v = star1.plug_p.pin[1].v;
//   idealDiode2.plug_n.pin[3].i + (idealDiode1.plug_p.pin[3].i + supplyL.plug_n.pin[3].i) = 0.0;
//   idealDiode1.plug_p.pin[3].v = idealDiode2.plug_n.pin[3].v;
//   idealDiode1.plug_p.pin[3].v = supplyL.plug_n.pin[3].v;
//   idealDiode2.plug_n.pin[2].i + (idealDiode1.plug_p.pin[2].i + supplyL.plug_n.pin[2].i) = 0.0;
//   idealDiode1.plug_p.pin[2].v = idealDiode2.plug_n.pin[2].v;
//   idealDiode1.plug_p.pin[2].v = supplyL.plug_n.pin[2].v;
//   idealDiode2.plug_n.pin[1].i + (idealDiode1.plug_p.pin[1].i + supplyL.plug_n.pin[1].i) = 0.0;
//   idealDiode1.plug_p.pin[1].v = idealDiode2.plug_n.pin[1].v;
//   idealDiode1.plug_p.pin[1].v = supplyL.plug_n.pin[1].v;
//   sineVoltage.plug_p.pin[3].i + supplyL.plug_p.pin[3].i = 0.0;
//   sineVoltage.plug_p.pin[3].v = supplyL.plug_p.pin[3].v;
//   sineVoltage.plug_p.pin[2].i + supplyL.plug_p.pin[2].i = 0.0;
//   sineVoltage.plug_p.pin[2].v = supplyL.plug_p.pin[2].v;
//   sineVoltage.plug_p.pin[1].i + supplyL.plug_p.pin[1].i = 0.0;
//   sineVoltage.plug_p.pin[1].v = supplyL.plug_p.pin[1].v;
//   starS.plug_p.pin[3].i + sineVoltage.plug_n.pin[3].i = 0.0;
//   sineVoltage.plug_n.pin[3].v = starS.plug_p.pin[3].v;
//   starS.plug_p.pin[2].i + sineVoltage.plug_n.pin[2].i = 0.0;
//   sineVoltage.plug_n.pin[2].v = starS.plug_p.pin[2].v;
//   starS.plug_p.pin[1].i + sineVoltage.plug_n.pin[1].i = 0.0;
//   sineVoltage.plug_n.pin[1].v = starS.plug_p.pin[1].v;
//   cDC1.n.i + (cDC2.p.i + groundDC.p.i) = 0.0;
//   cDC1.n.v = cDC2.p.v;
//   cDC1.n.v = groundDC.p.v;
//   (-star2.plug_p.pin[3].i) + ((-star2.plug_p.pin[2].i) + ((-star2.plug_p.pin[1].i) + (-star2.pin_n.i))) = 0.0;
//   star2.pin_n.v = star2.plug_p.pin[1].v;
//   star2.pin_n.v = star2.plug_p.pin[2].v;
//   star2.pin_n.v = star2.plug_p.pin[3].v;
//   idealDiode2.idealDiode[3].n.i + (-idealDiode2.plug_n.pin[3].i) = 0.0;
//   idealDiode2.idealDiode[3].n.v = idealDiode2.plug_n.pin[3].v;
//   idealDiode2.idealDiode[2].n.i + (-idealDiode2.plug_n.pin[2].i) = 0.0;
//   idealDiode2.idealDiode[2].n.v = idealDiode2.plug_n.pin[2].v;
//   idealDiode2.idealDiode[1].n.i + (-idealDiode2.plug_n.pin[1].i) = 0.0;
//   idealDiode2.idealDiode[1].n.v = idealDiode2.plug_n.pin[1].v;
//   (-idealDiode2.plug_p.pin[3].i) + idealDiode2.idealDiode[3].p.i = 0.0;
//   idealDiode2.idealDiode[3].p.v = idealDiode2.plug_p.pin[3].v;
//   (-idealDiode2.plug_p.pin[2].i) + idealDiode2.idealDiode[2].p.i = 0.0;
//   idealDiode2.idealDiode[2].p.v = idealDiode2.plug_p.pin[2].v;
//   (-idealDiode2.plug_p.pin[1].i) + idealDiode2.idealDiode[1].p.i = 0.0;
//   idealDiode2.idealDiode[1].p.v = idealDiode2.plug_p.pin[1].v;
//   (-star1.plug_p.pin[3].i) + ((-star1.plug_p.pin[2].i) + ((-star1.plug_p.pin[1].i) + (-star1.pin_n.i))) = 0.0;
//   star1.pin_n.v = star1.plug_p.pin[1].v;
//   star1.pin_n.v = star1.plug_p.pin[2].v;
//   star1.pin_n.v = star1.plug_p.pin[3].v;
//   idealDiode1.idealDiode[3].n.i + (-idealDiode1.plug_n.pin[3].i) = 0.0;
//   idealDiode1.idealDiode[3].n.v = idealDiode1.plug_n.pin[3].v;
//   idealDiode1.idealDiode[2].n.i + (-idealDiode1.plug_n.pin[2].i) = 0.0;
//   idealDiode1.idealDiode[2].n.v = idealDiode1.plug_n.pin[2].v;
//   idealDiode1.idealDiode[1].n.i + (-idealDiode1.plug_n.pin[1].i) = 0.0;
//   idealDiode1.idealDiode[1].n.v = idealDiode1.plug_n.pin[1].v;
//   (-idealDiode1.plug_p.pin[3].i) + idealDiode1.idealDiode[3].p.i = 0.0;
//   idealDiode1.idealDiode[3].p.v = idealDiode1.plug_p.pin[3].v;
//   (-idealDiode1.plug_p.pin[2].i) + idealDiode1.idealDiode[2].p.i = 0.0;
//   idealDiode1.idealDiode[2].p.v = idealDiode1.plug_p.pin[2].v;
//   (-idealDiode1.plug_p.pin[1].i) + idealDiode1.idealDiode[1].p.i = 0.0;
//   idealDiode1.idealDiode[1].p.v = idealDiode1.plug_p.pin[1].v;
//   supplyL.inductor[3].n.i + (-supplyL.plug_n.pin[3].i) = 0.0;
//   supplyL.inductor[3].n.v = supplyL.plug_n.pin[3].v;
//   supplyL.inductor[2].n.i + (-supplyL.plug_n.pin[2].i) = 0.0;
//   supplyL.inductor[2].n.v = supplyL.plug_n.pin[2].v;
//   supplyL.inductor[1].n.i + (-supplyL.plug_n.pin[1].i) = 0.0;
//   supplyL.inductor[1].n.v = supplyL.plug_n.pin[1].v;
//   supplyL.inductor[3].p.i + (-supplyL.plug_p.pin[3].i) = 0.0;
//   supplyL.inductor[3].p.v = supplyL.plug_p.pin[3].v;
//   supplyL.inductor[2].p.i + (-supplyL.plug_p.pin[2].i) = 0.0;
//   supplyL.inductor[2].p.v = supplyL.plug_p.pin[2].v;
//   supplyL.inductor[1].p.i + (-supplyL.plug_p.pin[1].i) = 0.0;
//   supplyL.inductor[1].p.v = supplyL.plug_p.pin[1].v;
//   (-starS.plug_p.pin[3].i) + ((-starS.plug_p.pin[2].i) + ((-starS.plug_p.pin[1].i) + (-starS.pin_n.i))) = 0.0;
//   starS.pin_n.v = starS.plug_p.pin[1].v;
//   starS.pin_n.v = starS.plug_p.pin[2].v;
//   starS.pin_n.v = starS.plug_p.pin[3].v;
//   starS.pin_n.i = 0.0;
//   sineVoltage.sineVoltage[3].n.i + (-sineVoltage.plug_n.pin[3].i) = 0.0;
//   sineVoltage.plug_n.pin[3].v = sineVoltage.sineVoltage[3].n.v;
//   sineVoltage.sineVoltage[2].n.i + (-sineVoltage.plug_n.pin[2].i) = 0.0;
//   sineVoltage.plug_n.pin[2].v = sineVoltage.sineVoltage[2].n.v;
//   sineVoltage.sineVoltage[1].n.i + (-sineVoltage.plug_n.pin[1].i) = 0.0;
//   sineVoltage.plug_n.pin[1].v = sineVoltage.sineVoltage[1].n.v;
//   sineVoltage.sineVoltage[3].p.i + (-sineVoltage.plug_p.pin[3].i) = 0.0;
//   sineVoltage.plug_p.pin[3].v = sineVoltage.sineVoltage[3].p.v;
//   sineVoltage.sineVoltage[2].p.i + (-sineVoltage.plug_p.pin[2].i) = 0.0;
//   sineVoltage.plug_p.pin[2].v = sineVoltage.sineVoltage[2].p.v;
//   sineVoltage.sineVoltage[1].p.i + (-sineVoltage.plug_p.pin[1].i) = 0.0;
//   sineVoltage.plug_p.pin[1].v = sineVoltage.sineVoltage[1].p.v;
// end Modelica.Electrical.MultiPhase.Examples.Rectifier;
// "
// ""
// "Check of Modelica.Electrical.MultiPhase.Examples.Rectifier completed successfully.
// 
// 
// Class Modelica.Electrical.MultiPhase.Examples.Rectifier has 218 equation(s) and 218 variable(s).
// 150 of these are trivial equation(s).
// "
// ""
// record SimulationResult
//     resultFile = "Modelica.Electrical.MultiPhase.Examples.Rectifier_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'Modelica.Electrical.MultiPhase.Examples.Rectifier', storeInTemp = false, noClean = false, options = '', outputFormat = 'mat', variableFilter = '.*', cflags = ''",
//     messages = ""
// end SimulationResult;
// ""
// 0
// endResult
