// name:     Bug3817.mos
// keywords: modification should respect declared inner!
// status:   correct
// teardown_command: rm -rf PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv*
// cflags: -d=-newInst

loadFile("Bug3817.mo"); getErrorString();
instantiateModel(PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv); getErrorString();
checkModel(PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv); getErrorString();
simulate(PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv); getErrorString();

// Result:
// true
// ""
// "function PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Inverter$sm_ctrl$inverter.Data \"Automatically generated record constructor for PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Inverter$sm_ctrl$inverter.Data\"
//   input Real V_nom(min = 0.0, quantity = \"ElectricPotential\", unit = \"V\") = 100.0;
//   input Real I_nom(min = 0.0, quantity = \"ElectricCurrent\", unit = \"A\") = 10.0;
//   input Real[2] eps(min = 0.0, unit = \"1\") = {0.0001, 0.0001};
//   input Real Vf(min = 0.0, quantity = \"ElectricPotential\", unit = \"V\") = 2.5;
//   input Real Hsw_nom(quantity = \"Energy\", unit = \"J\") = 0.25;
//   input Real[0] cT_loss = {};
//   input Real T0_loss(quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, start = 288.15, nominal = 300.0, displayUnit = \"degC\") = 300.0;
//   output Data res;
// end PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Inverter$sm_ctrl$inverter.Data;
//
// function PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Inverter$sm_ctrl$inverter.loss \"temp dependence of losses\"
//   input Real x \"argument\";
//   input Real[:] c \"coefficients\";
//   output Real y \"sum(c[n]*x^n)\";
//   protected Real x_k;
// algorithm
//   y := 1.0;
//   x_k := 1.0;
//   for k in 1:size(c, 1) loop
//     x_k := x * x_k;
//     y := y + c[k] * x_k;
//   end for;
// end PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Inverter$sm_ctrl$inverter.loss;
//
// function PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Motor$sm_ctrl$motor.Data \"Automatically generated record constructor for PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Motor$sm_ctrl$motor.Data\"
//   input Boolean puUnits = true;
//   input Real V_nom(min = 0.0, quantity = \"ElectricPotential\", unit = \"V\") = 400.0;
//   input Real S_nom(min = 0.0, quantity = \"Power\", unit = \"VA\") = 30000.0;
//   input Real f_nom(quantity = \"Frequency\", unit = \"Hz\") = system.f_nom;
//   input Boolean neu_iso = false;
//   input Integer pp = 2;
//   input Integer excite(min = 0, max = 3) = 2;
//   input Real psi_pm(quantity = \"MagneticFlux\", unit = \"Wb/Wb\") = 1.1;
//   input Real x_d(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.4;
//   input Real x_q(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.4;
//   input Real x_o(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.1;
//   input Real r_s(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0) = 0.03;
//   input Real r_n(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0) = 1.0;
//   output Data res;
// end PowerSystems.AC3ph.Drives.SM_ctrl$sm_ctrl.Motor$sm_ctrl$motor.Data;
//
// function PowerSystems.AC3ph.Machines.Coefficients.Synchron3rd \"Automatically generated record constructor for PowerSystems.AC3ph.Machines.Coefficients.Synchron3rd\"
//   input Real[3] L_s(quantity = \"Inductance\", unit = \"H\");
//   input Real R_s(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real R_n(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real Psi_pm(quantity = \"MagneticFlux\", unit = \"Wb\");
//   input Real omega_nom(quantity = \"AngularFrequency\", unit = \"rad/s\");
//   output Synchron3rd res;
// end PowerSystems.AC3ph.Machines.Coefficients.Synchron3rd;
//
// function PowerSystems.AC3ph.Machines.Parameters.Synchron3rd \"Automatically generated record constructor for PowerSystems.AC3ph.Machines.Parameters.Synchron3rd\"
//   input Boolean puUnits = true;
//   input Real V_nom(min = 0.0, quantity = \"ElectricPotential\", unit = \"V\") = 1.0;
//   input Real S_nom(min = 0.0, quantity = \"Power\", unit = \"VA\") = 1.0;
//   input Real f_nom(quantity = \"Frequency\", unit = \"Hz\") = 50.0;
//   input Boolean neu_iso;
//   input Integer pp;
//   input Integer excite(min = 0, max = 3);
//   input Real psi_pm(quantity = \"MagneticFlux\", unit = \"Wb/Wb\");
//   input Real x_d(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\");
//   input Real x_q(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\");
//   input Real x_o(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\");
//   input Real r_s(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0);
//   input Real r_n(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0);
//   output Synchron3rd res;
// end PowerSystems.AC3ph.Machines.Parameters.Synchron3rd;
//
// function PowerSystems.Basic.Precalculation.baseRL \"Base resistance and inductance\"
//   input Boolean puUnits \"= true if pu else SI units\";
//   input Real V_nom(quantity = \"ElectricPotential\", unit = \"V\") \"nom voltage\";
//   input Real S_nom(quantity = \"Power\", unit = \"VA\") \"apparent power\";
//   input Real omega_nom(quantity = \"AngularFrequency\", unit = \"rad/s\") \"angular frequency\";
//   input Integer scale = 1 \"scaling factor topology (Y:1, Delta:3)\";
//   output Real[2] RL_base \"base {resistance, inductance}\";
// algorithm
//   if puUnits then
//     RL_base := {/*Real*/(scale) * V_nom ^ 2.0 / S_nom, /*Real*/(scale) * V_nom ^ 2.0 / S_nom / omega_nom};
//   else
//     RL_base := {/*Real*/(scale), /*Real*/(scale) / omega_nom};
//   end if;
// end PowerSystems.Basic.Precalculation.baseRL;
//
// function PowerSystems.Basic.Precalculation.baseV \"Base voltage\"
//   input Boolean puUnits \"= true if pu else SI units\";
//   input Real V_nom(quantity = \"ElectricPotential\", unit = \"V\") \"nom voltage\";
//   output Real V_base(quantity = \"ElectricPotential\", unit = \"V\") \"base voltage\";
// algorithm
//   if puUnits then
//     V_base := V_nom;
//   else
//     V_base := 1.0;
//   end if;
// end PowerSystems.Basic.Precalculation.baseV;
//
// function PowerSystems.Basic.Precalculation.machineSyn3rd \"Calculates coefficient matrices of synchronous machine, 3rd order\"
//   input PowerSystems.AC3ph.Machines.Parameters.Synchron3rd p \"parameters synchronous machine 3rd order\";
//   input Integer scale = 1 \"scaling factor topology (Y:1, Delta:3)\";
//   output PowerSystems.AC3ph.Machines.Coefficients.Synchron3rd c \"coefficient matrices synchronous machine 3rd order\";
//   protected final parameter Real omega_nom(quantity = \"AngularFrequency\", unit = \"rad/s\") = 6.283185307179586 * p.f_nom;
//   protected final parameter Real[2] RL_base = PowerSystems.Basic.Precalculation.baseRL(p.puUnits, p.V_nom, p.S_nom, omega_nom, scale) \"base resistance inductance\";
// algorithm
//   c.L_s := {p.x_d * RL_base[2], p.x_q * RL_base[2], p.x_o * RL_base[2]};
//   c.R_s := p.r_s * RL_base[1];
//   c.R_n := p.r_n * RL_base[1];
//   c.Psi_pm := p.psi_pm * p.V_nom / omega_nom;
//   c.omega_nom := omega_nom;
// end PowerSystems.Basic.Precalculation.machineSyn3rd;
//
// function PowerSystems.Basic.Transforms.der2_rotation_dq \"2nd derivative of rotation matrix dq\"
//   input Real theta(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   input Real omega(quantity = \"AngularFrequency\", unit = \"rad/s\") \"d/dt theta\";
//   input Real omega_dot(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"d/dt omega\";
//   output Real[2, 2] der2_R_dq \"d/2dt2 rotation_dq\";
//   protected Real c;
//   protected Real s;
//   protected Real d2c;
//   protected Real d2s;
//   protected Real omega2 = omega ^ 2.0;
// algorithm
//   c := cos(theta);
//   s := sin(theta);
//   d2c := (-omega_dot) * s - omega2 * c;
//   d2s := omega_dot * c - omega2 * s;
//   der2_R_dq := {{d2c, -d2s}, {d2s, d2c}};
// end PowerSystems.Basic.Transforms.der2_rotation_dq;
//
// function PowerSystems.Basic.Transforms.der_rotation_dq \"Derivative of rotation matrix dq\"
//   input Real theta(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   input Real omega(quantity = \"AngularFrequency\", unit = \"rad/s\") \"d/dt theta\";
//   output Real[2, 2] der_R_dq \"d/dt rotation_dq\";
//   protected Real dc;
//   protected Real ds;
// algorithm
//   dc := (-omega) * sin(theta);
//   ds := omega * cos(theta);
//   der_R_dq := {{dc, -ds}, {ds, dc}};
// end PowerSystems.Basic.Transforms.der_rotation_dq;
//
// function PowerSystems.Basic.Transforms.rotation_dq \"Rotation matrix dq\"
//   input Real theta(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"rotation angle\";
//   output Real[2, 2] R_dq \"rotation matrix\";
//   protected Real c;
//   protected Real s;
// algorithm
//   c := cos(theta);
//   s := sin(theta);
//   R_dq := {{c, -s}, {s, c}};
// end PowerSystems.Basic.Transforms.rotation_dq;
//
// function PowerSystems.Basic.Types.ReferenceAngle.equalityConstraint
//   input Real[:] theta1(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   input Real[:] theta2(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Real[0] residue \"No constraints\";
// algorithm
//   for i in 1:size(theta1, 1) loop
//     assert(abs(theta1[i] - theta2[i]) < 1e-15, \"angles theta1 and theta2 not equal over connection!\");
//   end for;
// end PowerSystems.Basic.Types.ReferenceAngle.equalityConstraint;
//
// class PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv \"AC synchronous pm machine, current controlled with average inverter\"
//   parameter Real system.f_nom(quantity = \"Frequency\", unit = \"Hz\") = 50.0 \"nominal frequency\";
//   parameter Real system.f(quantity = \"Frequency\", unit = \"Hz\") = system.f_nom \"frequency if fType_par = true, else initial frequency\";
//   parameter Boolean system.fType_par = true \"= true, if system frequency defined by parameter f, else average frequency\";
//   parameter Real system.f_lim[1](quantity = \"Frequency\", unit = \"Hz\") = 0.5 * system.f_nom \"limit frequencies (for supervision of average frequency)\";
//   parameter Real system.f_lim[2](quantity = \"Frequency\", unit = \"Hz\") = 2.0 * system.f_nom \"limit frequencies (for supervision of average frequency)\";
//   parameter Real system.alpha0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"phase angle\";
//   parameter String system.ref = \"synchron\" \"reference frame (3-phase)\";
//   parameter String system.ini = \"st\" \"transient or steady-state initialisation\";
//   parameter String system.sim = \"tr\" \"transient or steady-state simulation\";
//   final parameter Real system.omega_nom(quantity = \"AngularFrequency\", unit = \"rad/s\") = 6.283185307179586 * system.f_nom \"nominal angular frequency\";
//   final parameter Real system.w_nom(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rpm\") = 6.283185307179586 * system.f_nom \"nom r.p.m.\";
//   final parameter Boolean system.synRef = if system.transientSim then system.ref == \"synchron\" else true;
//   final parameter Boolean system.steadyIni = system.ini == \"st\" \"steady state initialisation of electric equations\";
//   final parameter Boolean system.transientSim = system.sim == \"tr\" \"transient mode of electric equations\";
//   final parameter Boolean system.steadyIni_t = system.steadyIni and system.transientSim;
//   discrete Real system.initime(quantity = \"Time\", unit = \"s\");
//   Real system.theta(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0, stateSelect = StateSelect.default);
//   Real system.omega(quantity = \"AngularFrequency\", unit = \"rad/s\", start = 6.283185307179586 * system.f);
//   Real system.receiveFreq.H(quantity = \"Time\", unit = \"s\") \"inertia constant\";
//   Real system.receiveFreq.w_H(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"angular velocity, inertia-weighted\";
//   Real system.receiveFreq.h \"Dummy potential-variable to balance flow-variable H\";
//   Real system.receiveFreq.w_h \"Dummy potential-variable to balance flow-variable w_H\";
//   Real grd.term.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real grd.term.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   Real voltage.term.v[1](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real voltage.term.v[2](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real voltage.term.i[1](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   Real voltage.term.i[2](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   parameter Boolean voltage.puUnits = true \"= true, if scaled with nom. values (pu), else scaled with 1 (SI)\";
//   parameter Real voltage.V_nom(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0) = 653.1972647421808 \"nominal Voltage (= base for pu)\";
//   parameter Real voltage.S_nom(quantity = \"Power\", unit = \"VA\", min = 0.0) = 1.0 \"nominal Power (= base for pu)\";
//   parameter Integer voltage.pol(min = -1, max = 1) = 0 \"grounding scheme\";
//   parameter Boolean voltage.scType_par = true \"= true: voltage defined by parameter otherwise by input signal\";
//   Real voltage.neutral.v(quantity = \"ElectricPotential\", unit = \"V\") \"Potential at the pin\";
//   Real voltage.neutral.i(quantity = \"ElectricCurrent\", unit = \"A\") \"Current flowing into the pin\";
//   protected final parameter Real voltage.V_base = PowerSystems.Basic.Precalculation.baseV(voltage.puUnits, voltage.V_nom);
//   protected Real voltage.vDC_internal \"Needed to connect to conditional connector\";
//   parameter Real voltage.v0(quantity = \"Voltage\", unit = \"V/V\") = 1.0 \"DC voltage\";
//   protected Real voltage.v(quantity = \"ElectricPotential\", unit = \"V\");
//   parameter Real sm_ctrl.w_ini(quantity = \"AngularVelocity\", unit = \"rad/s\", displayUnit = \"rpm\") = 0.0 \"initial rpm (start-value if ini='st')\";
//   Real sm_ctrl.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.rotor.flange_p.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.rotor.flange_p.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.rotor.flange_n.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.rotor.flange_n.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real sm_ctrl.rotor.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.3 \"inertia\";
//   parameter Real sm_ctrl.rotor.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"start value of angular velocity\";
//   Real sm_ctrl.rotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"rotation angle absolute\";
//   Real sm_ctrl.rotor.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = sm_ctrl.w_ini);
//   Real sm_ctrl.rotor.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\");
//   Real sm_ctrl.rotor.rotor.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.rotor.rotor.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.rotor.stator.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.rotor.stator.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.rotor.friction.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.rotor.friction.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.gear.flange_p.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.gear.flange_p.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real sm_ctrl.gear.flange_n.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.gear.flange_n.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Integer sm_ctrl.heat.m(min = 1) = sm_ctrl.heat_adapt.m[1] + sm_ctrl.heat_adapt.m[2] \"number of single heat-ports\";
//   Real sm_ctrl.heat.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.heat.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real sm_ctrl.heat.ports[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.heat.ports[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real sm_ctrl.heat.ports[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.heat.ports[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real sm_ctrl.term.v[1](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.term.v[2](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.term.i[1](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.term.i[2](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.i_meas[1](unit = \"1\") \"measured current {i_d, i_q} pu\";
//   Real sm_ctrl.i_meas[2](unit = \"1\") \"measured current {i_d, i_q} pu\";
//   Real sm_ctrl.i_act[1](unit = \"1\") \"actuated current {i_d, i_q} pu\";
//   Real sm_ctrl.i_act[2](unit = \"1\") \"actuated current {i_d, i_q} pu\";
//   protected parameter Integer sm_ctrl.heat_adapt.m[1] = 2 \"dimension {port_a, port_b}\";
//   protected parameter Integer sm_ctrl.heat_adapt.m[2] = sm_ctrl.inverter.heat.m \"dimension {port_a, port_b}\";
//   protected parameter Integer sm_ctrl.heat_adapt.port_a.m(min = 1) = sm_ctrl.heat_adapt.m[1] \"number of single heat-ports\";
//   protected Real sm_ctrl.heat_adapt.port_a.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_a.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real sm_ctrl.heat_adapt.port_a.ports[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_a.ports[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected parameter Integer sm_ctrl.heat_adapt.port_b.m(min = 1) = sm_ctrl.heat_adapt.m[2] \"number of single heat-ports\";
//   protected Real sm_ctrl.heat_adapt.port_b.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_b.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected parameter Integer sm_ctrl.heat_adapt.port_ab.m(min = 1) = sm_ctrl.heat_adapt.m[1] + sm_ctrl.heat_adapt.m[2] \"number of single heat-ports\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   protected Real sm_ctrl.heat_adapt.port_ab.ports[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real sm_ctrl.inverter.AC.v[1](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.inverter.AC.v[2](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.inverter.AC.v[3](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.inverter.AC.i[1](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.inverter.AC.i[2](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.inverter.AC.i[3](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.inverter.AC.theta[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"optional vector of phase angles\";
//   Real sm_ctrl.inverter.AC.theta[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"optional vector of phase angles\";
//   Real sm_ctrl.inverter.DC.v[1](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.inverter.DC.v[2](quantity = \"Voltage.TwoConductor\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.inverter.DC.i[1](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.inverter.DC.i[2](quantity = \"Current.TwoConductor\", unit = \"A\") \"current vector\";
//   parameter Integer sm_ctrl.inverter.heat.m(min = 1) = 1 \"number of single heat-ports\";
//   Real sm_ctrl.inverter.heat.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.inverter.heat.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected Real sm_ctrl.inverter.vDC1(quantity = \"ElectricPotential\", unit = \"V\") = 0.5 * (sm_ctrl.inverter.DC.v[1] - sm_ctrl.inverter.DC.v[2]);
//   protected Real sm_ctrl.inverter.vDC0(quantity = \"ElectricPotential\", unit = \"V\") = 0.5 * (sm_ctrl.inverter.DC.v[1] + sm_ctrl.inverter.DC.v[2]);
//   protected Real sm_ctrl.inverter.iDC1(quantity = \"ElectricCurrent\", unit = \"A\") = sm_ctrl.inverter.DC.i[1] - sm_ctrl.inverter.DC.i[2];
//   protected Real sm_ctrl.inverter.iDC0(quantity = \"ElectricCurrent\", unit = \"A\") = sm_ctrl.inverter.DC.i[1] + sm_ctrl.inverter.DC.i[2];
//   protected Real sm_ctrl.inverter.v_dq0[1] \"switching function voltage in dq0 representation\";
//   protected Real sm_ctrl.inverter.v_dq0[2] \"switching function voltage in dq0 representation\";
//   protected Real sm_ctrl.inverter.v_dq0[3] \"switching function voltage in dq0 representation\";
//   protected Real sm_ctrl.inverter.switch_dq0[1] \"switching function in dq0 representation\";
//   protected Real sm_ctrl.inverter.switch_dq0[2] \"switching function in dq0 representation\";
//   protected Real sm_ctrl.inverter.switch_dq0[3] \"switching function in dq0 representation\";
//   protected Real sm_ctrl.inverter.T[1](quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"component temperature\";
//   protected Real sm_ctrl.inverter.Q_flow[1](quantity = \"Power\", unit = \"W\") \"component loss-heat flow\";
//   final parameter Real sm_ctrl.inverter.par.V_nom(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0) = 100.0 \"nom Voltage\";
//   final parameter Real sm_ctrl.inverter.par.I_nom(quantity = \"ElectricCurrent\", unit = \"A\", min = 0.0) = 10.0 \"nom Current\";
//   final parameter Real sm_ctrl.inverter.par.eps[1](unit = \"1\", min = 0.0) = 0.0001 \"{resistance 'on', conductance 'off'}\";
//   final parameter Real sm_ctrl.inverter.par.eps[2](unit = \"1\", min = 0.0) = 0.0001 \"{resistance 'on', conductance 'off'}\";
//   final parameter Real sm_ctrl.inverter.par.Vf(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0) = 2.5 \"forward threshold-voltage\";
//   final parameter Real sm_ctrl.inverter.par.Hsw_nom(quantity = \"Energy\", unit = \"J\") = 0.25 \"switching loss at V_nom, I_nom (av on off)\";
//   final parameter Real sm_ctrl.inverter.par.T0_loss(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 300.0 \"reference T for cT_loss expansion\";
//   parameter Integer sm_ctrl.inverter.modulation = 1 \"equivalent modulation :\";
//   parameter Boolean sm_ctrl.inverter.syn = false \"synchronous, asynchronous\";
//   parameter Integer sm_ctrl.inverter.m_carr(min = 1) = 1 \"f_carr/f, pulses/period\";
//   parameter Real sm_ctrl.inverter.f_carr(quantity = \"Frequency\", unit = \"Hz\") = 1000.0 \"carrier frequency\";
//   parameter Real sm_ctrl.inverter.width0 = 0.6666666666666666 \"relative width, (0 - 1)\";
//   Real sm_ctrl.inverter.theta \"abs angle, der(theta)=omega\";
//   Real sm_ctrl.inverter.uPhasor[1] \"desired {abs(u), phase(u)}\";
//   Real sm_ctrl.inverter.uPhasor[2] \"desired {abs(u), phase(u)}\";
//   protected final parameter Real sm_ctrl.inverter.R_nom(quantity = \"Resistance\", unit = \"Ohm\") = sm_ctrl.inverter.par.V_nom / sm_ctrl.inverter.par.I_nom;
//   protected final parameter Real sm_ctrl.inverter.factor = if sm_ctrl.inverter.modulation == 1 then 1.224744871391589 else if sm_ctrl.inverter.modulation == 2 then 1.632993161855452 else if sm_ctrl.inverter.modulation == 3 then 1.559393602467352 * sin(1.570796326794897 * sm_ctrl.inverter.width0) else 0.0;
//   protected Real sm_ctrl.inverter.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   protected Real sm_ctrl.inverter.Vloss(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real sm_ctrl.inverter.iAC2;
//   protected Real sm_ctrl.inverter.cT;
//   protected Real sm_ctrl.inverter.hsw_nom;
//   Real sm_ctrl.motor.term.v[1](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.motor.term.v[2](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.motor.term.v[3](quantity = \"Voltage.ThreePhase_dq0\", unit = \"V\") \"voltage vector\";
//   Real sm_ctrl.motor.term.i[1](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.motor.term.i[2](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.motor.term.i[3](quantity = \"Current.ThreePhase_dq0\", unit = \"A\") \"current vector\";
//   Real sm_ctrl.motor.term.theta[1](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"optional vector of phase angles\";
//   Real sm_ctrl.motor.term.theta[2](quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"optional vector of phase angles\";
//   parameter Integer sm_ctrl.motor.top.n_n(min = 0, max = 1) = 1 \"1 for Y, 0 for Delta\";
//   parameter Integer sm_ctrl.motor.top.sh(min = -1, max = 1) = 0 \"(-1,0,+1)*120deg phase shift\";
//   Real sm_ctrl.motor.top.v_term[1](quantity = \"ElectricPotential\", unit = \"V\") \"terminal voltage\";
//   Real sm_ctrl.motor.top.v_term[2](quantity = \"ElectricPotential\", unit = \"V\") \"terminal voltage\";
//   Real sm_ctrl.motor.top.v_term[3](quantity = \"ElectricPotential\", unit = \"V\") \"terminal voltage\";
//   Real sm_ctrl.motor.top.i_term[1](quantity = \"ElectricCurrent\", unit = \"A\") \"terminal current\";
//   Real sm_ctrl.motor.top.i_term[2](quantity = \"ElectricCurrent\", unit = \"A\") \"terminal current\";
//   Real sm_ctrl.motor.top.i_term[3](quantity = \"ElectricCurrent\", unit = \"A\") \"terminal current\";
//   Real sm_ctrl.motor.top.v_cond[1](quantity = \"ElectricPotential\", unit = \"V\") \"conductor voltage\";
//   Real sm_ctrl.motor.top.v_cond[2](quantity = \"ElectricPotential\", unit = \"V\") \"conductor voltage\";
//   Real sm_ctrl.motor.top.v_cond[3](quantity = \"ElectricPotential\", unit = \"V\") \"conductor voltage\";
//   Real sm_ctrl.motor.top.i_cond[1](quantity = \"ElectricCurrent\", unit = \"A\") \"conductor current\";
//   Real sm_ctrl.motor.top.i_cond[2](quantity = \"ElectricCurrent\", unit = \"A\") \"conductor current\";
//   Real sm_ctrl.motor.top.i_cond[3](quantity = \"ElectricCurrent\", unit = \"A\") \"conductor current\";
//   Real sm_ctrl.motor.top.v_n[1](quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) \"voltage neutral\";
//   Real sm_ctrl.motor.top.i_n[1](quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) \"current neutral to ground\";
//   protected constant Real sm_ctrl.motor.top.s3 = 1.732050807568877;
//   constant Integer sm_ctrl.motor.top.scale = 1 \"for scaling of impedance values\";
//   Real sm_ctrl.motor.v[1](quantity = \"ElectricPotential\", unit = \"V\", start = cos(system.alpha0) * sm_ctrl.motor.par.V_nom) \"voltage conductor\";
//   Real sm_ctrl.motor.v[2](quantity = \"ElectricPotential\", unit = \"V\", start = sin(system.alpha0) * sm_ctrl.motor.par.V_nom) \"voltage conductor\";
//   Real sm_ctrl.motor.v[3](quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) \"voltage conductor\";
//   Real sm_ctrl.motor.i[1](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_start[1]) \"current conductor\";
//   Real sm_ctrl.motor.i[2](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_start[2]) \"current conductor\";
//   Real sm_ctrl.motor.i[3](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_start[3]) \"current conductor\";
//   Real sm_ctrl.motor.v_n[1](quantity = \"ElectricPotential\", unit = \"V\") \"voltage neutral\";
//   Real sm_ctrl.motor.i_n[1](quantity = \"ElectricCurrent\", unit = \"A\") \"current neutral to ground\";
//   protected final parameter Integer sm_ctrl.motor.n_n = sm_ctrl.motor.top.n_n;
//   parameter Boolean sm_ctrl.motor.stIni_en = true \"enable steady-state initialization\";
//   parameter Real sm_ctrl.motor.i_start[1](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of current conductor\";
//   parameter Real sm_ctrl.motor.i_start[2](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of current conductor\";
//   parameter Real sm_ctrl.motor.i_start[3](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of current conductor\";
//   parameter Real sm_ctrl.motor.phi_el_ini(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"initial rotor angle electric\";
//   parameter Real sm_ctrl.motor.w_ini(quantity = \"AngularVelocity\", unit = \"rad/s\") = sm_ctrl.motor.w_ini \"initial rotor angular velocity\";
//   parameter Integer sm_ctrl.motor.pp = sm_ctrl.motor.par.pp \"pole-pair number\";
//   Real sm_ctrl.motor.phi_el(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = sm_ctrl.motor.phi_el_ini, stateSelect = StateSelect.prefer) \"rotor angle electric (syn: +pi/2)\";
//   Real sm_ctrl.motor.w_el(quantity = \"AngularVelocity\", unit = \"rad/s\", start = sm_ctrl.motor.w_el_ini, stateSelect = StateSelect.prefer) \"rotor angular velocity el\";
//   Real sm_ctrl.motor.tau_el(quantity = \"Torque\", unit = \"N.m\") \"electromagnetic torque\";
//   Real sm_ctrl.motor.airgap.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real sm_ctrl.motor.airgap.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Integer sm_ctrl.motor.heat.m(min = 1) = 2 \"number of single heat-ports\";
//   Real sm_ctrl.motor.heat.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.motor.heat.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real sm_ctrl.motor.heat.ports[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real sm_ctrl.motor.heat.ports[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   protected final parameter Boolean sm_ctrl.motor.steadyIni_t = system.steadyIni_t and sm_ctrl.motor.stIni_en;
//   protected final parameter Real sm_ctrl.motor.w_el_ini(quantity = \"AngularVelocity\", unit = \"rad/s\") = sm_ctrl.motor.w_ini * /*Real*/(sm_ctrl.motor.pp) \"initial rotor angular velocity electric\";
//   protected Real sm_ctrl.motor.omega[1](quantity = \"AngularFrequency\", unit = \"rad/s\");
//   protected Real sm_ctrl.motor.omega[2](quantity = \"AngularFrequency\", unit = \"rad/s\");
//   parameter Real sm_ctrl.motor.i_s_start[1](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of stator current dq0 in rotor-system\";
//   parameter Real sm_ctrl.motor.i_s_start[2](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of stator current dq0 in rotor-system\";
//   parameter Real sm_ctrl.motor.i_s_start[3](quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"start value of stator current dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.psi_e(quantity = \"MagneticFlux\", unit = \"Wb\") \"excitation flux\";
//   protected Real sm_ctrl.motor.v_s[1](quantity = \"ElectricPotential\", unit = \"V\") \"stator voltage dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.v_s[2](quantity = \"ElectricPotential\", unit = \"V\") \"stator voltage dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.v_s[3](quantity = \"ElectricPotential\", unit = \"V\") \"stator voltage dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.i_s[1](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_s_start[1], stateSelect = StateSelect.prefer) \"stator current dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.i_s[2](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_s_start[2], stateSelect = StateSelect.prefer) \"stator current dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.i_s[3](quantity = \"ElectricCurrent\", unit = \"A\", start = sm_ctrl.motor.i_s_start[3], stateSelect = StateSelect.prefer) \"stator current dq0 in rotor-system\";
//   protected Real sm_ctrl.motor.Rot_dq[1,1] \"Rotation reference-dq0 to rotor-dq0 system\";
//   protected Real sm_ctrl.motor.Rot_dq[1,2] \"Rotation reference-dq0 to rotor-dq0 system\";
//   protected Real sm_ctrl.motor.Rot_dq[2,1] \"Rotation reference-dq0 to rotor-dq0 system\";
//   protected Real sm_ctrl.motor.Rot_dq[2,2] \"Rotation reference-dq0 to rotor-dq0 system\";
//   final parameter Boolean sm_ctrl.motor.par.puUnits = true \"= true, if scaled with nom. values (pu), else scaled with 1 (SI)\";
//   final parameter Real sm_ctrl.motor.par.V_nom(quantity = \"ElectricPotential\", unit = \"V\", min = 0.0) = 400.0 \"nominal Voltage (= base for pu)\";
//   final parameter Real sm_ctrl.motor.par.S_nom(quantity = \"Power\", unit = \"VA\", min = 0.0) = 30000.0 \"nominal Power (= base for pu)\";
//   final parameter Real sm_ctrl.motor.par.f_nom(quantity = \"Frequency\", unit = \"Hz\") = system.f_nom \"nominal frequency\";
//   final parameter Boolean sm_ctrl.motor.par.neu_iso = false \"isolated neutral if Y\";
//   final parameter Integer sm_ctrl.motor.par.pp = 2 \"pole-pair number\";
//   final parameter Integer sm_ctrl.motor.par.excite(min = 0, max = 3) = 2 \"excitation (1:el, 2:pm, 3:reluctance)\";
//   final parameter Real sm_ctrl.motor.par.psi_pm(quantity = \"MagneticFlux\", unit = \"Wb/Wb\") = 1.1 \"magnetisation (V/V_nom at open term at omega_nom)\";
//   final parameter Real sm_ctrl.motor.par.x_d(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.4 \"syn reactance d-axis\";
//   final parameter Real sm_ctrl.motor.par.x_q(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.4 \"syn reactance q-axis\";
//   final parameter Real sm_ctrl.motor.par.x_o(quantity = \"Reactance\", unit = \"Ohm/(V.V/VA)\") = 0.1 \"reactance o-axis\";
//   final parameter Real sm_ctrl.motor.par.r_s(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0) = 0.03 \"resistance armature\";
//   final parameter Real sm_ctrl.motor.par.r_n(quantity = \"Resistance\", unit = \"Ohm/(V.V/VA)\", min = 0.0) = 1.0 \"resistance neutral to grd (if Y)\";
//   protected final parameter Real sm_ctrl.motor.c.L_s[1](quantity = \"Inductance\", unit = \"H\") = 0.0067906109052542 \"L matrix stator dq0\";
//   protected final parameter Real sm_ctrl.motor.c.L_s[2](quantity = \"Inductance\", unit = \"H\") = 0.0067906109052542 \"L matrix stator dq0\";
//   protected final parameter Real sm_ctrl.motor.c.L_s[3](quantity = \"Inductance\", unit = \"H\") = 0.00169765272631355 \"L matrix stator dq0\";
//   protected final parameter Real sm_ctrl.motor.c.R_s(quantity = \"Resistance\", unit = \"Ohm\") = 0.16 \"R stator (armature)\";
//   protected final parameter Real sm_ctrl.motor.c.R_n(quantity = \"Resistance\", unit = \"Ohm\") = 5.333333333333333 \"resistance neutral to grd (if Y)\";
//   protected final parameter Real sm_ctrl.motor.c.Psi_pm(quantity = \"MagneticFlux\", unit = \"Wb\") = 1.400563499208679 \"flux permanent magnet\";
//   protected final parameter Real sm_ctrl.motor.c.omega_nom(quantity = \"AngularFrequency\", unit = \"rad/s\") = 314.1592653589793;
//   protected Real sm_ctrl.motor.psi_s[1](quantity = \"MagneticFlux\", unit = \"Wb\") \"magnetic flux stator dq\";
//   protected Real sm_ctrl.motor.psi_s[2](quantity = \"MagneticFlux\", unit = \"Wb\") \"magnetic flux stator dq\";
//   Real sm_ctrl.motor.i_meas[1](unit = \"1\") \"measured current {i_d, i_q} pu\";
//   Real sm_ctrl.motor.i_meas[2](unit = \"1\") \"measured current {i_d, i_q} pu\";
//   Real sm_ctrl.motor.i_act[1](unit = \"1\") \"actuated current {i_d, i_q} pu\";
//   Real sm_ctrl.motor.i_act[2](unit = \"1\") \"actuated current {i_d, i_q} pu\";
//   Real sm_ctrl.motor.phiRotor = sm_ctrl.motor.phi_el \"rotor angle el\";
//   Real sm_ctrl.motor.uPhasor[1] \"desired {abs(u), phase(u)}\";
//   Real sm_ctrl.motor.uPhasor[2] \"desired {abs(u), phase(u)}\";
//   protected final parameter Real sm_ctrl.motor.I_nom(quantity = \"ElectricCurrent\", unit = \"A\") = sm_ctrl.motor.par.S_nom / sm_ctrl.motor.par.V_nom;
//   protected Real sm_ctrl.motor.v_dq[1](quantity = \"ElectricPotential\", unit = \"V\") \"voltage demand {v_d, v_q} pu\";
//   protected Real sm_ctrl.motor.v_dq[2](quantity = \"ElectricPotential\", unit = \"V\") \"voltage demand {v_d, v_q} pu\";
//   protected Real sm_ctrl.motor.i_dq[1](quantity = \"ElectricCurrent\", unit = \"A\") \"current demand {i_d, i_q} pu\";
//   protected Real sm_ctrl.motor.i_dq[2](quantity = \"ElectricCurrent\", unit = \"A\") \"current demand {i_d, i_q} pu\";
//   parameter Real bdCond.T_amb(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 300.0 \"ambient temperature\";
//   parameter Integer bdCond.m(min = 1) = 3 \"dimension of heat port\";
//   parameter Integer bdCond.heat.m(min = 1) = bdCond.m \"number of single heat-ports\";
//   Real bdCond.heat.ports[1].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real bdCond.heat.ports[1].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real bdCond.heat.ports[2].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real bdCond.heat.ports[2].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real bdCond.heat.ports[3].T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Port temperature\";
//   Real bdCond.heat.ports[3].Q_flow(quantity = \"Power\", unit = \"W\") \"Heat flow rate (positive if flowing from outside into the component)\";
//   Real loadInertia.flange_p.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real loadInertia.flange_p.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   Real loadInertia.flange_n.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real loadInertia.flange_n.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real loadInertia.J(quantity = \"MomentOfInertia\", unit = \"kg.m2\") = 0.5 \"inertia\";
//   parameter Real loadInertia.w_start(quantity = \"AngularVelocity\", unit = \"rad/s\") = 0.0 \"start value of angular velocity\";
//   Real loadInertia.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"rotation angle absolute\";
//   Real loadInertia.w(quantity = \"AngularVelocity\", unit = \"rad/s\", start = loadInertia.w_start);
//   Real loadInertia.a(quantity = \"AngularAcceleration\", unit = \"rad/s2\");
//   Real frictTorq.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real frictTorq.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   parameter Real frictTorq.cFrict[1](min = 0.0) = 0.1 \"friction cst {lin, quadr} in {[N.s/m], [N.s2/m2]}\";
//   parameter Real frictTorq.cFrict[2](min = 0.0) = 0.01 \"friction cst {lin, quadr} in {[N.s/m], [N.s2/m2]}\";
//   Real frictTorq.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real frictTorq.w(quantity = \"AngularVelocity\", unit = \"rad/s\");
//   protected constant Real frictTorq.cFrictUnit1(unit = \"N.s/m\") = 1.0;
//   protected constant Real frictTorq.cFrictUnit2(unit = \"N.s2/m2\") = 1.0;
//   parameter Boolean torqueStep.useSupport = false \"= true, if support flange enabled, otherwise implicitly grounded\";
//   Real torqueStep.flange.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute rotation angle of flange\";
//   Real torqueStep.flange.tau(quantity = \"Torque\", unit = \"N.m\") \"Cut torque in the flange\";
//   protected Real torqueStep.phi_support(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Absolute angle of support flange\";
//   Real torqueStep.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"Angle of flange with respect to support (= flange.phi - support.phi)\";
//   parameter Real torqueStep.stepTorque(quantity = \"Torque\", unit = \"N.m\", start = 1.0) = -100.0 \"Height of torque step (if negative, torque is acting as load)\";
//   parameter Real torqueStep.offsetTorque(quantity = \"Torque\", unit = \"N.m\", start = 0.0) = 0.0 \"Offset of torque\";
//   parameter Real torqueStep.startTime(quantity = \"Time\", unit = \"s\") = 6.0 \"Torque = offset for time < startTime\";
//   Real torqueStep.tau(quantity = \"Torque\", unit = \"N.m\") \"Accelerating torque acting at flange (= -flange.tau)\";
//   Real i_q.y \"output signal\";
//   parameter Real i_q.t_change(quantity = \"Time\", unit = \"s\") = 3.0 \"time when change\";
//   parameter Real i_q.t_duration(quantity = \"Time\", unit = \"s\") = 1.0 \"transition duration\";
//   parameter Real i_q.s_ini = 0.1 \"initial value\";
//   parameter Real i_q.s_fin = 1.0 \"final value\";
//   protected final parameter Real i_q.coef(quantity = \"Frequency\", unit = \"Hz\") = 5.43656365691809 / i_q.t_duration;
//   Real i_d.y \"output signal\";
//   parameter Real i_d.t_change(quantity = \"Time\", unit = \"s\") = 3.0 \"time when change\";
//   parameter Real i_d.t_duration(quantity = \"Time\", unit = \"s\") = 1.0 \"transition duration\";
//   parameter Real i_d.s_ini = 0.0 \"initial value\";
//   parameter Real i_d.s_fin = 0.0 \"final value\";
//   protected final parameter Real i_d.coef(quantity = \"Frequency\", unit = \"Hz\") = 5.43656365691809 / i_d.t_duration;
//   Real PI_i_q.u_s \"Connector of setpoint input signal\";
//   Real PI_i_q.u_m \"Connector of measurement input signal\";
//   Real PI_i_q.y \"Connector of actuator output signal\";
//   Real PI_i_q.controlError = PI_i_q.u_s - PI_i_q.u_m \"Control error (set point - measurement)\";
//   parameter enumeration(P, PI, PD, PID) PI_i_q.controllerType = Modelica.Blocks.Types.SimpleController.PI \"Type of controller\";
//   parameter Real PI_i_q.k(unit = \"1\", min = 0.0) = 1.0 \"Gain of controller\";
//   parameter Real PI_i_q.Ti(quantity = \"Time\", unit = \"s\", min = 1e-60) = 0.2 \"Time constant of Integrator block\";
//   parameter Real PI_i_q.Td(quantity = \"Time\", unit = \"s\", min = 0.0) = 0.1 \"Time constant of Derivative block\";
//   parameter Real PI_i_q.yMax(start = 1.0) = 1.0 \"Upper limit of output\";
//   parameter Real PI_i_q.yMin = -PI_i_q.yMax \"Lower limit of output\";
//   parameter Real PI_i_q.wp(min = 0.0) = 1.0 \"Set-point weight for Proportional block (0..1)\";
//   parameter Real PI_i_q.wd(min = 0.0) = 0.0 \"Set-point weight for Derivative block (0..1)\";
//   parameter Real PI_i_q.Ni(min = 1e-13) = 0.9 \"Ni*Ti is time constant of anti-windup compensation\";
//   parameter Real PI_i_q.Nd(min = 1e-13) = 10.0 \"The higher Nd, the more ideal the derivative block\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput, DoNotUse_InitialIntegratorState) PI_i_q.initType = Modelica.Blocks.Types.InitPID.SteadyState \"Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)\";
//   parameter Boolean PI_i_q.limitsAtInit = true \"= false, if limits are ignored during initialization\";
//   parameter Real PI_i_q.xi_start = 0.0 \"Initial or guess value value for integrator output (= integrator state)\";
//   parameter Real PI_i_q.xd_start = 0.0 \"Initial or guess value for state of derivative block\";
//   parameter Real PI_i_q.y_start = 0.0 \"Initial value of output\";
//   parameter Boolean PI_i_q.strict = false \"= true, if strict limits with noEvent(..)\";
//   constant Real PI_i_q.unitTime(quantity = \"Time\", unit = \"s\") = 1.0;
//   Real PI_i_q.addP.u1 \"Connector of Real input signal 1\";
//   Real PI_i_q.addP.u2 \"Connector of Real input signal 2\";
//   Real PI_i_q.addP.y \"Connector of Real output signal\";
//   parameter Real PI_i_q.addP.k1 = PI_i_q.wp \"Gain of upper input\";
//   parameter Real PI_i_q.addP.k2 = -1.0 \"Gain of lower input\";
//   parameter Real PI_i_q.P.k(unit = \"1\", start = 1.0) = 1.0 \"Gain value multiplied with input signal\";
//   Real PI_i_q.P.u \"Input signal connector\";
//   Real PI_i_q.P.y \"Output signal connector\";
//   parameter Real PI_i_q.gainPID.k(unit = \"1\", start = 1.0) = PI_i_q.k \"Gain value multiplied with input signal\";
//   Real PI_i_q.gainPID.u \"Input signal connector\";
//   Real PI_i_q.gainPID.y(start = 0.1) \"Output signal connector\";
//   parameter Real PI_i_q.addPID.k1 = 1.0 \"Gain of upper input\";
//   parameter Real PI_i_q.addPID.k2 = 1.0 \"Gain of middle input\";
//   parameter Real PI_i_q.addPID.k3 = 1.0 \"Gain of lower input\";
//   Real PI_i_q.addPID.u1 \"Connector 1 of Real input signals\";
//   Real PI_i_q.addPID.u2 \"Connector 2 of Real input signals\";
//   Real PI_i_q.addPID.u3 \"Connector 3 of Real input signals\";
//   Real PI_i_q.addPID.y \"Connector of Real output signals\";
//   Real PI_i_q.limiter.u \"Connector of Real input signal\";
//   Real PI_i_q.limiter.y \"Connector of Real output signal\";
//   parameter Real PI_i_q.limiter.uMax(start = 1.0) = PI_i_q.yMax \"Upper limits of input signals\";
//   parameter Real PI_i_q.limiter.uMin = PI_i_q.yMin \"Lower limits of input signals\";
//   parameter Boolean PI_i_q.limiter.strict = PI_i_q.strict \"= true, if strict limits with noEvent(..)\";
//   parameter Boolean PI_i_q.limiter.limitsAtInit = PI_i_q.limitsAtInit \"Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)\";
//   protected parameter Boolean PI_i_q.with_I = PI_i_q.controllerType == Modelica.Blocks.Types.SimpleController.PI or PI_i_q.controllerType == Modelica.Blocks.Types.SimpleController.PID;
//   protected parameter Boolean PI_i_q.with_D = PI_i_q.controllerType == Modelica.Blocks.Types.SimpleController.PD or PI_i_q.controllerType == Modelica.Blocks.Types.SimpleController.PID;
//   Real PI_i_q.I.u \"Connector of Real input signal\";
//   Real PI_i_q.I.y(start = PI_i_q.I.y_start) \"Connector of Real output signal\";
//   parameter Real PI_i_q.I.k(unit = \"1\") = 1.0 / PI_i_q.Ti \"Integrator gain\";
//   parameter enumeration(NoInit, SteadyState, InitialState, InitialOutput) PI_i_q.I.initType = if PI_i_q.initType == Modelica.Blocks.Types.InitPID.SteadyState then Modelica.Blocks.Types.Init.SteadyState else if PI_i_q.initType == Modelica.Blocks.Types.InitPID.InitialState or PI_i_q.initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState then Modelica.Blocks.Types.Init.InitialState else Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\";
//   parameter Real PI_i_q.I.y_start = PI_i_q.xi_start \"Initial or guess value of output (= state)\";
//   parameter Real PI_i_q.addI.k1 = 1.0 \"Gain of upper input\";
//   parameter Real PI_i_q.addI.k2 = -1.0 \"Gain of middle input\";
//   parameter Real PI_i_q.addI.k3 = 1.0 \"Gain of lower input\";
//   Real PI_i_q.addI.u1 \"Connector 1 of Real input signals\";
//   Real PI_i_q.addI.u2 \"Connector 2 of Real input signals\";
//   Real PI_i_q.addI.u3 \"Connector 3 of Real input signals\";
//   Real PI_i_q.addI.y \"Connector of Real output signals\";
//   Real PI_i_q.addSat.u1 \"Connector of Real input signal 1\";
//   Real PI_i_q.addSat.u2 \"Connector of Real input signal 2\";
//   Real PI_i_q.addSat.y \"Connector of Real output signal\";
//   parameter Real PI_i_q.addSat.k1 = 1.0 \"Gain of upper input\";
//   parameter Real PI_i_q.addSat.k2 = -1.0 \"Gain of lower input\";
//   parameter Real PI_i_q.gainTrack.k(unit = \"1\", start = 1.0) = 1.0 / (PI_i_q.Ni * PI_i_q.k) \"Gain value multiplied with input signal\";
//   Real PI_i_q.gainTrack.u \"Input signal connector\";
//   Real PI_i_q.gainTrack.y \"Output signal connector\";
//   Real PI_i_q.Dzero.y \"Connector of Real output signal\";
//   parameter Real PI_i_q.Dzero.k(start = 1.0) = 0.0 \"Constant output value\";
// initial equation
//   sm_ctrl.motor.phi_el = sm_ctrl.motor.phi_el_ini;
//   der(sm_ctrl.motor.w_el) = 0.0;
//   der(sm_ctrl.motor.psi_s[1]) = 0.0;
//   der(sm_ctrl.motor.psi_s[2]) = 0.0;
//   der(sm_ctrl.motor.c.L_s[3] * sm_ctrl.motor.i_s[3]) = 0.0;
//   der(PI_i_q.I.y) = 0.0;
// equation
//   {} = PowerSystems.Basic.Types.ReferenceAngle.equalityConstraint(sm_ctrl.inverter.AC.theta[2], sm_ctrl.motor.term.theta[2]) \" equation generated by overconstrained connection graph breaking\";
//   when initial() then
//     system.initime = time;
//   end when;
//   system.omega = 6.283185307179586 * system.f;
//   system.theta = system.omega * time;
//   system.receiveFreq.h = 0.0;
//   system.receiveFreq.w_h = 0.0;
//   grd.term.v = 0.0;
//   voltage.v = voltage.v0 * voltage.V_base;
//   voltage.term.v[1] - voltage.term.v[2] = voltage.v;
//   voltage.vDC_internal = 0.0;
//   voltage.term.v[1] + voltage.term.v[2] = voltage.neutral.v;
//   voltage.term.i[1] + voltage.term.i[2] + voltage.neutral.i = 0.0;
//   sm_ctrl.rotor.stator.phi = 0.0;
//   sm_ctrl.rotor.rotor.phi = sm_ctrl.rotor.phi - sm_ctrl.rotor.stator.phi;
//   sm_ctrl.rotor.friction.phi = sm_ctrl.rotor.rotor.phi;
//   sm_ctrl.rotor.J * sm_ctrl.rotor.a = sm_ctrl.rotor.rotor.tau + sm_ctrl.rotor.flange_p.tau + sm_ctrl.rotor.flange_n.tau + sm_ctrl.rotor.friction.tau;
//   sm_ctrl.rotor.phi = sm_ctrl.rotor.flange_p.phi;
//   sm_ctrl.rotor.w = der(sm_ctrl.rotor.phi);
//   sm_ctrl.rotor.a = der(sm_ctrl.rotor.w);
//   sm_ctrl.rotor.flange_p.phi = sm_ctrl.rotor.flange_n.phi;
//   sm_ctrl.gear.flange_p.phi = sm_ctrl.gear.flange_n.phi;
//   sm_ctrl.gear.flange_p.tau + sm_ctrl.gear.flange_n.tau = 0.0;
//   sm_ctrl.heat_adapt.port_a.ports[1].T = sm_ctrl.heat_adapt.port_ab.ports[1].T;
//   sm_ctrl.heat_adapt.port_a.ports[2].T = sm_ctrl.heat_adapt.port_ab.ports[2].T;
//   sm_ctrl.heat_adapt.port_b.ports[1].T = sm_ctrl.heat_adapt.port_ab.ports[3].T;
//   sm_ctrl.heat_adapt.port_a.ports[1].Q_flow + sm_ctrl.heat_adapt.port_ab.ports[1].Q_flow = 0.0;
//   sm_ctrl.heat_adapt.port_a.ports[2].Q_flow + sm_ctrl.heat_adapt.port_ab.ports[2].Q_flow = 0.0;
//   sm_ctrl.heat_adapt.port_b.ports[1].Q_flow + sm_ctrl.heat_adapt.port_ab.ports[3].Q_flow = 0.0;
//   sm_ctrl.inverter.AC.theta[1] = if system.synRef then 0.0 else sm_ctrl.inverter.theta;
//   sm_ctrl.inverter.AC.theta[2] = if system.synRef then sm_ctrl.inverter.theta else 0.0;
//   sm_ctrl.inverter.Vloss = if sm_ctrl.inverter.par.Vf < 0.001 then 0.0 else 2.0 * tanh(10.0 * sm_ctrl.inverter.iDC1 / sm_ctrl.inverter.par.I_nom) * sm_ctrl.inverter.par.Vf;
//   sm_ctrl.inverter.iAC2 = sm_ctrl.inverter.AC.i[1] ^ 2.0 + sm_ctrl.inverter.AC.i[2] ^ 2.0 + sm_ctrl.inverter.AC.i[3] ^ 2.0;
//   sm_ctrl.inverter.cT = 1.0;
//   sm_ctrl.inverter.hsw_nom = if sm_ctrl.inverter.syn then 2.0 * sm_ctrl.inverter.par.Hsw_nom * /*Real*/(sm_ctrl.inverter.m_carr) / (3.141592653589793 * sm_ctrl.inverter.par.V_nom * sm_ctrl.inverter.par.I_nom) * der(sm_ctrl.inverter.theta) else 4.0 * sm_ctrl.inverter.par.Hsw_nom * sm_ctrl.inverter.f_carr / (sm_ctrl.inverter.par.I_nom * sm_ctrl.inverter.par.V_nom);
//   sm_ctrl.inverter.phi = sm_ctrl.inverter.AC.theta[1] + sm_ctrl.inverter.uPhasor[2] + system.alpha0;
//   sm_ctrl.inverter.switch_dq0[1] = cos(sm_ctrl.inverter.phi) * sm_ctrl.inverter.factor * sm_ctrl.inverter.uPhasor[1];
//   sm_ctrl.inverter.switch_dq0[2] = sin(sm_ctrl.inverter.phi) * sm_ctrl.inverter.factor * sm_ctrl.inverter.uPhasor[1];
//   sm_ctrl.inverter.switch_dq0[3] = 0.0;
//   sm_ctrl.inverter.v_dq0[1] = sm_ctrl.inverter.switch_dq0[1] * (sm_ctrl.inverter.vDC1 - sm_ctrl.inverter.cT * sm_ctrl.inverter.Vloss);
//   sm_ctrl.inverter.v_dq0[2] = sm_ctrl.inverter.switch_dq0[2] * (sm_ctrl.inverter.vDC1 - sm_ctrl.inverter.cT * sm_ctrl.inverter.Vloss);
//   sm_ctrl.inverter.v_dq0[3] = sm_ctrl.inverter.switch_dq0[3] * (sm_ctrl.inverter.vDC1 - sm_ctrl.inverter.cT * sm_ctrl.inverter.Vloss);
//   sm_ctrl.inverter.Q_flow[1] = sm_ctrl.inverter.par.eps[1] * sm_ctrl.inverter.R_nom * sm_ctrl.inverter.iAC2 + 1.559393602467352 * sm_ctrl.inverter.cT * (sm_ctrl.inverter.par.Vf + sm_ctrl.inverter.hsw_nom * abs(sm_ctrl.inverter.vDC1)) * sqrt(sm_ctrl.inverter.iAC2);
//   sm_ctrl.inverter.AC.v[1] = sm_ctrl.inverter.v_dq0[1];
//   sm_ctrl.inverter.AC.v[2] = sm_ctrl.inverter.v_dq0[2];
//   sm_ctrl.inverter.AC.v[3] = sm_ctrl.inverter.v_dq0[3] + 1.732050807568877 * sm_ctrl.inverter.vDC0;
//   sm_ctrl.inverter.iDC1 + sm_ctrl.inverter.switch_dq0[1] * sm_ctrl.inverter.AC.i[1] + sm_ctrl.inverter.switch_dq0[2] * sm_ctrl.inverter.AC.i[2] + sm_ctrl.inverter.switch_dq0[3] * sm_ctrl.inverter.AC.i[3] = 0.0;
//   sm_ctrl.inverter.iDC0 + 1.732050807568877 * sm_ctrl.inverter.AC.i[3] = 0.0;
//   sm_ctrl.inverter.T[1] = sm_ctrl.inverter.heat.ports[1].T;
//   sm_ctrl.inverter.heat.ports[1].Q_flow = -sm_ctrl.inverter.Q_flow[1];
//   sm_ctrl.motor.top.v_cond = {sm_ctrl.motor.v[1], sm_ctrl.motor.v[2], sm_ctrl.motor.v[3]};
//   sm_ctrl.motor.top.i_cond = {sm_ctrl.motor.i[1], sm_ctrl.motor.i[2], sm_ctrl.motor.i[3]};
//   sm_ctrl.motor.top.v_n = {sm_ctrl.motor.v_n[1]};
//   sm_ctrl.motor.top.v_cond[1] = sm_ctrl.motor.top.v_term[1];
//   sm_ctrl.motor.top.v_cond[2] = sm_ctrl.motor.top.v_term[2];
//   sm_ctrl.motor.top.v_cond[3] = sm_ctrl.motor.top.v_term[3] - 1.732050807568877 * sm_ctrl.motor.top.v_n[1];
//   sm_ctrl.motor.top.i_term[1] = sm_ctrl.motor.top.i_cond[1];
//   sm_ctrl.motor.top.i_term[2] = sm_ctrl.motor.top.i_cond[2];
//   sm_ctrl.motor.top.i_term[3] = sm_ctrl.motor.top.i_cond[3];
//   sm_ctrl.motor.top.i_n[1] = 1.732050807568877 * sm_ctrl.motor.top.i_term[3];
//   sm_ctrl.motor.i_n = {sm_ctrl.motor.top.i_n[1]};
//   sm_ctrl.motor.psi_e = sm_ctrl.motor.c.Psi_pm;
//   sm_ctrl.motor.i_meas[1] = sm_ctrl.motor.i_s[1] / sm_ctrl.motor.I_nom;
//   sm_ctrl.motor.i_meas[2] = sm_ctrl.motor.i_s[2] / sm_ctrl.motor.I_nom;
//   sm_ctrl.motor.i_dq[1] = sm_ctrl.motor.i_act[1] * sm_ctrl.motor.I_nom;
//   sm_ctrl.motor.i_dq[2] = sm_ctrl.motor.i_act[2] * sm_ctrl.motor.I_nom;
//   sm_ctrl.motor.v_dq[1] = (-sm_ctrl.motor.c.L_s[2]) * sm_ctrl.motor.i_dq[2] * sm_ctrl.motor.w_el + sm_ctrl.motor.i_dq[1] * sm_ctrl.motor.c.R_s;
//   sm_ctrl.motor.v_dq[2] = (sm_ctrl.motor.c.L_s[1] * sm_ctrl.motor.i_dq[1] + sm_ctrl.motor.psi_e) * sm_ctrl.motor.w_el + sm_ctrl.motor.i_dq[2] * sm_ctrl.motor.c.R_s;
//   sm_ctrl.motor.uPhasor[1] = sqrt(sm_ctrl.motor.v_dq[1] ^ 2.0 + sm_ctrl.motor.v_dq[2] ^ 2.0) / sm_ctrl.motor.par.V_nom;
//   sm_ctrl.motor.uPhasor[2] = atan2(sm_ctrl.motor.v_dq[2], sm_ctrl.motor.v_dq[1]);
//   sm_ctrl.motor.psi_s[1] = sm_ctrl.motor.c.L_s[1] * sm_ctrl.motor.i_s[1] + sm_ctrl.motor.psi_e;
//   sm_ctrl.motor.psi_s[2] = sm_ctrl.motor.c.L_s[2] * sm_ctrl.motor.i_s[2];
//   der(sm_ctrl.motor.psi_s[1]) - sm_ctrl.motor.psi_s[2] * sm_ctrl.motor.w_el + sm_ctrl.motor.i_s[1] * sm_ctrl.motor.c.R_s = sm_ctrl.motor.v_s[1];
//   der(sm_ctrl.motor.psi_s[2]) + sm_ctrl.motor.psi_s[1] * sm_ctrl.motor.w_el + sm_ctrl.motor.i_s[2] * sm_ctrl.motor.c.R_s = sm_ctrl.motor.v_s[2];
//   sm_ctrl.motor.c.L_s[3] * der(sm_ctrl.motor.i_s[3]) + sm_ctrl.motor.c.R_s * sm_ctrl.motor.i_s[3] = sm_ctrl.motor.v_s[3];
//   sm_ctrl.motor.v_n[1] = sm_ctrl.motor.i_n[1] * sm_ctrl.motor.c.R_n \"equation neutral to ground (relevant if Y-topology)\";
//   sm_ctrl.motor.tau_el = sm_ctrl.motor.i_s[2] * sm_ctrl.motor.psi_s[1] - sm_ctrl.motor.i_s[1] * sm_ctrl.motor.psi_s[2];
//   sm_ctrl.motor.heat.ports[1].Q_flow = (-sm_ctrl.motor.c.R_s) * (sm_ctrl.motor.i_s[1] ^ 2.0 + sm_ctrl.motor.i_s[2] ^ 2.0 + sm_ctrl.motor.i_s[3] ^ 2.0);
//   sm_ctrl.motor.heat.ports[2].Q_flow = 0.0;
//   sm_ctrl.motor.Rot_dq = PowerSystems.Basic.Transforms.rotation_dq(sm_ctrl.motor.phi_el - sm_ctrl.motor.term.theta[2]);
//   sm_ctrl.motor.v_s[1] = sm_ctrl.motor.Rot_dq[1,1] * sm_ctrl.motor.v[1] + sm_ctrl.motor.Rot_dq[2,1] * sm_ctrl.motor.v[2];
//   sm_ctrl.motor.v_s[2] = sm_ctrl.motor.Rot_dq[1,2] * sm_ctrl.motor.v[1] + sm_ctrl.motor.Rot_dq[2,2] * sm_ctrl.motor.v[2];
//   sm_ctrl.motor.v_s[3] = sm_ctrl.motor.v[3];
//   sm_ctrl.motor.i[1] = sm_ctrl.motor.Rot_dq[1,1] * sm_ctrl.motor.i_s[1] + sm_ctrl.motor.Rot_dq[1,2] * sm_ctrl.motor.i_s[2];
//   sm_ctrl.motor.i[2] = sm_ctrl.motor.Rot_dq[2,1] * sm_ctrl.motor.i_s[1] + sm_ctrl.motor.Rot_dq[2,2] * sm_ctrl.motor.i_s[2];
//   sm_ctrl.motor.i[3] = sm_ctrl.motor.i_s[3];
//   sm_ctrl.motor.omega[1] = der(sm_ctrl.motor.term.theta[1]);
//   sm_ctrl.motor.omega[2] = der(sm_ctrl.motor.term.theta[2]);
//   /*Real*/(sm_ctrl.motor.pp) * sm_ctrl.motor.airgap.phi = sm_ctrl.motor.phi_el;
//   sm_ctrl.motor.airgap.tau = (-/*Real*/(sm_ctrl.motor.pp)) * sm_ctrl.motor.tau_el;
//   sm_ctrl.motor.w_el = der(sm_ctrl.motor.phi_el);
//   sm_ctrl.motor.term.v[1] = sm_ctrl.motor.top.v_term[1];
//   sm_ctrl.motor.term.v[2] = sm_ctrl.motor.top.v_term[2];
//   sm_ctrl.motor.term.v[3] = sm_ctrl.motor.top.v_term[3];
//   sm_ctrl.motor.term.i[1] = sm_ctrl.motor.top.i_term[1];
//   sm_ctrl.motor.term.i[2] = sm_ctrl.motor.top.i_term[2];
//   sm_ctrl.motor.term.i[3] = sm_ctrl.motor.top.i_term[3];
//   assert(sm_ctrl.motor.heat.m == sm_ctrl.heat_adapt.port_a.m, \"automatically generated from connect\");
//   assert(sm_ctrl.inverter.heat.m == sm_ctrl.heat_adapt.port_b.m, \"automatically generated from connect\");
//   assert(sm_ctrl.heat_adapt.port_ab.m == sm_ctrl.heat.m, \"automatically generated from connect\");
//   bdCond.heat.ports[1].T = bdCond.T_amb;
//   bdCond.heat.ports[2].T = bdCond.T_amb;
//   bdCond.heat.ports[3].T = bdCond.T_amb;
//   loadInertia.J * loadInertia.a = loadInertia.flange_p.tau + loadInertia.flange_n.tau;
//   loadInertia.phi = loadInertia.flange_p.phi;
//   loadInertia.w = der(loadInertia.phi);
//   loadInertia.a = der(loadInertia.w);
//   loadInertia.flange_p.phi = loadInertia.flange_n.phi;
//   frictTorq.phi = frictTorq.flange.phi;
//   frictTorq.w = der(frictTorq.phi);
//   frictTorq.flange.tau = (frictTorq.cFrict[1] + frictTorq.cFrict[2] * abs(frictTorq.w)) * frictTorq.w;
//   torqueStep.tau = -torqueStep.flange.tau;
//   torqueStep.tau = torqueStep.offsetTorque + (if time < torqueStep.startTime then 0.0 else torqueStep.stepTorque);
//   torqueStep.phi = torqueStep.flange.phi - torqueStep.phi_support;
//   torqueStep.phi_support = 0.0;
//   i_q.y = 0.5 * (i_q.s_fin + i_q.s_ini + (i_q.s_fin - i_q.s_ini) * tanh(i_q.coef * (time - i_q.t_change)));
//   i_d.y = 0.5 * (i_d.s_fin + i_d.s_ini + (i_d.s_fin - i_d.s_ini) * tanh(i_d.coef * (time - i_d.t_change)));
//   PI_i_q.addP.y = PI_i_q.addP.k1 * PI_i_q.addP.u1 + PI_i_q.addP.k2 * PI_i_q.addP.u2;
//   PI_i_q.P.y = PI_i_q.P.k * PI_i_q.P.u;
//   PI_i_q.gainPID.y = PI_i_q.gainPID.k * PI_i_q.gainPID.u;
//   PI_i_q.addPID.y = PI_i_q.addPID.k1 * PI_i_q.addPID.u1 + PI_i_q.addPID.k2 * PI_i_q.addPID.u2 + PI_i_q.addPID.k3 * PI_i_q.addPID.u3;
//   assert(PI_i_q.limiter.uMax >= PI_i_q.limiter.uMin, \"Limiter: Limits must be consistent. However, uMax (=\" + String(PI_i_q.limiter.uMax, 6, 0, true) + \") < uMin (=\" + String(PI_i_q.limiter.uMin, 6, 0, true) + \")\");
//   PI_i_q.limiter.y = homotopy(smooth(0, if PI_i_q.limiter.u > PI_i_q.limiter.uMax then PI_i_q.limiter.uMax else if PI_i_q.limiter.u < PI_i_q.limiter.uMin then PI_i_q.limiter.uMin else PI_i_q.limiter.u), PI_i_q.limiter.u);
//   der(PI_i_q.I.y) = PI_i_q.I.k * PI_i_q.I.u;
//   PI_i_q.addI.y = PI_i_q.addI.k1 * PI_i_q.addI.u1 + PI_i_q.addI.k2 * PI_i_q.addI.u2 + PI_i_q.addI.k3 * PI_i_q.addI.u3;
//   PI_i_q.addSat.y = PI_i_q.addSat.k1 * PI_i_q.addSat.u1 + PI_i_q.addSat.k2 * PI_i_q.addSat.u2;
//   PI_i_q.gainTrack.y = PI_i_q.gainTrack.k * PI_i_q.gainTrack.u;
//   PI_i_q.Dzero.y = PI_i_q.Dzero.k;
//   assert(sm_ctrl.heat.m == bdCond.heat.m, \"automatically generated from connect\");
//   system.receiveFreq.w_H = 0.0;
//   system.receiveFreq.H = 0.0;
//   grd.term.i + voltage.neutral.i = 0.0;
//   voltage.term.i[1] + sm_ctrl.term.i[1] = 0.0;
//   voltage.term.i[2] + sm_ctrl.term.i[2] = 0.0;
//   sm_ctrl.flange.tau + loadInertia.flange_p.tau = 0.0;
//   sm_ctrl.gear.flange_p.tau + sm_ctrl.rotor.flange_n.tau = 0.0;
//   (-sm_ctrl.flange.tau) + sm_ctrl.gear.flange_n.tau = 0.0;
//   sm_ctrl.inverter.AC.i[1] + sm_ctrl.motor.term.i[1] = 0.0;
//   sm_ctrl.inverter.AC.i[2] + sm_ctrl.motor.term.i[2] = 0.0;
//   sm_ctrl.inverter.AC.i[3] + sm_ctrl.motor.term.i[3] = 0.0;
//   (-sm_ctrl.term.i[1]) + sm_ctrl.inverter.DC.i[1] = 0.0;
//   (-sm_ctrl.term.i[2]) + sm_ctrl.inverter.DC.i[2] = 0.0;
//   sm_ctrl.inverter.heat.ports[1].Q_flow + sm_ctrl.heat_adapt.port_b.ports[1].Q_flow = 0.0;
//   sm_ctrl.motor.airgap.tau + sm_ctrl.rotor.rotor.tau = 0.0;
//   sm_ctrl.motor.heat.ports[2].Q_flow + sm_ctrl.heat_adapt.port_a.ports[2].Q_flow = 0.0;
//   sm_ctrl.motor.heat.ports[1].Q_flow + sm_ctrl.heat_adapt.port_a.ports[1].Q_flow = 0.0;
//   sm_ctrl.rotor.flange_p.tau = 0.0;
//   sm_ctrl.rotor.stator.tau = 0.0;
//   sm_ctrl.rotor.friction.tau = 0.0;
//   sm_ctrl.heat_adapt.port_ab.ports[3].Q_flow + (-sm_ctrl.heat.ports[3].Q_flow) = 0.0;
//   sm_ctrl.heat_adapt.port_ab.ports[2].Q_flow + (-sm_ctrl.heat.ports[2].Q_flow) = 0.0;
//   sm_ctrl.heat_adapt.port_ab.ports[1].Q_flow + (-sm_ctrl.heat.ports[1].Q_flow) = 0.0;
//   sm_ctrl.heat.ports[3].Q_flow + bdCond.heat.ports[3].Q_flow = 0.0;
//   sm_ctrl.heat.ports[2].Q_flow + bdCond.heat.ports[2].Q_flow = 0.0;
//   sm_ctrl.heat.ports[1].Q_flow + bdCond.heat.ports[1].Q_flow = 0.0;
//   sm_ctrl.motor.airgap.phi = sm_ctrl.rotor.rotor.phi;
//   sm_ctrl.inverter.DC.v[1] = sm_ctrl.term.v[1];
//   sm_ctrl.inverter.DC.v[2] = sm_ctrl.term.v[2];
//   sm_ctrl.motor.term.theta[1] = sm_ctrl.inverter.AC.theta[1];
//   sm_ctrl.motor.term.theta[2] = sm_ctrl.inverter.AC.theta[2];
//   sm_ctrl.inverter.AC.v[1] = sm_ctrl.motor.term.v[1];
//   sm_ctrl.inverter.AC.v[2] = sm_ctrl.motor.term.v[2];
//   sm_ctrl.inverter.AC.v[3] = sm_ctrl.motor.term.v[3];
//   sm_ctrl.heat_adapt.port_a.ports[1].T = sm_ctrl.motor.heat.ports[1].T;
//   sm_ctrl.heat_adapt.port_a.ports[2].T = sm_ctrl.motor.heat.ports[2].T;
//   sm_ctrl.heat_adapt.port_b.ports[1].T = sm_ctrl.inverter.heat.ports[1].T;
//   sm_ctrl.inverter.theta = sm_ctrl.motor.phiRotor;
//   sm_ctrl.inverter.uPhasor[1] = sm_ctrl.motor.uPhasor[1];
//   sm_ctrl.inverter.uPhasor[2] = sm_ctrl.motor.uPhasor[2];
//   sm_ctrl.i_meas[1] = sm_ctrl.motor.i_meas[1];
//   sm_ctrl.i_meas[2] = sm_ctrl.motor.i_meas[2];
//   sm_ctrl.i_act[1] = sm_ctrl.motor.i_act[1];
//   sm_ctrl.i_act[2] = sm_ctrl.motor.i_act[2];
//   sm_ctrl.heat.ports[1].T = sm_ctrl.heat_adapt.port_ab.ports[1].T;
//   sm_ctrl.heat.ports[2].T = sm_ctrl.heat_adapt.port_ab.ports[2].T;
//   sm_ctrl.heat.ports[3].T = sm_ctrl.heat_adapt.port_ab.ports[3].T;
//   sm_ctrl.gear.flange_p.phi = sm_ctrl.rotor.flange_n.phi;
//   sm_ctrl.flange.phi = sm_ctrl.gear.flange_n.phi;
//   loadInertia.flange_n.tau + frictTorq.flange.tau + torqueStep.flange.tau = 0.0;
//   PI_i_q.addI.u1 = PI_i_q.addP.u1;
//   PI_i_q.addI.u1 = PI_i_q.u_s;
//   PI_i_q.P.u = PI_i_q.addP.y;
//   PI_i_q.I.u = PI_i_q.addI.y;
//   PI_i_q.P.y = PI_i_q.addPID.u1;
//   PI_i_q.I.y = PI_i_q.addPID.u3;
//   PI_i_q.addPID.y = PI_i_q.gainPID.u;
//   PI_i_q.addSat.u2 = PI_i_q.gainPID.y;
//   PI_i_q.addSat.u2 = PI_i_q.limiter.u;
//   PI_i_q.addSat.u1 = PI_i_q.limiter.y;
//   PI_i_q.addSat.u1 = PI_i_q.y;
//   PI_i_q.addSat.y = PI_i_q.gainTrack.u;
//   PI_i_q.addI.u3 = PI_i_q.gainTrack.y;
//   PI_i_q.addI.u2 = PI_i_q.addP.u2;
//   PI_i_q.addI.u2 = PI_i_q.u_m;
//   PI_i_q.Dzero.y = PI_i_q.addPID.u2;
//   bdCond.heat.ports[1].T = sm_ctrl.heat.ports[1].T;
//   bdCond.heat.ports[2].T = sm_ctrl.heat.ports[2].T;
//   bdCond.heat.ports[3].T = sm_ctrl.heat.ports[3].T;
//   grd.term.v = voltage.neutral.v;
//   PI_i_q.u_s = i_q.y;
//   loadInertia.flange_p.phi = sm_ctrl.flange.phi;
//   frictTorq.flange.phi = loadInertia.flange_n.phi;
//   frictTorq.flange.phi = torqueStep.flange.phi;
//   sm_ctrl.term.v[1] = voltage.term.v[1];
//   sm_ctrl.term.v[2] = voltage.term.v[2];
//   PI_i_q.u_m = sm_ctrl.i_meas[2];
//   PI_i_q.y = sm_ctrl.i_act[2];
//   i_d.y = sm_ctrl.i_act[1];
// end PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv;
// "
// ""
// "Check of PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv completed successfully.
// Class PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv has 214 equation(s) and 214 variable(s).
// 135 of these are trivial equation(s)."
// ""
// record SimulationResult
//     resultFile = "PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 10.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'PowerSystems.Examples.Spot.DrivesAC3ph.SM_ctrlAv', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = "LOG_SUCCESS       | info    | The initialization finished successfully with 3 homotopy steps.
// LOG_SUCCESS       | info    | The simulation finished successfully.
// "
// end SimulationResult;
// ""
// endResult
