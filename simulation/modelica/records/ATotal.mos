// name:     ATotal.mos
// keywords: record constants evaluation
// status:   correct
// teardown_command: rm -rf A A.exe A_*.* A.*

loadFile("ATotal.mo"); getErrorString();
instantiateModel(A); getErrorString();
simulate(A); getErrorString();

// Result:
// true
// ""
// "function Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp \"Temperature dependency of energy gap\"
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperature\";
//   output Real ret(quantity = \"ElectricPotential\", unit = \"V\") \"Output voltage\";
// algorithm
//   ret := 1.16 + (-0.000702) * temp ^ 2.0 / (1108.0 + temp);
// end Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp;
//
// function Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp_old \"Temperature dependency of energy gap\"
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperature\";
//   output Real ret(quantity = \"ElectricPotential\", unit = \"V\") \"Output voltage\";
//   protected Real gap0(quantity = \"ElectricPotential\", unit = \"V\") = 1.16;
//   protected Real coeff1(unit = \"V/K\") = 0.000702;
//   protected Real coeff2(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 1108.0;
// algorithm
//   ret := gap0 - coeff1 * temp ^ 2.0 / (temp + coeff2);
// end Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp_old;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junction2SPICE3MOSFET \"Junction current and conductance calculation, obsolete, use junction2SPICE3MOSFETRevised\"
//   input Real current(quantity = \"ElectricCurrent\", unit = \"A\") \"Input current\";
//   input Real cond(quantity = \"Conductance\", unit = \"S\") \"Input conductance\";
//   input Real voltage(quantity = \"ElectricPotential\", unit = \"V\") \"Input voltage\";
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Device Temperature\";
//   input Real ncoeff;
//   input Real satcur(quantity = \"ElectricCurrent\", unit = \"A\") \"Saturation current\";
//   output Real out_current(quantity = \"ElectricCurrent\", unit = \"A\") \"Calculated current\";
//   output Real out_cond(quantity = \"Conductance\", unit = \"S\") \"Calculated conductance\";
//   protected Real vte(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real max_exponent;
//   protected Real evbd;
//   protected Real evd;
//   protected constant Real max_exp = 50.0;
//   protected constant Real max_current(quantity = \"ElectricCurrent\", unit = \"A\") = 10000.0;
// algorithm
//   out_current := current;
//   out_cond := cond;
//   if satcur > 1e-101 then
//     vte := 8.61726105451295e-05 * temp * ncoeff;
//     max_exponent := log(10000.0 / satcur);
//     max_exponent := min(50.0, max_exponent);
//     if voltage <= 0.0 then
//       out_cond := satcur / vte;
//       out_current := out_cond * voltage;
//       out_cond := 1e-12 + out_cond;
//     elseif voltage >= max_exponent * vte then
//       evd := exp(max_exponent);
//       out_cond := satcur * evd / vte;
//       out_current := satcur * (-1.0 + evd) + out_cond * (voltage - max_exponent * vte);
//     else
//       evbd := exp(voltage / vte);
//       out_cond := 1e-12 + satcur * evbd / vte;
//       out_current := satcur * (-1.0 + evbd);
//     end if;
//   else
//     out_current := 0.0;
//     out_cond := 0.0;
//   end if;
// end Modelica.Electrical.Spice3.Internal.Functions.junction2SPICE3MOSFET;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junctionCap \"Junction capacity, obsolete, use JunctionCapRevised\"
//   input Real capin(quantity = \"Capacitance\", unit = \"F\", min = 0.0) \"Input capacitance\";
//   input Real voltage(quantity = \"ElectricPotential\", unit = \"V\") \"Input voltage\";
//   input Real depcap(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real mj;
//   input Real phij;
//   input Real f1(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real f2;
//   input Real f3;
//   output Real capout(quantity = \"Capacitance\", unit = \"F\", min = 0.0) \"Output capacitance\";
//   output Real charge(quantity = \"ElectricCharge\", unit = \"C\") \"Output charge\";
//   protected Real arg;
//   protected Real sarg;
//   protected Real czof2;
// algorithm
//   if voltage < depcap then
//     arg := 1.0 - voltage / phij;
//     if mj == 0.5 then
//       sarg := 1.0 / sqrt(arg);
//     else
//       sarg := arg ^ (-mj);
//     end if;
//     capout := capin * sarg;
//     charge := phij * capin * (1.0 - arg * sarg) / (1.0 - mj);
//   else
//     czof2 := capin / f2;
//     capout := czof2 * (f3 + mj * voltage / phij);
//     charge := capin * f1 + czof2 * (f3 * (voltage - depcap) + 0.5 * mj * (voltage ^ 2.0 - depcap ^ 2.0) / phij);
//   end if;
// end Modelica.Electrical.Spice3.Internal.Functions.junctionCap;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junctionCapCoeffs \"Coefficient calculation\"
//   input Real mj;
//   input Real fc;
//   input Real phij(quantity = \"ElectricPotential\", unit = \"V\");
//   output Real f1(quantity = \"ElectricPotential\", unit = \"V\");
//   output Real f2;
//   output Real f3;
//   protected Real xfc;
// algorithm
//   xfc := log(1.0 - fc);
//   f1 := phij * (1.0 - exp((1.0 - mj) * xfc)) / (1.0 - mj);
//   f2 := exp((1.0 + mj) * xfc);
//   f3 := 1.0 - fc * (1.0 + mj);
// end Modelica.Electrical.Spice3.Internal.Functions.junctionCapCoeffs;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3 \"Temperature dependency of junction parameters\"
//   input Real phi0(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real cap0;
//   input Real mcoeff;
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Device temperature\";
//   input Real tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Nominal temperature\";
//   output Real junctionpot(quantity = \"ElectricPotential\", unit = \"V\") \"Junction potential\";
//   output Real jucntioncap \"Junction capacitance\";
//   protected Real phibtemp(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real phibtnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vt(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vtnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real arg;
//   protected Real fact2;
//   protected Real pbfact;
//   protected Real arg1;
//   protected Real fact1;
//   protected Real pbfact1;
//   protected Real pbo;
//   protected Real gmaold;
//   protected Real gmanew;
// algorithm
//   phibtemp := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(temp);
//   phibtnom := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(tnom);
//   vt := 8.61726105451295e-05 * temp;
//   vtnom := 8.61726105451295e-05 * tnom;
//   arg := 1.345417051337526e+20 + (-3.621481323477592e+22) * phibtemp / temp;
//   fact2 := 0.003331667499583542 * temp;
//   pbfact := (-2.0) * vt * (1.5 * log(fact2) + 1.6021918e-19 * arg);
//   arg1 := 1.345417051337526e+20 + (-3.621481323477592e+22) * phibtnom / tnom;
//   fact1 := 0.003331667499583542 * tnom;
//   pbfact1 := (-2.0) * vtnom * (1.5 * log(fact1) + 1.6021918e-19 * arg1);
//   pbo := (phi0 - pbfact1) / fact1;
//   junctionpot := pbfact + fact2 * pbo;
//   gmaold := (phi0 - pbo) / pbo;
//   gmanew := (junctionpot - pbo) / pbo;
//   jucntioncap := cap0 * (1.0 + mcoeff * (0.0004 * (-300.15 + temp) - gmanew)) / (1.0 + mcoeff * (0.0004 * (-300.15 + tnom) - gmaold));
// end Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junctionPotDepTemp \"Temperature dependency of junction potential\"
//   input Real phi0(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Device Temperature\";
//   input Real tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Nominal Temperature\";
//   output Real ret(quantity = \"ElectricPotential\", unit = \"V\") \"Output voltage\";
//   protected Real phibtemp(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real phibtnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vt(quantity = \"ElectricPotential\", unit = \"V\");
// algorithm
//   phibtemp := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(temp);
//   phibtnom := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(tnom);
//   vt := 8.61726105451295e-05 * temp;
//   ret := (phi0 - phibtnom) * temp / tnom + phibtemp + 3.0 * vt * log(tnom / temp);
// end Modelica.Electrical.Spice3.Internal.Functions.junctionPotDepTemp;
//
// function Modelica.Electrical.Spice3.Internal.Functions.junctionVCrit \"Voltage limitation\"
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"temperature\";
//   input Real ncoeff;
//   input Real satcur(quantity = \"ElectricCurrent\", unit = \"A\") \"Saturation current\";
//   output Real ret \"Output value\";
//   protected Real vte(quantity = \"ElectricPotential\", unit = \"V\");
// algorithm
//   vte := 8.61726105451295e-05 * temp * ncoeff;
//   ret := vte * log(0.7071067811865475 * vte / satcur);
//   ret := if ret > 10000000000.0 then 10000000000.0 else ret;
// end Modelica.Electrical.Spice3.Internal.Functions.junctionVCrit;
//
// function Modelica.Electrical.Spice3.Internal.Functions.saturationCurDepTempSPICE3MOSFET \"Temperature dependency of saturation current\"
//   input Real satcur0(quantity = \"ElectricCurrent\", unit = \"A\") \"Saturation current\";
//   input Real temp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Device Temperature\";
//   input Real tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Nominal Temperature\";
//   output Real ret \"Output current\";
//   protected Real vt(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vtnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real energygaptnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real energygaptemp(quantity = \"ElectricPotential\", unit = \"V\");
// algorithm
//   vt := 8.61726105451295e-05 * temp;
//   vtnom := 8.61726105451295e-05 * tnom;
//   energygaptnom := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(tnom);
//   energygaptemp := Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp(temp);
//   ret := satcur0 * exp(energygaptnom / vtnom - energygaptemp / vt);
// end Modelica.Electrical.Spice3.Internal.Functions.saturationCurDepTempSPICE3MOSFET;
//
// function Modelica.Electrical.Spice3.Internal.ModelcardMOS \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.ModelcardMOS\"
//   input Real VTO(quantity = \"ElectricPotential\", unit = \"V\") = -1e+40;
//   input Real KP(quantity = \"Transconductance\", unit = \"A/V2\") = -1e+40;
//   input Real GAMMA = -1e+40;
//   input Real PHI(quantity = \"ElectricPotential\", unit = \"V\") = -1e+40;
//   input Real LAMBDA(quantity = \"InversePotential\", unit = \"1/V\") = 0.0;
//   input Real RD(quantity = \"Resistance\", unit = \"Ohm\") = -1e+40;
//   input Real RS(quantity = \"Resistance\", unit = \"Ohm\") = -1e+40;
//   input Real CBD(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = -1e+40;
//   input Real CBS(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = -1e+40;
//   input Real IS(quantity = \"ElectricCurrent\", unit = \"A\") = 1e-14;
//   input Real PB(quantity = \"ElectricPotential\", unit = \"V\") = 0.8;
//   input Real CGSO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0;
//   input Real CGDO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0;
//   input Real CGBO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0;
//   input Real RSH(quantity = \"Resistance\", unit = \"Ohm\") = 0.0;
//   input Real CJ(quantity = \"CapacitancePerArea\", unit = \"F/m2\") = 0.0;
//   input Real MJ = 0.5;
//   input Real CJSW(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0;
//   input Real MJSW = 0.5;
//   input Real JS(quantity = \"CurrentDensity\", unit = \"A/m2\") = 0.0;
//   input Real TOX(quantity = \"Length\", unit = \"m\") = -1e+40;
//   input Real NSUB = -1e+40;
//   input Real NSS(quantity = \"PerArea\", unit = \"1/cm2\") = 0.0;
//   input Real TPG = 1.0;
//   input Real LD(quantity = \"Length\", unit = \"m\") = 0.0;
//   input Real UO(quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\") = 600.0;
//   input Real KF = 0.0;
//   input Real AF = 1.0;
//   input Real FC = 0.5;
//   input Real TNOM(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = 27.0;
//   protected Integer LEVEL = 1;
//   output ModelcardMOS res;
// end Modelica.Electrical.Spice3.Internal.ModelcardMOS;
//
// function Modelica.Electrical.Spice3.Internal.Mos.CurrrentsCapacitances \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos.CurrrentsCapacitances\"
//   input Real idrain(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real iBD(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real iBS(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real cGS(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real cGB(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real cGD(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real cBS(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real cBD(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capgd(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   output CurrrentsCapacitances res;
// end Modelica.Electrical.Spice3.Internal.Mos.CurrrentsCapacitances;
//
// function Modelica.Electrical.Spice3.Internal.Mos.DEVqmeyer \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos.DEVqmeyer\"
//   input Real qm_capgb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real qm_capgs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real qm_capgd(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real qm_qgs(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real qm_qgb(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real qm_qgd(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real qm_vgs(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real qm_vgb(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real qm_vgd(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   output DEVqmeyer res;
// end Modelica.Electrical.Spice3.Internal.Mos.DEVqmeyer;
//
// function Modelica.Electrical.Spice3.Internal.Mos.MosCalc \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos.MosCalc\"
//   input Real m_vds(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vgs(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vbs(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_cbs(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gbs(quantity = \"Conductance\", unit = \"S\");
//   input Real m_cbd(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gbd(quantity = \"Conductance\", unit = \"S\");
//   input Real m_cdrain(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gds(quantity = \"Conductance\", unit = \"S\");
//   input Real m_gm(quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_gmbs(quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_capbsb(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebsb(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbss(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebss(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbdb(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebdb(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbds(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebds(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_Beta;
//   input Real m_capGSovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capGDovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capGBovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capOx(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_von(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vdsat(quantity = \"ElectricPotential\", unit = \"V\");
//   input Integer m_mode(start = 1);
//   input Real m_lEff(quantity = \"Length\", unit = \"m\");
//   input Real m_sourceResistance(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_drainResistance(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_tTransconductance(start = 0.0, quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_tSurfMob(start = 0.0, quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\");
//   input Real m_tPhi(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tVto(start = 1.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tSatCurDens(start = 0.0, quantity = \"CurrentDensity\", unit = \"A/m2\");
//   input Real m_tDrainSatCur(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_tSourceSatCur(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_tCBDb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBDs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBSb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBSs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCj(start = 0.0, quantity = \"CapacitancePerArea\", unit = \"F/m2\");
//   input Real m_tCjsw(start = 0.0, quantity = \"Permittivity\", unit = \"F/m\", min = 0.0);
//   input Real m_tBulkPot(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tDepCap(start = 0.35, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tVbi(start = 1.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_VBScrit(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_VBDcrit(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f1b(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f2b(start = 0.0);
//   input Real m_f3b(start = 0.0);
//   input Real m_f1s(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f2s(start = 0.0);
//   input Real m_f3s(start = 0.0);
//   input Real m_dVt(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_capgd(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capgs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capgb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_qgs(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_qgd(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_qgb(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   output MosCalc res;
// end Modelica.Electrical.Spice3.Internal.Mos.MosCalc;
//
// function Modelica.Electrical.Spice3.Internal.Mos.MosModelLineParams \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos.MosModelLineParams\"
//   input Real m_jctSatCurDensity(start = 0.0);
//   input Real m_sheetResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_bulkJctPotential(start = 0.8);
//   input Real m_bulkJctBotGradingCoeff(start = 0.5, quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\");
//   input Real m_bulkJctSideGradingCoeff(start = 0.5, quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\");
//   input Real m_oxideThickness(start = 1e-07);
//   input Real m_oxideThicknessIsGiven;
//   input Real m_gateSourceOverlapCapFactor(start = 0.0);
//   input Real m_gateDrainOverlapCapFactor(start = 0.0);
//   input Real m_gateBulkOverlapCapFactor(start = 0.0);
//   input Real m_fNcoef(start = 0.0);
//   input Real m_fNexp(start = 1.0);
//   input Real m_mjswIsGiven;
//   input Real m_cgsoIsGiven;
//   input Real m_cgdoIsGiven;
//   input Real m_cgboIsGiven;
//   input Real m_pbIsGiven;
//   input Real m_oxideCapFactor(start = 0.0);
//   input Real m_vt0(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vtOIsGiven;
//   input Real m_capBD(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capBDIsGiven;
//   input Real m_capBS(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capBSIsGiven;
//   input Real m_bulkCapFactor(start = 0.0, quantity = \"CapacitancePerArea\", unit = \"F/m2\");
//   input Real m_bulkCapFactorIsGiven;
//   input Real m_sideWallCapFactor(start = 0.0, quantity = \"Permittivity\", unit = \"F/m\", min = 0.0);
//   input Real m_fwdCapDepCoeff(start = 0.5);
//   input Real m_phi(start = 0.6, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_phiIsGiven;
//   input Real m_gamma(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_gammaIsGiven;
//   input Real m_lambda(quantity = \"InversePotential\", unit = \"1/V\");
//   input Real m_substrateDoping(start = 0.0);
//   input Real m_substrateDopingIsGiven;
//   input Real m_gateType(start = 1.0);
//   input Real m_surfaceStateDensity(start = 0.0, quantity = \"PerArea\", unit = \"1/cm2\");
//   input Real m_surfaceStateDensityIsGiven(start = 0.0);
//   input Real m_surfaceMobility(start = 600.0, quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\");
//   input Real m_latDiff(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real m_jctSatCur(start = 1e-14, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_drainResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_drainResistanceIsGiven;
//   input Real m_sourceResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_sourceResistanceIsGiven;
//   input Real m_transconductance(quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_transconductanceIsGiven;
//   input Real m_tnom(start = 300.15, quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, nominal = 300.0, displayUnit = \"degC\");
//   output MosModelLineParams res;
// end Modelica.Electrical.Spice3.Internal.Mos.MosModelLineParams;
//
// function Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables\"
//   input Real m_oxideCapFactor;
//   input Real m_vt0(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_phi(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_gamma;
//   input Real m_transconductance(quantity = \"Transconductance\", unit = \"A/V2\");
//   output MosModelLineVariables res;
// end Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables;
//
// function Modelica.Electrical.Spice3.Internal.Mos.mosCalcCalcTempDependencies \"Precalculation relating to temperature\"
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams in_p \"Input record model line parameters for MOS1\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants in_C \"Input record SPICE constants\";
//   input Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables in_vp \"Input record model line variables\";
//   input Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet in_m \"Input record MOSFET parameters\";
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc in_c \"Input record Mos1Calc\";
//   input Integer in_m_type \"Type of MOS transistor\";
//   output Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc out_c \"Output record with calculated values\";
//   protected Real ratio;
//   protected Real ratio4;
//   protected Real res;
// algorithm
//   out_c := in_c;
//   ratio := in_m.m_dTemp / in_p.m_tnom;
//   ratio4 := ratio ^ 1.5;
//   out_c.m_tTransconductance := in_vp.m_transconductance / ratio4;
//   out_c.m_Beta := out_c.m_tTransconductance * in_m.m_width / out_c.m_lEff;
//   out_c.m_tSurfMob := in_p.m_surfaceMobility / ratio4;
//   out_c.m_tPhi := Modelica.Electrical.Spice3.Internal.Functions.junctionPotDepTemp(in_vp.m_phi, in_m.m_dTemp, in_p.m_tnom);
//   out_c.m_tVbi := in_vp.m_vt0 + 0.5 * (Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp_old(in_p.m_tnom) - Modelica.Electrical.Spice3.Internal.Functions.energyGapDepTemp_old(in_m.m_dTemp)) + /*Real*/(in_m_type) * (0.5 * (out_c.m_tPhi - in_vp.m_phi) - in_vp.m_gamma * sqrt(in_vp.m_phi));
//   out_c.m_tVto := out_c.m_tVbi + /*Real*/(in_m_type) * in_vp.m_gamma * sqrt(out_c.m_tPhi);
//   out_c.m_tBulkPot := Modelica.Electrical.Spice3.Internal.Functions.junctionPotDepTemp(in_p.m_bulkJctPotential, in_m.m_dTemp, in_p.m_tnom);
//   out_c.m_tDepCap := in_p.m_fwdCapDepCoeff * out_c.m_tBulkPot;
//   if in_p.m_jctSatCurDensity == 0.0 or in_m.m_sourceArea == 0.0 or in_m.m_drainArea == 0.0 then
//     out_c.m_tDrainSatCur := Modelica.Electrical.Spice3.Internal.Functions.saturationCurDepTempSPICE3MOSFET(in_p.m_jctSatCur, in_m.m_dTemp, in_p.m_tnom);
//     out_c.m_tSourceSatCur := out_c.m_tDrainSatCur;
//     out_c.m_VBScrit := Modelica.Electrical.Spice3.Internal.Functions.junctionVCrit(in_m.m_dTemp, 1.0, out_c.m_tSourceSatCur);
//     out_c.m_VBDcrit := out_c.m_VBScrit;
//   else
//     out_c.m_tSatCurDens := Modelica.Electrical.Spice3.Internal.Functions.saturationCurDepTempSPICE3MOSFET(in_p.m_jctSatCurDensity, in_m.m_dTemp, in_p.m_tnom);
//     out_c.m_tDrainSatCur := out_c.m_tSatCurDens * in_m.m_drainArea;
//     out_c.m_tSourceSatCur := out_c.m_tSatCurDens * in_m.m_sourceArea;
//     out_c.m_VBScrit := Modelica.Electrical.Spice3.Internal.Functions.junctionVCrit(in_m.m_dTemp, 1.0, out_c.m_tSourceSatCur);
//     out_c.m_VBDcrit := Modelica.Electrical.Spice3.Internal.Functions.junctionVCrit(in_m.m_dTemp, 1.0, out_c.m_tDrainSatCur);
//   end if;
//   if not in_p.m_capBDIsGiven > 0.5 or not in_p.m_capBSIsGiven > 0.5 then
//     (res, out_c.m_tCj) := Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3(in_p.m_bulkJctPotential, in_p.m_bulkCapFactor, in_p.m_bulkJctBotGradingCoeff, in_m.m_dTemp, in_p.m_tnom);
//     (res, out_c.m_tCjsw) := Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3(in_p.m_bulkJctPotential, in_p.m_sideWallCapFactor, in_p.m_bulkJctSideGradingCoeff, in_m.m_dTemp, in_p.m_tnom);
//     (out_c.m_f1s, out_c.m_f2s, out_c.m_f3s) := Modelica.Electrical.Spice3.Internal.Functions.junctionCapCoeffs(in_p.m_bulkJctSideGradingCoeff, in_p.m_fwdCapDepCoeff, out_c.m_tBulkPot);
//   end if;
//   if in_p.m_capBDIsGiven > 0.5 then
//     (res, out_c.m_tCBDb) := Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3(in_p.m_bulkJctPotential, in_p.m_capBD, in_p.m_bulkJctBotGradingCoeff, in_m.m_dTemp, in_p.m_tnom);
//     out_c.m_tCBDs := 0.0;
//   else
//     out_c.m_tCBDb := out_c.m_tCj * in_m.m_drainArea;
//     out_c.m_tCBDs := out_c.m_tCjsw * in_m.m_drainPerimeter;
//   end if;
//   if in_p.m_capBSIsGiven > 0.5 then
//     (res, out_c.m_tCBSb) := Modelica.Electrical.Spice3.Internal.Functions.junctionParamDepTempSPICE3(in_p.m_bulkJctPotential, in_p.m_capBS, in_p.m_bulkJctBotGradingCoeff, in_m.m_dTemp, in_p.m_tnom);
//     out_c.m_tCBSs := 0.0;
//   else
//     out_c.m_tCBSb := out_c.m_tCj * in_m.m_sourceArea;
//     out_c.m_tCBSs := out_c.m_tCjsw * in_m.m_sourcePerimeter;
//   end if;
//   (out_c.m_f1b, out_c.m_f2b, out_c.m_f3b) := Modelica.Electrical.Spice3.Internal.Functions.junctionCapCoeffs(in_p.m_bulkJctBotGradingCoeff, in_p.m_fwdCapDepCoeff, out_c.m_tBulkPot);
//   out_c.m_dVt := 8.61726105451295e-05 * in_m.m_dTemp;
// end Modelica.Electrical.Spice3.Internal.Mos.mosCalcCalcTempDependencies;
//
// function Modelica.Electrical.Spice3.Internal.Mos.mosCalcDEVqmeyer \"Calculation of Meyer capacities\"
//   input Real vgs(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real vgd(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real vgb(quantity = \"ElectricPotential\", unit = \"V\");
//   input Modelica.Electrical.Spice3.Internal.Mos.MosCalc in_c \"Input variable set\";
//   output Modelica.Electrical.Spice3.Internal.Mos.DEVqmeyer out_qm \"Qmeyer values\";
//   protected Real vds(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vddif(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vddif1(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vddif2(quantity = \"ElectricalPotential2\", unit = \"V2\");
//   protected Real vgst(quantity = \"ElectricPotential\", unit = \"V\");
// algorithm
//   vgst := vgs - in_c.m_von;
//   if vgst <= (-in_c.m_tPhi) then
//     out_qm.qm_capgb := 0.5 * in_c.m_capOx;
//     out_qm.qm_capgs := 0.0;
//     out_qm.qm_capgd := 0.0;
//   elseif vgst <= (-0.5) * in_c.m_tPhi then
//     out_qm.qm_capgb := (-0.5) * vgst * in_c.m_capOx / in_c.m_tPhi;
//     out_qm.qm_capgs := 0.0;
//     out_qm.qm_capgd := 0.0;
//   elseif vgst <= 0.0 then
//     out_qm.qm_capgb := (-0.5) * vgst * in_c.m_capOx / in_c.m_tPhi;
//     out_qm.qm_capgs := 0.6666666666666666 * vgst * in_c.m_capOx / in_c.m_tPhi + 0.3333333333333333 * in_c.m_capOx;
//     out_qm.qm_capgd := 0.0;
//   else
//     vds := vgs - vgd;
//     if in_c.m_vdsat <= vds then
//       out_qm.qm_capgs := 0.3333333333333333 * in_c.m_capOx;
//       out_qm.qm_capgd := 0.0;
//       out_qm.qm_capgb := 0.0;
//     else
//       vddif := 2.0 * in_c.m_vdsat - vds;
//       vddif1 := in_c.m_vdsat - vds;
//       vddif2 := vddif ^ 2.0;
//       out_qm.qm_capgd := 0.3333333333333333 * in_c.m_capOx * (1.0 - in_c.m_vdsat ^ 2.0 / vddif2);
//       out_qm.qm_capgs := 0.3333333333333333 * in_c.m_capOx * (1.0 - vddif1 ^ 2.0 / vddif2);
//       out_qm.qm_capgb := 0.0;
//     end if;
//   end if;
//   out_qm.qm_qgs := 0.0;
//   out_qm.qm_qgb := 0.0;
//   out_qm.qm_qgd := 0.0;
//   out_qm.qm_vgs := 0.0;
//   out_qm.qm_vgb := 0.0;
//   out_qm.qm_vgd := 0.0;
// end Modelica.Electrical.Spice3.Internal.Mos.mosCalcDEVqmeyer;
//
// function Modelica.Electrical.Spice3.Internal.Mos.mosCalcInitEquations \"Mosfet initial precalculations (level 1)\"
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams in_p \"Input record model line parameters for MOS1\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants in_C \"Input record SPICE constants\";
//   input Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables in_vp \"Input record model line variables\";
//   input Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet in_m \"Input record MOSFET parameters\";
//   output Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc out_c \"Output record Mos1 calculated values\";
// algorithm
//   out_c.m_drainResistance := if in_p.m_drainResistanceIsGiven > 0.5 then in_p.m_drainResistance else in_p.m_sheetResistance * in_m.m_drainSquares;
//   out_c.m_sourceResistance := if in_p.m_sourceResistanceIsGiven > 0.5 then in_p.m_sourceResistance else in_p.m_sheetResistance * in_m.m_sourceSquares;
//   out_c.m_lEff := in_m.m_len + (-2.0) * in_p.m_latDiff;
//   if abs(out_c.m_lEff) < 1e-18 then
//     out_c.m_lEff := 1e-06;
//   end if;
//   out_c.m_capGSovl := in_p.m_gateSourceOverlapCapFactor * in_m.m_width;
//   out_c.m_capGDovl := in_p.m_gateDrainOverlapCapFactor * in_m.m_width;
//   out_c.m_capGBovl := in_p.m_gateBulkOverlapCapFactor * out_c.m_lEff;
//   out_c.m_capOx := in_vp.m_oxideCapFactor * out_c.m_lEff * in_m.m_width;
//   out_c.m_tTransconductance := 0.0;
//   out_c.m_tSurfMob := 0.0;
//   out_c.m_tPhi := 0.7;
//   out_c.m_tVto := 1.0;
//   out_c.m_tSatCurDens := 0.0;
//   out_c.m_tDrainSatCur := 0.0;
//   out_c.m_tSourceSatCur := 0.0;
//   out_c.m_tCBDb := 0.0;
//   out_c.m_tCBDs := 0.0;
//   out_c.m_tCBSb := 0.0;
//   out_c.m_tCBSs := 0.0;
//   out_c.m_tCj := 0.0;
//   out_c.m_tCjsw := 0.0;
//   out_c.m_tBulkPot := 0.7;
//   out_c.m_tDepCap := 0.35;
//   out_c.m_tVbi := 1.0;
//   out_c.m_VBScrit := 0.7;
//   out_c.m_VBDcrit := 0.7;
//   out_c.m_f1b := 0.0;
//   out_c.m_f2b := 0.0;
//   out_c.m_f3b := 0.0;
//   out_c.m_f1s := 0.0;
//   out_c.m_f2s := 0.0;
//   out_c.m_f3s := 0.0;
//   out_c.m_dVt := 0.0;
//   out_c.m_capgd := 0.0;
//   out_c.m_capgs := 0.0;
//   out_c.m_capgb := 0.0;
//   out_c.m_qgs := 0.0;
//   out_c.m_qgd := 0.0;
//   out_c.m_qgb := 0.0;
//   out_c.m_vds := 0.0;
//   out_c.m_vgs := 0.0;
//   out_c.m_vbs := 0.0;
//   out_c.m_cbs := 0.0;
//   out_c.m_gbs := 0.0;
//   out_c.m_cbd := 0.0;
//   out_c.m_gbd := 0.0;
//   out_c.m_cdrain := 0.0;
//   out_c.m_gds := 0.0;
//   out_c.m_gm := 0.0;
//   out_c.m_gmbs := 0.0;
//   out_c.m_capbsb := 0.0;
//   out_c.m_chargebsb := 0.0;
//   out_c.m_capbss := 0.0;
//   out_c.m_chargebss := 0.0;
//   out_c.m_capbdb := 0.0;
//   out_c.m_chargebdb := 0.0;
//   out_c.m_capbds := 0.0;
//   out_c.m_chargebds := 0.0;
//   out_c.m_Beta := 0.0;
//   out_c.m_von := 0.0;
//   out_c.m_vdsat := 0.0;
//   out_c.m_mode := 1;
// end Modelica.Electrical.Spice3.Internal.Mos.mosCalcInitEquations;
//
// function Modelica.Electrical.Spice3.Internal.Mos.mosCalcNoBypassCode \"Calculation of currents and capacities (level 1)\"
//   input Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet in_m \"Input record MOSFET parameters\";
//   input Integer in_m_type \"Type of MOS transistor\";
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc in_c \"Input record Mos1Calc\";
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams in_p \"Input record model line parameters for MOS1\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants in_C \"Input record SPICE constants\";
//   input Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables in_vp \"Input record model line variables\";
//   input Boolean in_m_bInit;
//   input Real[4] in_m_pVoltageValues(quantity = \"ElectricPotential\", unit = \"V\");
//   output Modelica.Electrical.Spice3.Internal.Mos.CurrrentsCapacitances out_cc;
//   protected Real vbd(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vgd(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real vgb(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real cur(quantity = \"ElectricCurrent\", unit = \"A\");
//   protected Integer n;
//   protected Modelica.Electrical.Spice3.Internal.Mos.DEVqmeyer qm;
//   protected Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc int_c;
//   protected Real hlp;
// algorithm
//   int_c := in_c;
//   out_cc.m_capgd := 0.0;
//   int_c.m_vgs := /*Real*/(in_m_type) * (in_m_pVoltageValues[1] - in_m_pVoltageValues[4]);
//   int_c.m_vbs := /*Real*/(in_m_type) * (in_m_pVoltageValues[2] - in_m_pVoltageValues[4]);
//   int_c.m_vds := /*Real*/(in_m_type) * (in_m_pVoltageValues[3] - in_m_pVoltageValues[4]);
//   vbd := int_c.m_vbs - int_c.m_vds;
//   vgd := int_c.m_vgs - int_c.m_vds;
//   if int_c.m_vds >= 0.0 then
//     vbd := int_c.m_vbs - int_c.m_vds;
//   else
//     int_c.m_vbs := vbd + int_c.m_vds;
//   end if;
//   vgb := int_c.m_vgs - int_c.m_vbs;
//   (int_c.m_cbd, int_c.m_gbd) := Modelica.Electrical.Spice3.Internal.Functions.junction2SPICE3MOSFET(int_c.m_cbd, int_c.m_gbd, vbd, in_m.m_dTemp, 1.0, int_c.m_tDrainSatCur);
//   out_cc.iBD := /*Real*/(in_m_type) * int_c.m_cbd;
//   (int_c.m_cbs, int_c.m_gbs) := Modelica.Electrical.Spice3.Internal.Functions.junction2SPICE3MOSFET(int_c.m_cbs, int_c.m_gbs, int_c.m_vbs, in_m.m_dTemp, 1.0, int_c.m_tSourceSatCur);
//   out_cc.iBS := /*Real*/(in_m_type) * int_c.m_cbs;
//   int_c.m_mode := if int_c.m_vds >= 0.0 then 1 else -1;
//   if int_c.m_mode == 1 then
//     int_c := Modelica.Electrical.Spice3.Internal.Mos1.drainCur(int_c.m_vbs, int_c.m_vgs, int_c.m_vds, int_c, in_p, in_C, in_vp, in_m_type);
//   else
//     int_c := Modelica.Electrical.Spice3.Internal.Mos1.drainCur(vbd, vgd, -int_c.m_vds, int_c, in_p, in_C, in_vp, in_m_type);
//   end if;
//   n := if int_c.m_mode == 1 then 6 else 5;
//   out_cc.idrain := /*Real*/(in_m_type) * int_c.m_cdrain * /*Real*/(int_c.m_mode);
//   int_c.m_capbss := 0.0;
//   int_c.m_chargebss := 0.0;
//   int_c.m_capbds := 0.0;
//   int_c.m_chargebds := 0.0;
//   (int_c.m_capbsb, int_c.m_chargebsb) := Modelica.Electrical.Spice3.Internal.Functions.junctionCap(int_c.m_tCBSb, int_c.m_vbs, int_c.m_tDepCap, in_p.m_bulkJctBotGradingCoeff, int_c.m_tBulkPot, int_c.m_f1b, int_c.m_f2b, int_c.m_f3b);
//   (int_c.m_capbdb, int_c.m_chargebdb) := Modelica.Electrical.Spice3.Internal.Functions.junctionCap(int_c.m_tCBDb, vbd, int_c.m_tDepCap, in_p.m_bulkJctBotGradingCoeff, int_c.m_tBulkPot, int_c.m_f1b, int_c.m_f2b, int_c.m_f3b);
//   if not in_p.m_capBSIsGiven > 0.5 then
//     (int_c.m_capbss, int_c.m_chargebss) := Modelica.Electrical.Spice3.Internal.Functions.junctionCap(int_c.m_tCBSs, int_c.m_vbs, int_c.m_tDepCap, in_p.m_bulkJctSideGradingCoeff, int_c.m_tBulkPot, int_c.m_f1s, int_c.m_f2s, int_c.m_f3s);
//   end if;
//   if not in_p.m_capBDIsGiven > 0.5 then
//     (int_c.m_capbds, int_c.m_chargebds) := Modelica.Electrical.Spice3.Internal.Functions.junctionCap(int_c.m_tCBDs, vbd, int_c.m_tDepCap, in_p.m_bulkJctSideGradingCoeff, int_c.m_tBulkPot, int_c.m_f1s, int_c.m_f2s, int_c.m_f3s);
//   end if;
//   out_cc.cBS := if in_m_bInit then 1e-15 else int_c.m_capbsb + int_c.m_capbss;
//   out_cc.cBD := if in_m_bInit then 1e-15 else int_c.m_capbdb + int_c.m_capbds;
//   if int_c.m_mode > 0 then
//     qm := Modelica.Electrical.Spice3.Internal.Mos.mosCalcDEVqmeyer(int_c.m_vgs, vgd, vgb, /*.Modelica.Electrical.Spice3.Internal.Mos.MosCalc*/(int_c));
//   else
//     qm := Modelica.Electrical.Spice3.Internal.Mos.mosCalcDEVqmeyer(vgd, int_c.m_vgs, vgb, /*.Modelica.Electrical.Spice3.Internal.Mos.MosCalc*/(int_c));
//     hlp := qm.qm_capgd;
//     qm.qm_capgd := qm.qm_capgs;
//     qm.qm_capgs := hlp;
//   end if;
//   int_c.m_capgd := 2.0 * qm.qm_capgd + int_c.m_capGDovl;
//   int_c.m_capgs := 2.0 * qm.qm_capgs + int_c.m_capGSovl;
//   int_c.m_capgb := 2.0 * qm.qm_capgb + int_c.m_capGBovl;
//   out_cc.cGB := if in_m_bInit then -1e+40 else int_c.m_capgb;
//   out_cc.cGD := if in_m_bInit then -1e+40 else int_c.m_capgd;
//   out_cc.cGS := if in_m_bInit then -1e+40 else int_c.m_capgs;
// end Modelica.Electrical.Spice3.Internal.Mos.mosCalcNoBypassCode;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc\"
//   input Real m_vds(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vgs(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vbs(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_cbs(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gbs(quantity = \"Conductance\", unit = \"S\");
//   input Real m_cbd(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gbd(quantity = \"Conductance\", unit = \"S\");
//   input Real m_cdrain(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_gds(quantity = \"Conductance\", unit = \"S\");
//   input Real m_gm(quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_gmbs(quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_capbsb(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebsb(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbss(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebss(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbdb(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebdb(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_capbds(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_chargebds(quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_Beta;
//   input Real m_capGSovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capGDovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capGBovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capOx(quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_von(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vdsat(quantity = \"ElectricPotential\", unit = \"V\");
//   input Integer m_mode(start = 1);
//   input Real m_lEff(quantity = \"Length\", unit = \"m\");
//   input Real m_sourceResistance(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_drainResistance(quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_tTransconductance(start = 0.0, quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_tSurfMob(start = 0.0, quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\");
//   input Real m_tPhi(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tVto(start = 1.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tSatCurDens(start = 0.0, quantity = \"CurrentDensity\", unit = \"A/m2\");
//   input Real m_tDrainSatCur(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_tSourceSatCur(start = 0.0, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_tCBDb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBDs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBSb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCBSs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_tCj(start = 0.0, quantity = \"CapacitancePerArea\", unit = \"F/m2\");
//   input Real m_tCjsw(start = 0.0, quantity = \"Permittivity\", unit = \"F/m\", min = 0.0);
//   input Real m_tBulkPot(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tDepCap(start = 0.35, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_tVbi(start = 1.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_VBScrit(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_VBDcrit(start = 0.7, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f1b(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f2b(start = 0.0);
//   input Real m_f3b(start = 0.0);
//   input Real m_f1s(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_f2s(start = 0.0);
//   input Real m_f3s(start = 0.0);
//   input Real m_dVt(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_capgd(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capgs(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capgb(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_qgs(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_qgd(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   input Real m_qgb(start = 0.0, quantity = \"ElectricCharge\", unit = \"C\");
//   output Mos1Calc res;
// end Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams\"
//   input Real m_jctSatCurDensity(start = 0.0);
//   input Real m_sheetResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_bulkJctPotential(start = 0.8);
//   input Real m_bulkJctBotGradingCoeff(start = 0.5, quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\");
//   input Real m_bulkJctSideGradingCoeff(start = 0.5, quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\");
//   input Real m_oxideThickness(start = 1e-07);
//   input Real m_oxideThicknessIsGiven;
//   input Real m_gateSourceOverlapCapFactor(start = 0.0);
//   input Real m_gateDrainOverlapCapFactor(start = 0.0);
//   input Real m_gateBulkOverlapCapFactor(start = 0.0);
//   input Real m_fNcoef(start = 0.0);
//   input Real m_fNexp(start = 1.0);
//   input Real m_mjswIsGiven;
//   input Real m_cgsoIsGiven;
//   input Real m_cgdoIsGiven;
//   input Real m_cgboIsGiven;
//   input Real m_pbIsGiven;
//   input Real m_oxideCapFactor(start = 0.0);
//   input Real m_vt0(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_vtOIsGiven;
//   input Real m_capBD(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capBDIsGiven;
//   input Real m_capBS(start = 0.0, quantity = \"Capacitance\", unit = \"F\", min = 0.0);
//   input Real m_capBSIsGiven;
//   input Real m_bulkCapFactor(start = 0.0, quantity = \"CapacitancePerArea\", unit = \"F/m2\");
//   input Real m_bulkCapFactorIsGiven;
//   input Real m_sideWallCapFactor(start = 0.0, quantity = \"Permittivity\", unit = \"F/m\", min = 0.0);
//   input Real m_fwdCapDepCoeff(start = 0.5);
//   input Real m_phi(start = 0.6, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_phiIsGiven;
//   input Real m_gamma(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_gammaIsGiven;
//   input Real m_lambda(start = 0.0, quantity = \"InversePotential\", unit = \"1/V\");
//   input Real m_substrateDoping(start = 0.0);
//   input Real m_substrateDopingIsGiven;
//   input Real m_gateType(start = 1.0);
//   input Real m_surfaceStateDensity(start = 0.0, quantity = \"PerArea\", unit = \"1/cm2\");
//   input Real m_surfaceStateDensityIsGiven(start = 0.0);
//   input Real m_surfaceMobility(start = 600.0, quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\");
//   input Real m_latDiff(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real m_jctSatCur(start = 1e-14, quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real m_drainResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_drainResistanceIsGiven;
//   input Real m_sourceResistance(start = 0.0, quantity = \"Resistance\", unit = \"Ohm\");
//   input Real m_sourceResistanceIsGiven;
//   input Real m_transconductance(start = 2e-05, quantity = \"Transconductance\", unit = \"A/V2\");
//   input Real m_transconductanceIsGiven;
//   input Real m_tnom(start = 300.15, quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, nominal = 300.0, displayUnit = \"degC\");
//   output Mos1ModelLineParams res;
// end Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.drainCur \"Drain current calculation\"
//   input Real vb(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real vg(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real vds(quantity = \"ElectricPotential\", unit = \"V\");
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc in_c \"Input record Mos1Calc\";
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams in_p \"Input record model line parameters for MOS1\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants in_C \"Spice constants\";
//   input Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables in_vp \"Input record model line variables\";
//   input Integer in_m_type \"Type of Mos transistor\";
//   output Modelica.Electrical.Spice3.Internal.Mos1.Mos1Calc out_c \"Output record Mos1Calc\";
//   protected Real arg;
//   protected Real betap;
//   protected Real sarg;
//   protected Real vgst(quantity = \"ElectricPotential\", unit = \"V\");
// algorithm
//   out_c := in_c;
//   if vb <= 0.0 then
//     sarg := sqrt(out_c.m_tPhi - vb);
//   else
//     sarg := sqrt(out_c.m_tPhi);
//     sarg := sarg + (-0.5) * vb / sarg;
//     sarg := max(0.0, sarg);
//   end if;
//   out_c.m_von := out_c.m_tVbi * /*Real*/(in_m_type) + in_vp.m_gamma * sarg;
//   vgst := vg - out_c.m_von;
//   out_c.m_vdsat := max(vgst, 0.0);
//   arg := if sarg <= 0.0 then 0.0 else 0.5 * in_vp.m_gamma / sarg;
//   if vgst <= 0.0 then
//     out_c.m_cdrain := 0.0;
//     out_c.m_gm := 0.0;
//     out_c.m_gds := 0.0;
//     out_c.m_gmbs := 0.0;
//   else
//     betap := out_c.m_Beta * (1.0 + in_p.m_lambda * vds);
//     if vgst <= vds then
//       out_c.m_cdrain := 0.5 * betap * vgst ^ 2.0;
//       out_c.m_gm := betap * vgst;
//       out_c.m_gds := 0.5 * in_p.m_lambda * out_c.m_Beta * vgst ^ 2.0;
//       out_c.m_gmbs := out_c.m_gm * arg;
//     else
//       out_c.m_cdrain := betap * vds * (vgst + (-0.5) * vds);
//       out_c.m_gm := betap * vds;
//       out_c.m_gds := betap * (vgst - vds) + in_p.m_lambda * out_c.m_Beta * vds * (vgst + (-0.5) * vds);
//       out_c.m_gmbs := out_c.m_gm * arg;
//     end if;
//   end if;
// end Modelica.Electrical.Spice3.Internal.Mos1.drainCur;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.mos1ModelLineParamsInitEquations \"Initial precalculation\"
//   input Modelica.Electrical.Spice3.Internal.Mos1.Mos1ModelLineParams in_p \"Input record model line parameters for MOS1\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants in_C \"Spice constants\";
//   input Integer in_m_type \"Type of MOS transistor\";
//   output Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables out_v \"Output record model line variables\";
//   protected Real vtnom(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real fermis(quantity = \"ElectricPotential\", unit = \"V\");
//   protected Real fermig;
//   protected Real wkfng;
//   protected Real wkfngs;
//   protected Real egfet1;
//   protected Real vfb;
// algorithm
//   out_v.m_oxideCapFactor := in_p.m_oxideCapFactor;
//   out_v.m_transconductance := in_p.m_transconductance;
//   out_v.m_phi := in_p.m_phi;
//   out_v.m_gamma := in_p.m_gamma;
//   out_v.m_vt0 := in_p.m_vt0;
//   vtnom := 8.61726105451295e-05 * in_p.m_tnom;
//   egfet1 := 1.16 + (-0.000702) * in_p.m_tnom ^ 2.0 / (1108.0 + in_p.m_tnom);
//   if not in_p.m_oxideThicknessIsGiven > 0.5 or in_p.m_oxideThickness == 0.0 then
//     if in_p.m_oxideThickness == 0.0 then
//       out_v.m_oxideCapFactor := 0.0;
//     end if;
//   else
//     out_v.m_oxideCapFactor := 3.45314379969e-11 / in_p.m_oxideThickness;
//     if out_v.m_oxideCapFactor <> 0.0 then
//       if not in_p.m_transconductanceIsGiven > 0.5 then
//         out_v.m_transconductance := 0.0001 * in_p.m_surfaceMobility * out_v.m_oxideCapFactor;
//       end if;
//       if in_p.m_substrateDopingIsGiven > 0.5 then
//         if 1000000.0 * in_p.m_substrateDoping > 1.45e+16 then
//           if not in_p.m_phiIsGiven > 0.5 then
//             out_v.m_phi := 2.0 * vtnom * log(6.896551724137932e-11 * in_p.m_substrateDoping);
//             out_v.m_phi := max(0.1, out_v.m_phi);
//           end if;
//           fermis := 0.5 * /*Real*/(in_m_type) * out_v.m_phi;
//           wkfng := 3.2;
//           if in_p.m_gateType <> 0.0 then
//             fermig := 0.5 * /*Real*/(in_m_type) * in_p.m_gateType * egfet1;
//             wkfng := 3.25 + 0.5 * egfet1 - fermig;
//           end if;
//           wkfngs := -3.25 + wkfng + (-0.5) * egfet1 - fermis;
//           if not in_p.m_gammaIsGiven > 0.5 then
//             out_v.m_gamma := 5.761561600860045e-12 * sqrt(in_p.m_substrateDoping / out_v.m_oxideCapFactor);
//           end if;
//           if not in_p.m_vtOIsGiven > 0.5 then
//             vfb := wkfngs + (-1.6021918e-15) * in_p.m_surfaceStateDensity / out_v.m_oxideCapFactor;
//             out_v.m_vt0 := vfb + /*Real*/(in_m_type) * (out_v.m_gamma * sqrt(out_v.m_phi) + out_v.m_phi);
//           end if;
//         end if;
//       end if;
//     end if;
//   end if;
// end Modelica.Electrical.Spice3.Internal.Mos1.mos1ModelLineParamsInitEquations;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.mos1RenameParameters \"Parameter renaming to internal names\"
//   input Modelica.Electrical.Spice3.Internal.ModelcardMOS ex \"Modelcard with technologieparameters\";
//   input Modelica.Electrical.Spice3.Internal.SpiceConstants con \"Spice constants\";
//   output Modelica.Electrical.Spice3.Internal.Mos.MosModelLineParams intern \"Output record model line parameters\";
// algorithm
//   intern.m_cgboIsGiven := 0.0;
//   intern.m_cgdoIsGiven := 0.0;
//   intern.m_cgsoIsGiven := 0.0;
//   intern.m_mjswIsGiven := 0.0;
//   intern.m_pbIsGiven := 0.0;
//   intern.m_surfaceStateDensityIsGiven := 0.0;
//   intern.m_oxideCapFactor := 0.0;
//   intern.m_vtOIsGiven := if ex.VTO > -1e+40 then 1.0 else 0.0;
//   intern.m_vt0 := if ex.VTO > -1e+40 then ex.VTO else 0.0;
//   intern.m_capBDIsGiven := if ex.CBD > -1e+40 then 1.0 else 0.0;
//   intern.m_capBD := if ex.CBD > -1e+40 then ex.CBD else 0.0;
//   intern.m_capBSIsGiven := if ex.CBS > -1e+40 then 1.0 else 0.0;
//   intern.m_capBS := if ex.CBS > -1e+40 then ex.CBS else 0.0;
//   intern.m_bulkCapFactorIsGiven := if ex.CJ > -1e+40 then 1.0 else 0.0;
//   intern.m_bulkCapFactor := if ex.CJ > -1e+40 then ex.CJ else 0.0;
//   intern.m_sideWallCapFactor := ex.CJSW;
//   intern.m_fwdCapDepCoeff := ex.FC;
//   intern.m_phiIsGiven := if ex.PHI > -1e+40 then 1.0 else 0.0;
//   intern.m_phi := if ex.PHI > -1e+40 then ex.PHI else 0.6;
//   intern.m_gammaIsGiven := if ex.GAMMA > -1e+40 then 1.0 else 0.0;
//   intern.m_gamma := if ex.GAMMA > -1e+40 then ex.GAMMA else 0.0;
//   intern.m_lambda := ex.LAMBDA;
//   intern.m_substrateDopingIsGiven := if ex.NSUB > -1e+40 then 1.0 else 0.0;
//   intern.m_substrateDoping := if ex.NSUB > -1e+40 then ex.NSUB else 0.0;
//   intern.m_gateType := ex.TPG;
//   intern.m_surfaceStateDensity := ex.NSS;
//   intern.m_surfaceMobility := ex.UO;
//   intern.m_latDiff := ex.LD;
//   intern.m_jctSatCur := ex.IS;
//   intern.m_drainResistanceIsGiven := if ex.RD > -1e+40 then 1.0 else 0.0;
//   intern.m_drainResistance := if ex.RD > -1e+40 then ex.RD else 0.0;
//   intern.m_sourceResistanceIsGiven := if ex.RS > -1e+40 then 1.0 else 0.0;
//   intern.m_sourceResistance := if ex.RS > -1e+40 then ex.RS else 0.0;
//   intern.m_transconductanceIsGiven := if ex.KP > -1e+40 then 1.0 else 0.0;
//   intern.m_transconductance := if ex.KP > -1e+40 then ex.KP else 2e-05;
//   intern.m_tnom := if ex.TNOM > -1e+40 then 273.15 + ex.TNOM else 300.15;
//   intern.m_jctSatCurDensity := ex.JS;
//   intern.m_sheetResistance := ex.RSH;
//   intern.m_bulkJctPotential := ex.PB;
//   intern.m_bulkJctBotGradingCoeff := ex.MJ;
//   intern.m_bulkJctSideGradingCoeff := ex.MJSW;
//   intern.m_oxideThicknessIsGiven := if ex.TOX > -1e+40 then 1.0 else 0.0;
//   intern.m_oxideThickness := if ex.TOX > -1e+40 then ex.TOX else 0.0;
//   intern.m_gateSourceOverlapCapFactor := ex.CGSO;
//   intern.m_gateDrainOverlapCapFactor := ex.CGDO;
//   intern.m_gateBulkOverlapCapFactor := ex.CGBO;
//   intern.m_fNcoef := ex.KF;
//   intern.m_fNexp := ex.AF;
// end Modelica.Electrical.Spice3.Internal.Mos1.mos1RenameParameters;
//
// function Modelica.Electrical.Spice3.Internal.Mos1.mos1RenameParametersDev \"Device parameter renaming to internal names\"
//   input Modelica.Electrical.Spice3.Internal.ModelcardMOS ex;
//   input Integer mtype;
//   input Real W(quantity = \"Length\", unit = \"m\") \"Channel Width\";
//   input Real L(quantity = \"Length\", unit = \"m\") \"Channel Length\";
//   input Real AD(quantity = \"Area\", unit = \"m2\") \"Area of the drain diffusion\";
//   input Real AS(quantity = \"Area\", unit = \"m2\") \"Area of the source diffusion\";
//   input Real PD(quantity = \"Length\", unit = \"m\") \"Perimeter of the drain junction\";
//   input Real PS(quantity = \"Length\", unit = \"m\") \"Perimeter of the source junction\";
//   input Real NRD \"Number of squares of the drain diffusions\";
//   input Real NRS \"Number of squares of the source diffusions\";
//   input Integer OFF \"Optional initial condition: 0 - IC not used, 1 - IC used, not implemented yet\";
//   input Real IC \"Initial condition values, not implemented yet\";
//   input Real TEMP(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Temperature\";
//   output Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet dev \"Output record Mosfet\";
// algorithm
//   dev.m_len := L;
//   dev.m_width := W;
//   dev.m_drainArea := AD;
//   dev.m_sourceArea := AS;
//   dev.m_drainSquares := NRD;
//   dev.m_sourceSquares := NRS;
//   dev.m_drainPerimeter := PD;
//   dev.m_sourcePerimeter := PS;
//   dev.m_dICVDSIsGiven := if IC > -1e+40 then 1.0 else 0.0;
//   dev.m_dICVDS := if IC > -1e+40 then IC else 0.0;
//   dev.m_dICVGSIsGiven := if IC > -1e+40 then 1.0 else 0.0;
//   dev.m_dICVGS := if IC > -1e+40 then IC else 0.0;
//   dev.m_dICVBSIsGiven := if IC > -1e+40 then 1.0 else 0.0;
//   dev.m_dICVBS := if IC > -1e+40 then IC else 0.0;
//   dev.m_off := OFF;
//   dev.m_bPMOS := mtype;
//   dev.m_nLevel := 1;
//   dev.m_dTemp := 273.15 + TEMP;
//   dev.m_drainPerimiter := 0.0;
//   dev.m_sourcePerimiter := 0.0;
//   dev.m_uic := false;
// end Modelica.Electrical.Spice3.Internal.Mos1.mos1RenameParametersDev;
//
// function Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet\"
//   input Real m_dTemp(start = 300.15, quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, nominal = 300.0, displayUnit = \"degC\");
//   input Real m_len(start = 0.0001, quantity = \"Length\", unit = \"m\");
//   input Real m_width(start = 0.0001, quantity = \"Length\", unit = \"m\");
//   input Real m_drainArea(start = 0.0, quantity = \"Area\", unit = \"m2\");
//   input Real m_sourceArea(start = 0.0, quantity = \"Area\", unit = \"m2\");
//   input Real m_drainSquares(start = 1.0);
//   input Real m_sourceSquares(start = 1.0);
//   input Real m_drainPerimeter(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real m_sourcePerimeter(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real m_dICVDS(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_dICVDSIsGiven;
//   input Real m_dICVGS(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_dICVGSIsGiven;
//   input Real m_dICVBS(start = 0.0, quantity = \"ElectricPotential\", unit = \"V\");
//   input Real m_dICVBSIsGiven;
//   input Integer m_off(start = 0);
//   input Integer m_bPMOS(start = 0);
//   input Integer m_nLevel(start = 1);
//   input Real m_drainPerimiter(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Real m_sourcePerimiter(start = 0.0, quantity = \"Length\", unit = \"m\");
//   input Boolean m_uic;
//   output Mosfet res;
// end Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet;
//
// function Modelica.Electrical.Spice3.Internal.SpiceConstants \"Automatically generated record constructor for Modelica.Electrical.Spice3.Internal.SpiceConstants\"
//   protected Real EPSSIL = 1.035943139907e-10;
//   protected Real EPSOX = 3.453133e-11;
//   protected Real CHARGE(quantity = \"ElectricCharge\", unit = \"C\") = 1.6021918e-19;
//   protected Real CONSTCtoK(quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, start = 288.15, nominal = 300.0, displayUnit = \"degC\") = 273.15;
//   protected Real CONSTboltz(quantity = \"HeatCapacity\", unit = \"J/K\") = 1.3806226e-23;
//   protected Real REFTEMP(quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, start = 288.15, nominal = 300.0, displayUnit = \"degC\") = 300.15;
//   protected Real CONSTroot2 = 1.414213562373095;
//   protected Real CONSTvt0(unit = \"(J/K)/(A.s)\") = 0.02586470905512062;
//   protected Real CONSTKoverQ(unit = \"(J/K)/(A.s)\") = 8.61726105451295e-05;
//   protected Real CONSTe = 2.718281828459045;
//   protected Real CKTgmin(quantity = \"Conductance\", unit = \"S\") = 1e-12;
//   protected Real CKTnomTemp(quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, start = 288.15, nominal = 300.0, displayUnit = \"degC\") = 300.15;
//   protected Real CKTtemp(quantity = \"ThermodynamicTemperature\", unit = \"K\", min = 0.0, start = 288.15, nominal = 300.0, displayUnit = \"degC\") = 300.15;
//   protected Real CKTdefaultMosAD(quantity = \"Area\", unit = \"m2\") = 0.0;
//   protected Real CKTdefaultMosAS(quantity = \"Area\", unit = \"m2\") = 0.0;
//   protected Real CKTdefaultMosL(quantity = \"Length\", unit = \"m\") = 0.0001;
//   protected Real CKTdefaultMosW(quantity = \"Length\", unit = \"m\") = 0.0001;
//   protected Real CKTreltol = 1e-10;
//   protected Real CKTabstol = 1e-15;
//   protected Real CKTvolttol = 1e-10;
//   protected Real CKTtemptol = 0.001;
//   output SpiceConstants res;
// end Modelica.Electrical.Spice3.Internal.SpiceConstants;
//
// function Modelica.Electrical.Spice3.Internal.SpiceRoot.initJunctionVoltages \"Choice of junction voltage handling, obsolete, use initJunctionVoltageRevised\"
//   output Boolean ret;
// algorithm
//   ret := false;
// end Modelica.Electrical.Spice3.Internal.SpiceRoot.initJunctionVoltages;
//
// function Modelica.Electrical.Spice3.Internal.SpiceRoot.useInitialConditions \"Initial condition handling\"
//   output Boolean ret;
// algorithm
//   ret := false;
// end Modelica.Electrical.Spice3.Internal.SpiceRoot.useInitialConditions;
//
// function Modelica.SIunits.Conversions.from_degC \"Inline before index reduction\" \"Convert from degCelsius to Kelvin\"
//   input Real Celsius(quantity = \"ThermodynamicTemperature\", unit = \"degC\") \"Celsius value\";
//   output Real Kelvin(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Kelvin value\";
// algorithm
//   Kelvin := 273.15 + Celsius;
// end Modelica.SIunits.Conversions.from_degC;
//
// class A
//   constant Real L(quantity = \"Length\", unit = \"m\") = 0.0001 \"Length\";
//   constant Real W(quantity = \"Length\", unit = \"m\") = 0.0001 \"Width\";
//   constant Real AD(quantity = \"Area\", unit = \"m2\") = 0.0 \"Area of the drain diffusion\";
//   constant Real AS(quantity = \"Area\", unit = \"m2\") = 0.0 \"Area of the source diffusion\";
//   constant Real PD(quantity = \"Length\", unit = \"m\") = 0.0 \"Perimeter of the drain junction\";
//   constant Real PS(quantity = \"Length\", unit = \"m\") = 0.0 \"Perimeter of the source junction\";
//   constant Real NRD = 1.0 \"Number of squares of the drain diffusions\";
//   constant Real NRS = 1.0 \"Number of squares of the source diffusions\";
//   constant Integer OFF = 0 \"Optional initial condition: 0 - IC not used, 1 - IC used, not implemented yet\";
//   constant Real IC(quantity = \"ElectricPotential\", unit = \"V\") = -1e+40 \"Initial condition values, not implemented yet\";
//   constant Real TEMP(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = 27.0 \"Operating temperature of the device\";
//   constant Real modelcard.VTO(quantity = \"ElectricPotential\", unit = \"V\") = -1e+40 \"Zero-bias threshold voltage, default 0\";
//   constant Real modelcard.KP(quantity = \"Transconductance\", unit = \"A/V2\") = -1e+40 \"Transconductance parameter, default 2e-5\";
//   constant Real modelcard.GAMMA = -1e+40 \"Bulk threshold parameter, default 0\";
//   constant Real modelcard.PHI(quantity = \"ElectricPotential\", unit = \"V\") = -1e+40 \"Surface potential, default 0.6\";
//   constant Real modelcard.LAMBDA(quantity = \"InversePotential\", unit = \"1/V\") = 0.0 \"Channel-length modulation, default 0\";
//   constant Real modelcard.RD(quantity = \"Resistance\", unit = \"Ohm\") = -1e+40 \"Drain ohmic resistance, default 0\";
//   constant Real modelcard.RS(quantity = \"Resistance\", unit = \"Ohm\") = -1e+40 \"Source ohmic resistance, default 0\";
//   constant Real modelcard.CBD(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = -1e+40 \"Zero-bias B-D junction capacitance, default 0\";
//   constant Real modelcard.CBS(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = -1e+40 \"Zero-bias B-S junction capacitance, default 0\";
//   constant Real modelcard.IS(quantity = \"ElectricCurrent\", unit = \"A\") = 1e-14 \"Bulk junction saturation current\";
//   constant Real modelcard.PB(quantity = \"ElectricPotential\", unit = \"V\") = 0.8 \"Bulk junction potential\";
//   constant Real modelcard.CGSO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0 \"Gate-source overlap capacitance per meter channel width\";
//   constant Real modelcard.CGDO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0 \"Gate-drain overlap capacitance per meter channel width\";
//   constant Real modelcard.CGBO(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0 \"Gate-bulk overlap capacitance per meter channel width\";
//   constant Real modelcard.RSH(quantity = \"Resistance\", unit = \"Ohm\") = 0.0 \"Drain and source diffusion sheet resistance\";
//   constant Real modelcard.CJ(quantity = \"CapacitancePerArea\", unit = \"F/m2\") = 0.0 \"Zero-bias bulk junction bottom cap. per sq-meter of junction area\";
//   constant Real modelcard.MJ = 0.5 \"Bulk junction bottom grading coefficient\";
//   constant Real modelcard.CJSW(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0) = 0.0 \"Zero-bias junction sidewall cap. per meter of junction perimeter\";
//   constant Real modelcard.MJSW = 0.5 \"Bulk junction sidewall grading coefficient\";
//   constant Real modelcard.JS(quantity = \"CurrentDensity\", unit = \"A/m2\") = 0.0 \"Bulk junction saturation current per sq-meter of junction area\";
//   constant Real modelcard.TOX(quantity = \"Length\", unit = \"m\") = -1e+40 \"Oxide thickness, default 1e-7\";
//   constant Real modelcard.NSUB = -1e+40 \"Substrate doping, default 0\";
//   constant Real modelcard.NSS(quantity = \"PerArea\", unit = \"1/cm2\") = 0.0 \"Surface state density\";
//   constant Real modelcard.TPG = 1.0 \"Type of gate material: +1 opp. to substrate, -1 same as substrate, 0 Al gate\";
//   constant Real modelcard.LD(quantity = \"Length\", unit = \"m\") = 0.0 \"Lateral diffusion\";
//   constant Real modelcard.UO(quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\") = 600.0 \"Surface mobility\";
//   constant Real modelcard.KF = 0.0 \"Flicker noise coefficient\";
//   constant Real modelcard.AF = 1.0 \"Flicker noise exponent\";
//   constant Real modelcard.FC = 0.5 \"Coefficient for forward-bias depletion capacitance formula\";
//   constant Real modelcard.TNOM(quantity = \"ThermodynamicTemperature\", unit = \"degC\") = 27.0 \"Parameter measurement temperature, default 27\";
//   constant Integer modelcard.LEVEL = 1 \"Model level: Shichman-Hodges\";
//   constant Real C.EPSSIL = 1.035943139907e-10;
//   constant Real C.EPSOX = 3.453133e-11;
//   constant Real C.CHARGE(quantity = \"ElectricCharge\", unit = \"C\") = 1.6021918e-19;
//   constant Real C.CONSTCtoK(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 273.15;
//   constant Real C.CONSTboltz(quantity = \"HeatCapacity\", unit = \"J/K\") = 1.3806226e-23;
//   constant Real C.REFTEMP(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 300.15;
//   constant Real C.CONSTroot2 = 1.414213562373095;
//   constant Real C.CONSTvt0(unit = \"(J/K)/(A.s)\") = 0.02586470905512062;
//   constant Real C.CONSTKoverQ(unit = \"(J/K)/(A.s)\") = 8.61726105451295e-05;
//   constant Real C.CONSTe = 2.718281828459045;
//   constant Real C.CKTgmin(quantity = \"Conductance\", unit = \"S\") = 1e-12;
//   constant Real C.CKTnomTemp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 300.15;
//   constant Real C.CKTtemp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 300.15;
//   constant Real C.CKTdefaultMosAD(quantity = \"Area\", unit = \"m2\") = 0.0;
//   constant Real C.CKTdefaultMosAS(quantity = \"Area\", unit = \"m2\") = 0.0;
//   constant Real C.CKTdefaultMosL(quantity = \"Length\", unit = \"m\") = 0.0001;
//   constant Real C.CKTdefaultMosW(quantity = \"Length\", unit = \"m\") = 0.0001;
//   constant Real C.CKTreltol = 1e-10;
//   constant Real C.CKTabstol = 1e-15;
//   constant Real C.CKTvolttol = 1e-10;
//   constant Real C.CKTtemptol = 0.001;
//   constant Integer m_type = 1;
//   constant Boolean m_bInit = false;
//   constant Real p.m_jctSatCurDensity(start = 0.0) = 0.0 \"JS, Bulk jct. sat. current density, input - use tSatCurDens\";
//   constant Real p.m_sheetResistance(quantity = \"Resistance\", unit = \"Ohm\", start = 0.0) = 0.0 \"RSH, Sheet resistance\";
//   constant Real p.m_bulkJctPotential(start = 0.8) = 0.8 \"PB, Bulk junction potential, input - use tBulkPot\";
//   constant Real p.m_bulkJctBotGradingCoeff(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\", start = 0.5) = 0.5 \"MJ, Bottom grading coefficient\";
//   constant Real p.m_bulkJctSideGradingCoeff(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\", start = 0.5) = 0.5 \"MJSW, Side grading coefficient\";
//   constant Real p.m_oxideThickness(start = 1e-07) = 0.0 \"TOX, Oxide thickness unit: micron\";
//   constant Real p.m_oxideThicknessIsGiven = 0.0 \"TOX, IsGiven value\";
//   constant Real p.m_gateSourceOverlapCapFactor(start = 0.0) = 0.0 \"CGS0, Gate-source overlap cap\";
//   constant Real p.m_gateDrainOverlapCapFactor(start = 0.0) = 0.0 \"CGD0, Gate-drain overlap cap\";
//   constant Real p.m_gateBulkOverlapCapFactor(start = 0.0) = 0.0 \"CGB0, Gate-bulk overlap cap\";
//   constant Real p.m_fNcoef(start = 0.0) = 0.0 \"KF, Flicker noise coefficient\";
//   constant Real p.m_fNexp(start = 1.0) = 1.0 \"AF, Flicker noise exponent\";
//   constant Real p.m_mjswIsGiven = 0.0 \"MJSW, IsGivenValue\";
//   constant Real p.m_cgsoIsGiven = 0.0 \"CGSO, IsGivenValue\";
//   constant Real p.m_cgdoIsGiven = 0.0 \"CGDO, IsGivenValue\";
//   constant Real p.m_cgboIsGiven = 0.0 \"CGBO, IsGivenValue\";
//   constant Real p.m_pbIsGiven = 0.0 \"PB, IsGivenValue\";
//   constant Real p.m_oxideCapFactor(start = 0.0) = 0.0;
//   constant Real p.m_vt0(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0 \"VTO, Threshold voltage\";
//   constant Real p.m_vtOIsGiven = 0.0 \"VTO IsGivenValue\";
//   constant Real p.m_capBD(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0 \"CBD, B-D junction capacitance\";
//   constant Real p.m_capBDIsGiven = 0.0 \"CapBD IsGivenValue\";
//   constant Real p.m_capBS(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0 \"CBS, B-S junction capacitance\";
//   constant Real p.m_capBSIsGiven = 0.0 \"CapBS IsGivenValue\";
//   constant Real p.m_bulkCapFactor(quantity = \"CapacitancePerArea\", unit = \"F/m2\", start = 0.0) = 0.0 \"CJ, Bottom junction cap per area\";
//   constant Real p.m_bulkCapFactorIsGiven = 1.0 \"Bulk cap factor IsGivenValue\";
//   constant Real p.m_sideWallCapFactor(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0, start = 0.0) = 0.0 \"CJSW, Side grading coefficient\";
//   constant Real p.m_fwdCapDepCoeff(start = 0.5) = 0.5 \"FC, Forward bias junction fit parameter\";
//   constant Real p.m_phi(quantity = \"ElectricPotential\", unit = \"V\", start = 0.6) = 0.6 \"PHI, Surface potential\";
//   constant Real p.m_phiIsGiven = 0.0 \"Phi IsGivenValue\";
//   constant Real p.m_gamma(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0 \"GAMMA, Bulk threshold parameter\";
//   constant Real p.m_gammaIsGiven = 0.0 \"Gamma IsGivenValue\";
//   constant Real p.m_lambda(quantity = \"InversePotential\", unit = \"1/V\", start = 0.0) = 0.0 \"Channel-length modulation\";
//   constant Real p.m_substrateDoping(start = 0.0) = 0.0 \"NSUB, Substrate doping\";
//   constant Real p.m_substrateDopingIsGiven = 0.0 \"Substrate doping IsGivenValue\";
//   constant Real p.m_gateType(start = 1.0) = 1.0 \"TPG, Gate type\";
//   constant Real p.m_surfaceStateDensity(quantity = \"PerArea\", unit = \"1/cm2\", start = 0.0) = 0.0 \"NSS, Gate type\";
//   constant Real p.m_surfaceStateDensityIsGiven(start = 0.0) = 0.0 \"surfaceStateDensityIsGivenValue\";
//   constant Real p.m_surfaceMobility(quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\", start = 600.0) = 600.0 \"UO, Surface mobility\";
//   constant Real p.m_latDiff(quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"LD, Lateral diffusion\";
//   constant Real p.m_jctSatCur(quantity = \"ElectricCurrent\", unit = \"A\", start = 1e-14) = 1e-14 \"IS, Bulk junction sat. current\";
//   constant Real p.m_drainResistance(quantity = \"Resistance\", unit = \"Ohm\", start = 0.0) = 0.0 \"RD, Drain ohmic resistance\";
//   constant Real p.m_drainResistanceIsGiven = 0.0 \"Drain resistance IsGivenValue\";
//   constant Real p.m_sourceResistance(quantity = \"Resistance\", unit = \"Ohm\", start = 0.0) = 0.0 \"RS, Source ohmic resistance\";
//   constant Real p.m_sourceResistanceIsGiven = 0.0 \"Source resistance IsGivenValue\";
//   constant Real p.m_transconductance(quantity = \"Transconductance\", unit = \"A/V2\", start = 2e-05) = 2e-05 \"input - use tTransconductance\";
//   constant Real p.m_transconductanceIsGiven = 0.0 \"Transconductance IsGivenValue\";
//   constant Real p.m_tnom(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 300.15, nominal = 300.0) = 300.15 \"TNOM, Parameter measurement temperature\";
//   constant Real m.m_dTemp(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 300.15, nominal = 300.0) = 300.15 \"TEMP, Device Temperature\";
//   constant Real m.m_len(quantity = \"Length\", unit = \"m\", start = 0.0001) = 0.0001 \"L, length of channel region\";
//   constant Real m.m_width(quantity = \"Length\", unit = \"m\", start = 0.0001) = 0.0001 \"W, width of channel region\";
//   constant Real m.m_drainArea(quantity = \"Area\", unit = \"m2\", start = 0.0) = 0.0 \"AD, area of drain diffusion\";
//   constant Real m.m_sourceArea(quantity = \"Area\", unit = \"m2\", start = 0.0) = 0.0 \"AS, area of source diffusion\";
//   constant Real m.m_drainSquares(start = 1.0) = 1.0 \"NRD, length of drain in squares\";
//   constant Real m.m_sourceSquares(start = 1.0) = 1.0 \"NRS, length of source in squares\";
//   constant Real m.m_drainPerimeter(quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"PD, Drain perimeter\";
//   constant Real m.m_sourcePerimeter(quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"PS, Source perimeter\";
//   constant Real m.m_dICVDS(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0 \"IC_VDS, Initial D-S voltage\";
//   constant Real m.m_dICVDSIsGiven = 0.0 \"IC_VDS, IsGivenValue\";
//   constant Real m.m_dICVGS(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0 \"IC_VGS, Initial G-S voltage\";
//   constant Real m.m_dICVGSIsGiven = 0.0 \"IC_VGS, IsGivenValue\";
//   constant Real m.m_dICVBS(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0 \"IC_VBS, Initial B-S voltage\";
//   constant Real m.m_dICVBSIsGiven = 0.0 \"IC_VBS, IsGivenValue\";
//   constant Integer m.m_off(start = 0) = 0 \"Device initially off, non-zero to indicate device is off for dc analysis\";
//   constant Integer m.m_bPMOS(start = 0) = 1 \"P type MOSFET model\";
//   constant Integer m.m_nLevel(start = 1) = 1 \"MOS model level\";
//   constant Real m.m_drainPerimiter(quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"PD, Drain perimeter\";
//   constant Real m.m_sourcePerimiter(quantity = \"Length\", unit = \"m\", start = 0.0) = 0.0 \"PS, Source perimeter\";
//   constant Boolean m.m_uic = false;
//   constant Real vp.m_oxideCapFactor = 0.0;
//   constant Real vp.m_vt0(quantity = \"ElectricPotential\", unit = \"V\") = 0.0;
//   constant Real vp.m_phi(quantity = \"ElectricPotential\", unit = \"V\") = 0.6;
//   constant Real vp.m_gamma = 0.0;
//   constant Real vp.m_transconductance(quantity = \"Transconductance\", unit = \"A/V2\") = 2e-05;
//   constant Real c1.m_vds(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vds, Drain-Source voltage\";
//   constant Real c1.m_vgs(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vgs, Gate-Source voltage\";
//   constant Real c1.m_vbs(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vbs, Bulk-Source voltage\";
//   constant Real c1.m_cbs(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ibs, B-S junction current\";
//   constant Real c1.m_gbs(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gbs, Bulk-Source conductance\";
//   constant Real c1.m_cbd(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ibd, B-D junction current\";
//   constant Real c1.m_gbd(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gbd, Bulk-Drain conductance\";
//   constant Real c1.m_cdrain(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ids\";
//   constant Real c1.m_gds(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gds, Drain-Source conductance\";
//   constant Real c1.m_gm(quantity = \"Transconductance\", unit = \"A/V2\") = 0.0 \"Gm, Transconductance\";
//   constant Real c1.m_gmbs(quantity = \"Transconductance\", unit = \"A/V2\") = 0.0 \"Gmbs, Bulk-Source transconductance\";
//   constant Real c1.m_capbsb(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbsb\";
//   constant Real c1.m_chargebsb(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbsb\";
//   constant Real c1.m_capbss(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbss\";
//   constant Real c1.m_chargebss(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbss\";
//   constant Real c1.m_capbdb(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbdb\";
//   constant Real c1.m_chargebdb(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbdb\";
//   constant Real c1.m_capbds(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbds\";
//   constant Real c1.m_chargebds(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbds\";
//   constant Real c1.m_Beta = 0.0 \"Beta\";
//   constant Real c1.m_capGSovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgso, Gate-source overlap cap.\";
//   constant Real c1.m_capGDovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgdo, Gate-drain overlap cap.\";
//   constant Real c1.m_capGBovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgbo, Gate-bulk overlap cap.\";
//   constant Real c1.m_capOx(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cox\";
//   constant Real c1.m_von(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Von, Turn-on voltage\";
//   constant Real c1.m_vdsat(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vdsat\";
//   constant Integer c1.m_mode(start = 1) = 1 \"Mode\";
//   constant Real c1.m_lEff(quantity = \"Length\", unit = \"m\") = 0.0001;
//   constant Real c1.m_sourceResistance(quantity = \"Resistance\", unit = \"Ohm\") = 0.0 \"Rs\";
//   constant Real c1.m_drainResistance(quantity = \"Resistance\", unit = \"Ohm\") = 0.0 \"Rd\";
//   constant Real c1.m_tTransconductance(quantity = \"Transconductance\", unit = \"A/V2\", start = 0.0) = 0.0;
//   constant Real c1.m_tSurfMob(quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\", start = 0.0) = 0.0;
//   constant Real c1.m_tPhi(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7;
//   constant Real c1.m_tVto(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = 1.0;
//   constant Real c1.m_tSatCurDens(quantity = \"CurrentDensity\", unit = \"A/m2\", start = 0.0) = 0.0;
//   constant Real c1.m_tDrainSatCur(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 0.0;
//   constant Real c1.m_tSourceSatCur(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 0.0;
//   constant Real c1.m_tCBDb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_tCBDs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_tCBSb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_tCBSs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_tCj(quantity = \"CapacitancePerArea\", unit = \"F/m2\", start = 0.0) = 0.0;
//   constant Real c1.m_tCjsw(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_tBulkPot(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7;
//   constant Real c1.m_tDepCap(quantity = \"ElectricPotential\", unit = \"V\", start = 0.35) = 0.35;
//   constant Real c1.m_tVbi(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = 1.0;
//   constant Real c1.m_VBScrit(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7;
//   constant Real c1.m_VBDcrit(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7;
//   constant Real c1.m_f1b(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0;
//   constant Real c1.m_f2b(start = 0.0) = 0.0;
//   constant Real c1.m_f3b(start = 0.0) = 0.0;
//   constant Real c1.m_f1s(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0;
//   constant Real c1.m_f2s(start = 0.0) = 0.0;
//   constant Real c1.m_f3s(start = 0.0) = 0.0;
//   constant Real c1.m_dVt(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.0;
//   constant Real c1.m_capgd(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_capgs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_capgb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c1.m_qgs(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real c1.m_qgd(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real c1.m_qgb(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real c2.m_vds(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vds, Drain-Source voltage\";
//   constant Real c2.m_vgs(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vgs, Gate-Source voltage\";
//   constant Real c2.m_vbs(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vbs, Bulk-Source voltage\";
//   constant Real c2.m_cbs(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ibs, B-S junction current\";
//   constant Real c2.m_gbs(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gbs, Bulk-Source conductance\";
//   constant Real c2.m_cbd(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ibd, B-D junction current\";
//   constant Real c2.m_gbd(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gbd, Bulk-Drain conductance\";
//   constant Real c2.m_cdrain(quantity = \"ElectricCurrent\", unit = \"A\") = 0.0 \"Ids\";
//   constant Real c2.m_gds(quantity = \"Conductance\", unit = \"S\") = 0.0 \"Gds, Drain-Source conductance\";
//   constant Real c2.m_gm(quantity = \"Transconductance\", unit = \"A/V2\") = 0.0 \"Gm, Transconductance\";
//   constant Real c2.m_gmbs(quantity = \"Transconductance\", unit = \"A/V2\") = 0.0 \"Gmbs, Bulk-Source transconductance\";
//   constant Real c2.m_capbsb(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbsb\";
//   constant Real c2.m_chargebsb(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbsb\";
//   constant Real c2.m_capbss(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbss\";
//   constant Real c2.m_chargebss(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbss\";
//   constant Real c2.m_capbdb(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbdb\";
//   constant Real c2.m_chargebdb(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbdb\";
//   constant Real c2.m_capbds(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cbds\";
//   constant Real c2.m_chargebds(quantity = \"ElectricCharge\", unit = \"C\") = 0.0 \"Qbds\";
//   constant Real c2.m_Beta = 2e-05 \"Beta\";
//   constant Real c2.m_capGSovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgso, Gate-source overlap cap.\";
//   constant Real c2.m_capGDovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgdo, Gate-drain overlap cap.\";
//   constant Real c2.m_capGBovl(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cgbo, Gate-bulk overlap cap.\";
//   constant Real c2.m_capOx(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0 \"Cox\";
//   constant Real c2.m_von(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Von, Turn-on voltage\";
//   constant Real c2.m_vdsat(quantity = \"ElectricPotential\", unit = \"V\") = 0.0 \"Vdsat\";
//   constant Integer c2.m_mode(start = 1) = 1 \"Mode\";
//   constant Real c2.m_lEff(quantity = \"Length\", unit = \"m\") = 0.0001;
//   constant Real c2.m_sourceResistance(quantity = \"Resistance\", unit = \"Ohm\") = 0.0 \"Rs\";
//   constant Real c2.m_drainResistance(quantity = \"Resistance\", unit = \"Ohm\") = 0.0 \"Rd\";
//   constant Real c2.m_tTransconductance(quantity = \"Transconductance\", unit = \"A/V2\", start = 0.0) = 2e-05;
//   constant Real c2.m_tSurfMob(quantity = \"AreaPerVoltageSecond\", unit = \"cm2/(V.s)\", start = 0.0) = 600.0;
//   constant Real c2.m_tPhi(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.6;
//   constant Real c2.m_tVto(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = 0.0;
//   constant Real c2.m_tSatCurDens(quantity = \"CurrentDensity\", unit = \"A/m2\", start = 0.0) = 0.0;
//   constant Real c2.m_tDrainSatCur(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 1e-14;
//   constant Real c2.m_tSourceSatCur(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 1e-14;
//   constant Real c2.m_tCBDb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_tCBDs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_tCBSb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_tCBSs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_tCj(quantity = \"CapacitancePerArea\", unit = \"F/m2\", start = 0.0) = 0.0;
//   constant Real c2.m_tCjsw(quantity = \"Permittivity\", unit = \"F/m\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_tBulkPot(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.8;
//   constant Real c2.m_tDepCap(quantity = \"ElectricPotential\", unit = \"V\", start = 0.35) = 0.4;
//   constant Real c2.m_tVbi(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = 0.0;
//   constant Real c2.m_VBScrit(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7302833841653967;
//   constant Real c2.m_VBDcrit(quantity = \"ElectricPotential\", unit = \"V\", start = 0.7) = 0.7302833841653967;
//   constant Real c2.m_f1b(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.4686291501015239;
//   constant Real c2.m_f2b(start = 0.0) = 0.3535533905932738;
//   constant Real c2.m_f3b(start = 0.0) = 0.25;
//   constant Real c2.m_f1s(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.4686291501015239;
//   constant Real c2.m_f2s(start = 0.0) = 0.3535533905932738;
//   constant Real c2.m_f3s(start = 0.0) = 0.25;
//   constant Real c2.m_dVt(quantity = \"ElectricPotential\", unit = \"V\", start = 0.0) = 0.02586470905512062;
//   constant Real c2.m_capgd(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_capgs(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_capgb(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real c2.m_qgs(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real c2.m_qgd(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real c2.m_qgb(quantity = \"ElectricCharge\", unit = \"C\", start = 0.0) = 0.0;
//   constant Real cc.idrain(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 0.0;
//   constant Real cc.iBD(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 0.0;
//   constant Real cc.iBS(quantity = \"ElectricCurrent\", unit = \"A\", start = 0.0) = 0.0;
//   constant Real cc.cGS(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real cc.cGB(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real cc.cGD(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real cc.cBS(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real cc.cBD(quantity = \"Capacitance\", unit = \"F\", min = 0.0, start = 0.0) = 0.0;
//   constant Real cc.m_capgd(quantity = \"Capacitance\", unit = \"F\", min = 0.0) = 0.0;
// end A;
// "
// ""
// record SimulationResult
//     resultFile = "A_res.mat",
//     simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 500, tolerance = 1e-06, method = 'dassl', fileNamePrefix = 'A', options = '', outputFormat = 'mat', variableFilter = '.*', cflags = '', simflags = ''",
//     messages = "LOG_SUCCESS       | info    | The initialization finished successfully without homotopy method.
// LOG_SUCCESS       | info    | The simulation finished successfully.
// "
// end SimulationResult;
// ""
// endResult
