(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 types.rml
 ** module:      Types
 ** description: Type system
 **
 ** RCS: $Id$
 **
 ** This file defines the type system.  It contains an RML type
 ** called `Type' which defines types.  It also contains relations for
 ** determining subtyping etc.
 **
 ** There are a few known problems with this module.  It currently
 ** depends on `SCode.Attributes', which in turn depends on
 ** `Absyn.ArrayDim'.  However, the only things used from those
 ** modules are constants that could be moved to their own modules.
 **)

module Types :

  with "classinf.rml"
  with "absyn.rml"
  with "exp.rml"
  with "values.rml"
  with "explode.rml"

  (** - Identifiers *)
  type Ident = string

  (** - Variables *)
  datatype Var = VAR of Ident			  (* name *)
		      * Attributes		  (* attributes *)
		      * bool	                  (* protected *)
		      * Type			  (* type *)
		      * Binding			  (* equation modification *)

  datatype Attributes = ATTR of bool	(* flow *)
			      * SCode.Accessibility
	  		      * SCode.Variability	(* parameter *)
			      * Absyn.Direction

  datatype Binding = UNBOUND
		   | EQBOUND of Exp.Exp * bool (* LS: bool for constant? *)
		   | VALBOUND of Values.Value

  (** - Types *)
  type Type = (TType * Absyn.Path option)

  datatype TType = T_INTEGER of Var list
		| T_REAL of Var list
		| T_STRING of Var list
		| T_BOOL of Var list
		| T_ENUM 
		| T_ENUMERATION of string list * Var list
		| T_ARRAY of ArrayDim * Type
		| T_COMPLEX of ClassInf.State
			     * Var list
		| T_FUNCTION of FuncArg list 
			     * Type (* Only single-result *)
		| T_TUPLE of Type list (*PR. Used by functions who return multiple values. *)
		| T_NOTYPE


  datatype ArrayDim = DIM of int option

  type FuncArg = Ident * Type


  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
  datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Type * (* type *)
				 bool (* if the type is a tuple, each element 
				          have a const flag. *)

(* Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Type * Const (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)

  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)


  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `Type' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)


  (** - Modification datatype, was originally in Mod *)

  datatype EqMod = TYPED of Exp.Exp * Properties |
		   UNTYPED of Absyn.Exp
  datatype SubMod = NAMEMOD of Ident * Mod
		  | IDXMOD of int list * Mod
  and Mod = MOD of bool * (SubMod list) * EqMod option
  	  | REDECL of bool * (SCode.Element*Mod) list
	  | NOMOD


  (** - Exported relations *)
  relation basic_type : Type => bool
  relation equivtypes : (Type, Type) => bool
  relation subtype : (Type, Type) => bool
  relation lookup_component : (Type, Ident) => Var
  relation lift_array : (Type,int option) => Type
  relation unlift_array : Type => Type
  relation make_array: (Type, Absyn.ArrayDim) => Type
  relation array_element_type : Type => Type
  relation print_type : Type => ()
  relation print_prop : Properties => ()
  relation unparse_type : Type => string
  relation print_var : Var => ()
  relation print_binding : Binding => ()
  relation print_binding_str : Binding => string
  relation print_params : FuncArg list => () 
  relation print_farg: FuncArg => () 
  relation make_function_type : (Absyn.Path, Var list) => Type
  relation make_enumeration_type: (Absyn.Path, Var list) => Type 
  relation is_parameter: Var => ()
  relation contain_real: Type list => bool
  relation dimensions_known: Type => bool 
	 
  relation get_vars: (Var list, Var => () )  => Var list
  relation get_classname: (Type) => Absyn.Path
  relation get_type_name: Type => string
  relation is_array : Type => bool
  relation is_string : Type => bool
  relation is_array_or_string : Type => bool
  relation is_input_attr : Attributes => bool
  relation is_output_attr : Attributes => bool
  relation is_bidir_attr : Attributes => bool
  relation ndims : Type => int
  relation get_dimension_sizes: Type => int list
  relation type_of_value: (Values.Value) => Type

  relation values_to_mods: (Values.Value list,string list) => Mod
	  
  relation is_prop_const : Properties => bool
  relation get_prop_type : Properties => Type
  relation is_prop_array : Properties => bool

  relation elab_type : Type => Exp.Type
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation match_type_list : (Exp.Exp, Type list, Type list) => (Exp.Exp, Type list) 
  relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) 
  relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list 
  relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) => Properties 

  relation flatten_array_type : Type => (Type, int list)

end


with "dump.rml"
with "debug.rml"
with "print.rml"
with "util.rml"

relation is_array : Type => bool =

  axiom	is_array((T_ARRAY(_,_),_)) => true
  axiom	is_array((_,_)) => false

end

relation is_string : Type => bool =

  axiom	is_string ((T_STRING(_),_)) => true
  axiom	is_string ((_,_)) => false

end

relation is_array_or_string : Type => bool =

  rule	is_array ty => true
	-------------------
	is_array_or_string ty => true

  rule	is_string ty => true
	-------------------
	is_array_or_string ty => true

  axiom	is_array_or_string _ => false

end

relation ndims : Type => int =

  rule	ndims t => n &
	int_add(n,1) => n'
	---
	ndims( (T_ARRAY(_,t),_) ) => n'

  axiom ndims( (_,_) ) => 0

end
relation dimensions_known: Type => bool =
	
  rule	not get_dimension_sizes(tp) => _
	-----------------------
	dimensions_known(tp) => false

  rule	get_dimension_sizes(tp) => _
	-----------------------
	dimensions_known(tp) => true
end

relation get_dimension_sizes: Type => int list =

  rule	get_dimension_sizes(tp) => res
	----------------
	get_dimension_sizes((T_ARRAY(DIM(SOME(i)),tp),_)) => i::res

(*  rule	get_dimension_sizes(tp) => res
	------------------------------
	get_dimension_sizes((T_ARRAY(DIM(NONE),tp),_)) => -1::res *)

  axiom	get_dimension_sizes((_,_)) => []

end

(* This relation takes a list of values and convert into a Modification.
 Used for record construction evaluation. PersonRecord("name",45) has a value list 
 { "name",45 } that needs to be converted into a modifier for the record class
 PersonRecord ("name,45)
*)
relation values_to_mods: (Values.Value list,Ident list) => Mod =

  axiom	values_to_mods([],_) => MOD(false,[],NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.INTEGER(i)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.ICONST(i),PROP((T_INTEGER([]),NONE),false)))))::res,NONE)

  rule	values_to_mods(rest,ids) => MOD(_,res,_)
	---------------------------------------
	values_to_mods(Values.REAL(r)::rest,id::ids) 
	  => MOD(false,NAMEMOD(id,MOD(false,[],SOME(TYPED(Exp.RCONST(r),PROP((T_REAL([]),NONE),false)))))::res,NONE)

end

relation type_of_value: (Values.Value) => Type =

  axiom	type_of_value(Values.INTEGER(_)) => ((T_INTEGER([]),NONE))
  axiom	type_of_value(Values.REAL(_)) => ((T_REAL([]),NONE))
  axiom	type_of_value(Values.STRING(_)) => ((T_STRING([]),NONE))
  axiom	type_of_value(Values.BOOL(_)) => ((T_BOOL([]),NONE))

  rule	type_of_value(v) => (tp as(T_ARRAY(_,_),_)) &
	list_length(v::vs) => dim1 
	--------------------
	type_of_value(w as Values.ARRAY(v::vs)) 
	  => ((T_ARRAY(DIM(SOME(dim1)),tp),NONE))

  rule	type_of_value(v) => tp &
	list_length(v::vs) => dim1 
	--------------------
	type_of_value(w as Values.ARRAY(v::vs)) 
	  => ((T_ARRAY(DIM(SOME(dim1)),tp),NONE))
end


(** relation: basic_type
 **
 ** Test whether a type is one of the builtin types.
 **)

relation basic_type : Type => bool =

  axiom	basic_type( (T_INTEGER(_),_) ) => true
  axiom	basic_type( (T_REAL(_),_) ) => true
  axiom	basic_type( (T_STRING(_),_) ) => true
  axiom	basic_type( (T_BOOL(_),_) ) => true
  axiom	basic_type( (T_ENUM,_) ) => true
  axiom	basic_type( (T_ARRAY(_,_),_) ) => false
  axiom	basic_type( (T_COMPLEX(_,_),_) ) => false
  axiom	basic_type( (T_ENUMERATION(_,_),_) ) => false
end

(** relation: equivtypes
 **
 ** This is the type equivalence relation.  It is defined in terms of
 ** the subtype relation.  Two types are considered equivalent if they
 ** are subtypes of each other.
 **)

relation equivtypes : (Type, Type) => bool =

  rule	subtype(t1, t2) => true &
	subtype(t2, t1) => true
	-----------------------
	equivtypes(t1, t2) => true

	(* default *)
  axiom	equivtypes(t1, t2) => false

end

(** relation: subtype
 **
 ** Is the first type a subtype of the second type?  This relation
 ** specifies the rules for subtyping in Modelica.
 **)

relation subtype : (Type, Type) => bool =
	
  axiom	subtype ( (T_INTEGER(_),_),(T_INTEGER(_),_)) => true
  axiom	subtype ((T_REAL(_),_),(T_REAL(_),_))       => true
  axiom	subtype ((T_STRING(_),_),(T_STRING(_),_))   => true
  axiom	subtype ((T_BOOL(_),_),(T_BOOL(_),_))       => true
  axiom	subtype ((T_ENUM,_),(T_ENUM,_))	      => true

  rule	l2 = l1 &
	subtype((T_ENUMERATION(rest1,vl1),p1),(T_ENUMERATION(rest2,vl2),p2))=> res
	----------------------------------------------------------
	subtype ((T_ENUMERATION(l1::rest1,vl1),p1),(T_ENUMERATION(l2::rest2,vl2),p2))
	  => res

  axiom	subtype ((T_ENUMERATION([],_),_),(T_ENUMERATION(_,_),_))=> true
	
  rule	subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(_,t1),_),(T_ARRAY(DIM(NONE),t2),_)) => true
	
  rule	subtype (t1,t2) => true
	-----------------------
	subtype((T_ARRAY(DIM(NONE),t1),_),(T_ARRAY(_,t2),_)) => true
	
  rule	i1 = i2 &
 	subtype (t1,t2) => true
	---------------------------------------------------------
	subtype((T_ARRAY(DIM(SOME(i1)),t1),_),(T_ARRAY(DIM(SOME(i2)),t2),_)) => true
	
  rule	subtype_varlist(els1, els2) => true
	-----------------------------------
	subtype((T_COMPLEX(st1,els1),_), (T_COMPLEX(st2,els2),_)) => true

	(* PR. Check of tuples, similar to complex. Just that
	 identifier name do not have to be checked. Only types are
	 checked. *)
  rule	subtype_typelist(type_list1,type_list2) => true
	-----------------------------------
	subtype((T_TUPLE(type_list1),_), (T_TUPLE(type_list2),_)) => true

  axiom subtype(t1,t2) => false

(* What? If not subtye should return false. Doesn't mean no matching rule

  rule	Debug.fprint ("tytr", "subtype: no matching subtype rule.\n") &
	Debug.fcall ("tytr", print_type, t1) &
	Debug.fprint ("tytr", " <> ") &
	Debug.fcall ("tytr", print_type, t2) &
	Debug.fprint ("tytr", "\n")
	-----------------------------------
	subtype(t1,t2) => false
*)

end


(** PR. relation: subtype_typelist
 **
 ** This relation checks if the both `Type' lists matches types, element
 ** by element.
 **)

relation subtype_typelist: (Type list,Type list) => bool =

  axiom	subtype_typelist ([], []) => true

  rule	subtype(t1,t2) => true &
	subtype_typelist(rest1,rest2) => true		
	-----------------------------
	subtype_typelist(t1::rest1,t2::rest2) => true

	(* default *)
  axiom	subtype_typelist(_,_) => false


end

(** relation: subtype_varlist
 **
 ** This relation checks if the `Var' list in the first list is a
 ** subset of the list in the second argument.  More precisely, it
 ** checks if, for each `Var' in the second list there is a `Var' in
 ** the first list with a type that is a subtype of the `Var' in the
 ** second list.
 **)

relation subtype_varlist : (Var list, Var list) => bool =

  axiom	subtype_varlist(_, []) => true

  rule	varlist_lookup(l,n) => VAR(_,_,_,t1,_) &
	subtype(t1,t2) => true &
	subtype_varlist(l,vs) => true
	-----------------------------
	subtype_varlist(l, VAR(n,_,_,t2,_)::vs) => true

	(* default *)
  axiom	subtype_varlist(_,_) => false

end

(** relation: varlist_lookup
 **
 ** Given a list of `Var' and a name, this relation finds any `Var'
 ** with the given name.
 **)

relation varlist_lookup : (Var list, Ident) => Var =

  rule	n = name
	--------
	varlist_lookup((v as VAR(n,_,_,_,_))::_, name) => v

  rule	varlist_lookup(vs, name) => v
	-----------------------------
	varlist_lookup(v::vs, name) => v

end

(** relation: lookup_component
 **
 ** This relation finds a subcomponent by name.
 **)

relation lookup_component : (Type, Ident) => Var =
	
  rule	basic_type(t) => true &
	lookup_in_builtin(t,n) => v
	-------------------------
	lookup_component(t,n) => v

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component((T_COMPLEX(st,cs),_), id) => v

  rule	lookup_component2(cs,id) => VAR(n,attr,prot,ty,bnd) &
	let ty' = ((T_ARRAY(dim,ty),NONE))
	-----------------------------
	lookup_component((T_ARRAY(dim,(T_COMPLEX(st,cs),_)),_), id) 
	  => VAR(n,attr,prot,ty',bnd)

  rule	Print.print_buf "- Looking up " &
	Print.print_buf id &
	Print.print_buf " in noncomplex type\n"
	-----------------------------------------
	lookup_component(_, id) => fail

end

(** relation: lookup_in_builtin
 **
 ** Since builtin types are not represented as T_COMPLEX, special care
 ** is needed to be able to lookup the attributes (`start' etc) in
 ** them.
 **
 ** This is not a complete solution.  The current way of mapping the
 ** both the Modelica type `Real' and the simple type `RealType' to
 ** `T_REAL' is a bit problematic, since it doesn't make a
 ** difference between `Real' and `RealType', which makes the
 ** translator accept things like `x.start.start.start'.
 **)

relation lookup_in_builtin : (Type,Ident) => Var =
(* PA: covers Modelica 2.0 spec.*)
	(* Real *)	
  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_REAL(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_INTEGER(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_STRING(cs),_),id) => v

  rule	lookup_component2(cs, id) => v
	-------------------------------
	lookup_in_builtin((T_BOOL(cs),_),id) => v

(*	
  axiom	lookup_in_builtin(T_REAL,"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"unit")
	  => VAR("unit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"displayUnit")
	  => VAR("displayUnit",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_STRING, VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin(T_REAL,"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, UNBOUND)

  axiom	lookup_in_builtin(T_REAL,"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_REAL, VALBOUND(Values.REAL(0.0)))

  axiom	lookup_in_builtin(T_REAL,"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, T_BOOL, UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_REAL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

  axiom	lookup_in_builtin((T_REAL(_),_),"nominal")
	  => VAR("nominal",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_REAL(_),_),"stateSelect")
	  => VAR("stateSelect",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUMERATION(["never","avoid","default","prefer","always"]),NONE),
		 VALBOUND(Values.ENUM("default")))
		 (* optimized away looking up the builtin enumeration type 'stateSelect' *)

	(* Integer *)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_INTEGER([]),NONE), UNBOUND)

  axiom	lookup_in_builtin((T_INTEGER(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_REAL([]),NONE), VALBOUND(Values.INTEGER(0)))

  axiom	lookup_in_builtin((T_INTEGER(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_INTEGER(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* Boolean *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(false)))

  axiom	lookup_in_builtin((T_BOOL(_),_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))

	(* String *)
  axiom	lookup_in_builtin((T_BOOL(_),_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE), VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_BOOL(_),_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))
*)
	(* Enumeration ( type E in spec) *)
  axiom	lookup_in_builtin((T_ENUM,_),"quantity")
	  => VAR("quantity",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_STRING([]),NONE),VALBOUND(Values.STRING("")))

  axiom	lookup_in_builtin((T_ENUM,_),"min")
	  => VAR("min",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the first element of
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"max")
	  => VAR("max",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_ENUM,NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)
  axiom	lookup_in_builtin((T_ENUM,_),"start")
	  => VAR("start",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Should be bound to the last element of 
					  T_ENUMERATION list higher up in the call chain *)

  axiom	lookup_in_builtin((T_ENUM,_),"fixed")
	  => VAR("fixed",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), UNBOUND) (* Needs to be set to true/false higher up the call chain
					  depending on variability of instance*)
  axiom	lookup_in_builtin((T_ENUM,_),"enable")
	  => VAR("enable",
		 ATTR(false, SCode.RW, SCode.PARAM, Absyn.BIDIR),
		 false, (T_BOOL([]),NONE), VALBOUND(Values.BOOL(true)))		 
end

(** relation: lookup_component2
 **
 ** This relation finds a named `Var' in a list of `Var's, comparing
 ** the name against the second argument to this relation.
 **)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: make_array
 **  This relation makes an array type given a Type and an Absyn.ArrayDim
 **)
relation make_array: (Type, Absyn.ArrayDim) => Type =
  axiom	 make_array(t,[]) => t

  rule	list_length(l) => len
	--------------------
	make_array(t,l) => ((T_ARRAY(DIM(SOME(len)),t),NONE))
end

(** relation: lift_array
 **
 ** This relation turns a type into an array of that type.  If the
 ** type already is an array, aonther dimension is simply added.
 **)

relation lift_array : (Type,int option) => Type =

  rule	(*print("\nDebug: lifts the array.") 
*)	-------------------
	lift_array (ty,i) => ((T_ARRAY(DIM(i),ty),NONE))
(* PR  axiom	lift_array (ty,i) => T_ARRAY(DIM(i),ty) *)

end

(** relation: unlift_array
 **
 ** This relation turns an array of a type into that type.
 **)

relation unlift_array : Type => Type =

  axiom	unlift_array((T_ARRAY(DIM(_),ty),_)) => ty

end

(** relation: array_element_type
 **
 ** This relation turns an array into the element type
 ** of the array.
 **)

relation array_element_type : Type => Type =

  rule	array_element_type(ty) => ty'
	------------------------------
	array_element_type( (T_ARRAY(DIM(_),ty),_)) => ty'

  axiom	array_element_type t => t

end

(** relation: unparse_type
 **
 ** This relation prints a Modelica type as a piece of Modelica code.
**)
relation unparse_type: Type => string =

  axiom	unparse_type((T_INTEGER(_),_)) =>  "Integer"
  axiom	unparse_type((T_REAL(_),_)) =>  "Real"
  axiom	unparse_type((T_STRING(_),_)) =>  "String"
  axiom	unparse_type((T_BOOL(_),_)) =>  "Boolean"

  rule	Util.string_delimit_list(l,",") => s1 &
	Util.string_append_list(["enumeration(",s1,")"]) => str
	-----------------
	unparse_type((T_ENUMERATION(l,_),_)) =>  str

  rule  flatten_array_type t => (ty, dimlst) &
	Util.list_map(dimlst,int_string) => dimlststr &
	list_reverse(dimlststr) => dimlststr' &
	unparse_type ty => tys &
	Util.string_delimit_list(dimlststr',", ") => dims &
	Util.string_append_list([tys,"[",dims,"]"]) => res
	--------------------
	unparse_type(t as (T_ARRAY(_,_),_) ) => res

  rule	Util.list_map(vs,unparse_var) => vars &
	Util.string_append_list(vars) => vstr &
	Util.string_append_list(["record ",name,"\n",vstr,"end record;"]) => res
	---------------------------
	unparse_type((t as T_COMPLEX(ClassInf.RECORD(name),vs),_))=> res

  rule	ClassInf.get_state_name(ci_state) => res
	--------------------------------------
	unparse_type((T_COMPLEX(ci_state,vs),_)) => res

  axiom	unparse_type(_) => "not implemented yet\n" 
end	

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `composite'.  The actual code is expluded from the report.
 **)

(*!ignorecode*)

relation print_type : Type => () =

  rule	Print.print_buf "Integer" 
	---------------
	print_type((T_INTEGER(_),_))

  rule	Print.print_buf "Real" 
	------------
	print_type((T_REAL(_),_))

  rule	Print.print_buf "String"
	--------------
	print_type((T_STRING(_),_))

  rule	Print.print_buf "Boolean" 
	---------------
	print_type((T_BOOL(_),_))

  rule	Print.print_buf "EnumType" 
	---------------
	print_type((T_ENUM,_))

  rule	Print.print_buf "enumeration(" &
	Dump.print_list(l,print, ", ") &
	Print.print_buf ") "  
	---------------------
	print_type((T_ENUMERATION(l,_),_))

  rule	Print.print_buf "composite(" &
	Print.print_buf ", (" &
	ClassInf.print_state(st) &
	Print.print_buf ", (" &
	Dump.print_list(vars, print_var, ", ") &
	Print.print_buf ")" 
	-----------------
	print_type((T_COMPLEX(st,vars),_))

  rule	Print.print_buf "array[" & print_arraydim dim & Print.print_buf "] of " &
	print_type t & Print.print_buf ")" 
	------------
	print_type((T_ARRAY(dim,t),_))

  rule	Print.print_buf "function(" & print_params params & Print.print_buf " => " &
	print_type restype &  Print.print_buf ")"
	------------------------------
	print_type((T_FUNCTION(params,restype),_))

  rule	Print.print_buf "(" & 
	Dump.print_list(tys, print_type, ", ") &
	Print.print_buf ")"  
	---------
	print_type((T_TUPLE(tys),_))

  rule	Print.print_buf "#NOTYPE#"
	----------------
	print_type((T_NOTYPE,_))

  rule	Print.print_buf "print_type failed!\n"
	---------------------------
	print_type( (_,_) )

end

relation print_arraydim: ArrayDim => () =

  rule	get_arraydim_str ad => s &
	Print.print_buf s
	-------
	print_arraydim ad

end


relation get_arraydim_str: ArrayDim => string =

  axiom	get_arraydim_str DIM(NONE) => ":"

  rule	int_string i => s
	---------------------------
	get_arraydim_str DIM(SOME(i)) => s

  axiom	get_arraydim_str _ =>  "#STRANGE#"

end


relation print_params : FuncArg list => () =

  axiom	print_params []

  rule	Print.print_buf n & Print.print_buf " :: " & print_type t
	-------------------------------------
	print_params [(n,t)]

  rule	Print.print_buf n & Print.print_buf " :: " & print_type t &
	Print.print_buf " * " & print_params params
	---------------------------------
	print_params ((n,t)::params)

end

(*!includecode*)

relation unparse_var: Var => string =

  rule	unparse_type typ => t &
	Util.string_append_list([t," ",n,";\n"]) => res
	----------------------------
	unparse_var VAR(n, attr, prot, typ, bind) => res
end

(* LS *)
relation print_var : Var => () =

  rule	print_type typ & Print.print_buf " " &
	Print.print_buf n & Print.print_buf " " & 
	print_binding bind 
	-------
	print_var VAR(n, attr, prot, typ, bind)

end

(* LS *)
relation print_binding : Binding => () =

  rule	Print.print_buf "UNBOUND"
	---------------
	print_binding UNBOUND

  rule	Print.print_buf "EQBOUND: " &
	Exp.print_exp exp &
	Dump.print_select (f, " true", " false")
	----------------------------------------
	print_binding EQBOUND (exp,f)

  rule	Print.print_buf "VALBOUND: " &
	Values.print_val v
	--------------------
	print_binding VALBOUND (v)

end

relation print_binding_str : Binding => string =

  axiom	print_binding_str UNBOUND => "UNBOUND" 

  rule	Exp.print_exp_str exp => str &
	Dump.select_string (f, " true", " false") => str2 &
	Util.string_append_list(["EQBOUND(", str, ", ",str2, ")"]) => res
	----------------------------------------
	print_binding_str EQBOUND (exp,f) => res

  rule	Values.unparse_values [v] => s &
	Util.string_append_list(["VALBOUND(",s,")"]) => res
	--------------------
	print_binding_str VALBOUND (v) => res

end

(* LS *)
relation make_function_type: (Absyn.Path, Var list) => Type =

  rule	get_input_vars vl => invl &
	get_output_vars vl => outvl &
	make_fargs_list invl => fargs &
	make_return_type outvl => rettype 

(*	& Debug.fprint ("ft", " <fargs: ") & 
	Debug.fprint_list ("ft", fargs, print_farg, ", ") &
	Debug.fprint ("ft", " >") &

	Debug.fprint ("ft", " <rettype: ") & 
	Debug.fcall ("ft", print_type, rettype) &
	Debug.fprint ("ft", " >")
*)
	---------------------------------
	make_function_type(p,vl) => ((T_FUNCTION(fargs, rettype),SOME(p)))

end

relation make_enumeration_type: (Absyn.Path, Var list) => Type =

  rule	make_enumeration_type(p,xs) => ((T_ENUMERATION(strs,[]),_))
	---------------------------------
	make_enumeration_type (p,VAR(name,_,_,_,_)::xs) 
	  => ((T_ENUMERATION(name::strs,[]),SOME(p)))

  axiom	make_enumeration_type(p,[]) => ((T_ENUMERATION([],[]),SOME(p)))
end

relation print_farg: FuncArg => () =

  rule	print_type ty & Print.print_buf " " & Print.print_buf n
	-----------------------------------
	print_farg ((n,ty))

end

(* LS *)
relation get_input_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(* LS *)
relation get_output_vars: Var list  => Var list =
	
  rule	get_vars(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end


relation get_classname: (Type) => Absyn.Path =

  axiom	get_classname((_,SOME(p))) => p

end

(* LS *)
relation get_vars: (Var list, Var => () )  => Var list =

  axiom	get_vars ([],_) => []

  rule	cond(v) &
	get_vars (vl, cond) => vl'
	-------------------
	get_vars (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_vars (vl, cond) => vl'
	--------------------------
	get_vars (v::vl, cond) => vl'

end	


(* LS *)
relation is_input_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_input_attr attr => true
	--------------------------
	is_input_var VAR(n, attr, false, ty, bnd)

end

relation is_output_var: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  rule	is_output_attr attr => true
	---------------------------
	is_output_var VAR(n, attr, false, ty, bnd)

end

relation is_input_attr : Attributes => bool =

  axiom	is_input_attr ATTR(_,_,_,Absyn.INPUT) => true

end

relation is_output_attr : Attributes => bool =

  axiom	is_output_attr ATTR(_,_,_,Absyn.OUTPUT) => true

end

relation is_bidir_attr : Attributes => bool =

  axiom	is_bidir_attr ATTR(_,_,_,Absyn.BIDIR) => true

end

(* LS *)
relation make_fargs_list: Var list => FuncArg list =

  axiom	make_fargs_list [] => []

  rule	(*is_input_var v &*)
	make_fargs_list vl => fargl
	------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd) :: vl) => ((n,ty)::fargl)

  rule	Print.print_buf "#-- Not an input var:" & Print.print_buf n
	---------------------------------------
	make_fargs_list (VAR(n,attr,pr,ty,bnd)::vl) => fail

end

(* LS *)
relation make_return_type: Var list => Type =

  axiom	make_return_type [] => ((T_NOTYPE,NONE))

  rule	make_return_type_single var => ty
	---------------------------------
	make_return_type [var] => ty

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type vl => ((T_TUPLE(tys),NONE))

end

(* LS *)
relation make_return_type_single: Var => Type =

  axiom	make_return_type_single VAR(n,attr,pr,ty,bnd) => ty

end

(* LS *)
relation make_return_type_tuple: (Var list) => Type list =

  axiom	make_return_type_tuple [] => []

  rule	make_return_type_tuple vl => tys
	--------------------------------
	make_return_type_tuple VAR(n,attr,pr,ty,bnd)::vl => ty::tys

end

(* LS *)
relation is_parameter: Var => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(n, ATTR(fl, ac, SCode.PARAM, dir), false, ty, bnd)

end

(* Returns true if a buitlin type, or array-type is Real *)
relation contain_real: Type list => bool =

  rule	contain_real([tp]) => r1 &
	contain_real(xs) => r2 &
	bool_or(r1,r2) => res 
	---------------
	contain_real ((T_ARRAY(d,tp),_)::xs) => res 

  axiom	contain_real ((T_REAL(_),_)::_) => true

  rule	contain_real(xs) => res
	--------------
	contain_real(_::xs) => res

  axiom	contain_real(_)=> false
end

relation flatten_array_type : Type => (Type, int list) =

  rule	flatten_array_type ty => (ty', dimlist')
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(NONE),ty), _)) => (ty', dimlist')

  rule	flatten_array_type ty => (ty', dimlist) &
	list_append (dimlist,[dim]) => dimlist'
	--------------------------------------
  	flatten_array_type((T_ARRAY(DIM(SOME(dim)), ty),_)) => (ty', dimlist')

  axiom	flatten_array_type ty => (ty, [])

end

relation get_type_name: Type => string =

  axiom	get_type_name((T_INTEGER(_),_))=> "Integer"
  axiom	get_type_name((T_REAL(_),_))	=> "Real"
  axiom	get_type_name((T_STRING(_),_))=> "String"
  axiom	get_type_name((T_BOOL(_),_))	=> "Boolean"

  rule	ClassInf.get_state_name st => n
	-------------------------------
	get_type_name((T_COMPLEX(st, _),_)) => n

  rule	flatten_array_type arrayty => (ty, dims) &
	Util.list_map(dims, int_string) => dimstrs &
	Util.string_delimit_list(dimstrs,", ") => dimstr &
	get_type_name ty => tystr &
	Util.string_append_list([tystr,"[",dimstr,"]"]) => str
	------------------------------------------------------
	get_type_name(arrayty as (T_ARRAY(_,_),_) ) => str

  axiom	get_type_name( (_,_)) => "Not nameable type or no type"


end

(** LS: If PROP_TUPLE, returns true if any of the flags is true **)
relation is_prop_const: Properties => bool =

  axiom	is_prop_const PROP(_,constant) => constant

  rule	is_prop_tuple_const constant => res
	-----------------------------------
	is_prop_const PROP_TUPLE(_,constant) => res

end
(** LS: **)
relation is_prop_tuple_const: Const => bool =

  axiom	is_prop_tuple_const CONST(f) => f

  rule	is_prop_tuple_const first => true
	---------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => true

  rule	is_prop_tuple_const first => false &
	is_prop_tuple_const TUPLE_CONST(rest) => res
	--------------------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => res

end

relation is_prop_array : Properties => bool =

  rule	get_prop_type p => t &
	is_type_array t => b
	----------------------
	is_prop_array p => b

end

(** LS: **)
relation get_prop_type: Properties => Type = 

  axiom	get_prop_type PROP(ty,_) => ty
  axiom	get_prop_type PROP_TUPLE(ty,_) => ty

end

relation is_type_array : Type => bool =
	
	axiom is_type_array((T_ARRAY(_,_),_)) => true
	axiom is_type_array((_,_)) => false

end

relation elab_type : Type => Exp.Type =

  axiom	elab_type((T_INTEGER(_),_)) => Exp.INT
  axiom	elab_type((T_REAL(_),_)) => Exp.REAL
  axiom	elab_type((T_BOOL(_),_)) => Exp.BOOL
  axiom	elab_type((T_STRING(_),_)) => Exp.STRING
  axiom elab_type((T_ENUM,_)) => Exp.ENUM

  rule	array_element_type t => et &
	elab_type et => t'
	----------------
	elab_type(t as (T_ARRAY(_,_),_)) => t'

  axiom	elab_type((_,_)) => Exp.OTHER

end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	Debug.print "Debug: match prop." &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	Debug.print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end


(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =

  rule	subtype(e_type, expected_type) => true
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e, e_type)

  rule	subtype(e_type, expected_type) => false &
(*	Debug.fprint("sei", "trying type convert\n") &*)
	type_convert(e, e_type, expected_type) => (e',e_type') 
(*	& Debug.fprint("sei", "Type convert succeded\n") *)
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e',e_type')
end

(** relation: match_type_list
 **
 ** This relation matches a list of types, with a list of other types.
 ** Type conversion is disredaded, but an expression is given (the rhs of a tuple assignment)
 ** if such conversions should be implemented
 **)

relation match_type_list : (Exp.Exp, Type list, Type list ) => (Exp.Exp, Type list) =

  axiom	match_type_list(e,[],[]) => (e,[])

  rule	match_type(e,t1,t2) => (e',tp) &
	match_type_list(e',ts1,ts2) => (e'',res) 
	--------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => (e',tp::res)

(*  rule	Debug.fprint("failtrace","- match_type_list failed\n") 
	-----------------------------------------------------
	match_type_list(e, t1::ts1, t2::ts2) => fail*)
end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Type, Type) => (Exp.Exp, Type) =
	    
  rule	int_eq (dim1, dim2) => true &
	type_convert_array (elist, ty1, ty2) => elist' &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	  => (Exp.ARRAY(at,a,elist'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(step,ty1,ty2) => (step',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,SOME(step),stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',SOME(step'),stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	int_eq (dim1, dim2) => true &
	type_convert(begin,ty1,ty2) => (begin',_) &
	type_convert(stop,ty1,ty2) => (stop',_) &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.RANGE(t,begin,NONE,stop), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p))
	    => (Exp.RANGE(at,begin',NONE,stop'),(T_ARRAY(DIM(SOME(dim1)),ty2),p))

  rule	int_eq (dim1, dim2) => true &
	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(SOME(dim2)), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))
	    
  rule	int_eq (dim11,dim22) => true &
	type_convert_matrix (ell, t1, t2) => ell' &
	elab_type t2 => at 
	------------------------------------------
	type_convert(Exp.MATRIX(_,nmax,ell), 
		     (T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t1),_)),_), 
		     (T_ARRAY(DIM(NONE), (T_ARRAY(DIM(SOME(dim22)),t2),p1)),p2))
	    => (Exp.MATRIX(at,nmax,ell'),(T_ARRAY(DIM(SOME(dim1)),(T_ARRAY(DIM(SOME(dim11)),t2),p1)),p2))

  rule	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(NONE), ty2),p2))

	    
  rule	(* This rule is used to ensure that casts are made on each *)
	(* element, instead of on the whole array *)
	type_convert_array (elist, ty1, ty2) => (elist') &
	elab_type ty2 => at &
	is_array ty2 => a
	------------------------------------------
	type_convert(Exp.ARRAY(_,_,elist), 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (Exp.ARRAY(at,a,elist'), (T_ARRAY(DIM(SOME(dim1)), ty2),p2))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     (T_ARRAY(DIM(NONE), ty1),_), 
		     (T_ARRAY(DIM(SOME(dim2)), ty2),p2))
	  => (e', (T_ARRAY(DIM(NONE), t'),p2))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	--------------------
	type_convert(e,
	    (T_ARRAY(DIM(NONE), ty1),_), 
	    (T_ARRAY(DIM(NONE), ty2),p2))
	    => (e', (T_ARRAY(DIM(NONE), t'),p2))
	    
  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     (T_ARRAY(DIM(SOME(dim1)), ty1),_), 
		     (T_ARRAY(DIM(NONE), ty2),p2))
	  => (e', (T_ARRAY(DIM(SOME(dim1)), t'),p2))

  rule	type_convert_list (elist, tys1, tys2) => (elist',tys')
	------------------------------------------
	type_convert(Exp.TUPLE(elist), 
		     (T_TUPLE(tys1),_), 
		     (T_TUPLE(tys2),p2))
	  => (Exp.TUPLE(elist'), (T_TUPLE(tys'),p2))

  axiom	type_convert(exp, 
	    (T_ENUM,_),
	    (T_ENUMERATION(l,v),p2))
	    => (exp, (T_ENUMERATION(l,v),p2))
	    
  axiom	type_convert(e, (T_INTEGER(v),_), (T_REAL(_),p)) 
	  => (Exp.CAST(Exp.REAL,e),(T_REAL(v),p))

(*  rule	Debug.fprint("tcvt","- type conversion failed: ") &
	Debug.fcall ("tcvt",print_type,t1) & 
	Debug.fprint("tcvt",", ") & 
	Debug.fcall ("tcvt",print_type,t2) &
	Debug.fprint("tcvt","\n")
	-------------------------------
	type_convert (_,t1,t2) => fail *)
end

relation type_convert_array : (Exp.Exp list, Type, Type) => Exp.Exp list =

  axiom type_convert_array ([], _, _) => []

  rule	type_convert_array (rest, ty1, ty2) => rest' &
	type_convert (first, ty1, ty2) => (first',_)
	-------------------------------------------
	type_convert_array (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_buf "- type conversion of array failed exp=" &
	Exp.print_exp e &
	Print.print_buf "t1 = " &
	print_type t1 & 
	Print.print_buf " t2 = " &
	print_type t2 &
	Print.print_buf "\n" 
	-------------------------------
	type_convert_array (e::_,t1,t2) => fail *)

end

relation type_convert_matrix : ((Exp.Exp*bool) list list, Type, Type) => (Exp.Exp*bool) list list =

  axiom type_convert_matrix ([], _, _) => []

  rule	type_convert_matrix (rest, ty1, ty2) => rest' &
	type_convert_matrix_row(first,ty1,ty2) => first'
	-------------------------------------------
	type_convert_matrix (first::rest, ty1, ty2) => first'::rest'

(*  rule	Print.print_buf "- type conversion of matrix failed" &
	Print.print_buf "t1 = " &
	print_type t1 & 
	Print.print_buf " t2 = " &
	print_type t2 &
	Print.print_buf "\n" 
	-------------------------------
	type_convert_matrix (e::_,t1,t2) => fail *)

end

relation type_convert_matrix_row: ((Exp.Exp*bool) list , Type, Type) 
	    => ( Exp.Exp * bool) list =
  axiom type_convert_matrix_row ([],_,_) => []

  rule	type_convert_matrix_row(rest,t1,t2) => rest &
	type_convert(exp,t1,t2) => (exp',newt) &
	is_array t2 => a
	---------------------------------
	type_convert_matrix_row((exp,_)::rest,t1,t2 )=> ((exp',a)::rest)
end

relation type_convert_list : (Exp.Exp list, Type list, Type list) 
	  => (Exp.Exp list, Type list) =

  axiom type_convert_list ([], _, _) => ([],[])

  rule	type_convert_list (rest, ty1rest, ty2rest) => (rest',tyrest') &
	type_convert (first, ty1, ty2) => (first',ty')
	-------------------------------------------
	type_convert_list (first::rest, ty1::ty1rest, ty2::ty2rest) => (first'::rest',ty'::tyrest')

end

relation match_with_promote : (Properties, Properties, bool (* Allow Integer => Real *)) 
	  => Properties =

  rule	match_with_promote(PROP(t1,c1),PROP(t2,c2),havereal) => PROP(t,c) &
	let dim = dim1
	-----
	match_with_promote(PROP((T_ARRAY(dim1,t1),_),c1),
			   PROP((T_ARRAY(dim2,t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(dim,t),p2),c)

  rule	is_array t1 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	---------------------------
	match_with_promote(PROP(t1,c1),
			   PROP((T_ARRAY(DIM(SOME(1)),t2),p2),c2), havereal) 
	  => PROP((T_ARRAY(DIM(SOME(1)),t),p2),c)

  rule	is_array t2 => false &
	match_with_promote(PROP(t1,c1),PROP(t2,c2), havereal) => PROP(t,c)
	-----
	match_with_promote(PROP((T_ARRAY(DIM(SOME(1)),t1),p),c1),
			   PROP(t2,c2), havereal)
	  => PROP( (T_ARRAY(DIM(SOME(1)),t),p) ,c)


  rule	is_array t1 => false &
	is_array t2 => false &	
	t1 = t2 &
	let t = t1 &
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP(t1,c1),PROP(t2,c2), false) => PROP(t,c)


  rule	(* Have real and both Real *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_REAL(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and first Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_REAL(v),p2),c2), true) 
	  => PROP((T_REAL(v),p2),c)

  rule	(* Have real and second Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_REAL(v),_),c1),PROP((T_INTEGER(_),p2),c2), true) => PROP((T_REAL(v),p2),c)

  rule	(* Have real and both Integer *)
	bool_and(c1,c2) => c
	--------------
	match_with_promote(PROP((T_INTEGER(_),_),c1),PROP((T_INTEGER(_),p2),c2), true) 
	  => PROP((T_REAL([]),p2),c)
end

relation print_prop : Properties => () =

  rule	Print.print_buf "PROP(" &
	print_type ty &
	Dump.print_select(const,"const","non_const") &
	Print.print_buf ")"
	-------------------
	print_prop PROP(ty,const)

  rule	Print.print_buf "PROP_TUPLE(" &
	print_type ty &
	Print.print_buf ",<Type.Const>)"
	---------------------------------
	print_prop PROP_TUPLE(ty,const)

end