(** file: types.rml
 **)

module Types :

  with "classinf.rml"
  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** FIXME: This is declared in many places. *)

  (** - Variables *)
  datatype Var = VAR of Ident * Absyn.VarAttr * Type * Absyn.Exp option
  (** I wonder why this goes here? *)

  (** - Types *)
  datatype Type = TYPE of ClassInf.State * Var list
  (** The `Type' datatype stores information about the type of an *)
  (** instantiated variable. The only information that is kept is the *)
  (** class inference state, and the subcomponents. *)

  (** - Basic types and arrays *)
  datatype BasicType = T_INTEGER
		     | T_REAL
		     | T_STRING
		     | T_BOOL
		     | T_ARRAY of ArrayDim * BasicType
		     | T_COMPLEX of Component list (* really a set *)

  datatype ArrayDim = NODIM
		    | DIM of int option * ArrayDim

  datatype Component = COMP of Ident * BasicType

  (** To generate the correct set of equations, the translator has to *)
  (** differentiate between the primitive types `Real', `Integer', *)
  (** `String', `Boolean' and types directly derived from then from *)
  (** other, complex types.  For arrays and matrices the type *)
  (** `T_ARRAY' is used, with the first argument being the number of *)
  (** dimensions, and the second being the type of the objects in the *)
  (** array.  The `BasicType' type is used to store *)
  (** information about whether a class is derived from a primitive *)
  (** type, and whether a variable is of one of these types.  *)

  (** - Exported relations *)
  relation simplify_type : Type => BasicType
  relation same_type : (BasicType, BasicType) => bool
  relation lookup_component : (Type, Ident) => Var
  relation known_type : (ClassInf.State, Absyn.ArrayDim) => BasicType
  relation print_type : BasicType => ()

end

(** relation: simplify_type *)

relation simplify_type : Type => BasicType =

  rule	known_type(st,[]) => t
	----------------------
	simplify_type(TYPE(st,_)) => t

  rule	simplify_vars(v) => cl
	----------------------
	simplify_type(TYPE(_,v)) => T_COMPLEX(cl)

end

(** relation: simplify_vars *)

relation simplify_vars : Var list => Component list =

	(* FIXME: What about array dimensions? *)

  axiom	simplify_vars [] => []
	
  rule	simplify_type t => t' & simplify_vars(vs) => cs
	-----------------------------------------------
	simplify_vars(VAR(n,_,t,_)::vs) => COMP(n,t')::cs

end

(** relation: same_type
 **)

relation same_type : (BasicType, BasicType) => bool =
	
  axiom	same_type (T_INTEGER,T_INTEGER) => true
  axiom	same_type (T_REAL,T_REAL)       => true
  axiom	same_type (T_STRING,T_STRING)   => true
  axiom	same_type (T_BOOL,T_BOOL)       => true

  rule	same_arraydim (d1,d2) => true & same_type (t1,t2) => true
	---------------------------------------------------------
	same_type (T_ARRAY(d1,t1),T_ARRAY(d2,t2)) => true
	
  rule	same_type_comp (c1, c2) => true
	----------------------------------
	same_type (T_COMPLEX(c1),T_COMPLEX(c2)) => true

	(* default *)
  axiom	same_type (_,_) => false

end

relation same_arraydim : (ArrayDim, ArrayDim) => bool =

  axiom	same_arraydim (NODIM,NODIM) => true

  rule	i1 = i2 & same_arraydim (d1,d2) => true
	---------------------------------------
	same_arraydim (DIM(i1,d1),DIM(i2,d2)) => true

	(* default *)
  axiom	same_arraydim (_,_) => false

end

relation same_type_comp : (Component list, Component list) => bool =

  axiom same_type_comp([], []) => true

  rule  pick(xs2,n) => (xs2',t2) &
	same_type(t1,t2) => true &
	same_type_comp(xs1,xs2') => true
	---------------------
	same_type_comp(COMP(n,t1)::xs1, xs2) => true

	(* default *)
  axiom	same_type_comp (_,_) => false

end

(** relation: pick *)

relation pick : (Component list, Ident) => (Component list, BasicType) =

  rule  n1 = n2
	-------
	pick(COMP(n1,ty)::xs,n2) => (xs,ty)

  rule  pick(xs,n) => (xs',ty)
	---------------------
	pick(_::xs,n) => (xs',ty)

end

(*
relation same_type : (Type, Type) => () =
	
	(* FIXME: Check state? *)
  rule	same_type_c(els1, els2)
	-----------------------
	same_type(TYPE(st1,els1), TYPE(st2,els2))

end

relation same_type_c : (Var list, Var list) => () =

  axiom same_type_c([], [])

  rule  pick(xs2,n) => (xs2',attr,t2) &
	same_type(t1,t2) &
	same_type_c(xs1,xs2')
	---------------------
	same_type_c(VAR(n,_,t1,_)::xs1, xs2)

end

(** relation: pick *)

relation pick : (Var list, Ident)
	  => (Var list, Absyn.VarAttr, Type) =

  rule  n1 = n2
	-------
	pick(VAR(n1,attr,ty,_)::xs,n2) => (xs,attr,ty)

  rule  pick(xs,n) => (xs',attr,ty)
	---------------------
	pick(_::xs,n) => (xs',attr,ty)

end
*)

(** relation: lookup_component *)

relation lookup_component : (Type, Ident) => Var =

  rule  lookup_component2(cs, id) => v
	------------------------------
	lookup_component(TYPE(st,cs), id) => v

end

(**)

relation lookup_component2 : (Var list , Ident) => Var =

  rule  n = m
	-----
	lookup_component2((v as VAR(n,_,_,_))::_, m) => v

  rule  lookup_component2(vs, n) => v
	-----------------------------
	lookup_component2(v::vs, n) => v

end

(** relation: known_type *)

relation known_type : (ClassInf.State, Absyn.ArrayDim) => BasicType =

  rule	known_type (st, []) => t &
	mk_arraydim dims => dims'
	-------------------------
	known_type (st, dims as (_::_)) => T_ARRAY(dims',t)

  axiom	known_type (ClassInf.TYPE_INTEGER(_),[]) => T_INTEGER
  axiom	known_type (ClassInf.TYPE_REAL(_),[])    => T_REAL
  axiom	known_type (ClassInf.TYPE_STRING(_),[])  => T_STRING
  axiom	known_type (ClassInf.TYPE_BOOL(_),[])    => T_BOOL

	(* FIXME *)
  axiom	known_type (_,[])                        => T_COMPLEX([])

  rule	print "- known_type failed\n"
	-----------------------------
	known_type (_,_) => fail

end

(** relation: mk_arraydim *)

relation mk_arraydim : Absyn.ArrayDim => ArrayDim =

  axiom	mk_arraydim [] => NODIM

  rule	mk_arraydim ds => ds'
	(* FIXME: calculate d *)
	---------------------
	mk_arraydim d::ds => DIM(NONE,ds')

end

(** relation: print_type
 **
 ** This relation prints a textual description of a Modelica type.  If
 ** the type is not one of the primitive types, it simply prints
 ** `complex'.
 **)

relation print_type : BasicType => () =

  rule	print "integer"
	---------------
	print_type T_INTEGER

  rule	print "real"
	------------
	print_type T_REAL

  rule	print "string"
	--------------
	print_type T_STRING

  rule	print "bool"
	------------
	print_type T_BOOL

  rule	print "complex"
	------------
	print_type T_OTHER

  rule	print "array(" & print_arraydim dim & print ") of " &
	print_type t
	------------
	print_type T_ARRAY(dim,t)

end

relation print_arraydim =

  axiom	print_arraydim NODIM

  rule	print ":"
	---------
	print_arraydim DIM(NONE,NODIM)

  rule	int_string i => s & print s
	---------------------------
	print_arraydim DIM(SOME(i),NODIM)

  rule	print ":," & print_arraydim(d)
	------------------------------
	print_arraydim DIM(NONE,d)

  rule	int_string i => s & print s & print "," & print_arraydim(d)
	-----------------------------------------------------------
	print_arraydim DIM(SOME(i),d)

end
