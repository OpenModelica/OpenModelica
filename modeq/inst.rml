(*
    Copyright PELAB, Linkoping University
 
    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 inst.rml
 ** module:      Inst
 ** description: Model instantiation
 **
 ** RCS: $Id$
 **
 ** This module exports only one relation. Not true anymore...
 **)

(** debug flags: inst *)

module Inst:
  with "classinf.rml"
  with "connect.rml"
  with "dae.rml"
  with "debug.rml"
  with "env.rml"
  with "exp.rml"
  with "explode.rml"
  with "mod.rml"
  with "prefix.rml"
  with "types.rml"
  with "util.rml"
  with "interactive.rml"							  
  with "cache.rml"

  type InstDims = Exp.Subscript list

  datatype Initial = INITIAL | NON_INITIAL

  datatype DimExp = DIMINT of int
		  | DIMEXP of Exp.Subscript * Exp.Exp option

  relation instantiate: SCode.Program => DAE.DAElist
  relation instantiate_implicit: SCode.Program => DAE.DAElist
  
  relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option)
	  => Types.Binding

  relation instantiate_class : (SCode.Program,SCode.Path) => DAE.DAElist

  relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env 
	
  relation inst_class: (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix, 
			Connect.Sets, SCode.Class, InstDims,bool)
	  => (Cache.Cache, DAE.Element list, Connect.Sets, Types.Type, ClassInf.State)


  relation inst_class_decl : (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix,
			      Connect.Sets, SCode.Class, InstDims, bool)
	  => (Cache.Cache, Env.Env, DAE.Element list)

  relation inst_class_in: (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix, 
			   Connect.Sets, ClassInf.State,
			   SCode.Class, bool, InstDims, bool, bool)
	  => (Cache.Cache, DAE.Element list, Env.Env, Connect.Sets, 
	      ClassInf.State, Types.Var list)

  relation inst_record_constructor_elt : (Env.Env, SCode.Element) 
	 => (Types.Var)
  relation mktype : (ClassInf.State,Types.Var list) => Types.Type

  relation init_vars_modelica_output : DAE.Element list => DAE.Element list

  relation new_ident : () => Exp.ComponentRef
  relation implicit_function_instantiation : (Cache.Cache, Env.Env, Mod.Mod, 
					      Prefix.Prefix, Connect.Sets, SCode.Class,
					      InstDims, bool)
	  => (Cache.Cache, Env.Env, DAE.Element list)
	    
end


with "absyn.rml"
with "algorithm.rml"
with "builtin.rml"
with "dump.rml"
with "lookup.rml"
with "modutil.rml"
with "rtopts.rml"
with "staticexp.rml"
with "values.rml"
with "print.rml"
with "system.rml"
(**
 ** These type aliases are introduced to make the code a little more
 ** readable.
 **)

type Prefix = Prefix.Prefix
type Mod = Mod.Mod
type Ident = Exp.Ident
type Env = Env.Env


relation print_dims: DimExp list => () =
  rule	print_dim([SOME(x)]) => () &
	print_dims(xs) => ()
	-------------------
	print_dims(x::xs) => ()

  axiom	print_dims([]) => ()
end


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l 
	-----------------------------
	instantiate(p) => DAE.DAE(l)
end

(** Implicit instantiation of a program can be used for e.g. code generation of functions, since a function must be implicitly instantiated in order to generate code from it. *)

relation instantiate_implicit: SCode.Program => DAE.DAElist =

  rule	Builtin.initial_env => env &
	Env.extend_frame_classes(env,p) => env' &
	inst_program_implicit(env',p) => l 
	-----------------------------
	instantiate_implicit(p) => DAE.DAE(l)
end


(** relation: instantiate_class
 **
 **
 ** To enable interactive instantiation, an arbitrary class in the program needs to be
 ** possible to instantiate. This relation performs the same action as `inst_program', 
 **  but given a specific class to instantiate.
 **  First all the class
 ** definitions is added to the environment without modifications, and
 ** then the specified class is instantiated in the relation `inst_class'
 **)

relation instantiate_class : (SCode.Program, SCode.Path) => DAE.DAElist =

  rule	Print.print_buf "# Empty program\n"
	------------------------------
	instantiate_class([],cr) => fail

  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path) => (env',dae1) &
	inst_class_in_program(env',cdecls,path) => dae
	-----------------------------
	instantiate_class(cdecls, path as Absyn.IDENT(name2)) => DAE.DAE([DAE.COMP(name2,DAE.DAE(dae))])

  rule	Builtin.initial_env => env &
	inst_class_decls(env,cdecls,path)=> (env',_) &
	Lookup.lookup_class(Cache.CACHE([],[]),env',path,true) 
	  => (_,cdef as SCode.CLASS(n,_,_,_,_), env'') &
	inst_class(Cache.CACHE([],[]), env'', Mod.NOMOD, Prefix.NOPRE, [], cdef, [], false) 
	  => (_, dae, _, _, _) &
	Absyn.path_string path => pathstr
	--------------------------------------------
	instantiate_class(cdecls, path as Absyn.QUALIFIED(name,_)) 
	  => DAE.DAE([DAE.COMP(pathstr,DAE.DAE(dae))])
	

  rule	Debug.fprint("failtrace", "- instantiate_class failed\n")
	------------
	instantiate_class(_,_) => fail
end

relation inst_class_in_program: (Env, SCode.Program, SCode.Path ) => (DAE.Element list) =
	
  rule	name = name2 &
	inst_class(Cache.CACHE([],[]), env, Mod.NOMOD, Prefix.NOPRE, [], c, [], false) 
	  => (_, dae, _, _, _) 
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs,Absyn.IDENT(name2)) => dae

  rule	not name = name2 &
	inst_class_in_program(env,cs,path) => dae
	-------------------------------------------------------------
	inst_class_in_program(env,(c as SCode.CLASS(name,_,_,_,_))::cs, path as Absyn.IDENT(name2)) => dae
  axiom	inst_class_in_program(env,[],_) => []
	
  rule	Debug.fprint("failtrace", "inst_class_in_program failed\n")
	-------------------------------
	inst_class_in_program(env,_,_) => fail

end

relation inst_class_decls:(Env, SCode.Program, SCode.Path) => ( Env.Env, DAE.Element list) =
  rule	not name = name2 &
	inst_class_decl(Cache.CACHE([],[]), env, Mod.NOMOD, Prefix.NOPRE, [], c, [], false) 
	  => (_, env', dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env'',dae)

  rule	name = name2 &      
	inst_class_decls(env,cs,ref) => (env', dae2)
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.IDENT(name2)) => (env',dae2)

  rule	name = name2 &      
	(* How should be do here ??? *)
	inst_class_decl(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (_,env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

  rule	not name = name2 &      
	inst_class_decl(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (_,env',dae1) &
	inst_class_decls(env',cs,ref) => (env'', dae2) &
	list_append(dae1,dae2) => dae  
	-----------------------------
	inst_class_decls(env, (c as SCode.CLASS(name,_,_,_,_))::cs,ref as Absyn.QUALIFIED(name2,_)) => (env'',dae)

axiom	inst_class_decls(env,[],_) => (env,[])
	
  rule	print "inst_class_decls failed\n ref =" &
	Absyn.path_string ref => str &
	print str & print "\n" 
	--------------------
	inst_class_decls(_,_,ref) => fail
end

(** relation: make_env_from_program
 ** This relation takes a `SCode.Program' and builds an environment, excluding the class in A1.
**)

relation make_env_from_program: (SCode.Program,SCode.Path) => Env.Env = 
  rule	Builtin.initial_env => env &
	add_program_to_env(env,prog,c) => env'
	--------------------------------
	make_env_from_program (prog,c) => env'
end

relation add_program_to_env: (Env.Env,SCode.Program,SCode.Path) => Env.Env =
  rule	inst_class_decls(env,p,path) => (env' ,_) 
	-----------------------------------------
	add_program_to_env (env,p,path) => env'
end


(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	Print.print_buf "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail


  rule	Debug.fprintln ("insttr", "inst_program1") &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (_,dae,csets,_,_) 
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

  rule	Debug.fprintln ("insttr", "inst_program2") &
	inst_class_decl(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (_,env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

  rule	Print.print_buf "- inst_program failed\n" 
	------------
	inst_program(_,_) => fail
end


relation inst_program_implicit : (Env, SCode.Program) => DAE.Element list =
	
  rule	Debug.fprintln ("insttr", "inst_program_implicit") &
	implicit_instantiation(Cache.CACHE([],[]),env,Mod.NOMOD,Prefix.NOPRE,[],c,[],false) 
	  => (_, env', dae1) &
	inst_program_implicit(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	-----------------------------
	inst_program_implicit(env,(c as SCode.CLASS(n,_,_,restr,_))::cs) => dae

  rule	Debug.fprintln ("insttr", "inst_program_implicit (end)")
	----------------------------------------------------
	 inst_program_implicit(env,[]) => []

end

(** relation: inst_class
 **
 ** Instantiation of a class can be either implicit or "normal". This relation is 
 ** used in both cases. When implicit instantiation is performed, the last argument 
 ** is true, otherwise it is false.
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class : (Cache.Cache, Env, Mod, Prefix, Connect.Sets, SCode.Class, InstDims,bool)
	  => (Cache.Cache, DAE.Element list, Connect.Sets, Types.Type, ClassInf.State) =

  rule	Print.print_buf "# Can't instantiate partial class " & Print.print_buf n & Print.print_buf "\n"
	------------------------------------------------------	
	inst_class(cache,env,mod,pre, csets, SCode.CLASS(n,true,_,_,_),_,false) => fail

  rule	Env.open_scope(env,encflag) => env' &
	Env.name_scope(env',n) => env'' &
	ClassInf.start(r,n) => ci_state &
	inst_class_in(cache, env'', mod, pre, csets, ci_state, c, false, inst_dims, impl,false)
	  => (cache', dae1, _, csets', ci_state', tys) &
	Connect.equations csets' => dae2 &
	list_append(dae1, dae2) => dae &
	mktype(ci_state',tys) => ty
	-------------------------------------------
	inst_class(cache, env, mod, pre, csets, c as SCode.CLASS(n,_,encflag,r,_),inst_dims,impl)
	  => (cache', dae, [], ty, ci_state')

  rule	Debug.fprint("failtrace", "- inst_class ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", " failed\n") 
	-----------------------------------------------------
	inst_class(_,_,_,_,_,SCode.CLASS(n,_,_,_,_),_,impl) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 ** The next last boolean indicates if the class should be instantiated 
 ** implicit, i.e. without generating DAE.
 ** The last boolean is a even stronger indication of implicit instantiation,
 ** used when looking up variables in packages. This must be used because 
 ** generation of functions in implicit instanitation (according to next last 
 ** boolean) can cause circular dependencies (e.g. if a function uses a
 ** constant in its body) 
 **)

relation inst_class_in: (Cache.Cache, Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool, InstDims, bool, bool)
	  => (Cache.Cache, DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  rule	(*For the builtin classes. no DAE for elts. E.g. unit, quantity, ... *)
	Util.string_equal(cname,"Real") => r &
	Util.string_equal(cname,"Integer") => i &
	Util.string_equal(cname,"String") => s &
	Util.string_equal(cname,"Boolean") => b &
	Util.bool_or_list([r,i,s,b]) => true & 
	inst_classdef(cache, env,mods,pre,csets,ci_state,d,restr,prot,inst_dims
		      ,impl,packimpl)
	  => (cache', l,env', csets', ci_state', tys)
	-------------------------------------
	inst_class_in(cache, env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(cname,_,_,restr,d), prot, inst_dims,
		      impl,packimpl)
	  => (cache', [] (* No DAE *), env', csets', ci_state', tys)

  rule	clock() => t1 &
	inst_classdef(cache, env,mods,pre,csets,ci_state,d,r,prot,inst_dims
		      ,impl,packimpl)
	  => (cache', l,env', csets', ci_state', tys) &
	clock() => t2 &
	real_sub(t2,t1) => time &
	real_gt(time,0.3) => b &
	real_string time =>timestr &
	Util.string_append_list(["inst_class_in", n, ": ", timestr, "\n" ]) => s1 &
	Dump.select_string(b,s1,"") => str &
	print str &
	Prefix.print_prefix_str pre => prestr &
	string_append(prestr, " : ") => prestr' &
	string_append(prestr', n) => prestr'' &
	Debug.fcall ("envgraph", Env.print_env_graphviz, (env,prestr'')) &
	Debug.fprintl ("envprint", ["------------ ", prestr'', "\n"]) &
	Debug.fcall ("envprint", Env.print_env, env') & 
	Debug.fprintl ("envprint", ["------------ /", prestr'', "\n"])
	-------------------------------------
	inst_class_in(cache, env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,_,r,d), prot, inst_dims,
		      impl,packimpl)
	  => (cache', l,env', csets', ci_state', tys)

  rule  Debug.fprint("failtrace", "- inst_class_in failed\n")
	----------------------------------
	inst_class_in(_,_,_,_,csets,_,_,_,_,_,_) => fail

end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 ** The last two arguments are the same as for inst_class_in: 
 ** implicit instantiation and implicit package instantiation
 **)

relation inst_classdef: (Cache.Cache, Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, SCode.Restriction, bool,InstDims,
			 bool, bool)
	  => (Cache.Cache, DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	Prefix.print_prefix_str pre => prestr &
	Debug.fprintl ("insttr", ["inst_class parts: pre=",prestr,"\n"]) &       
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
(*	inst_element_list2(env,mods,pre,csets,ci_state,cdefelts,inst_dims, impl)
	  => (_,env1,csets',ci_state',tys) &*)	
	add_classdefs_to_env(env,cdefelts,impl) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(cache, env1, mods, extendselts, impl)
	  => (cache', env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
		
	Util.list_flatten([extcomps,compelts,cdefelts]) => compelts' &	
	
	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',compelts',inst_dims,impl) => env3 &
	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &
	(*3. Instantiate components *)
	inst_element_list(cache', env3, mods, pre, csets, ci_state1, compelts', 
			  inst_dims, impl, false)
	  => (cache'',dae1,env4, csets1, ci_state2, tys) &
	inst_list(env4,mods,pre,csets1,ci_state2,inst_equation, eqs')
	  => (dae2,_,csets2, ci_state3) &
	inst_list(env4,mods,pre,csets2,ci_state3,inst_initialequation, initeqs')
	  => (dae3,_,csets3, ci_state4) &
	inst_list(env4,mods,pre,csets3,ci_state4, inst_algorithm, alg')
	  => (dae4,_,csets4, ci_state5) &
	inst_list(env4,mods,pre,csets4,ci_state5, inst_initialalgorithm, initalg')
	  => (dae5,_,csets5, ci_state6) &
	list_append(dae1,dae2) => dae6 &
	list_append(dae6,dae3) => dae7 &
	list_append(dae7,dae4) => dae8 &
	list_append(dae8,dae5) => dae 
	------------------------------------------------------
	inst_classdef(cache, env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, false)
	  => (cache'', dae, env4, csets5, ci_state6, tys)

	(** This rule describes how to instantiate an explicit
	 ** class definition *)
  rule	Prefix.print_prefix_str pre => prestr &
	Debug.fprintl ("insttr", ["inst_class parts: pre=",prestr,"\n"]) &       
	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state1 &

	classdef_elts(els) => cdefelts &
	component_elts(els) => compelts &
	extends_elts(els) => extendselts &
	(* 1. CLASSDEF & IMPORT nodes and COMPONENT nodes(add to env)*)
	add_classdefs_to_env(env,cdefelts,impl) => env1 &

	(*2. EXTENDS Nodes*)
	(* inst_extends_list only flatten inhteritance structure. *)
	(* It does not perform component instantiations. *)
	inst_extends_list(cache, env1, mods, extendselts, impl)
	  => (cache', env2, emods, extcomps, eqs2, initeqs2, alg2, initalg2) &
		
	Util.list_flatten([extcomps,compelts,cdefelts]) => compelts' &	
	
	(* Add variables to env, wihtout type and binding, *)
	(* which will be added later in inst_element_list  *)
	(* (where update_variable is called) *)
	add_components_to_env(env2,emods,pre,csets,ci_state,compelts',compelts',inst_dims,impl) => env3 &
	(* Add components from base classes to be instantiated in 3 as well. *)
	list_append(eqs,eqs2) => eqs' &
	list_append(initeqs,initeqs2) => initeqs' &
	list_append(alg,alg2) => alg' &
	list_append(initalg,initalg2) => initalg' &
	(*3. Instantiate components *)
	inst_element_list(cache',env3,mods,pre,csets,ci_state1, compelts', 
			  inst_dims, impl, true)
	  => (cache'', dae1, env4, csets1, ci_state2, tys) 
	------------------------------------------------------
	inst_classdef(cache, env, mods, pre, csets, ci_state,
		      SCode.PARTS(els,eqs,initeqs,alg,initalg,_), re, prot, 
		      inst_dims, impl, true)
	  => (cache'', dae1, env4, csets1, ci_state2, tys)


	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Prefix.print_prefix_str pre => prestr &
	Absyn.path_string cn => cnstr &
	Debug.fprintl ("insttr", ["inst_class derived: ", cnstr, ", pre=",prestr,"\n"]) &
	Lookup.lookup_class(Cache.CACHE([],[]),env,cn,true) 
	  => (_, c as SCode.CLASS(cn2,_,enc2,r,_), cenv) &
	Env.open_scope(cenv,enc2) => cenv' &
	Env.name_scope(cenv',cn2) => cenv'' &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod') => mods'' &
	inst_class_in(cache, cenv'', mods'', pre, csets, new_ci_state, c,prot,inst_dims,impl,false)
	  => (cache', dae, env'', csets', ci_state', tys) &

	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(cache, env, mods, pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => (cache', dae, env'', csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(Cache.CACHE([],[]), env,cn,false) => (_,_,_) &
	Absyn.path_string(cn) => cns &
	Print.print_buf "# unknown class: " & Print.print_buf cns & Print.print_buf "\n"
	----------------------------------------
	inst_classdef(cache, env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot, 
		      inst_dims, impl, packimpl)
	  => fail

  rule	Debug.fprint("failtrace", "- inst_classdef failed\n")
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_,_,_,_,_) => fail

end	

(** relation: inst_extends_list 
 ** 
 ** This relations flattens out the inheritance structure of a class.
 ** It takes an SCode.Element list and flattens out the extends nodes
 ** of that list. The result is a list of components and lists of equations
 ** and algorithms.
**)
relation	inst_extends_list:(Cache.Cache, Env.Env, Mod.Mod, SCode.Element list, bool)
	  => (Cache.Cache, Env.Env, Mod.Mod, SCode.Element list, SCode.Equation list,
	      SCode.Equation list, SCode.Algorithm list, SCode.Algorithm list) 
	=
  rule	Lookup.lookup_class(cache, env, tp, true) 
	  => (cache', c as SCode.CLASS(cn,_,encf,r,_), cenv) &
	Mod.lookup_modification_p(mod, Absyn.IDENT(cn)) => innermod &
	inst_derived_classes(cenv, innermod, c, impl) =>
	  (cenv1, els, eq1, ieq1, alg1, ialg1) &
	
	Env.open_scope(cenv1,encf) => cenv' &
	Env.name_scope(cenv',cn) => cenv'' &
	ClassInf.start(r, cn) => new_ci_state &
	inst_class_in(cache, cenv'', Mod.NOMOD, Prefix.NOPRE, [], new_ci_state, c,false (*prot*) ,[],false,false)
	  => (cache', _, env'', _, _, _) &

	make_complete_type_names(env'',els) => els' &
	inst_extends_list(cache',env'', innermod, els', impl) 
	  => (cache'',_,mods, compelts1, eq2, ieq2, alg2, ialg2) &  
	inst_extends_list(cache'', env, mod, rest, impl)
	  => (cache''', env', mods', compelts2, eq3, ieq3, alg3, ialg3) & 
	(* Must merge(mod,emod) here and then apply the bindings to the *)
	(* corresponding elements. But emod is Absyn.Mod and can not  *)
	(* be elaborated, because for instance extends A(x=y) can reference *)
	(* a variable y defined in A and will thus not be found. *)
	(* Solution: made new relation elab_untyped_mod which transforms *)
	(* to a Mod, but set the type information to unknown. *)
	(* We can then perform the merge, and update untyped modifications *)
	(* later (using update_mod), when we are instantiating the components. *)
	Mod.elab_untyped_mod(emod) => emod' &
	Mod.merge(mod,mods') => mod' &			      
	Mod.merge(mod',emod') => mods' &
	list_append(compelts1, compelts2) => compelts &	

(*	  Print.print_buf "\n compelts list: " &
	  SCode.print_element_list(compelts) &
	Print.print_buf "mod =" & 
	Mod.print_mod mods' &			      
	Print.get_string() => str1 & print str1 &*)
				      
	update_components(compelts,mods') => compelts3 &

        Util.list_flatten([eq1, eq2, eq3]) => eq &
	Util.list_flatten([ieq1, ieq2, ieq3]) => ieq &
	Util.list_flatten([alg1, alg2, alg3]) => alg &
	Util.list_flatten([ialg1, ialg2,ialg3]) => ialg 
	-----------------------------------
	inst_extends_list(cache, env, mod, SCode.EXTENDS(tp,emod)::rest, impl)
	  => (cache''', env', mods',compelts3, eq, ieq, alg, ialg)

  rule	Debug.fprint("failtrace", "Failed inst_extends_list on EXTENDS\n")
	------------------------------------------------
	inst_extends_list(cache, env, mod, SCode.EXTENDS(tp,emod)::rest, impl) 
	  => fail

  rule	inst_extends_list(cache, env, mod, rest, impl)
	  => (cache', env', mods, compelts2, eq2, initeq2, alg2, ialg2) 
	------------------------------------------------
	inst_extends_list(cache, env, mod, elt::rest, impl) 
	  => (cache', env',mods, elt::compelts2, eq2, initeq2, alg2, ialg2) 

  axiom	inst_extends_list(cache, env, mod, [], impl) 
	  => (cache, env, mod, [], [], [], [], [])

  rule	Debug.fprint("failtrace",  "- inst_extends_list failed\n" )
	---------------------
	inst_extends_list(_,_,_,_,_) => fail
end

(** relation: update_components
 ** This relation takes a list of components and a Mod and returns a list of components with the modifiers updated.
 ** The relation is used when flattening the inheritance structure, resulting in a list of components to insert into
 ** the class definition. For instance model A extends B(modifiers) end A; will result in a list of components from B 
 ** which 'modifiers' should be applied to.
**)
relation update_components: (SCode.Element list, Mod.Mod) => SCode.Element list =

  axiom	update_components([],_) => []

  rule 	Mod.lookup_comp_modification(mod,id) => Mod.NOMOD &
	update_components(xs,mod) => res 
	--------------------------------
	update_components(SCode.COMPONENT(id,f,r,p,attr,tp,m)::xs,mod) 
	  => SCode.COMPONENT(id,f,r,p,attr,tp,m)::res

  rule	Mod.lookup_comp_modification(mod,id) => m1 &
	Mod.unelab_mod(m1) => m2 &
	update_components(xs,mod) => res 
	--------------------------------
	update_components(SCode.COMPONENT(id,f,r,p,attr,tp,m)::xs,mod) 
	  => SCode.COMPONENT(id,f,r,p,attr,tp,m2)::res

  rule	update_components(xs,mod) => res 
	--------------------------------
	update_components((c as SCode.EXTENDS(_,_))::xs,mod) 
	  => c::res

  rule	update_components(xs,mod) => res 
	--------------------------------
	update_components((c as SCode.CLASSDEF(_,_,_,_))::xs,mod) 
	  => c::res

  rule	update_components(xs,mod) => res 
	--------------------------------
	update_components((c as SCode.IMPORT(_))::xs,mod) 
	  => c::res

  rule	Debug.fprint("failtrace", "-update_components failed\n")
	----------------------
	update_components(_,_) => fail
end


(** relation: make_complete_type_names 
 **
 ** This relation takes an environment and an Element list and makes all references to types
 ** in the elements fully qualified, such that they can be looked up from a different env.
 ** This is needed when flattening the inheritance structure and inserting elements into the flattened
 ** class. The lookup of elements in the flattenend class is performed in that environment and thus 
 ** must the type names be expanded such that a lookup from this environment gives the same class as
** if the lookup was performed from the scope of the base class.
 **)
relation make_complete_type_names: (Env.Env, SCode.Element list) => SCode.Element list =
	
  axiom	make_complete_type_names(env, []) => []
	
  rule	make_complete_type_names(env, rest) => res &
	Lookup.complete_path(env, path) => path' 
	(*& print "completed to " & Absyn.path_string path' => s & print s & print "\n" *)
	------------------------------------
	make_complete_type_names(env, SCode.EXTENDS(path, mod)::rest)
	  => SCode.EXTENDS(path', mod)::res
	  
  rule	make_complete_type_names(env, rest) => res 
	-------------------------------------
	make_complete_type_names(env, (elt as SCode.CLASSDEF(_,_,_,_))::rest)
	  => elt::res

  rule	make_complete_type_names(env, rest) => res 
	--------------------------------------------------
	make_complete_type_names(env, (elt as SCode.IMPORT(_))::rest)
	  => elt::res
	  
  rule	make_complete_type_names(env, rest) => res &
	Lookup.complete_path(env, tp) => tp' 
        (*& print "completed to " & Absyn.path_string tp' => s & print s & print "\n" *)
	--------------------------------------------------
	make_complete_type_names(env, (SCode.COMPONENT(id,f,r,p,attr,tp,mod))::rest)
	  => SCode.COMPONENT(id,f,r,p,attr,tp',mod)::res
end


(** relation: inst_derived_classes
 ** 
 ** This relation takes a class definition and returns the
 ** elements and equations and algorithms of the class.
 ** If the class is derived, the class is looked up and the 
 ** derived class parts are fetched.
 **)

relation inst_derived_classes: 	(Env.Env, Mod.Mod, SCode.Class, bool) =>
	  (Env.Env, SCode.Element list, SCode.Equation list, 
	   SCode.Equation list, SCode.Algorithm list, SCode.Algorithm list) =
	
  axiom	inst_derived_classes(env,mod,SCode.CLASS(_,_,_,_,SCode.PARTS(elt,eq,ieq,alg,ialg,_)),_) => (env,elt,eq,ieq,alg,ialg)

  rule	Lookup.lookup_class(Cache.CACHE([],[]),env,tp,true) => (_,c,cenv) &
	(* Mod.lookup_modification_p(mod, c) => innermod & *)
	(* We have to merge and apply modifications as well! *)
	inst_derived_classes(cenv, mod, c, impl) 
	  => (env, elt, eq, ieq, alg, ialg)
	-------------------------------------
	inst_derived_classes(env, mod, SCode.CLASS(_,_,_,_,SCode.DERIVED(tp,_,dmod)),impl) 
	  => (env, elt, eq, ieq, alg, ialg) 

  rule	Print.print_buf "- inst_derived_classes failed\n" 
	----------------------
	inst_derived_classes(_,_,_,_) => fail
end


(** relation: inst_element_list
 **
 ** Moved to inst_classdef, FIXME: Move commments later
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 ** P.A, Modelica1.4: (enables declare before use)
 ** 1. "First names of declared local classes (and components) are found. Redeclarations are performed."
 ** This means that we first handle all CLASSDEF nodes and apply modifiers and declarations to them and 
 ** also COMPONENT nodes to add the variables to the environment.
 ** 2. Second, "base-classes are looked up, flattened and inserted into the class."
 ** This means that all EXTENDS nodes are handled.
 ** 3. Third, "Flatten the class, apply modifiers and instantiate all local elements."
 ** This handles COMPONENT nodes.
 **)

relation inst_element_list : (Cache.Cache, Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			    SCode.Element list, InstDims, bool, bool)
	    => (Cache.Cache, DAE.Element list, Env, Connect.Sets, ClassInf.State,
		Types.Var list) =
	
  axiom	inst_element_list(cache, env,_,_,csets,ci_state,[],_,_,_)
	    => (cache,[], env, csets, ci_state, [])
	
  rule  inst_element(cache,env,mod,pre,csets,ci_state,el,inst_dims,impl, packimpl)
	  => (cache',dae1,env',csets',ci_state',tys1) &
	inst_element_list(cache',env',mod,pre,csets',ci_state',els,inst_dims,impl,packimpl)
	  => (cache'',dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae 
	------------------------------
	inst_element_list(cache, env, mod, pre, csets, ci_state, el::els, inst_dims, impl, packimpl)
	  => (cache'', dae, env'', csets'', ci_state'', tys)

  rule	Debug.fprint("failtrace", "- inst_element_list2 failed\n")
	------------------------------------
	inst_element_list(_,_,_,_,_,_,els,_,_,_) => fail
end

relation classdef_elts: (SCode.Element list) => (SCode.Element list) =

  axiom classdef_elts ([]) => []
	
  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts ((cdef as SCode.CLASSDEF(_,_,_,_))::xs) => cdef::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts((imp as SCode.IMPORT(_))::xs) => imp::res

  rule	classdef_elts(xs) => res
	------------------------
	classdef_elts(_::xs) => res
end

relation extends_elts: (SCode.Element list) => (SCode.Element list) =

  axiom extends_elts ([]) => []
	
  rule	extends_elts(xs) => res
	------------------------
	extends_elts ((cdef as SCode.EXTENDS(_,_))::xs) => cdef::res

  rule	extends_elts(xs) => res
	------------------------
	extends_elts(_::xs) => res
end

relation component_elts: (SCode.Element list) => (SCode.Element list) =

  axiom component_elts ([]) => []
	
  rule	component_elts(xs) => res
	------------------------
	component_elts ((cdef as SCode.COMPONENT(_,_,_,_,_,_,_))::xs) => cdef::res

  rule	component_elts(xs) => res
	------------------------
	component_elts(_::xs) => res
end

relation add_classdefs_to_env : (Env, SCode.Element list, bool) => (Env) =

  axiom	add_classdefs_to_env(env,[],_) => env

  rule	Env.extend_frame_c(env,cl) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	------------------
	add_classdefs_to_env(env,(SCode.CLASSDEF(_,_,_,cl))::xs,impl) => env''

  rule	Env.extend_frame_i(env,imp) => env' &
	add_classdefs_to_env(env',xs,impl) => env''
	-------------------------
	add_classdefs_to_env(env,(SCode.IMPORT(imp))::xs,impl) => env''
end  

(** This first relation in the two stage solution changes parameters to structural parameters if they are affecting
 ** the number of variables or equations. For now by only looking at dimension sizes of components.
**)
relation add_components_to_env : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
				  SCode.Element list, SCode.Element list,  InstDims, bool)
	=> (Env) =

  axiom	add_components_to_env(env,_,_,_,_,[],_,_,_) => env 

  rule	(* ChecIf the component is a structural parameter, change it's
	 attribute to STRUCTPARAM *)
	get_crefs_from_compdims(allcomps) => crefs &
	member_crefs(Absyn.CREF_IDENT(n,[]),crefs) => true &
	add_components_to_env2(env,mod,pre,csets,cistate,[SCode.COMPONENT(n,final,repl,prot,
									  SCode.ATTR(ad,flow,acc,SCode.STRUCTPARAM,dir),t,m)],instdims,impl) => env' &
	
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       (comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m))::xs, allcomps,instdims,impl) => env''

  rule	(* Not structural parameter. No Change.*)
	get_crefs_from_compdims(allcomps) => crefs &
	member_crefs(Absyn.CREF_IDENT(n,[]),crefs) => false &
	add_components_to_env2(env,mod,pre,csets,cistate,[SCode.COMPONENT(n,final,repl,prot,
									  SCode.ATTR(ad,flow,acc,param,dir),t,m)],instdims,impl) => env' &
	
	add_components_to_env(env',mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------------------------------------------------------------------------
	add_components_to_env (env, mod, pre, csets, cistate, 
			       (comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m))::xs, allcomps,instdims,impl) => env''
	
  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       (SCode.IMPORT(_))::xs, allcomps,instdims,impl) => env''

  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       (SCode.EXTENDS(_,_))::xs, allcomps,instdims,impl) => env''

  rule	add_components_to_env(env,mod,pre,csets,cistate,xs,allcomps,instdims,impl) => env''
	------------------
	add_components_to_env(env, mod, pre, csets, cistate, 
			       (SCode.CLASSDEF(_,_,_,_))::xs, allcomps,instdims,impl) => env''

(*  rule	add_components_to_env(env,mods,pre,csets,ci_state,
				 xs,allcomps,inst_dims,impl) => env' 
	-----------------
	add_components_to_env(env,mods,pre,csets,ci_state,
				 nocomp::xs,allcomps,inst_dims,impl) => env'*)
	
  rule	Debug.fprint("failtrace", "- add_components_to_env failed\n" )
	-------------------------------------
	add_components_to_env(_,_,_,_,_,_,_,_,_) => fail
end


relation add_components_to_env2 : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			    SCode.Element list, InstDims, bool)
	    => (Env) =

  rule	Lookup.lookup_class(Cache.CACHE([],[]),env,t,true) => (_,cl,cenv) & 
	Debug.fprint ("decl", "got class \n") &

	(** PA: PROBLEM, Modifiers should be merged in this phase, but
	   since undeclared components can not be found (is done in this phase)
	   the modifiers can not be elaborated to get a variable binding.
	   Thus, we need to store the merged modifier for elaboration in the 
	   next stage. 
	   Save all modifiers in environment...
	   **)	

	(* Use type T_NOTYPE instead of as earier trying to instantiate, since instanitation might fail without having correct
	 modifications (e.g. when instanitating a partial class that must be redeclared through a modification)*)
	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
	    prot,Types.T_NOTYPE,Types.UNBOUND),SOME(comp),false) => env' & 
	add_components_to_env2(env',mods,pre,csets,ci_state,xs,inst_dims,impl) 
	  => env'' &
	Debug.fprint("decl", " updated env :") &
	Debug.fcall ("decl", Env.print_env, env'') 
	-----------------
	add_components_to_env2(env,mods,pre,csets,ci_state,
		     (comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m))::xs,inst_dims,impl) => env''

(*  rule	add_components_to_env2(env,mods,pre,csets,ci_state,
				 xs,inst_dims,impl) => env' 
	-----------------
	add_components_to_env2(env,mods,pre,csets,ci_state,
				 nocomp::xs,inst_dims,impl) => env' *)


  axiom	add_components_to_env2(env,_,_,_,_,[],_,_) => env

  rule	Debug.fprint("failtrace", "- add_components_to_env2 failed\n") &
	Debug.fprint("failtrace", "  - env: \n") & 
	Debug.fcall("failtrace", Env.print_env, env) & 
	Debug.fprint("failtrace", "\n")
	--------------------
	add_components_to_env2(env,_,_,_,_,_,_,_) => fail 
end

relation get_crefs_from_compdims: (SCode.Element list) => Absyn.ComponentRef list =

  axiom	get_crefs_from_compdims([]) => []
	
  rule	get_cref_from_dim(arraydim) => crefs1 &
	(*Util.list_map(crefs1,Absyn.cref_get_first) => crefs1' &*)
	get_crefs_from_compdims(xs) => crefs2 &
	(*Util.list_map(crefs2,Absyn.cref_get_first) => crefs2' &*)
	list_append(crefs1,crefs2) => crefs
	------------------------------------
	get_crefs_from_compdims(SCode.COMPONENT(_,_,_,_,SCode.ATTR(arraydim,_,_,_,_),_,_)::xs) => crefs

  rule	get_crefs_from_compdims(xs) => crefs
	------------------------------------
	get_crefs_from_compdims(_::xs) => crefs
end
(** This relation checks if a componentreferece is a member of a list of component references, disregarding subscripts.
 **)
relation member_crefs: (Absyn.ComponentRef, Absyn.ComponentRef list) => bool =

  rule	Absyn.cref_equal(cr,cr1) => true
	-------------------
	member_crefs(cr,cr1::xs) => true

  rule	Absyn.cref_equal(cr,cr1) => false &
	member_crefs(cr,xs) => res
	-------------------
	member_crefs(cr,cr1::xs) => res

  axiom	member_crefs(_,_) => false

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 ** Last two bools are implicit instanitation and implicit package instantiation
 **)

relation inst_element : (Cache.Cache, Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Element, InstDims, bool, bool)
	  => (Cache.Cache, DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** imports
	   ** imports are simply added to the current frame, so that the lookup rule can find them.
	   **)

  rule	Env.extend_frame_i(env,imp) => env'
	------------------------------------
	inst_element(cache, env, mod, pre, csets, ci_state, SCode.IMPORT(imp), instdims,_,_) 
	  => (cache, [], env', csets, ci_state, [])
		 
	(* If a variable is declared multiple times, the first is used *)

  rule	Lookup.lookup_ident_local(env,n) => (_,NONE,true) &
	Debug.fprint ("insttr", "variable already declared, using first def") 
	-------------------------------------
	inst_element(cache, env, mods, pre, csets, ci_state,
		     SCode.COMPONENT(n,final,repl,prot,_,_,_),_,_,_)
	  => (cache, [], env, csets, ci_state, []) 

  	  (* Illegal redeclarations *)

  rule	Lookup.lookup_ident_local(env,n) => (_,_,_) &
	Print.print_buf "# Trying to redeclare the class " & Print.print_buf n &
	Print.print_buf " as a variable\n, env =" &
	Env.print_env env
	------------------------
	inst_element(cache, env, mods, pre, csets, ci_state,
		     SCode.CLASSDEF(n,_,_,_),_,_,_)
	  => fail
	  
  rule	Lookup.lookup_class(Cache.CACHE([],[]), env,Absyn.IDENT(n),false) => (_,_,_) &
	Print.print_buf "# Trying to redeclare the variable " & Print.print_buf n &
	Print.print_buf " as a class\n"
	---------------------
	inst_element(cache, env, mods, pre, csets, ci_state,
		     SCode.COMPONENT(n,_,_,_,_,_,_),_,_,_)
	  => fail
	  
          (**  A new class definition
	   **
	   ** Put it in the current frame in the environment
	   **)

  rule	(* Redeclare of class definition, replaceable is true *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Mod.REDECL(final, [SCode.CLASSDEF(n2,f2,repl2,cls2)])) &
	  print "replacable classdef\n" &
	Debug.fprintln ("insttr", "*--*Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "*--*All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &
	inst_class_decl(cache, env, classmod, pre, csets, cls2, inst_dims, packimpl)
	  => (cache', env', dae)
	-------------------------------------------------
	inst_element(cache, env, mods, pre, csets, ci_state, 
		     SCode.CLASSDEF(n,_,true,c), inst_dims, impl, packimpl)
	  => (cache', dae, env', csets, ci_state, [])

  rule	(* Redeclare of class definition, replaceable is false *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) 
	  => (classmod as Mod.REDECL(final, [SCode.CLASSDEF(n2,f2,repl2,cls2)])) &
	Print.print_buf "# Trying to redeclare class " & Print.print_buf n &
	Print.print_buf " but class not declared as replacable.\n" 
	-------------------------------------------------
	inst_element(cache, env, mods, pre, csets, ci_state, 
		     SCode.CLASSDEF(n,_,false,c),inst_dims,impl,packimpl)
	  => fail

  rule	(* Classdefinition without redeclaration *)
	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	Debug.fprintln ("insttr", "**Classdef mods") &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "**All mods") &
	Debug.fcall ("insttr", Mod.print_mod, mods) &
	inst_class_decl(cache,env,classmod,pre,csets,c,inst_dims,packimpl) 
	  => (cache',env',dae)
	-------------------------------------------------------
	inst_element(cache, env, mods, pre, csets, ci_state, 
		     SCode.CLASSDEF(n,_,_,c),inst_dims,impl,packimpl)
	  => (cache', dae, env', csets, ci_state, []) 
	  
	  (**  A component
	   **
	   ** This is the rule for instantiating a model component.  A
	   ** component can be a structured subcomponent or a variable,
	   ** parameter or constant.  All of these are treated in a
	   ** similar way.
	   **
	   ** Lookup the class name, apply modifications and add the
	   ** variable to the current frame in the environment. Then
	   ** instantiate the class with an extended prefix.
	   **)
	
  rule	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &
	
	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation_ is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)
	Debug.fprintln ("insttr", "Looking up class modifications") &
	Mod.lookup_modification_p(mods,t) => classmod &
	Debug.fcall ("insttr", Mod.print_mod, classmod) &
	Debug.fprintln ("insttr", "Looking up component modifications") &
	Mod.lookup_comp_modification(mods,n) => mm &
	Debug.fcall ("insttr", Mod.print_mod, mm) &
	(* The types in the environment does not have correct Binding.
	   We must update those variables that is found in m into a new environment.*)
	let owncref = Absyn.CREF_IDENT(n,[]) &
	get_cref_from_mod(m) => crefs1' &
	remove_cref_from_crefs (crefs1', owncref) => crefs1 &
 	update_variables_in_env(mods,crefs1, env ,impl) => env2' &	
	get_cref_from_dim(ad) => crefs2' &
	remove_cref_from_crefs (crefs2', owncref) => crefs2 &
	update_variables_in_env(mods,crefs2,env2',impl) => env2 &
	(* Update the untyped modifiers to typed ones, and extract class *)
	(* and component modifiers again.*)
	Mod.update_mod(env2,pre,mods) => mods' &
	Mod.lookup_modification_p(mods',t) => classmod' &
	Mod.lookup_comp_modification(mods',n) => mm' &
		
	Debug.fprintln ("insttr", "Elaborating current modifications") &
	Mod.elab_mod(env2,pre,m) => m' &
	Debug.fcall ("insttr", Mod.print_mod, m') &

	Mod.merge(classmod',mm') => mod &
	Mod.merge(mod,m') => mod1 &

	redeclare_type(mod1,comp,env2,pre,impl) => (SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m),mod',env2') &

	Debug.fprint("insttr", "looking for type") &
	Debug.fcall("insttr",Dump.print_path,t) &
	Debug.fprint("insttr"," in env:") &
	Debug.fcall("insttr",Env.print_env,env) &
	Debug.fprint("insttr"," \n") &
	
	Lookup.lookup_class(cache,env,t,true) => (cache',cl,cenv) & 
	
	Debug.fprintl ("insttr", ["found type for: ", n, "\n"]) &
	
	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm', vn) &
	Debug.fprintln ("insttr", "Protection checked") &

	Mod.mod_equation mod' => eq &

	Debug.fprintln ("insttr", "mod equation done") &
	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env2',ad,eq,impl,NONE) => dims &
	Debug.fprintln ("insttr", "arraydim elabed") &
	(** Instantiate the component *)	
	inst_var(cache', cenv, mod', pre, csets, n, cl, attr, dims, [], inst_dims, impl)
	  => (cache'', dae, csets', ty) &
	Debug.fprintl ("insttr", ["instantiated: ", n, "\n"]) &

	(** The environment is extended (updated) with the new variable *)
	(** binding. *)

	make_binding (env2',attr,eq) => binding &
	Debug.fcall ("insttr", Types.print_binding, binding) &
	Debug.fcall ("insttr", print, "\n") &
	(* true in update_frame means the variable is now instantiated. *)
	Env.update_frame_v(env2',Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),true) => env' &

	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
					       
	Debug.fprint("insttr","inst_element Component succeeded\n") 
	-----------------------------------------------------------
	inst_element(cache,env,mods,pre,csets,ci_state,
		     comp as SCode.COMPONENT(n,final,repl,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m),inst_dims,impl,packimpl)
          => (cache', dae, env',csets',ci_state,
	      [Types.VAR(n,Types.ATTR(flow,acc,param,dir), prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(Cache.CACHE([],[]),env,t,false) => (_,cl,cenv) &
	Absyn.path_string(t) => s &
	Print.print_buf "# unknown class '" & Print.print_buf s & Print.print_buf "' while instantiating " &
	Prefix.prefix_add(n,[],pre) => pre' &
	Prefix.print_prefix_str pre' => ns &
	Print.print_buf ns & Print.print_buf "\n" &
	Debug.fcall ("instdb", Env.print_env, env)
	--------------------------
	inst_element(cache,env,_,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,repl,prot,_,t,_),_,_,_)
         => (cache,[],env,csets,ci_state,[])

  rule	Debug.fprint("failtrace", "- inst_element failed\n") &
	Debug.fcall("failtrace",SCode.print_element, el) &
	Debug.fprint("failtrace", "\n") 
	-----------------------------------------------------------------
	inst_element(_,_,_,_,_,_,el,_,_,_) => fail 

end	

relation remove_cref_from_crefs : (Absyn.ComponentRef list, Absyn.ComponentRef)
	  => Absyn.ComponentRef list =

  axiom	remove_cref_from_crefs ([],_) => []

  rule	let Absyn.CREF_IDENT(n1,[]) = cr1 &
	let Absyn.CREF_IDENT(n2,[]) = cr2 &
	n1 = n2 &
	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => rest'

  rule	remove_cref_from_crefs (rest, cr2) => rest'
	------------------------------------------
	remove_cref_from_crefs (cr1::rest, cr2) => cr1::rest'


end


(** relation: redeclare_type
 ** This relation takes a 'Mod' and an SCode.Element and if the modification contain
 ** a redeclare of that element, the type is changed and an updated element is returned
**)
relation redeclare_type: (Mod.Mod, SCode.Element,Env.Env,Prefix.Prefix,bool) => (SCode.Element,Mod.Mod,Env.Env) =

  rule	n1=n2 &
	get_cref_from_mod(mod) => crefs &
	update_variables_in_env(Mod.NOMOD (* m *),crefs,env,impl) => env' &
	Mod.elab_mod(env',pre,mod) => m' 
	--------------------------------
	redeclare_type (m as Mod.REDECL(_,(redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,mod))::rest),
			SCode.COMPONENT(n2,false,repl2,prot2,_,t2,_),env,pre,impl) => (redecl,m',env')

  rule	not n1=n2 &
	redeclare_type(Mod.REDECL(redfin,rest),comp,env,pre,impl) => (newcomp,mod,env')
	-------------
	redeclare_type (Mod.REDECL(redfin,(redecl as SCode.COMPONENT(n1,final,repl,prot,_,t,_))::rest),
			comp as SCode.COMPONENT(n2,false,repl2,prot2,_,t2,_),env,pre,impl) => (newcomp,mod,env')

  rule	redeclare_type(Mod.REDECL(redfin,rest),comp,env,pre,impl) 
	  => (newcomp,mod,env')
	  ----------------------------
	redeclare_type(Mod.REDECL(redfin,_::rest),comp,env,pre,impl) 
	  =>(newcomp,mod,env')

  axiom	redeclare_type(Mod.REDECL(redfin,[]),comp,env,pre,impl) => (comp,Mod.NOMOD,env)

  axiom	redeclare_type(mod,comp,env,pre,impl) => (comp,mod,env)

  rule	Debug.fprint("failtrace", "- redeclare_type failed\n")
	------------------------------------------------------
	redeclare_type(_,_,_,_,_) => fail
end


(** relation: inst_var
 **
 ** A component element in a class may consist of several subcomponents
 ** or array elements.  This relation is used to instantiate a
 ** component, instantiating all subcomponents and array elements
 ** separately.
 **)

relation inst_var : (Cache.Cache,
		     Env.Env,
		     Mod.Mod,
		     Prefix.Prefix,
		     Connect.Sets,
		     Ident,
		     SCode.Class,
		     SCode.Attributes,
		     DimExp list, 
		     int list,
		     InstDims,
		     bool)
	  => (Cache.Cache, DAE.Element list,Connect.Sets,Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)


	(** LS: Removed the part which checks if modelica_output is true
	 ** and generates variables with initialization expression from the
	 ** modifications, because it cannot handle right hand side which is a
	 ** component (T_COMPLEX) anyway. This case is handled by the rule below
	 ** which generates correct equations according to the modification.
	 ** Separate code can parse the DAE and put the rhs of the latest
	 ** equation inside the variable declaration, and discard all the
	 ** equations.
	 **)

  rule	(* Constants *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(cache,env,mod,pre',csets,cl,inst_dims,impl) 
	  => (cache',dae1,csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	(*inst_mod_equation(cr,ty,mod) => dae2 &*)
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e),inst_dims)
	  => dae3 & 
	list_append(dae1',dae3) => dae 
	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))
	--------------------------
	inst_var(cache,env,mod as Mod.MOD(_,_,SOME(Mod.TYPED(e,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt as SCode.CONST,dir),
		 [],idxs,inst_dims,impl)
          => (cache',dae,csets',ty)

  rule	(* Parameters *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	inst_class(cache,env,mod,pre',csets,cl,inst_dims,impl) 
	  => (cache',dae1,csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
(*	inst_mod_equation(cr,ty,mod) => dae2 &*)
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), SOME(e),inst_dims)
	  => dae3 &  
	list_append(dae1',dae3) => dae
	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))
	--------------------------
	inst_var(cache,env,mod as Mod.MOD(_,_,SOME(Mod.TYPED(e,_))),pre,csets,n,cl,SCode.ATTR(_,flow,acc, vt as SCode.PARAM,dir),
		 [],idxs,inst_dims,impl)
          => (cache',dae,csets',ty)

  rule	(* Variables *)
	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	(* This is where redeclare should be handled *)
	Debug.fprintl ("insttr", ["instantiating var class: ", n, "\n"]) &
	Debug.fcall ("envprint", Env.print_env, env) & 
	inst_class(cache,env,mod,pre',csets,cl,inst_dims,impl) 
	  => (cache',dae1,csets',ty,st) &
	fix_direction(dae1,dir) => dae1' &
	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod) => dae2 &
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir), NONE,inst_dims)
	  => dae3 & 
 
	list_append(dae1',dae2) => daex &
	list_append(daex,dae3) => dae
	& Debug.fcall ("instvardae",DAE.dump2,DAE.DAE(dae))
	--------------------------
	inst_var(cache,env,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		 [],idxs,inst_dims,impl)
          => (cache',dae,csets',ty)




  rule	inst_dim_exp (dim,impl) => dime &
	list_append(inst_dims,[dime]) => inst_dims' &
	inst_array(cache,env,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs,inst_dims',impl)
	  => (cache',dae, csets', ty) &
	inst_dim_type dim => dimt &
	Types.lift_array(ty,dimt) => ty'
	-------------------------------
	inst_var(cache,env,mod,pre,csets,n,cl,attr,dim::dims,idxs,inst_dims,impl)
          => (cache',dae,csets',ty')

  rule	Debug.fprint("failtrace", "- inst_var failed: ") & 
	Debug.fprint("failtrace",  n) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------
	inst_var(_,_,_,_,_,n,_,_,_,_,_,_) => fail
	
end

relation get_cref_from_mod: SCode.Mod => Absyn.ComponentRef list =

  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_mod(SCode.REDECL(b,xs)) => res1 &
	get_cref_from_mod(m) => res2 &
	list_append(res1,res2) => res 
	(*&Util.list_map(res,Absyn.cref_get_first) => res'*)
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, SCode.COMPONENT(n,_,_,_,_,_,m)::xs)) 
	  => res
  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_mod(SCode.REDECL(b,xs)) => res
	-----------------------------
	get_cref_from_mod(SCode.REDECL(b, _::xs)) 
	  => res

  axiom	get_cref_from_mod(SCode.REDECL(b,[])) => []

  rule	(* Find in sub modifications e.g A(B=3) find B *)
	get_cref_from_submods(submods) => l1 &
	Absyn.get_cref_from_exp(e) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_mod(mod as SCode.MOD(_,submods,SOME(e))) => res

  rule	get_cref_from_submods(submods) => res
	-------------------------------------
	get_cref_from_mod(SCode.MOD(_,submods,NONE)) => res 
	
  axiom	get_cref_from_mod(_) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_mod failed\n")
	----------
	get_cref_from_mod(_) => fail
end

relation get_cref_from_dim: Absyn.ArrayDim => Absyn.ComponentRef list =
	
  rule	get_cref_from_dim(rest) => l1 &
	Absyn.get_cref_from_exp(exp) => l2 &
	list_append(l1,l2) => res
	----------------------
	get_cref_from_dim(Absyn.SUBSCRIPT(exp)::rest) => res
	
  rule	get_cref_from_dim(rest) => res
	------------------------------
	get_cref_from_dim(Absyn.NOSUB::rest) => res

  axiom	 get_cref_from_dim([]) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_dim failed\n")
	------------
	get_cref_from_dim(_) => fail
end

relation get_cref_from_submods: (SCode.SubMod list) => Absyn.ComponentRef list =

  rule	get_cref_from_mod(mod) => res1 &
	get_cref_from_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_submods(SCode.NAMEMOD(_,mod)::rest) => res
	   
	axiom get_cref_from_submods([]) => []
end

relation get_cref_from_elabed_mod: Mod.Mod => Absyn.ComponentRef list =

  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	Print.print_buf "cref from redeclare, mod:" &
	get_cref_from_elabed_mod(Mod.REDECL(b,xs)) => res1 &
	get_cref_from_mod(m) => res2 &
	list_append(res1,res2) => res
	-----------------------------
	get_cref_from_elabed_mod(Mod.REDECL(b, SCode.COMPONENT(n,_,_,_,_,_,m)::xs)) 
	  => res
  rule	(* For redeclarations e.g "redeclare B2 b(cref=<expr>)", find cref *)
	get_cref_from_elabed_mod(Mod.REDECL(b,xs)) => res
	-----------------------------
	get_cref_from_elabed_mod(Mod.REDECL(b, _::xs)) 
	  => res

  axiom	get_cref_from_elabed_mod(Mod.REDECL(b,[])) => []

  rule	(* Find in sub modifications e.g A(B=3) find B *)
	get_cref_from_elabed_submods(submods) => l1 &
	get_cref_from_elabed_eqmod(e) => l2 &
	list_append(l1,l2) => res
	-------------------------
	get_cref_from_elabed_mod(mod as Mod.MOD(_,submods,SOME(e))) => res

  rule	get_cref_from_elabed_submods(submods) => res
	-------------------------------------
	get_cref_from_elabed_mod(Mod.MOD(_,submods,NONE)) => res 
	
  axiom	get_cref_from_elabed_mod(_) => []

  rule	Debug.fprint("failtrace", "- get_cref_from_mod failed\n")
	----------
	get_cref_from_elabed_mod(_) => fail
end

relation get_cref_from_elabed_eqmod: (Mod.EqMod) => Absyn.ComponentRef list =
	
  rule	Absyn.get_cref_from_exp(exp) => res
	---------------------------------
	get_cref_from_elabed_eqmod(Mod.UNTYPED(exp)) => res

	(* Otherwise, empty list, since typed expressions does not need to be updated *)
  axiom	get_cref_from_elabed_eqmod(_) => []
end

relation get_cref_from_elabed_submods: (Mod.SubMod list) => Absyn.ComponentRef list =

  rule	get_cref_from_elabed_mod(mod) => res1 &
	get_cref_from_elabed_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_elabed_submods(Mod.NAMEMOD(_,mod)::rest) => res
	   
  rule	get_cref_from_elabed_mod(mod) => res1 &
	get_cref_from_elabed_submods(rest) => res2 &
	list_append(res1,res2) => res
	-------------------------------
	get_cref_from_elabed_submods(Mod.IDXMOD(_,mod)::rest) => res

	axiom get_cref_from_elabed_submods([]) => []
end

relation update_variables_in_env:(Mod.Mod,Absyn.ComponentRef list, Env.Env, bool) 
	=> Env.Env =

  rule	update_variable_in_env(mods,cr,env,impl) => env' &
	update_variables_in_env(mods,rest,env',impl) => env''
	-------------------------------------------
	update_variables_in_env(mods,cr::rest,env,impl) => env''

  rule	Debug.fprint("decl", "update_variables_in_env finished\n")
	---------------
	update_variables_in_env(_,[],env,impl) => env
end

relation update_variable_in_env: (Mod.Mod,Absyn.ComponentRef, Env.Env, bool) 
	  => Env.Env =
	
  rule	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME(SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m)),_) &

	Lookup.lookup_class(Cache.CACHE([],[]),env,t,false) => (_,cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	update_variables_in_env(mods,crefs,env,impl) => env2' &
	
	get_cref_from_dim(ad) => crefs2 &
	update_variables_in_env(mods,crefs2,env2',impl) => env2 &

	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m) => m' &

	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	
	Mod.mod_equation mod' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env2,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(Cache.CACHE([],[]), cenv, mod', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], false)
	  => (_, dae1, csets', ty) &
	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env2,attr,eq) => binding &

	Env.update_frame_v(env2,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),false) => env' 
	----------------------------------
	update_variable_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,impl) => env'

  rule	Lookup.lookup_ident(env,id) => (ty,NONE,_) 
	----------------------------------
	update_variable_in_env (mods,cref as Absyn.CREF_IDENT(id,subscr),env,impl) => env
	
  rule	(* If first part of ident is a class, e.g StateSelect.None, nothing to update *)
	Lookup.lookup_class(Cache.CACHE([],[]),env,Absyn.IDENT(id),false) => (_,cl,cenv)
	--------------------------------------------------------------------
	update_variable_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,impl) => env

  rule	(* For qualified names, e.g. a.b.c, instanitate component a *)
	Lookup.lookup_ident(env,id) 
	  => (ty, 
	      SOME(SCode.COMPONENT(n,final,repl,prot,
				   attr as SCode.ATTR(ad,flow,acc,param,dir),
				   t,m)),_) &
	
	Lookup.lookup_class(Cache.CACHE([],[]),env,t,false) => (_,cl,cenv) & 

	get_cref_from_mod(m) => crefs &
 	update_variables_in_env(mods,crefs,env,impl) => env2' &
	
	get_cref_from_dim(ad) => crefs2 &
	update_variables_in_env(mods,crefs2,env2',impl) => env2 &

	(* Prefix does not matter, since we only update types in env, and does
	   not make any dae elements, etc.. *)
	Mod.elab_mod(env2,Prefix.NOPRE,m) => m' &

	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	
	Mod.mod_equation mod' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)
	elab_arraydim(env2,ad,eq,impl,NONE) => dims &

	(** Instantiate the component *)	
	inst_var(Cache.CACHE([],[]), cenv, mod', Prefix.NOPRE, [], n, cl, attr,
		 dims, [], [], false)
	  => (_, dae1, csets', ty) &
	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env2,attr,eq) => binding &

	Env.update_frame_v(env2,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding),false) => env' 
	------------
	update_variable_in_env(mods, Absyn.CREF_QUAL(id,_,_),env,impl) => env'

  rule	Debug.fprint("failtrace", "-update_variable_in_env failed, ident =") &
	Debug.fcall("failtrace", Dump.print_component_ref, cref) &
	Debug.fprint("failtrace", "\n" )
	---------------------------
	update_variable_in_env(_,cref,env,impl) => env
end

relation inst_dim_exp : (DimExp, bool) => Exp.Subscript =

  rule	Print.print_buf "# Error, can not determine size of array.\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.WHOLEDIM,_),false) => fail

  rule	Print.print_buf "# Error, can not determine size of array. SLICE\n"
	-------------------------------------------
	inst_dim_exp (DIMEXP(Exp.SLICE(_),_),false) => fail

  axiom	inst_dim_exp (DIMEXP(e as Exp.WHOLEDIM,_),true) => e
  axiom	inst_dim_exp (DIMINT(i),_) => Exp.INDEX(Exp.ICONST(i))

  axiom	inst_dim_exp (DIMEXP(e as Exp.INDEX(_),_),_) => e

end

relation inst_dim_type : DimExp => int option =

  axiom	inst_dim_type DIMINT(i) => SOME(i)
  axiom	inst_dim_type DIMEXP(_,_) => NONE

end

relation fix_direction : (DAE.Element list, Absyn.Direction)
	  => DAE.Element list =


  axiom	fix_direction ([],_) => []

  rule	absyn_dir_to_dae_dir dir => dir' &
	fix_direction (r,dir) => r'
	-----
	fix_direction (DAE.VAR(cr,vk,_,t,e,id)::r,dir) 
	  => DAE.VAR(cr,vk,dir',t,e,id)::r'

  rule	fix_direction(r,dir) => r'
	---------------------------
	fix_direction (x::r,dir) => x::r'

end

relation absyn_dir_to_dae_dir : Absyn.Direction => DAE.VarDirection =
	
  axiom	absyn_dir_to_dae_dir Absyn.INPUT  => DAE.INPUT
  axiom	absyn_dir_to_dae_dir Absyn.OUTPUT => DAE.OUTPUT
  axiom	absyn_dir_to_dae_dir Absyn.BIDIR  => DAE.BIDIR

end

(** relation: inst_array
 **
 ** When an array is instantiated by `inst_var', this relation is used
 ** to go through all the array elements and instantiate each array
 ** element separately.
 **)

relation inst_array : (Cache.Cache,
		       Env.Env,
		       Mod.Mod,
		       Prefix.Prefix,
		       Connect.Sets,
		       Ident,
		       (SCode.Class*SCode.Attributes),
		       int,
		       DimExp,
		       DimExp list,
		       int list,
		       InstDims,
		       bool
		       )
	  => (Cache.Cache, DAE.Element list, Connect.Sets, Types.Type) =

  rule	inst_var(cache,env,mod,pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl)
	  => (cache',dae,csets,ty)
	-----------------
	inst_array(cache,env,mod,pre,csets,n,(cl,attr),i,DIMEXP(_,_),dims,idxs,inst_dims,impl)
	  => (cache',dae,csets,ty)

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(cache,env,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl)
	  => (cache,[], csets, Types.T_NOTYPE)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	inst_var(cache,env,mod',pre,csets,n,cl,attr,dims,i::idxs,inst_dims,impl)
	  => (cache',dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(cache',env,mod,pre,csets',n,(cl,attr),i',DIMINT(stop),dims,idxs,inst_dims,impl)
	  => (cache'',dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(cache,env,mod,pre,csets,n,(cl,attr),i,DIMINT(stop),dims,idxs,inst_dims,impl)
          => (cache'',dae,csets'',ty)

  rule	Debug.fprint("failtrace", "- inst_array failed: ") &
	Debug.fcall("failtrace", Print.print_buf,  n) &
	Debug.fprint("failtrace", "\n") 
	--------------------------------------------------
	inst_array(_,_,_,_,_,n,(_,_),_,_,_,_,_,_) => fail
	
end

(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Mod.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ArrayDim, Mod.EqMod option, bool,Interactive.InteractiveSymbolTable option)
	  => DimExp list =

  rule	elab_arraydim_decl(env,ad,impl,cf) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,ad,NONE,impl,cf) => dim'

  rule	elab_arraydim_decl(env,ad,impl,cf) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3
	---------------------------------
	elab_arraydim(env,ad,SOME(Mod.TYPED(e,Types.PROP(t,c))),impl,cf) => dim3

  rule	elab_arraydim_decl(env,ad,impl,cf) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	Print.print_buf "# Array dimension mismatch\n" &
	Print.print_buf "    expression " & Exp.print_exp e &
	Print.print_buf " has type " & Types.print_type t & Print.print_buf "\n" &
	Print.print_buf "    expected array dimensions [" &
	print_dim dim1 & Print.print_buf "]\n"
	---------------------------------
	elab_arraydim(env,ad,SOME(Mod.TYPED(e,Types.PROP(t,c))),impl,cf) => fail


  rule	Debug.fprint("failtrace", "- elab_arraydim failed\n")
	-------------------------------------
	elab_arraydim(_,_,_,_,_) => fail

end

(** relation: print_dim
 **
 ** This relation prints array dimensions.  The code is not included
 ** in the report.
 **)

(*!ignorecode*)
relation print_dim : (DimExp option) list => () =

  rule	Print.print_buf ":"
	---------
	print_dim [NONE]

  rule	int_string x => s & Print.print_buf s
	---------------------------
	print_dim [SOME(DIMINT(x))]

  rule	Exp.print_subscript x
	---------------------------
	print_dim [SOME(DIMEXP(x,_))]

  rule	Print.print_buf ":," & print_dim xs
	-------------------------
	print_dim NONE::xs

  rule	int_string x => s & Print.print_buf s & Print.print_buf "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMINT(x))::xs

rule	Exp.print_subscript x & Print.print_buf "," & print_dim xs
	------------------------------------------------
	print_dim SOME(DIMEXP(x,_))::xs

end

relation print_dim2 : DimExp  list => () =

  rule	int_string x => s & Print.print_buf s
	---------------------------
	print_dim2 [DIMINT(x)]

  rule	Exp.print_subscript x
	---------------------------
	print_dim2 [DIMEXP(x,_)]

  rule	int_string x => s & Print.print_buf s & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMINT(x)::xs

rule	Exp.print_subscript x & Print.print_buf "," & print_dim2 xs
	------------------------------------------------
	print_dim2 DIMEXP(x,_)::xs
  axiom	print_dim2[] => ()

end
(*!includecode*)

(** relation: elab_arraydim_decl
 **
 ** Given an `Absyn.ArrayDim', this relation evaluates all dimension
 ** size specifications, creating a list of (optional) integers.  When
 ** the array dimension size is specified as `:', the result will
 ** contain `NONE'.
 **)

relation elab_arraydim_decl : (Env.Env, Absyn.ArrayDim, bool, Interactive.InteractiveSymbolTable option)
	    => (DimExp option) list =

  axiom	elab_arraydim_decl(_,[],_,_) => []

  rule	(*Print.print_buf "NOSUB in elab_arraydim_decl\n" & *)
	elab_arraydim_decl(env,ds,impl,cf) => l 	
	-------------------------------
	elab_arraydim_decl(env,Absyn.NOSUB::ds,impl,cf) => NONE::l

  rule	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP(Types.T_INTEGER(_),_),_) &  
	    (* _ Was true, but structural parameters must be given 
	       the numerical value in order to instantiate successfully.
	       PA: This is true for normal models, e.g. model test Real x[n]; end test;
	       It is NOT true for functions, or other implicit instantiated models. 
	     *)
	Static.ceval(env,e,impl,st) => (Values.INTEGER(i),_) &
 	elab_arraydim_decl(env,ds,impl,st) => l
	-------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds,impl,st) => SOME(DIMINT(i))::l

  rule	Static.elab_exp(env, d,impl,st)
	    => (e,Types.PROP(Types.T_INTEGER(_),true),_) &  
	    (* _ Was true, but structural parameters must be given 
	       the numerical value in order to instantiate successfully.
	       PA: This is true for normal models, e.g. model test Real x[n]; end test;
	       It is NOT true for functions, or other implicit instantiated models. 
	     *)
	Static.ceval(env,e,impl,st) => (Values.INTEGER(i),_) &
 	elab_arraydim_decl(env,ds,impl,st) => l
	-------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds,impl as true,st) => SOME(DIMINT(i))::l

  rule	Static.elab_exp(env, d,impl,st) => (e,Types.PROP(Types.T_INTEGER(_),false),_) &
	elab_arraydim_decl(env,ds,impl,st) => l
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds,impl,st) 
	  => SOME(DIMEXP(Exp.INDEX(e),NONE))::l 

  rule	Static.elab_exp(env,d,impl,st)
	  => (e,Types.PROP(t,_),_) &
	Print.print_buf "# Array dimensions must be integer\n" &
	Print.print_buf "    expression: " & Exp.print_exp e &
 	Print.print_buf " (" & Types.print_type t & Print.print_buf ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds,impl,st) => fail

  rule	Debug.fprint("failtrace", "- elab_arraydim_decl failed\n")
	-------------------------------------
	elab_arraydim_decl(_,_,_,_) => fail     
end

(** relation: complete_arraydim
 **
 ** This relation converts a list of optional integers to a list of
 ** integers.  If one element of the list is `NONE', this relation
 ** will fail.
 **
 ** This is used to check that an array specification contain fully
 ** specified array dimension sizes.
 **)

relation complete_arraydim : (DimExp option) list => DimExp list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim NONE::xs => DIMEXP(Exp.WHOLEDIM,NONE)::xs'

end

(** relation: compatible_arraydim
 **
 ** Given two, possibly incomplete, array dimension size
 ** specifications as list of optional integers, this relation checks
 ** whether they are compatible.  Being compatible means that they
 ** have the same number of dimension, and for every dimension at
 ** least one of the lists specifies its size.  If both lists specify
 ** a dimension size, they have to specify the same size.
 **)

relation compatible_arraydim : ((DimExp option) list,(DimExp option) list)
	  => DimExp list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMINT(y))::ys) 
	  => DIMINT(x)::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(x)),NONE),DIMEXP(y,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMINT(x))::xs,SOME(DIMEXP(y,e))::ys)
	  => de::l

  rule	arraydim_condition(DIMEXP(Exp.INDEX(Exp.ICONST(y)),NONE),DIMEXP(x,e))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e))::xs,SOME(DIMINT(y))::ys) 
	  => de::l

  rule	arraydim_condition(DIMEXP(x,e1),DIMEXP(y,e2))
	  => de &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(DIMEXP(x,e1))::xs,SOME(DIMEXP(y,e2))::ys)
	  => de::l


  rule	compatible_arraydim(xs,ys) => l
	--------------------------------
	compatible_arraydim (NONE::xs,NONE::ys) 
	  => DIMEXP(Exp.WHOLEDIM,NONE)::l

  rule	Debug.fprint("failtrace", "- compatible_arraydim failed\n")
	--------------------------------------
	compatible_arraydim (_,_) => fail

end

relation arraydim_condition : (DimExp, DimExp) => DimExp =
	
  axiom arraydim_condition (de,_) => de

end
(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => DimExp option list =

  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(NONE),t), _::ad) 
	  => NONE::l
	
  rule	elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(SOME(i)),t), _::ad) 
	  => SOME(DIMINT(i))::l
	
 axiom elab_arraydim_type(_,[]) => []

 (* PR, for debugging *)
  rule 	Debug.fprint("failtrace", "Undefined!") &
	Debug.fprint("failtrace", " The type detected: ") &
  	Debug.fcall("failtrace", Types.print_type, t)
       --------------------
	elab_arraydim_type(t,_::ad) => fail
end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class,InstDims, bool)
	  => (Cache.Cache, Env.Env, DAE.Element list) =

  rule	Debug.fprint("insttr","+\tinst_class_decl called\n") &
	Env.extend_frame_c(env,c) => env' &
	Debug.fprint("insttr","+\textended frame\n") &
	implicit_instantiation(cache,env',Mod.NOMOD,pre,csets,c,inst_dims,packimpl) 
	  => (cache', env'',dae) &
	Debug.fprint("insttr","+\timplicit instantiation of ") &
	Debug.fprint("insttr",n) & Debug.fprint("insttr", " finshed\n\n") 
	----------------------------------
	inst_class_decl(cache,env,mod,pre,csets,c as SCode.CLASS(n,_,_,restr,_),inst_dims,packimpl)
	  => (cache', env'', dae)

  rule	Debug.fprint("failtrace",  "- inst_class_decl failed\n Env=") &
	Debug.fcall("failtrace",Env.print_env, env )
	----------------------------------
	inst_class_decl(cache,env,_,_,_,_,_,_) => fail
end

(** relation implicit_instantiation
 ** This relation adds types to the environment.
 **
 ** If a class definition is a function or a package or an enumeration , 
 ** it is implicitly instantiated and added as a type binding under the
 ** same name as the class name.
 **)

relation implicit_instantiation : (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool)
	  => (Cache.Cache, Env.Env, DAE.Element list) =

(* LS:This rule extends the frame with the package as a type, but
inst_class also extends the frame with the package as a class. Is this
correct?
* PA: No, since we have now a special relation for looking up variables, first checking 
* the types and thereafter checking classes.
*)
(* Removed
  rule	Prefix.prefix_add(n,[],pre) => pre' &
(*	let pre' = pre & *)
	Debug.fprint ("insttr","implicit_instantiation called.\n") &
	print "implicit_instantiation  of " & print n & print " called.\n" &
	inst_class(cache,env,mod,pre',csets,c,inst_dims,true) 
	 => (cache', dae, csets', ty, st) &
	Debug.fprint ("insttr","implicit_instantiation inst class done.\n") &
	print "implicit_instantiation of " & print n & print " class done.\n" &
	Env.extend_frame_t(env, n, ty) => env' &
(*	let env' = env & *)
	Debug.fprintl ("insttr", ["implicit_instantiation done:", n, "\n"])
	--------------------------------------
	implicit_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_PACKAGE,_),
			       inst_dims)
	  => (cache', env', dae)
Removed *)

(* LS: changed from returning empty dae to returning a DAE.FUNCTION *)
(* LS: removed prefix because function elements shouldn't have
   one. They will contain the elements locally *)

(*  rule	(*Prefix.prefix_add(n,[],pre) => pre' &*)
	inst_class(cache, env, mod, pre, csets, c, inst_dims, true) 
	  => (cache', dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
        package_prefix (env, Absyn.IDENT(n)) => fpath
	--------------------------------------
	implicit_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
			       inst_dims, false)
	  => (cache', env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])


  rule	(* External functions should also have their type in env, but no dae! *)
	inst_class(cache, env, mod, pre, csets, c, inst_dims, true) 
	  => (cache', dae, csets', ty, st) &
	
	Env.extend_frame_t(env, n, ty) => env'	&
        package_prefix (env, Absyn.IDENT(n)) => fpath &
        let prot = false & (* how to get this? *)
	inst_classdef (cache', env, mod, pre, csets, ClassInf.UNKNOWN(n), parts, restr, 
		       prot, inst_dims, true, false) 
	  =>(cache'', _, tempenv,_,_,_) &

	inst_ext_decl(tempenv, n, parts) => extdecl
	--------------------------------------
	implicit_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, false)
	  => (cache'', env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])
*)

  rule	(*let ty = Types.T_ENUMERATION(l) &
	Env.extend_frame_t(env,n,ty) => env' & *)
	inst_enumeration(n,l) => enumclass &
	Env.extend_frame_c(env,enumclass) => env'' 
	-----------------------------------
	implicit_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_TYPE, SCode.ENUMERATION(l)),inst_dims,_)
	=> (cache, env'', [])

  axiom	implicit_instantiation(cache, env, mod, pre, csets, c, _, _) => (cache, env, [])
	
  rule	Debug.fprint("failtrace", "- implicit_instantiation failed\n")
	----------------
	implicit_instantiation(_,_,_,_,_,_,_,_) => fail
end


relation package_prefix : (Env.Env, Absyn.Path) => Absyn.Path =

  rule	Env.get_env_path env => NONE
	----------------------------
	package_prefix (env,path) => path

  rule	Env.get_env_path env => SOME(path') &
	Absyn.join_paths(path',path) => path''
	--------------------------------------
	package_prefix (env,path) => path''

end


relation implicit_function_instantiation : (Cache.Cache, Env.Env, Mod.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class,InstDims, bool)
	  => (Cache.Cache, Env.Env, DAE.Element list) =

rule	(*Prefix.prefix_add(n,[],pre) => pre' &*)
	inst_class(cache, env, mod, pre, csets, c, inst_dims, true) 
	  => (cache', dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env' &
        package_prefix (env, Absyn.IDENT(n)) => fpath
	--------------------------------------
	implicit_function_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_,SCode.R_FUNCTION,_),
			       inst_dims, false)
	  => (cache', env', [DAE.FUNCTION(fpath, DAE.DAE(dae), ty)])


  rule	(* External functions should also have their type in env, but no dae! *)
	inst_class(cache, env, mod, pre, csets, c, inst_dims, true) 
	  => (cache', dae, csets', ty, st) &
	
	Env.extend_frame_t(env, n, ty) => env'	&
        package_prefix (env, Absyn.IDENT(n)) => fpath &
        let prot = false & (* how to get this? *)
	inst_classdef (cache', env, mod, pre, csets, ClassInf.UNKNOWN(n), parts, restr, 
		       prot, inst_dims, true, false) 
	  =>(cache'', _, tempenv,_,_,_) &

	inst_ext_decl(tempenv, n, parts) => extdecl
	--------------------------------------
	implicit_function_instantiation(cache, env, mod, pre, csets,
			       c as SCode.CLASS(n,_,_, restr as SCode.R_EXT_FUNCTION, 
			       parts as SCode.PARTS(els,_,_,_,_,_)),
			       inst_dims, false)
	  => (cache'', env', [DAE.EXTFUNCTION(fpath,DAE.DAE(dae), ty, extdecl)])
end

(** relation: inst_ext_decl
 **
 ** This relation handles the external declaration. If there is an explicit call
 ** of the external function, the component references are looked up and
 ** inserted in the argument list, otherwise the input and output parameters are
 ** inserted in the argument list with their order. The return type is
 ** determined according to the specification; if there is a explicit call and a
 ** lhs, which must be an output parameter, the type of the function is that
 ** type. If no explicit call and only one output parameter exists, then this
 ** will be the return type of the function, otherwise the return type will be
 ** void. 
 **)

relation inst_ext_decl: (Env.Env, Ident, SCode.ClassDef) => DAE.ExternalDecl =
	
  rule	is_ext_explicit_call (extdecl) &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl) => fargs &
	inst_ext_get_rettype (env, extdecl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(_,_,_,_,_,SOME(extdecl))) => daeextdecl

  rule	not is_ext_explicit_call (orgextdecl) &
	inst_ext_make_externaldecl (n, els, orgextdecl) => extdecl &
	inst_ext_get_fname (extdecl, n) => fname &
	inst_ext_get_fargs (env, extdecl) => fargs &
	inst_ext_get_rettype (env, extdecl) => rettype &
	inst_ext_get_lang (extdecl) => lang &
	let daeextdecl = DAE.EXTERNALDECL(fname,fargs,rettype,lang)
	-------------------------------------
	inst_ext_decl (env, n, SCode.PARTS(els,_,_,_,_,SOME(orgextdecl))) => daeextdecl

  rule	Debug.fprint("failtrace",  "#-- inst_ext_decl failed" ) &
	Debug.fcall("failtrace", Env.print_env, env) 
	--------------------------
	inst_ext_decl (env, _, _) => fail
end


(** relation: is_ext_explicit_call
 ** 
 ** If the external function id is present, then a function call must
 ** exist, i.e. explicit call was written in the external clause.
 **)

relation is_ext_explicit_call : Absyn.ExternalDecl => () =

  axiom is_ext_explicit_call Absyn.EXTERNALDECL(SOME(id),_,_,_)

end

(** relation: inst_ext_make_externaldecl
 **
 ** This relation generates a default explicit function call, 
 ** when it is omitted. If only one output variable exists, the 
 ** implicit call is equivalent to 
 ** 
 **    external "C" output_var=func(input_var1, input_var2,...)
 **
 ** with the input_vars in their declaration order. If several output 
 ** variables exists, the implicit call is equivalent to
 **
 **    external "C" func(var1, var2, ...)
 **
 ** where each var can be input or output.
 **)

relation inst_ext_make_externaldecl: (Ident, SCode.Element list, Absyn.ExternalDecl) 
	  => Absyn.ExternalDecl = 

  (* the case with only one output var, and that cannot be array, otherwise
      inst_ext_make_crefs outvar will fail *)
  rule	Util.list_matching (els, is_output_var) => outvar::[] &
(*	is_not_array_type_var outvar & *)
	Util.list_matching (els, is_input_var) => invars &
	Util.list_map (invars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	inst_ext_make_crefs outvar => [Absyn.CREF(retcref)] &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,SOME(retcref),exps)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_)) 
	  => extdecl

  rule	Util.list_matching (els, is_inout_var) => inoutvars &
	Util.list_map (inoutvars, inst_ext_make_crefs) => explists &
	Util.list_flatten explists => exps &
	let extdecl = Absyn.EXTERNALDECL(SOME(id),lang,NONE,exps)
	------------------------------------------------
	inst_ext_make_externaldecl (id, els, Absyn.EXTERNALDECL(_,lang,_,_)) 
	  => extdecl

  rule	Debug.fprint("failtrace", "#-- inst_ext_make_externaldecl failed\n")
	---------------------------------------------------------
	inst_ext_make_externaldecl (_,_,_) => fail

end	

relation is_inout_var : SCode.Element => () =

  rule is_output_var e
       --------------
       is_inout_var e

  rule is_input_var e
       --------------
       is_inout_var e
end

relation is_output_var : SCode.Element => () =
  axiom	is_output_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.OUTPUT),_,_)
end

(* subscript list is empty => not an array type *)
relation is_not_array_type_var : SCode.Element => () =
  axiom	is_not_array_type_var SCode.COMPONENT(_,_,_,_,SCode.ATTR([],_,_,_,_),_,_)
end

relation is_input_var : SCode.Element => () =
  axiom	is_input_var SCode.COMPONENT(_,_,_,_,SCode.ATTR(_,_,_,_,Absyn.INPUT),_,_)
end

relation inst_ext_make_crefs : SCode.Element => Absyn.Exp list =

  rule	inst_ext_make_crefs_2 (id,dims,1) => sizelist &
	let crlist = Absyn.CREF(Absyn.CREF_IDENT(id,[]))::sizelist
	-----------------------------------------------
	inst_ext_make_crefs SCode.COMPONENT(id,fi,re,pr,SCode.ATTR(dims,_,_,_,_),path,mod)
	  => crlist
end

relation inst_ext_make_crefs_2 : (SCode.Ident, Absyn.ArrayDim, int) => Absyn.Exp list =

  axiom	inst_ext_make_crefs_2 (id, [], _) => []

  rule	int_add(dimno,1) => nextdimno &
	inst_ext_make_crefs_2 (id, restdim, nextdimno) => restlist &
	let exps = Absyn.CALL(Absyn.CREF_IDENT("size",[]),
			      Absyn.FUNCTIONARGS([Absyn.CREF(Absyn.CREF_IDENT(id,[])),
						  Absyn.INTEGER(dimno)], []))::restlist
	---------------------------------------
	inst_ext_make_crefs_2 (id,dim::restdim,dimno) => exps

end

relation inst_ext_get_fname : (Absyn.ExternalDecl, Ident) => Ident =

  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(SOME(id),_,_,_), fid) => id
  axiom	inst_ext_get_fname (Absyn.EXTERNALDECL(NONE,_,_,_), fid) => fid

end

(* Default is "C", so if no language specified, return "C" *)
relation inst_ext_get_lang : Absyn.ExternalDecl => string =

  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,SOME(lang),_,_) => lang
  axiom	inst_ext_get_lang Absyn.EXTERNALDECL(_,NONE,_,_) => "C"

end

(* special elab_exp for explicit external calls. This special relation calls 
   elab_exp_ext which handles size builtin calls specially, and uses the ordinary 
   Static.elab_exp for other expressions  *)
relation elab_exp_list_ext : (Env.Env, Absyn.Exp list, bool,
			      Interactive.InteractiveSymbolTable option) =>
	(Exp.Exp list, Types.Properties list, Interactive.InteractiveSymbolTable option) =

  axiom	elab_exp_list_ext (_,[],impl,st) => ([],[],st)

  rule	elab_exp_ext (env, e,impl,st) => (exp,p,st') & 
	elab_exp_list_ext (env, rest,impl,st') => (exps, props,st'')
	-----------------------------------------
	elab_exp_list_ext (env, e::rest,impl,st) => (exp::exps, p::props,st'') 

end

(* special elab_exp for explicit external calls. This special relation calls 
   elab_exp_ext which handles size builtin calls specially, and uses the ordinary 
   Static.elab_exp for other expressions  *)

relation elab_exp_ext : (Env.Env, Absyn.Exp, bool, Interactive.InteractiveSymbolTable option)
	    => (Exp.Exp, Types.Properties,Interactive.InteractiveSymbolTable option) =

  rule	(*Print.print_buf "// elab_exp_ext success for " &*)
(*	Static.elab_builtin_size(env,args) => (e,prop) & *)
	Static.elab_exp(env,dim,impl,NONE) => (dimp, Types.PROP(dimty,dim_const),_) &
	Static.elab_exp(env,arraycr,impl,NONE) => (arraycrefe, arraycrprop,_) &
	let exp = Exp.SIZE(arraycrefe,dimp) 
	(*& Exp.print_exp exp &
	Print.print_buf "\n" *)
	----------------------------------------------------	
	elab_exp_ext (env,
		      call as Absyn.CALL(Absyn.CREF_IDENT("size",_),
					 Absyn.FUNCTIONARGS(args as [arraycr,dim],nargs)),impl,st) 
	  => (exp,Types.PROP(Types.T_INTEGER([]),false),st)

  rule	(*Print.print_buf "// elab_exp_ext failed for " & 
	Absyn.print_absyn_exp exp &
	Print.print_buf " calling Static.elab_exp: " & *)
	Static.elab_exp (env,exp,impl,st) => (e,prop,st) 
(*	& Exp.print_exp e &
	Print.print_buf "\n"*)
	---------------------------------------------------
	elab_exp_ext (env,exp,impl,st) => (e,prop,st)

end

relation inst_ext_get_fargs : (Env.Env, Absyn.ExternalDecl) => DAE.ExtArg list =

  rule	elab_exp_list_ext (env, absexps, false, NONE) => (exps,props,_) &
	inst_ext_get_fargs2 (env, exps, props) => extargs	
	---------------------------------------------------------
	inst_ext_get_fargs (env, Absyn.EXTERNALDECL(id,lang,retcr,absexps)) => extargs

  rule	Debug.fprint("failtrace", "- inst_ext_get_fargs failed\n")
	-------------------------------------------------
	inst_ext_get_fargs (_,_) => fail
	
end

relation inst_ext_get_fargs2 : (Env.Env, Exp.Exp list, Types.Properties list) => DAE.ExtArg list =

  axiom	inst_ext_get_fargs2 (_,[],_) => []

  rule	inst_ext_get_fargs2 (env,exps,props) => extargs &
	inst_ext_get_fargs_single (env,e,p) => extarg
	-----------------------------------------
	inst_ext_get_fargs2 (env, e::exps,p::props) => extarg::extargs
end


relation inst_ext_get_fargs_single : (Env.Env, Exp.Exp, Types.Properties) => DAE.ExtArg =

  rule	Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) &
	Print.print_buf "inst_ext_get_fargs_single lookup_var_local success\n"
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => DAE.EXTARG(cref,attr,ty)

  rule	not Lookup.lookup_var_local (env, cref) => (attr, ty, bnd) &
	Print.print_buf "inst_ext_get_fargs_single lookup_var_local failed\n" &
	Exp.print_component_ref_str cref => crefstr &
	Util.string_append_list (["#-- Unknown component ", crefstr, " in external clause\n"]) => str &
	Print.print_buf str
	--------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.CREF(cref,crty), Types.PROP(ty,cnst)) => fail

  rule	Lookup.lookup_var_local (env, cref) => (attr, varty, bnd)
	------------------------------------------------------
	inst_ext_get_fargs_single (env, Exp.SIZE(Exp.CREF(cref,crty), dim), Types.PROP(ty,cnst)) 
	  => DAE.EXTARGSIZE(cref,attr,varty,dim)
				   
  axiom	inst_ext_get_fargs_single (env, exp, Types.PROP(ty,cnst)) => DAE.EXTARGEXP(exp,ty)

  rule	Debug.fprint("failtrace", "#-- inst_ext_get_fargs_single failed\n") &
	Debug.fcall("failtrace", Exp.print_exp, exp) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------------
	inst_ext_get_fargs_single (_,exp,prop) => fail
end


relation inst_ext_get_rettype : (Env.Env, Absyn.ExternalDecl) => DAE.ExtArg =

  axiom	inst_ext_get_rettype (_, Absyn.EXTERNALDECL(_,_,NONE,_)) => DAE.NOEXTARG

  rule	Static.elab_cref (env,cref) => (exp,prop,acc) &
	inst_ext_get_fargs_single (env, exp,prop) => extarg
	-----------------------------------------
	inst_ext_get_rettype (env,Absyn.EXTERNALDECL(n,lang,SOME(cref),args)) => extarg

  rule	Debug.fprint("failtrace", "#-- inst_ext_rettype failed\n")
	--------------------------------------------------------
	inst_ext_get_rettype (_,_) => fail

end

(** relation: inst_enumeration
 ** This relation takes an 'Ident' and list of strings, and returns an enumeration class.
**)
relation inst_enumeration: (SCode.Ident, string list) => SCode.Class =
  rule	make_enum_components(l) => comp
	--------------------------------
	inst_enumeration(n,l) => SCode.CLASS(n,false,false,SCode.R_ENUMERATION,SCode.PARTS(comp,[],[],[],[],NONE))
end

(** LS: false for replaceable added **)

(** relation: make_enum_components
 ** This relation takes a list of strings and returns the elements of 
 ** type 'EnumType' each corresponding to one of the enumeration values.
 **)
relation make_enum_components: string list => SCode.Element list =
  axiom make_enum_components ([str]) 
	  =>  [SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD)]
	  
  rule	make_enum_components(x) => els
	----------------------------
	make_enum_components (str::(x as (_::_)))
	  => SCode.COMPONENT(str,true,false,false,SCode.ATTR([],false,SCode.RO,SCode.CONST,Absyn.BIDIR),Absyn.IDENT("EnumType"),SCode.NOMOD):: els
end

(** relation: dae_declare
 **
 ** Given a global component name, a type, and a set of attributes,
 ** this relation declares a component for the DAE result.  Altough
 ** this relation returns a list of `DAE.Element's, only one component
 ** is actually declared.
 **
 ** The relations `dae_declare2' and `dae_declare3' below are helper
 ** relations that perform parts of the task.
 **)

(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare : (Exp.ComponentRef,
			Types.Type, 
			SCode.Attributes, 
			Exp.Exp option,
			InstDims
			) 
	  => DAE.Element list =

  rule	Debug.fprint( "insttr", "dae_declare(") &
	Debug.fcall ( "insttr", Exp.print_component_ref,vn) &
	Debug.fprint ( "insttr", ",") &
	Debug.fcall ( "insttr", Types.print_type,ty)  &
	Debug.fprint ("insttr", "...)\n") &
	dae_declare2 (vn, ty, par, dir, e, inst_dims) => dae
	-----------------------------------
	dae_declare (vn, ty, SCode.ATTR(_,_,_,par,dir), e, inst_dims) => dae

  rule	Debug.fprint("failtrace", "- dae_declare failed\n")
	------------------------------
	dae_declare(_,_,_,_,_) => fail

end

(**)
(* LS: Added direction so that function elements can be defined
   correctly *)
relation dae_declare2 : (Exp.ComponentRef, Types.Type, SCode.Variability,
			 Absyn.Direction, Exp.Exp option,InstDims)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, DAE.VARIABLE, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, SCode.VAR, dir, e,inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.DISCRETE, dir, e,inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, SCode.DISCRETE, dir, e, inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.PARAM, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, SCode.PARAM, dir, e, inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.CONST, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, SCode.CONST, dir, e, inst_dims) => dae

  rule	dae_declare3 (vn, ty, DAE.CONST, dir, e, inst_dims) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, SCode.STRUCTPARAM, dir, e, inst_dims) => dae

  rule	Debug.fprint("failtrace", "- dae_declare2 failed\n")
	------------------------------
	dae_declare2(_,_,_,_,_,_) => fail

end



relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.VarKind,
			 Absyn.Direction, Exp.Exp option, InstDims)
	  => DAE.Element list =

  rule	dae_declare4 (vn, ty, vk, DAE.INPUT, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.INPUT, e, inst_dims) => dae

  rule	dae_declare4 (vn, ty, vk, DAE.OUTPUT, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.OUTPUT, e, inst_dims) => dae

  rule	dae_declare4 (vn, ty, vk, DAE.BIDIR, e, inst_dims) => dae
	-----------------------------------------
	dae_declare3 (vn, ty, vk, Absyn.BIDIR, e, inst_dims) => dae

  rule	Debug.fprint("failtrace", "#- dae_declare3 failed\n")
	------------------------------
	dae_declare3(_,_,_,_,_,_) => fail

end



(**)

relation dae_declare4 : (Exp.ComponentRef, Types.Type, DAE.VarKind,
			 DAE.VarDirection, Exp.Exp option, InstDims)
	  => DAE.Element list =

  axiom	dae_declare4 (vn, Types.T_INTEGER(_), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.INT, e, inst_dims)]
	
  axiom	dae_declare4 (vn, Types.T_REAL(_), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.REAL, e, inst_dims)]

  axiom	dae_declare4 (vn, Types.T_BOOL(_), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.BOOL, e, inst_dims)]
	
  axiom	dae_declare4 (vn, Types.T_STRING(_), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.STRING, e, inst_dims)]
axiom dae_declare4 (vn, Types.T_ENUM, kind, dir, e, inst_dims)
	=> []
	(* We should not declare each enumeration value of an enumeration when instantiating,e.g Myenum my !=> constant EnumType my.enum1,... *)
	(*[DAE.VAR(vn, kind, dir, DAE.ENUM, e, inst_dims)]*)

  axiom	dae_declare4 (vn, Types.T_ENUMERATION(l,_), kind, dir, e, inst_dims)
	  => [DAE.VAR(vn, kind, dir, DAE.ENUMERATION(l), e, inst_dims)]

  axiom	dae_declare4 (c,ty,_,_,_,_) => []

end

(** LS & ELN 
 **
 ** Calls inst_equation_common with Inital set to NON_INITIAL. 
 ** 
 ** Has the same interface and semantics as the old inst_equation
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,NON_INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_equation (env,mods,pre,csets,ci_state,eq)
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_equation failed\n")
	----------------------------------
	inst_equation (_,_,_,_,_,_) => fail

end

(** LS & ELN 
 **
 ** Calls inst_equation_common with Inital set to INITIAL
 **)

relation inst_initialequation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_equation_common (env,mods,pre,csets,ci_state,eq,INITIAL)
	  => (dae,_,csets',ci_state')
	----------------------------------------------------------
	inst_initialequation (env,mods,pre,csets,ci_state,eq)
	  => (dae,env,csets',ci_state')

  rule	Debug.fprint("failtrace", "- inst_initialequation failed\n")
	----------------------------------
	inst_initialequation (_,_,_,_,_,_) => fail

end

(** LS & ELN 
 **
 ** Old inst_equation was renamed to inst_equation_common and 
 ** the Initial parameter was added.
 **)

(** relation: inst_equation_common
 **
 ** The DAE output of the translation contains equations which
 ** in most cases directly corresponds to equations in the source.
 ** Some of them are also generated from `connect' clauses.
 **
 ** This relation takes an equation from the source and generates DAE
 ** equations and connection sets.
 ** 
 **)

relation inst_equation_common : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
				 SCode.Equation, Initial)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => csets' &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------------
	inst_equation_common(env,mods,pre, csets, ci_state, 
			     SCode.EQ_CONNECT(c1,c2), 
			     initial)
	  => ([],env,csets',ci_state')
	  
	(**  assert
	 **)

  rule	Static.elab_exp(env,e,false,NONE) => (e', Types.PROP(t, c),_) &
	inst_assertion (env, e', t, c, d, pre) => dae &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	--------------------------------------------------------------
	inst_equation_common(env,mods,pre,csets, ci_state,
			     SCode.EQ_EXPR(Absyn.CALL(Absyn.CREF_IDENT("assert",[]),
						      Absyn.FUNCTIONARGS([e,Absyn.STRING(d)],[]))),
			     initial)
	  => (dae,env,csets,ci_state')

	(**  Normal equations *)

  rule	Print.print_buf "- No expression equations yet\n" &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' (* but fail? *)
	-------------------------------------
	inst_equation_common(env,mods,pre,csets,ci_state,SCode.EQ_EXPR(_),initial) => fail

	(** The following rule handles shadowed (replaced) equations. *)
	(** If an equation has a simple name on the left-hand side, *)
	(** and that component has an equation modifier, this equation *)
	(** is discarded. *)
  rule	Lookup.lookup_ident_local(env,n)
	  => (Types.VAR(_,_,_,_,Types.EQBOUND(_,_)),_,_) &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
	------------------------------------------------------
	inst_equation_common(env,mods,pre,csets,ci_state,
			     SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2),
			     initial)
	  => ([],env,csets,ci_state')

(* PR. This is probably where type checking of functions happen.*)
  rule	(*PR. propx contains the type/types(for functions) of the
	 resulting expression. But why are e1', e2' needed? They are
	 used to generate the dae's. Probably their type may have been
	 modified.  *)
	Debug.print("\n Expressions matched in inst equation:") &

(*	Absyn.print_absyn_exp(e1) &
*)	
	Debug.print(", ") &

(*	Absyn.print_absyn_exp(e2) &
*)	
	Debug.print("\n") &

	(* 
	 Do static analysis and constant evaluation of expressions. 
	 Gives expression and properties 
	 (Type * bool | (Type * Const as (bool | Const list))).
	 For a function, it checks the funtion name. 
	 Also the function call's in parameters are type checked with
	 the functions definition's inparameters. This is done with
	 regard to the position of the input arguments.

	 Returns the output parameters from the funktion.
	*)

	Static.elab_exp(env,e1,false,NONE) => (e1',prop1,_) &

	Debug.print("\nDebug: did left elab.") &
	Static.elab_exp(env,e2,false,NONE) => (e2',prop2,_) &
	Debug.print("\nDebug: did right elab.") &
	(*Exp.print_exp(e1') &*)
	Debug.print(", ") &
	(*Exp.print_exp(e2') & *)
	Debug.print("\n") &

	
	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &
	Debug.print("\nDebug: did prefixes.") &
(*
 put params-> in front of parameters
 doesn't work after prefix_exp, because of lookup failure

 prefix_params (env, e1'') => e1''' &
 prefix_params (env, e2'') => e2''' & 
*)
	(*PR. Check that the lefthandside and the righthandside get along. *)
	inst_eq_equation(e1'',prop1,e2'',prop2,initial) => dae &
	Debug.print("\nDebug: did inst_eq_equation.") &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' &
	Debug.print("\nDebug: did ClassInf trans.") &
	Prefix.print_prefix_str pre => prestr &
	Exp.print_exp_str e1' => e1str &
	Exp.print_exp_str e2' => e2str &
	string_append (prestr, ": ") => debugstr &
	string_append (debugstr, e1str) => debugstr2 &
	string_append (debugstr2, " = ") => debugstr3 &
	string_append (debugstr3, e2str) => debugstr4 &
	Debug.fcall ("expenvgraph", Env.print_env_graphviz, (env,debugstr4)) &
	Debug.fprintl ("expenvprint", ["------------ ", debugstr4, "\n"]) &
	Debug.fcall ("expenvprint", Env.print_env, env) &
	Debug.fprintl ("expenvprint", ["------------ /", debugstr4, "\n"])
	--------------------------------------------------------------
	inst_equation_common(env, mods, pre, csets, ci_state,
			     SCode.EQ_EQUALS(e1,e2), 
			     initial)
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 ** If statements are instantiated by evaluating the
	 ** conditional expression, and selecting the branch that
	 ** should be used.
	 **)

  rule	Static.elab_exp(env,e,false,NONE) => (e',Types.PROP(Types.T_BOOL(_),true),_) &
	Static.ceval(env,e',false,NONE) => (Values.BOOL(cond),_) &
	Debug.print("\nEQ_IF: ") &
(*!!	print(cond) &
*)
(*	Dump.print_exp(cond) &
	*)
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_equation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     NON_INITIAL)
	  => (dae,env',csets', ci_state')

  rule	Static.elab_exp(env,e,false,NONE) => (e',Types.PROP(Types.T_BOOL(_),true),_) &
	Static.ceval(env,e',false,NONE) => (Values.BOOL(cond),_) &
	Debug.print("\nEQ_IF: ") &
(*!!	print(cond) &
*)
(*	Dump.print_exp(cond) &
	*)
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_initialequation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb),
			     INITIAL)
	  => (dae,env',csets', ci_state')


	(**  `when equation' statement, modelica 1.1 
	 **
	 ** When statements are instantiated by evaluating the
	 ** conditional expression.
	 **)

(* Test this! 1.1*)
  rule	(* This is only done for 'for' loops. 
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND)  &  *)

 	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER(_)),
			     true),_) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e',false,NONE) => (v,_) &
	(* Not possilbe for 'when'.unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') & *)
	inst_list(env,mod,pre,csets,ci_state,inst_equation, el)
	  => (dae,env',csets', ci_state') (*&
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
*)	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el),
			     initial as NON_INITIAL)
	  => (dae, env',csets', ci_state')

(* Test this! 1.1*)
  rule	(* This is only done for 'for' loops. 
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND)  &  *)

 	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER(_)),
			     true),_) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e',false,NONE) => (v,_) &
	(* Not possilbe for 'when'.unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') & *)
	inst_list(env,mod,pre,csets,ci_state,inst_initialequation, el)
	  => (dae,env',csets', ci_state') (*&
	inst_equation_common_ci_trans (ci_state, initial) => ci_state'
*)	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el),
			     initial as INITIAL)
	  => (dae, env',csets', ci_state')





	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **
	 **)

  rule	Debug.fprintln ("insttr", "inst_equation_common_eqfor_1") &
	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP(Types.T_ARRAY(Types.DIM(_),
					   id_t),
			     true),_) &
	Debug.fprintln ("insti", "for expression elaborated") &
	add_for_loop_scope(env,i,id_t) => env' &
	Debug.fprintln ("insti", "loop-variable added to scope") &
	
	Lookup.lookup_var(env', Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      Types.T_INTEGER(_), Types.UNBOUND) &
	Debug.fprintln ("insti", "loop variable looked up") &
	
	(* FIXEM: Check bounds *)
	Static.ceval (env,e',false,NONE) => (v,_) &
	Debug.fprintln ("insti", "for expression evaluated") &
	unroll(env',mod,pre,csets,ci_state,i,v,el,initial) => (dae, csets') &
	Debug.fprintln ("insti", "for expression unrolled") &
	inst_equation_common_ci_trans (ci_state, initial) => ci_state' &
	Debug.fprintln ("insttr", "inst_equation_common_eqfor_1 succeeded")
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial)
	  => (dae, env,csets', ci_state')

  rule	Debug.fprintln ("insttr", "inst_equation_common_eqfor_2") &
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      Types.T_INTEGER(_), Types.UNBOUND) &
	Debug.fprintln ("insti", "loop variable looked up") &
	Static.elab_exp (env,e,false,NONE)
	  => (e',Types.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER(_)),
			     false),_) &
	Print.print_buf "#-- Error: Non-constant iteration bounds not supported\n" &
	Debug.fprintln ("insttr", "inst_equation_common_eqfor_2 succeeded")
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial)
	  => fail

  rule	not Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, SCode.VAR, _),
	      Types.T_INTEGER(_), Types.UNBOUND) &
	Print.print_buf "# Invalid loop variable: " & Print.print_buf i & Print.print_buf "\n"
	-----------------------------------------------------------
	inst_equation_common(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el),initial)
	  => fail

  rule	Debug.fprint("failtrace", "- inst_equation_common failed\n")
	----------------------------------
	inst_equation_common(_,_,_,_,_,_,_) => fail

end

(** LS & ELN **)
relation inst_equation_common_ci_trans : (ClassInf.State, Initial)
	  => ClassInf.State = 

  rule	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	---------------------------------------------------------------
	inst_equation_common_ci_trans (ci_state, NON_INITIAL) => ci_state'

  axiom	inst_equation_common_ci_trans (ci_state, INITIAL) => ci_state

(*
  rule	ClassInf.trans(ci_state, ClassInf.FOUND_INITIALEQUATION) => ci_state'
	---------------------------------------------------------------
	inst_equation_common_ci_trans (ci_state, INITIAL) => ci_state'
*)

end

(** HJ: **)
relation add_for_loop_scope : (Env.Env, Ident, Types.Type) => Env.Env =

  rule	Env.open_scope (env,false) => env' &
	Env.name_scope (env',"$for loop scope$") => env'' &
	Env.extend_frame_v(env'',
			   Types.VAR(i,
				     Types.ATTR(false,
						SCode.RW,
						SCode.VAR,
						Absyn.BIDIR),
				     false,
				     typ, 
				     Types.UNBOUND),NONE,false
			   ) => env''
	---------------
	add_for_loop_scope(env, i,typ) => env''

end

(** LS: **)
relation is_parameter : (Exp.ComponentRef, Env.Env) => () =

  rule	Env.print_env env &
	Lookup.lookup_var (env, cr) 
	  => (Types.ATTR(fl, acc, SCode.PARAM,dir), ty, bnd)
	----------------------------------------------------
	is_parameter (cr, env)

end 

(** LS: **)
relation prefix_params : (Env.Env, Exp.Exp) => Exp.Exp =

  rule	ModUtil.string_prefix_component_ref ("params->", is_parameter, env, e) => e'
	-----------------------------------------------------------------------
	prefix_params (env, e) => e'

end


(** LS & ELN 
 **
 ** Initial is added as a parameter.
 **  
 **)

(** relation: inst_eq_equation
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 **)

relation inst_eq_equation : (Exp.Exp, Types.Properties,
			     Exp.Exp, Types.Properties, Initial) => DAE.Element list =
	(*PR. e1= lefthandside, e2=righthandside
	* This seem to be a strange relation. 
	* wich rule is matched? or is both rules matched?
	*)

        (* LS: Static.type_convert in Static.match_prop can probably fail,
	 * then the first rule will not match. Question if whether the second
	 * rule can match in that case.
	 *)
	
	(* This rule is matched first, if it fail the next rule is matched.
	 *)
  rule	Debug.print("\ninst_eq_equation (match e1) PROP, PROP") &
	Types.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2, initial) => dae 

	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial)
	  => dae

	(* If it fails then this rule is matched. *)
  rule	Debug.print("\ninst_eq_equation (match e2) PROP, PROP") &
	Types.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation_ inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1, initial) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP(t1,_),
			 e2,p2 as Types.PROP(t2,_), initial)
	  => dae



  rule	Debug.print("\ninst_eq_equation(e1) PROP_TUPLE, PROP_TUPLE") &
	(*Exp.print_exp (e1) & *)
	Types.match_prop(e1, p1, p2) => e1' &
	(*Exp.print_exp (e1') & *)
	inst_eq_equation_2(e1', e2, t2, initial) => dae 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial)
	  => dae


(*
  rule
	print("\n So far so good.") &
	
	print("\n  ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,Types.PROP_TUPLE(t2,_))
	  => fail
*)



	(* PR. *)	
  rule	Debug.print("\ninst_eq_equation(e2) PROP_TUPLE, PROP_TUPLE") &
	Debug.print "\n About to do a static match e2. " &
	Types.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation_ inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1, initial) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Types.PROP_TUPLE(t1,_),
			 e2,p2 as Types.PROP_TUPLE(t2,_), initial)
	  => dae

	  (* An assignment to a varaible of T_ENUMERATION type is an explicit 
	     assignment to the value componnent of the enumeration, i.e. having a type T_ENUM*)
	
  rule	Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP(Types.T_ENUMERATION(_,_),_),
	    e2,Types.PROP(t as Types.T_ENUM,_), initial) => dae

  rule	Debug.fprint ("insttr", "Found assignment to T_ENUMERATION type. Rhs type must be T_ENUM or T_ENUMERATION.\n") &
	inst_eq_equation_2(e1,e2,t,initial) => dae
	----------------------
	inst_eq_equation(e1 as Exp.CREF(_,_),Types.PROP(Types.T_ENUMERATION(_,_),_),
	    e2,Types.PROP(t as Types.T_ENUMERATION(_,_),_), initial) => dae


  rule	(* Types.equivtypes(t1,t2) => false & *)
	Print.print_buf "# Illegal types in equation\n"&
	Print.print_buf "    lhs: " & Exp.print_exp e1 &
	Print.print_buf " :: " & Types.print_type t1 & Print.print_buf "\n" &
	Print.print_buf "    rhs: " & Exp.print_exp e2 &
	Print.print_buf " :: " & Types.print_type t2 & Print.print_buf "\n"
	----------
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2,Types.PROP(t2,_), initial) => fail


(* PR To debug*)

  rule	Debug.print("\ne1 is PROP and e2 is PROP_TUPLE.  ")
	---------------------------------	
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2, Types.PROP_TUPLE(_,_), initial) => fail

  rule	Debug.print("e2 is PROP")
	---------------------------------
	inst_eq_equation(e1,_,
			 e2,Types.PROP(t2,_), initial) => fail

  rule	Debug.print("e1 is PROP")
	---------------------------------
	inst_eq_equation(e1,Types.PROP(t1,_),
			 e2, _, initial) => fail




(* No match. *)
  rule	Debug.fprint("failtrace", "\n No match in inst_eq_equation. ")
	---------------------------------	
	inst_eq_equation(_,_,_,_,_) => fail

end

(** LS & ELN 
 **
 ** Initial is added as a parameter.
 **
 **)

(** relation: inst_eq_equation_2
 **
 ** This is the second stage of `inst_eq_equation', when the types are
 ** checked.
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type, Initial)
	=> DAE.Element list =

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_INTEGER(_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_REAL(_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_STRING(_),initial) => [dae]

  rule	make_dae_equation (e1,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_BOOL(_),initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,Types.T_ENUM,initial) => [dae]

  rule	make_dae_define (cr,e2,initial) => dae
	---------------------------------------
	inst_eq_equation_2(Exp.CREF(cr,t),e2,Types.T_ENUMERATION(_,_),initial) => [dae]


  rule	RTOpts.split_arrays => true &
	(* For debugging.
	Print.print_buf "  Array equation: " &
	Exp.print_exp e1 & Print.print_buf " = " &
	Exp.print_exp e2 & Print.print_buf "\n" & *)
	inst_array_equation(e1,e2,ad,t,initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t),initial) => dae


	(* PR. The muliple outputs from functions is outputed as is. *)

  rule	make_dae_equation (e1,e2,initial) => dae
	----------------------------------------
	inst_eq_equation_2 (e1,e2,Types.T_TUPLE(_),initial) => [dae]


  rule	RTOpts.split_arrays => false &
	make_dae_equation (e1, e2, initial) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t),initial) => [dae]

  axiom	inst_eq_equation_2(e1, e2, Types.T_COMPLEX(_,[]), initial) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1',t1), Exp.CREF(c2',t2), t, initial) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   Types.T_COMPLEX(cs,vs), initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1,t1), Exp.CREF(c2,t2),
			   Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs), initial) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[])
	  => decl &
	inst_eq_equation_2(Exp.CREF(n,Exp.OTHER), e2, t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_,_),
			   t as Types.T_COMPLEX(_,_), initial) => dae

	(** When the right-hand side is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     SCode.VAR, Absyn.BIDIR), NONE,[])
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n,Exp.OTHER), t, initial) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as Types.T_COMPLEX(_,_), initial) => dae

  rule	Debug.fprint("failtrace", "- inst_eq_equation_2 failed\n exp1=") &
	Debug.fcall("failtrace",Exp.print_exp, e1) &
	Debug.fprint("failtrace", " exp2=" ) &
	Debug.fcall("failtrace",Exp.print_exp, e2) &
	Debug.fprint("failtrace", " type =") &
	Debug.fcall("failtrace",Types.print_type, t) &
	Debug.fprint("failtrace", "\n")
	-------------------------------------
	inst_eq_equation_2(e1,e2,t,initial) => fail

end

(** LS & ELN **)

relation make_dae_equation : (Exp.Exp, Exp.Exp, Initial) => DAE.Element =

  axiom	make_dae_equation (e1,e2,NON_INITIAL) => DAE.EQUATION(e1,e2)

  axiom	make_dae_equation (e1,e2,INITIAL) => DAE.INITIALEQUATION(e1,e2)

end

(** LS & ELN **)

relation make_dae_define : (Exp.ComponentRef, Exp.Exp, Initial) => DAE.Element = 

  axiom	make_dae_define (cr, e2, NON_INITIAL) => DAE.DEFINE(cr,e2)

  axiom	make_dae_define (cr, e2, INITIAL) => DAE.INITIALDEFINE(cr,e2)

end

(** relation: inst_array_equation
 **
 ** This checks the array size and uses `inst_array_el_eq' to create
 ** equations for each array element.
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type, Initial)
	  => DAE.Element list =

  rule	Print.print_buf "# Cannot instantiate equations with arrays of unknown size\n" &
	Print.print_buf "    " & Exp.print_exp e1 & Print.print_buf " = " & Exp.print_exp e2&
	Print.print_buf "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t, initial) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz, initial) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t, initial) => dae

  rule	Debug.fprint("failtrace", "- inst_array_equation failed\n")
	--------------------------------------
	inst_array_equation (_,_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** This relation loops recursively through all indexes in the two
 ** arrays and generates an equation for each pair of elements.
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int, Initial)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t,initial) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz,initial) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz, initial) => []

  rule	Debug.fprint("failtrace", "- inst_array_el_eq failed\n")
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.  There are not assertions in the output
 ** currently.
 **)

relation inst_assertion : (Env.Env, Exp.Exp, Types.Type,
			   bool, string, Prefix)
	  => DAE.Element list =

	(* Constant assertions *)
  axiom	inst_assertion (env, e, Types.T_BOOL(_), true, d, pre) => [(* lost *)]

  axiom	inst_assertion (env, e, Types.T_BOOL(_), _, d, pre) => [(* lost *)]

  rule	Print.print_buf "# Assertions have to be of type Boolean\n" &
	Print.print_buf "  assertion: (" &
	Prefix.prefix_exp(env,e,pre) => e' & Exp.print_exp e' & Print.print_buf "): " &
 	Print.print_buf d & Print.print_buf "\n"
	-----------------------------
	inst_assertion (env, e, _, _, d, pre) => fail
	
end

(** LS & ELN
 **
 ** Added the Initial parameter
 **)

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.Equation list, Initial)
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_,_) => ([], csets)

  rule	Env.open_scope (env,false) => env' &
	Env.name_scope (env',"$for loop scope$") => env'' &
	Env.extend_frame_v (env'',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      Types.T_INTEGER([]),
				      Types.VALBOUND(fst)),NONE,false) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs, initial)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as NON_INITIAL)
	  => (dae, csets'')

  rule	Env.open_scope (env, false) => env' &
	Env.name_scope (env',"$for loop scope$") => env'' &
	Env.extend_frame_v (env'',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    SCode.CONST,
						    Absyn.BIDIR),
				      true,
				      Types.T_INTEGER([]),
				      Types.VALBOUND(fst)),NONE,false) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_initialequation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs, initial)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs,initial as INITIAL)
	  => (dae, csets'')

  rule	Debug.fprint("failtrace",  "- unroll ") & 
	Debug.fcall("failtrace", Values.print_val, v) &
	Debug.fprint("failtrace", " failed\n")
	-------------------------
	unroll (_,_,_,_,_,_,v,_,_) => fail

end

(** relation: inst_algorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements))
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_algorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_initialalgorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_initialalgorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_initialalgorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements))
	  => ([DAE.INITIALALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	Debug.fprint("failtrace", "- inst_algorithm failed\n")
	---------------------------------
	inst_initialalgorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_statements
 **
 ** This relation converts a list of algorithm statements.
 **)

relation inst_statements : (Env, Absyn.Algorithm list)
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_statements(env,xs) => xs'
	------------------------------
	inst_statements(env,x::xs) => x'::xs'
end

relation inst_algorithmitems : (Env, Absyn.AlgorithmItem list)
	  => Algorithm.Statement list =

  axiom	inst_algorithmitems(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_algorithmitems(env,xs) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEM(x,_)::xs) => x'::xs'

  rule	inst_algorithmitems(env,xs) => xs'
	------------------------------
	inst_algorithmitems(env,Absyn.ALGORITHMITEMANN(_)::xs) => xs'

end


(** relation: inst_statement
 **
 ** This relation Looks at an algorithm statement and uses relations
 ** in the `Algorithm' module to build a representation of it that can
 ** be used in the DAE output.
 **)

relation inst_statement : (Env, Absyn.Algorithm) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr) => (ce, cprop, acc) &
	Static.elab_exp (env,e,false,NONE) => (e', eprop,_) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_exp(env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,tb) => tb' &
	inst_elseifs(env,eib) => eib' &
	inst_algorithmitems(env,fb) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb)) => stmt

  rule	Static.elab_exp (env,e,false,NONE)  =>
	(e', prop as Types.PROP(Types.T_ARRAY(_,t),_),_) &
	
	add_for_loop_scope(env,i,t) => env' &
	
	inst_algorithmitems(env',sl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl)) => stmt

  rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl)) => stmt


  rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_when_a(e',prop,sl') => stmt
	(* TODO elsewhen *)
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN_A(e,sl,el)) => stmt

(* 1.0
 rule	Static.elab_exp (env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,sl) => sl' &
	Algorithm.make_when(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN(e,sl)) => stmt
*)

  rule	Static.elab_exp (env,cond,false,NONE) 
	  => (cond',cprop,_) &
	Static.elab_exp (env,msg,false,NONE) 
	  => (msg',msgprop,_) &
	Algorithm.make_assert(cond',msg',cprop,msgprop) => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_NORETCALL(Absyn.CREF_IDENT("assert",_),
					       Absyn.FUNCTIONARGS([cond,msg],[])))
	  => stmt

  rule  Debug.fprint("failtrace", "- inst_statement failed\n") 
	---------------------------------
	inst_statement(env,alg) => fail
end

(** relation: inst_elseifs
 **
 ** This relation helps `inst_statement' to handle `elseif' parts.
 **)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.AlgorithmItem list) list)
	=> (Exp.Exp * Types.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[]) => []

  rule	Static.elab_exp(env,e,false,NONE) => (e',prop,_) &
	inst_algorithmitems(env,l) => stmts &
	inst_elseifs(env,tail) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail) => ((e',prop,stmts)::tail')

  rule	Debug.fprint("failtrace", "- inst_elseifs failed\n")
	-------------------------------
	inst_elseifs(_,_) => fail

end

(** relation: inst_connect
 **)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => Connect.Sets =

  rule	Static.elab_cref(env, c1) => (Exp.CREF(c1',t1),prop1,acc) &
	Static.elab_cref(env, c2) => (Exp.CREF(c2',t2),prop2,acc) &
	Static.canon_cref(env, c1') => c1'' &
	Static.canon_cref(env, c2') => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (attr1 as Types.ATTR(flow1,_,_,_),ty1,_) &
	Lookup.lookup_var_local(env,c2'') => (attr2,ty2,_) &
	
	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,attr1,c2'',ty2,attr2) &
	
	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => sets'
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => sets'

  rule	Print.print_buf "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector Types.T_REAL(_)

  rule	ClassInf.valid(state,SCode.R_CONNECTOR)
	---------------------------------------
	valid_connector Types.T_COMPLEX(state,_)

  rule	Print.print_buf "# Can't connect objects of type " &
	Types.print_type t & Print.print_buf "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Types.Attributes,
			       	Exp.ComponentRef, Types.Type,
				Types.Attributes) => () =

  rule	Print.print_buf "# Can't connect two input variables\n" &
	Print.print_buf "    while connecting " & Exp.print_component_ref c1 &
	Print.print_buf " to " & Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.INPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.INPUT)) => fail

  rule	Print.print_buf "# Can't connect two output variables\n" &
	Print.print_buf "    while connecting " & Exp.print_component_ref c1 &
	Print.print_buf " to " & Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.OUTPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.OUTPUT)) => fail

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,Types.ATTR(flow1,_,_,_),
			    _,t2,Types.ATTR(flow2,_,_,_))

  rule	Print.print_buf "# Can't connect flow component " &
 	Exp.print_component_ref c1 &
	Print.print_buf " to non-flow component " &
 	Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(true,_,_,_),
			    c2,_,Types.ATTR(false,_,_,_)) => fail

  rule	Print.print_buf "# Can't connect non-flow component " &
 	Exp.print_component_ref c1 &
	Print.print_buf " to flow component " &
 	Exp.print_component_ref c2 & Print.print_buf "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(false,_,_,_),
			    c2,_,Types.ATTR(true,_,_,_)) => fail

  rule	Print.print_buf "- check_connect_types(" & Exp.print_component_ref c1 &
	Print.print_buf " <-> " & Exp.print_component_ref c2 & Print.print_buf ") failed\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,c2,_,_) => fail

end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 **)

relation connect_components: (Connect.Sets,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) => Connect.Sets =
	
	(**  Flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, f1, Types.T_REAL(_),
			   c2, f2, Types.T_REAL(_), true) => sets'
	
	(**  Non-flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, _, Types.T_REAL(_),
			   c2, _, Types.T_REAL(_), false) => sets'

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	connect_vars(sets,c1',f1,l1,c2',f2,l2) => sets'
	----------------------------------------
	connect_components(sets,pre,c1,f1, Types.T_COMPLEX(_,l1),
			   c2,f2, Types.T_COMPLEX(_,l2),_) => sets'

	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Print.print_buf "# Wrong type in connection\n"&
 	Print.print_buf "  while making connectiion " &
	Exp.print_component_ref c1 & Print.print_buf " <-> " &
	Exp.print_component_ref c2 & Print.print_buf "\n" &
	Print.print_buf "  The type `" & Types.print_type t1 &
	Print.print_buf "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => Connect.Sets =

  axiom	connect_vars(sets,_,_,[],_,_,[]) => sets

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, attr1, c2', ty2, attr2) &
	connect_components(sets,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => sets' &
	connect_vars(sets',c1,f1,xs1,c2,f2,xs2) => sets''
	--------------------------------------
	connect_vars(sets,
		     c1,f1, Types.VAR(n,attr1 as Types.ATTR(flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,attr2 as Types.ATTR(flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => sets''

end

(** relation: mktype **
 ** From a class inference state, and a list of subcomponents, this
 ** relation returns `Types.Type'.  If the class inference state
 ** indicates that the type should be a built-in type, one of the
 ** built-in type constructors is used.  Otherwise, a `T_COMPLEX' is
 ** built.
 **)

relation mktype : (ClassInf.State,Types.Var list) => Types.Type =

  axiom	mktype(ClassInf.TYPE_INTEGER(_),v) => Types.T_INTEGER(v)
  axiom	mktype(ClassInf.TYPE_REAL(_),v)    => Types.T_REAL(v)
  axiom	mktype(ClassInf.TYPE_STRING(_),v)  => Types.T_STRING(v)
  axiom	mktype(ClassInf.TYPE_BOOL(_),v)    => Types.T_BOOL(v)
  axiom	mktype(ClassInf.TYPE_ENUM(_),_)    => Types.T_ENUM

	(* Insert function type construction here
	   after checking input/output arguments? 
	   see types.rml T_FUNCTION *)

  rule	Types.make_function_type (vl) => functype
	--------------------------
	mktype(st as ClassInf.FUNCTION(name), vl) => functype

  rule	Types.make_enumeration_type (v1) => enumtype
	--------------------------------------------
	mktype(ClassInf.ENUMERATION(name),v1) => enumtype
(*
  rule	Print.print_buf " <function " & Print.print_buf name & Print.print_buf "> <" &
	Dump.print_list (vl, Types.print_var, ", ") &
	Print.print_buf " >"
	--------------------------
	mktype(st as ClassInf.FUNCTION(name), vl) => Types.T_COMPLEX(st,vl)
*)

  axiom	mktype(st,l) => Types.T_COMPLEX(st,l)

end

(** relation: inst_list
 **
 ** This is a utility used to do instantiation of list of things,
 ** collecting the result in another list.
 **)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(** relation: component_face
 ** 
 ** This relation determines whether a component reference refers to an
 ** inner or outer connector.
 **)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

  rule	Print.print_buf "# While connecting " &
	Exp.print_component_ref c & Print.print_buf "\n" &
	Print.print_buf "# Only local or child connectors allowed.\n"
	---------------------------------------------------
	component_face c => fail

end



(** LS & ELN
 ** 
 ** Added NON_INITIAL for inst_eq_equation
 **
 **)

(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 **)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod)
	  => DAE.Element list =

(*  rule	Print.print_buf "inst_mod_equation\n" &
	Exp.cref_str cr => str &
	Print.print_buf "cref = " & Print.print_buf str &
	Print.print_buf "\nmod=" &
	Mod.print_mod mod &
	int_eq(1,0) => true
	----------
	inst_mod_equation(cr,ty1,mod) => [] *)
	  
  rule	Types.elab_type ty1 => t &
	inst_eq_equation(Exp.CREF(cr,t),
			 Types.PROP(ty1,false(*FIXME*)), e,prop2,NON_INITIAL) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Mod.MOD(_,_,SOME(Mod.TYPED(e,prop2))))
	  => dae

  axiom inst_mod_equation(_,_,Mod.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,Mod.NOMOD) => []
  axiom	inst_mod_equation(_,_,Mod.REDECL(_,_)) => []

  rule	Debug.fprint("failtrace", "- inst_mod_equation failed\n")
	------------------------------------
  	inst_mod_equation (_,_,_) => fail

end






(** relation: check_prot
 **
 ** This relation is used to check that a protected element is not
 ** modified.
 **)

relation check_prot : (bool, Mod.Mod, Exp.ComponentRef) => () =

  axiom	check_prot(false,_,cref)
	
  axiom check_prot(_,Mod.NOMOD,_)

  rule	Print.print_buf "# Trying to modify protected element " &
	Exp.print_component_ref cref & Print.print_buf "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 **
 **)

relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option)
	  => Types.Binding =

  axiom	make_binding (_,_,NONE) => Types.UNBOUND

(* Numerical values becoms VALBOUND *)
  axiom	make_binding (env, _, SOME(Mod.TYPED(Exp.ICONST(i),_))) 
	    => Types.VALBOUND(Values.INTEGER(i))
	    
  axiom make_binding (env, _, SOME(Mod.TYPED(Exp.RCONST(r),_)))
	    => Types.VALBOUND(Values.REAL(r))
	    
  axiom	make_binding (env, _, SOME(Mod.TYPED(Exp.SCONST(s),_)))
	=> Types.VALBOUND(Values.STRING(s))
	    
  axiom	make_binding (env, _, SOME(Mod.TYPED(Exp.BCONST(b),_)))
	=> Types.VALBOUND(Values.BOOL(b))

	(* Constant binding *)
axiom  	make_binding (env, SCode.ATTR(_,_,_,SCode.CONST,_), SOME(Mod.TYPED(e,prop)))
	  => Types.EQBOUND(e,true)

	(* default *)

  rule	Exp.simplify(e) => e'
	-------------------
	make_binding (_,_, SOME(Mod.TYPED(e,Types.PROP(t,c)))) => Types.EQBOUND(e',c)

  rule	Debug.fprint("failtrace", "- make_binding failed\n")
	-------------------------------
	make_binding(_,_,_) => fail

end


relation canon_cref_list : (Env, Exp.Exp list) => Exp.Exp list =

  axiom	canon_cref_list (_, []) => []

  rule	canon_cref_list (env, rest) => elist &
	Static.canon_cref (env, cr) => cr'
	---------------------------------
	canon_cref_list (env, Exp.CREF(cr,t)::rest) => Exp.CREF(cr',t)::elist

end

(** LS:
 ** This rule goes through the elements and for each variable, searches the rest
 ** of the list for "equations" which refer to that variable on the LHS, and puts
 ** their RHS in the variable as the initialization expression. This is needed
 ** for modelica output where parameters must be "assigned" (?) during
 ** declaration.
 **)

relation init_vars_modelica_output : DAE.Element list => DAE.Element list =

  rule	init_vars_modelica_output_1 ([], l) => l'
	---------------------------------------
	init_vars_modelica_output l => l'
end


relation init_vars_modelica_output_1 : (DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom init_vars_modelica_output_1 (done, []) => done

  rule	init_vars_modelica_output_2 (cr, exp, done) => (exp', done') &
	init_vars_modelica_output_2 (cr, exp', todorest) => (exp'', todorest') &
	list_append (done', [DAE.VAR(cr, vk, vd, ty, exp'',inst_dims)]) => done'' &
	init_vars_modelica_output_1 (done'', todorest') => done'''
	--------------------------------------------------------
	init_vars_modelica_output_1 (done, (v as DAE.VAR(cr, vk, vd, ty, exp,inst_dims)) :: todorest)
	  => done'''


  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.COMP(n, DAE.DAE(dae'))]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.COMP(n, DAE.DAE(dae)) :: rest)
	  =>  done''

  rule	init_vars_modelica_output dae => dae' &
	list_append (done, [DAE.FUNCTION(fpath, DAE.DAE(dae'), ty)]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	-------------------------------------
	init_vars_modelica_output_1 (done, DAE.FUNCTION(fpath, DAE.DAE(dae), ty) :: rest)
	  =>  done''


  rule	list_append (done, [e]) => done' &
	init_vars_modelica_output_1 (done', rest) => done''
	---------------------------------------
	init_vars_modelica_output_1 (done,  e :: rest) => done''

end


(** LS:
 ** Search the list for equations with LHS as componentref = cr, remove from the
 ** list and return the RHS of the last of those equations
 **)

relation init_vars_modelica_output_2 : (Exp.ComponentRef, Exp.Exp option, DAE.Element list) 
	  => (Exp.Exp option, DAE.Element list) =

  axiom init_vars_modelica_output_2 (cr, exp, []) => (exp, [])


  rule	Exp.cref_equal (cr, e1cr) => true &
	init_vars_modelica_output_2 (cr, SOME(exp'), rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, DAE.EQUATION(Exp.CREF(e1cr,_ (*Exp.OTHER*)), exp') :: rest)
	  => (exp'', rest')


  rule	Exp.cref_equal (cr, e1cr) => false &
	init_vars_modelica_output_2 (cr, exp, rest) => (exp'', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (cr, exp, (e1 as DAE.EQUATION(Exp.CREF(e1cr,_(* Exp.OTHER*)), exp')) :: rest)
	  => (exp'', e1 :: rest')

  rule	init_vars_modelica_output_2 (excr, exp, rest) => (exp', rest')
	-----------------------------------------------------------------
	init_vars_modelica_output_2 (excr, exp, e1 :: rest) => (exp', e1 :: rest')

end
(** relation: inst_record_constructor_elt
 ** This relation takes an Env and an Element and builds a input argument to a record constructor.
   ** E.g if the element is Real x; the resulting Var is "input Real x;"
**)
relation inst_record_constructor_elt : (Env.Env,SCode.Element) =>
	Types.Var =
	  
  rule	Debug.fprint ("recconst", "inst_record_constructor_elt called\n") &
	elab_arraydim(env,dim,NONE,true,NONE) => dimexp &
	Debug.fprint ("recconst", "elaborated arraydim\n") &
	Lookup.lookup_class(Cache.CACHE([],[]),env,t,true) => (_,cl,cenv) &
	Debug.fprint ("recconst", "looked up class\n") &
	Mod.elab_mod(env,Prefix.NOPRE,mod) => mod' &
	
	elab_arraydim(env,dim,NONE,true,NONE) => dimexp &
	Debug.fprint ("recconst", "calling inst_var\n") &
	inst_var(Cache.CACHE([],[]), cenv, mod', Prefix.NOPRE, [], id, cl, attr,
		 dimexp, [], [], true) => (_, _, _, tp') &
	Debug.fprint ("recconst", "Type of argument:") &
	Debug.fcall ("recconst",Types.print_type,tp') &
	Debug.fprint ("recconst","\nMod=") &
	Debug.fcall ("recconst",Mod.print_mod,mod') &
	Mod.mod_equation mod' => eq &
	make_binding(env,attr,eq) => bind
	---------------------------------------
	inst_record_constructor_elt (env,SCode.COMPONENT(id,_,repl,prot,
							 attr as SCode.ATTR(dim,f,acc,var,dir),t,mod)) 
	    => Types.VAR(id,Types.ATTR(f,acc,var,Absyn.INPUT),prot,tp',bind)

  rule	Print.print_buf "#Error, inst_record_constructor_elt failed\n  element =" &
	SCode.print_element elt &
	Print.print_buf "\n"
	------------------
	inst_record_constructor_elt(env,elt) => fail
end
