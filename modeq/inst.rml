(* inst.rml *)

module Inst:

  with "exp.rml"
  with "absyn.rml"
  with "dae.rml"

  relation instantiate: Absyn.Program => DAE.DAEform

end

with "prefix.rml"
with "env.rml"
with "mod.rml"
with "builtin.rml"

type Prefix = Prefix.Prefix



(**********************************************************************)

relation inst_list (* : (Env.Env, Mod.Mod, Prefix, =>, foo list) *)
	 =

  axiom inst_list(env,mod,pre,r,[]) => (([],env))

  rule	r(env,mod,pre,e) => ((l,env')) &
	inst_list(env',mod,pre,r,es) => ((l',env'')) &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,r,e::es) => ((l'',env''))

end

relation inst_connect: (Exp.Exp,Exp.Exp) => DAE.DAEcomp list =

  rule	print "No connect() yet\n" & fail
	---------------------------------
	inst_connect(_,_) => []

end

relation inst_equation: (Env.Env,Mod.Mod,Prefix,Absyn.Equation)
	  => (DAE.DAEcomp list*Env.Env) =

  rule	inst_connect(o1,o2) => l
	------------------------
	inst_equation(env,mods,pre,Absyn.EQ_EXPR(Exp.CALL(Exp.IDENT("connect"),[o1,o2]))) => ((l,env))

  rule	print "No expression equations yet\n" & fail
	--------------------------------------------
	inst_equation(env,mods,pre,Absyn.EQ_EXPR(_)) => (([],env))

  rule	print " equation\n" &
	Prefix.prefix_exp(e1,pre) => e1' &
	Prefix.prefix_exp(e2,pre) => e2'
	------------------------
	inst_equation(env,mods,pre,Absyn.EQ_EQUALS(e1,e2)) =>
		(([DAE.EQUATION(Exp.RELATION(e1',Exp.EQUAL,e2'))],env))

end

relation inst_element: (Env.Env,Mod.Mod,Prefix,Absyn.Element)
	  => (DAE.DAEcomp list*Env.Env) =

  rule	Env.lookup_class(env,cn) => c &
	Mod.modify_class(env,Absyn.CLASSMOD(m),c) => c' &
	Mod.modify_class(env,mods,c') => Absyn.CLASS(n,_,r,d) &
	(* Can't use inst_class, as that creates a new frame *)
	inst_classdef(env,mods,pre,d) => x
	----------------------------------
	inst_element(env,mods,pre,Absyn.ELEMENT(_,_,Absyn.EXTENDS(cn,m)))
	 => x

  	(* If a variable is declared multiple times, the first is used *)
  rule	Env.lookup_var(env,n)
	--------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.COMPONENTS(_,_,_,_,_,_,_)))
	 => (([],env))

  rule	Env.lookup_var(env,n) &
	print "Trying to redeclare the class " & print n &
	print " as a variable\n" &
	fail
	------------------------
	inst_element(env,mods,pre,Absyn.ELEMENT(_,n,Absyn.CLASSDEF(_,_)))
	 => (([],env))

  rule	Env.lookup_class(env,Exp.IDENT(n)) => v &
	print "Trying to redeclare the variable " & print n &
	print " as a class\n" &
	fail
	------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.COMPONENTS(_,_,_,_,_,_,_)))
	 => (([],env))

  rule	Mod.lookup_modification(mods,n) => mm &
	Mod.maybe_modify_class(env,mm,c) => c' &
	Env.extend_frame_c(env,c') => env'
	----------------------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,n,Absyn.CLASSDEF(_,c)))
	 => (([],env'))

  rule	print " variable " & print n & print "\n" &
	Env.lookup_class(env,t) => cl &
	Mod.maybe_modify_class(env,m,cl) => cl' &
	Mod.lookup_modification(mods,n) => mm &
	Mod.maybe_modify_class(env,mm,cl') => cl'' &
	Env.extend_frame_v(env,Env.FRAMEVAR(n,ad,cl'',f,p,c,i,o)) => env' &
	Prefix.prefix_add(n,pre) => pre' &
	inst_class(env,Mod.empty_mod,pre',cl'') => l
	--------------------------
	inst_element(env,mods,pre,
		     Absyn.ELEMENT(_,_,Absyn.COMPONENTS(f,p,c,i,o,t,
					    [Absyn.COMPONENT(n,ad,m)])))
         => ((l,env'))

  rule	not Env.lookup_class(env,t) => cl &
	Exp.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_path(Exp.IDENT(n),pre) => n' &
	Exp.path_string(n') => ns &
	print ns & print "\n"
	--------------------------
	inst_element(env,_,pre,
		     Absyn.ELEMENT(_,_,Absyn.COMPONENTS(_,_,_,_,_,t,
					    [Absyn.COMPONENT(n,_,_)])))
         => (([],env))

end

and inst_classpart: (Env.Env,Mod.Mod,Prefix,Absyn.ClassPart)
	  => (DAE.DAEcomp list*Env.Env) =

  rule	inst_list(env,mods,pre,inst_element,l) => x
	-------------------------------------------
	inst_classpart(env,mods,pre,Absyn.PUBLIC(l)) => x

  rule	inst_list(env,mods,pre,inst_element,l) => x
	-------------------------------------------
	inst_classpart(env,mods,pre,Absyn.PROTECTED(l)) => x

  rule	print "No algorithms yet\n" & fail
	----------------------------------
	inst_classpart(env,mods,pre,Absyn.ALGORITHMS(l)) => (([],env))

  rule	inst_list(env,mods,pre,inst_equation,el) => el'
	------------------------------------
	inst_classpart(env,mods,pre,Absyn.EQUATIONS(el)) => el'

end

and inst_classdef: (Env.Env,Mod.Mod,Prefix,Absyn.ClassDef)
	  => (DAE.DAEcomp list*Env.Env) =

  rule	inst_list(env,mods,pre,inst_classpart,pl) => x
	------------------------------------------------
	inst_classdef(env,mods,pre,Absyn.PARTS(pl)) => x

  rule	print "DERIVED not handled\n" & fail
	------------------------------------
	inst_classdef(env,_,_,Absyn.DERIVED(_,_,_)) => (([],env))
end

and inst_class: (Env.Env,Mod.Mod,Prefix,Absyn.Class) => DAE.DAEcomp list =

  rule	print " instantiating " & print n & print "\n" &
	Env.new_frame(env) => env' &
	inst_classdef(env',mods,pre,d) => ((l,_))
	------------------------------------------------------	
	inst_class(env,mods,pre,c as Absyn.CLASS(n,false,r,d)) => l

  rule	print "Can't instantiate partial class " & print n & print "\n" &
	fail
	------------------------------------------------------	
	inst_class(env,mod,pre,Absyn.CLASS(n,true,_,_)) => []

  (* FIXME *)

end

relation inst_program : (Env.Env, Absyn.Program) => DAE.DAEcomp list =

  rule	print "Empty program\n" & fail
	------------------------------
	inst_program(env,[]) => []

  rule	inst_class(env,Absyn.CLASSMOD([]),[],c) => l
	-----------------------------
	inst_program(env,[c]) => l

  rule	Env.extend_frame_c(env,c) => env' &
	inst_program(env',cs) => l
	----------------------
	inst_program(env,c::cs) => l

end

relation instantiate: Absyn.Program => DAE.DAEform =

  rule	Builtin.initial_env => env &
	inst_program(env,p) => l
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end
