(**
 ** file:	 inst.rml
 ** module:      Inst
 ** description: Model instantiation
 **
 ** RCS: $Id$
 **
 ** This module exports only one relation.
 **)

module Inst:

  with "explode.rml"
  with "dae.rml"
  with "debug.rml"
  relation instantiate: SCode.Program => DAE.DAElist

end

(** Other modules used by this module *)

with "exp.rml"
with "algorithm.rml"
with "values.rml"
with "absyn.rml"
with "prefix.rml"
with "env.rml"
with "lookup.rml"
with "builtin.rml"
with "dump.rml"
with "types.rml"
with "connect.rml"
with "classinf.rml"
with "staticexp.rml"
with "mod.rml"
with "rtopts.rml"

(**
 ** These type aliases are introduced to make the code a little more
 ** readable.
 **)

type Prefix = Prefix.Prefix
type Mod = Mod.Mod
type Ident = Exp.Ident
type Env = Env.Env


(** relation: new_ident
 **
 ** This relation creates a new, unique identifer.  The same name is
 ** never returned twice.
 **)

relation new_ident : () => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append("__TMP__",is) => s
	-----------------------------------------------------------------
	new_ident => Exp.CREF_IDENT(s,[])

end


(** relation: select
 **
 ** This utility relation selects one of two objects depending on a
 ** boolean variable.
 **)

relation select : (bool, 'a, 'a) => 'a =

  axiom	select (true,x,_) => x
  axiom	select (false,_,x) => x

end

(** relation: instantiate
 **
 ** To instantiate a Modelica program, an initial environment is
 ** built, containing the predefined types. Then the program is
 ** instantiated by the relation `inst_program'
 **)

relation instantiate: SCode.Program => DAE.DAElist =

  rule	(*Debug. print "\nBefore initial." & *)
	Builtin.initial_env => env &
	(*Debug. print "\nBefore inst_program" & *)
	
	inst_program(env,p) => l 
	(*Debug. print "\nFinished instantiate." *)
	-----------------------------
	instantiate(p) => DAE.DAE(l)

end

(** relation: inst_program
 **
 ** Instantiating a Modelica program is the same as instantiating the
 ** last class definition in the source file. First all the class
 ** definitions is added to the environment without modifications, and
 ** then the last class is instantiated in the relation `inst_class'
 **)

relation inst_program : (Env, SCode.Program) => DAE.Element list =

  rule	print "# Empty program\n"
	------------------------------
	inst_program(env,[]) => fail


  rule	(*Debug. print "\nhepp" &*)
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],c) => (dae,csets,_,_)
	-----------------------------
	inst_program(env,[c as SCode.CLASS(n,_,_,_)])
	  => [DAE.COMP(n,DAE.DAE(dae))]

   (*Debug. rule print "\nfailed" 
	------------
	inst_program(_,_) => fail
*)
  rule	(*Debug. print "\nhopp" & *)
	inst_class_decl(env,Mod.NOMOD,Prefix.NOPRE,[],c) => (env',dae1) &
	(* Env.extend_frame_c(env,c) => env' & *)
	inst_program(env',cs) => dae2 &
	list_append(dae1,dae2) => dae
	----------------------
	inst_program(env,c::(cs as (_::_))) => dae

   rule print "failed" 
	------------
	inst_program(_,_) => fail
end

(** relation: inst_class
 **
 ** Instantiating a class consists of the following steps:
 **
 **  o Create a new frame on the environment
 **  o Initialize the class inference state machine
 **  o Instantiate all the elements and equations
 **  o Generate equations from the connection sets built during
 **    instantiation
 **)

relation inst_class: (Env, Mod, Prefix, Connect.Sets, SCode.Class)
	  => (DAE.Element list, Connect.Sets, Types.Type, ClassInf.State) =

  rule	print "# Can't instantiate partial class " & print n & print "\n"
	------------------------------------------------------	
	inst_class(env,mod,pre, csets, SCode.CLASS(n,true,_,_)) => fail

  rule	(*Debug. print "\n Before open_scope" & *)
	Env.open_scope(env) => env' &
	(*Debug. print "\n Before start" & *)
	ClassInf.start(r,n) => ci_state &
	(*Debug.  print "\n Before inst_class" & *)
	inst_class_in(env', mod, pre, csets, ci_state, c, false)
	  => (dae1,_,csets',ci_state', tys) &
	Connect.equations csets' => dae2 &
	list_append(dae1, dae2) => dae &
	mktype(ci_state',tys) => ty
	-------------------------------------------
	inst_class(env, mod, pre, csets, c as SCode.CLASS(n,_,r,_))
	  => (dae, [], ty,ci_state')

  rule	print "- inst_class " & print n & print " failed\n"
	-----------------------------------------------------
	inst_class(_,_,_,_,SCode.CLASS(n,_,_,_)) => fail
	
end

(** relation: inst_class_in
 **
 ** This rule instantiates the contents of a class definition, with a
 ** new environment already setup.
 **)

relation inst_class_in: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Class, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  rule	inst_classdef(env,mods,pre,csets,ci_state,d,r,prot)
	  => (l,env', csets', ci_state', tys)
	-------------------------------------
	inst_class_in(env,mods,pre,csets,ci_state,
		      c as SCode.CLASS(n,_,r,d), prot)
	  => (l,env', csets', ci_state', tys)

  rule  print "- inst_class_in failed\n"
	----------------------------------
	inst_class_in(_,_,_,csets,_,_,_) => fail

end

(** relation: inst_classdef
 **
 ** There are two kinds of class definitions, either explicit
 ** definitions (`SCode.PARTS()') or derived definitions
 ** (`SCode.DERIVED()').
 **
 ** When instantiating an explicit definition, the elements are first
 ** instantiated, using `inst_element_list', and then the equations
 ** and finally the algorithms are instantiated using `inst_equation'
 ** and `inst_algorithm', respectively. The resulting lists of
 ** equations are concatenated to produce the result.
 **)

relation inst_classdef: (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.ClassDef, Absyn.Restriction, bool)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(** This rule describes how to instantiate an explicit
	 ** class definition *)

  rule	ClassInf.trans(ci_state, ClassInf.NEWDEF) => ci_state' &
	inst_element_list(env,mods,pre,csets,ci_state', els)
	  => (dae1,env', csets', ci_state'', tys) &
	inst_list(env',mods,pre,csets',ci_state'',inst_equation, eqs)
	  => (dae2,env'',csets'', ci_state''') &
	inst_list(env'',mods,pre,csets'',ci_state''', inst_algorithm, als)
	  => (dae3,env''',csets''', ci_state'''') &
	list_append(dae1,dae2) => dae5 &
	list_append(dae5,dae3) => dae
	-----------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.PARTS(els,eqs,als), re, prot)
	  => (dae,env''', csets''', ci_state'''', tys)

	(** This rule describes how to instantiate a derived class *)
	(** definition *)

  rule	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,r,_), cenv) &
	Mod.lookup_modification_p(mods,cn) => m &
	Mod.elab_mod(env,pre,mod) => mod' &
	ClassInf.start(r, cn2) => new_ci_state &
	Mod.merge(mods,m) => mods' &
	Mod.merge(mods',mod') => mods'' &
	inst_class_in(cenv, mods'', pre, csets, new_ci_state, c, prot)
	  => (dae,env, csets', ci_state', tys) &

	(* Check for restriction violations *)
	ClassInf.assert_valid(ci_state', re)
	----------------------------------------
	inst_classdef(env,mods,pre, csets, ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => (dae,env, csets', ci_state', tys)

	(** If the class is derived from a class that can not be *)
	(** found in the environment, this rule prints an error *)
	(** message. *)

  rule	not Lookup.lookup_class(env,cn) => (_,_) &
	Absyn.path_string(cn) => cns &
	print "# unknown class: " & print cns & print "\n"
	----------------------------------------
	inst_classdef(env,mods,pre,csets,ci_state,
		      SCode.DERIVED(cn,ad,mod), re, prot)
	  => fail

  rule	print "- inst_classdef failed\n"
	----------------------------------
	inst_classdef(_,_,_,_,_,_,_,_) => fail

end	

(** relation: inst_element_list
 **
 ** Instantiate elements one at a time, and concatenate the resulting
 ** lists of equations.
 **)

relation inst_element_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			      SCode.Element list)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

  axiom inst_element_list(env,_,_,csets,ci_state,[])
	  => ([], env, csets, ci_state, [])

  rule  inst_element(env,mod,pre,csets,ci_state,el)
	  => (dae1,env',csets',ci_state',tys1) &
	inst_element_list(env',mod,pre,csets',ci_state',els)
	  => (dae2,env'',csets'',ci_state'',tys2) &
	list_append(tys1, tys2) => tys &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_element_list(env,mod,pre,csets,ci_state,el::els)
	  => (dae, env'', csets'', ci_state'', tys)

  rule	print "- inst_element_list failed\n"
	------------------------------------
	inst_element_list(_,_,_,_,_,_) => fail

end

(** relation: inst_element
 ** This monster relation instantiates an element of a class
 ** definition.  An element is either a class definition, a variable,
 ** or an `extends' clause.
 **)

relation inst_element : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			 SCode.Element)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State,
	      Types.Var list) =

	(**  extends
	 **
	 ** Handle "extends" elements by instantiating the class definition
	 ** of the extended class.
	 **)
	 
  rule	Absyn.path_string(cn) => cns &
	
	Lookup.lookup_class(env,cn) => (c as SCode.CLASS(cn2,_,restr,def),
					cenv) &
	Mod.lookup_modification_p(mods,cn) => classmod &
	Mod.elab_mod(env,pre,m) => m' &

	(* Build the combind set of modifications *)
	(* classmod is the modifications stored with the class *)
	(* mods     is the modifications passed to the relation *)
	(* m        is the modification stored in the element *)
	Mod.merge(classmod,mods) => mods' &
	Mod.merge(mods',m') => mods'' &
	
	(* Can't use inst_class, as that creates a new frame *)
	inst_class_in(cenv,mods'',pre,csets,ci_state,c,false)
	  => (dae,env',csets',ci_state',vars)
	----------------------------------
	inst_element(env,mods,pre,csets, ci_state, SCode.EXTENDS(cn,m))
	  => (dae,env',csets',ci_state',vars)
	
  	(**  Rules to catch redeclarations and name collsions
	 **)
	 
	 (* If a variable is declared multiple times, the first is used *)
  rule	Lookup.lookup_ident_local(env,n) => _
	-------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,_,_))
	  => ([],env,csets,ci_state,[])
	
  	(* Illegal redeclarations *)
  rule	Lookup.lookup_ident_local(env,n) => _ &
	print "# Trying to redeclare the class " & print n &
	print " as a variable\n"
	------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.CLASSDEF(n,_,_,_))
	  => fail

  rule	Lookup.lookup_class(env,Absyn.IDENT(n)) => (_,_) &
	print "# Trying to redeclare the variable " & print n &
	print " as a class\n"
	---------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,_,_,_,_,_))
	  => fail

        (**  A new class definition
	 **
	 ** Put it in the current frame in the environment
	 **)
   
  rule	Mod.lookup_modification_p(mods,Absyn.IDENT(n)) => classmod &
	inst_class_decl(env,classmod,pre,csets,c) => (env',dae)
	-------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state, SCode.CLASSDEF(n,_,_,c))
	  => (dae,env',csets,ci_state,[])

	(**  A component
	 **
	 ** This is the rule for instantiating a model component.  A
	 ** component can be a structured subcomponent or a variable,
	 ** parameter or constant.  All of these are treated in a
	 ** similar way.
	 **
	 ** Lookup the class name, apply modifications and add the
	 ** variable to the current frame in the environment. Then
	 ** instantiate the class with an extended prefix.
	 **)

  rule	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,[])) => vn &

	(** The class definition is fetched from the environment. *)
	(** Then the set of modifications is calculated.  The *)
	(** modificions is the result of merging the modifications *)
	(** from several sources.  The modification stored with the *)
	(** class definition is put in the variable `classmod', the *)
	(** modification passed to the relation is extracted and put *)
	(** in the variable `mm', and the modification that is *)
	(** included in the variable declaration is in the variable *)
	(** `m'.  All of these are merged so that the correct *)
	(** precedence rules are followed. *)

	Lookup.lookup_class(env,t) => (cl,cenv) &
	Mod.lookup_modification_p(mods,t) => classmod &
	Mod.lookup_comp_modification(mods,n) => mm &
	Mod.elab_mod(env,pre,m) => m' &

	Mod.merge(classmod,mm) => mod &
	Mod.merge(mod,m') => mod' &
	
	(** If the element is `protected', and an external *)
	(** modification is applied, it is an error. *)

	check_prot(prot, mm, vn) &

	Mod.mod_equation mod' => eq &

	(** The variable declaration and the (optional) equation *)
	(** modification are inspected for array dimensions. *)

	elab_arraydim(env,ad,eq) => dims &


	(** Instantiate the component *)
	inst_var(cenv,mod',pre,csets,n,cl,attr,dims,[])
	  => (dae1,csets',ty) &

	(** The environment is extended with the new variable *)
	(** binding. *)

	make_binding (env,attr,eq,cl) => binding &
	Env.extend_frame_v(env,Types.VAR(n,Types.ATTR(flow,acc,param,dir),
					 prot,ty,binding)) => env' &
	
	(** If the type is one of the simple, predifined types a *)
	(** simple variable declaration is added to the DAE. *)
	(* dae_declare (vn,cl,attr) => dae3 & *)

	let dae = dae1
	(*list_append(dae1, dae2) => dae4 &
	list_append(dae4, dae3) => dae*)
	-----------------------------------------------------------
	inst_element(env,mods,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,
				     attr as SCode.ATTR(ad,flow,acc,param,dir),
				     t,m))
          => (dae, env',csets',ci_state,
	      [Types.VAR(n,Types.ATTR(flow,acc,param,dir), prot, ty, binding)])
	

	(** If the class lookup in the previous rule fails, this
	 ** rule catches the error and prints an error message about
	 ** the unknown class. 
	 **)

	(**  Failure *)
  rule	not Lookup.lookup_class(env,t) => (cl,cenv) &
	Absyn.path_string(t) => s &
	print "# unknown class '" & print s & print "' while instantiating " &
	Prefix.prefix_path(Absyn.IDENT(n),pre) => n' &
	Absyn.path_string(n') => ns &
	print ns & print "\n"
	--------------------------
	inst_element(env,_,pre,csets,ci_state,
		     SCode.COMPONENT(n,final,prot,_,t,_))
         => ([],env,csets,ci_state,[])

  rule	Prefix.prefix_path(Absyn.IDENT(n),pre) => n' &
	Absyn.path_string(n') => ns &
	print "- inst_element COMPONENT(" & print ns & print ") failed\n"
	-----------------------------------------------------------------
	inst_element(_,_,pre,_,_,SCode.COMPONENT(n,_,_,_,_,_))
         => fail

end	

(** relation: inst_var
 **
 ** A component element in a class may consist of several subcomponents
 ** or array elements.  This relation is used to instantiate a
 ** component, instantiating all subcomponents and array elements
 ** separately.
 **)

relation inst_var : (Env.Env,Mod.Mod,Prefix.Prefix,Connect.Sets,Ident,
		     SCode.Class,SCode.Attributes,
		     int list, int list)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

	(** The class is instantiated with the calculated *)
	(** modification, and an extended prefix. *)

  rule	list_reverse idxs => idxs' &
	Prefix.prefix_add(n,idxs',pre) => pre' &
	(* This is where redeclare should be handled *)
	inst_class(env,mod,pre',csets,cl) => (dae1,csets',ty,st) &

	Exp.int_subscripts idxs' => subs &
	Prefix.prefix_cref(pre,Exp.CREF_IDENT(n,subs)) => cr &
	inst_mod_equation(cr,ty,mod) => dae2 &
	dae_declare(cr,ty,SCode.ATTR([], flow, acc, vt, dir)) => dae3 &

	list_append(dae1,dae2) => daex &
	list_append(daex,dae3) => dae
	--------------------------
	inst_var(env,mod,pre,csets,n,cl,SCode.ATTR(_,flow,acc,vt,dir),
		 [],idxs)
          => (dae,csets',ty)

  rule	(* for debugging.
	print "= inst_array mod: " & print n & Mod.print_mod mod & print "\n" & *)
	inst_array(env,mod,pre,csets,n,(cl,attr),1,dim,dims,idxs)
	  => (dae, csets', ty) &
	Types.lift_array(ty,SOME(dim)) => ty'
	-------------------------------
	inst_var(env,mod,pre,csets,n,cl,attr,dim::dims,idxs)
          => (dae,csets',ty')

  rule	print "- inst_var failed: " & print n & print "\n"
	--------------------------------------------------
	inst_var(_,_,_,_,n,_,_,_,_) => fail
	
end

(** relation: inst_array
 **
 ** When an array is instantiated by `inst_var', this relation is used
 ** to go through all the array elements and instantiate each array
 ** element separately.
 **)

relation inst_array : (Env.Env,Mod.Mod,Prefix.Prefix,Connect.Sets,Ident,
		       (SCode.Class*SCode.Attributes),int,int,int list,int list)
	  => (DAE.Element list,Connect.Sets,Types.Type) =

  rule	int_gt(i,stop) => true
	----------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,stop,dims,idxs)
	  => ([], csets, Types.T_NOTYPE)

  rule	Mod.lookup_idx_modification(mod,i) => mod' &
	inst_var(env,mod',pre,csets,n,cl,attr,dims,i::idxs)
	  => (dae1,csets',ty) &
	int_add(i,1) => i' &
	inst_array(env,mod,pre,csets',n,(cl,attr),i',stop,dims,idxs)
	  => (dae2, csets'',_) &

	list_append(dae1,dae2) => dae
	-----------------------------
	inst_array(env,mod,pre,csets,n,(cl,attr),i,stop,dims,idxs)
          => (dae,csets'',ty)

  rule	print "- inst_array failed: " & print n & print "\n"
	--------------------------------------------------
	inst_array(_,_,_,_,n,(_,_),_,_,_,_) => fail
	
end

(** relation: elab_arraydim
 **
 ** This relations examines both an `Absyn.ArrayDim' and an `Mod.EqMod
 ** option' argument to find out the dimensions af a component.  If
 ** no equation modifications is given, only the declared dimension is
 ** used.
 **
 ** When the size of a dimension in the type is undefined, the
 ** corresponding size in the type of the modification is used.
 **
 ** All this is accomplished by examining the two arguments separately
 ** and then using `complete_arraydime' or `compatible_arraydim' to
 ** check that that the dimension sizes are compatible and complete.
 **)

relation elab_arraydim : (Env.Env, Absyn.ArrayDim, Mod.EqMod option)
	  => int list =

  rule	elab_arraydim_decl(env,ad) => dim &
	complete_arraydim(dim) => dim'
	------------------------------
	elab_arraydim(env,ad,NONE) => dim'

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	compatible_arraydim(dim1,dim2) => dim3
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => dim3

  rule	elab_arraydim_decl(env,ad) => dim1 &
	elab_arraydim_type(t,ad) => dim2 &
	not compatible_arraydim(dim1,dim2) => dim3 &
	print "# Array dimension mismatch\n" &
	print "    expression " & Exp.print_exp e &
	print " has type " & Types.print_type t & print "\n" &
	print "    expected array dimensions [" &
	print_dim dim1 & print "]\n"
	---------------------------------
	elab_arraydim(env,ad,SOME((e,Static.PROP(t,c)))) => fail


  rule	print "- elab_arraydim failed\n"
	-------------------------------------
	elab_arraydim(_,_,_) => fail

end

(** relation: print_dim
 **
 ** This relation prints array dimensions.  The code is not included
 ** in the report.
 **)

(*!ignorecode*)
relation print_dim : (int option) list => () =

  rule	print ":"
	---------
	print_dim [NONE]

  rule	int_string x => s & print s
	---------------------------
	print_dim [SOME(x)]

  rule	print ":," & print_dim xs
	-------------------------
	print_dim NONE::xs

  rule	int_string x => s & print s & print "," & print_dim xs
	------------------------------------------------
	print_dim SOME(x)::xs

end
(*!includecode*)

(** relation: elab_arraydim_decl
 **
 ** Given an `Absyj.ArrayDim', this relation evaluates all dimension
 ** size specifications, creating a list of (optional) integers.  When
 ** the array dimension size is specified as `:', the result will
 ** contain `NONE'.
 **)

relation elab_arraydim_decl : (Env.Env, Absyn.ArrayDim) => (int option) list =

  axiom	elab_arraydim_decl(_,[]) => []

  rule	elab_arraydim_decl(env,ds) => l
	-------------------------------
	elab_arraydim_decl(env,Absyn.NOSUB::ds) => NONE::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(Types.T_INTEGER,true)) &
	Static.ceval(env,e) => Values.INTEGER(i) &
	elab_arraydim_decl(env,ds) => l
	-------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => SOME(i)::l

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(Types.T_INTEGER,false)) &
	print "# Variable array sizes are not allowed\n" &
	print "    expression: " & Exp.print_exp e & print "\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => fail

  rule	Static.elab_exp(env, d)
	  => (e,Static.PROP(t,_)) &
	print "# Array dimensions must be integer\n" &
	print "    expression: " & Exp.print_exp e &
 	print " (" & Types.print_type t & print ")\n"
	-------------------------------------------------------
	elab_arraydim_decl(env,Absyn.SUBSCRIPT(d)::ds) => fail

  rule	print "- elab_arraydim_decl failed\n"
	-------------------------------------
	elab_arraydim_decl(_,_) => fail
	
end

(** relation: complete_arraydim
 **
 ** This relation converts a list of optional integers to a list of
 ** integers.  If one element of the list is `NONE', this relation
 ** will fail.
 **
 ** This is used to check that an array specification contain fully
 ** specified array dimension sizes.
 **)

relation complete_arraydim : (int option) list => int list =

  axiom	complete_arraydim [] => []

  rule	complete_arraydim xs => xs'
	---------------------------
	complete_arraydim SOME(x)::xs => x::xs'

end

(** relation: compatible_arraydim
 **
 ** Given two, possibly incomplete, array dimension size
 ** specifications as list of optional integers, this relation checks
 ** whether they are compatible.  Being compatible means that they
 ** have the same number of dimension, and for every dimension at
 ** least one of the lists specifies its size.  If both lists specify
 ** a dimension size, they have to specify the same size.
 **)

relation compatible_arraydim : ((int option) list,(int option) list)
	  => int list =

  axiom	compatible_arraydim([],[]) => []

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(SOME(x)::xs,NONE::ys) => x::l

  rule	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim(NONE::xs,SOME(y)::ys) => y::l

  rule	x = y &
	compatible_arraydim(xs,ys) => l
	-------------------------------
	compatible_arraydim (SOME(x)::xs,SOME(y)::ys) => x::l

  rule	print "- compatible_arraydim failed\n"
	--------------------------------------
	compatible_arraydim (_,_) => fail

end

(** relation: elab_arraydim_type
 **
 ** Find out the dimension sizes of a type.  The second argument is
 ** used to know how many dimensions should be extracted from the
 ** type.
 **)

relation elab_arraydim_type : (Types.Type, Absyn.ArrayDim)
	  => int option list =

  rule  elab_arraydim_type(t,ad) => l
	---------------------------
	elab_arraydim_type(Types.T_ARRAY(Types.DIM(i),t), _::ad) => i::l
	
 axiom elab_arraydim_type(_,[]) => []

 (* PR, for debugging *)
 rule  print "Undefined!" &
	print " The type detected: " &
  	Types.print_type t 
       --------------------
	elab_arraydim_type(t,_::ad) => fail
end

(** relation: inst_class_decl
 **
 ** The class definition is instantiated although no variable
 ** is declared with it.  After instantiating it, it is
 ** checked to see if it can be used as a package, and if it
 ** can, then it is added as a variable under the same name as
 ** the class.  This makes it possible to use a unified lookup
 ** mechanism.  And since packages only can contain constants
 ** and class definition, instantiating a package does not do
 ** anything else.
 **)

relation inst_class_decl : (Env.Env, Mod.Mod, Prefix.Prefix,
			    Connect.Sets, SCode.Class)
	  => (Env.Env, DAE.Element list) =

  rule	Env.extend_frame_c(env,c) => env' &
	implicit_instantiation(env',Mod.NOMOD,pre,csets,c) => (env'',dae)
	----------------------------------
	inst_class_decl(env,mod,pre,csets,c as SCode.CLASS(n,_,restr,_))
	  => (env'', dae)

end

(** relation implicit_instantiation
 **
 ** If a class definition is a function or a package, it is implicitly
 ** instantiated and added as a type binding under the same name
 ** as the class name.
 **)

relation implicit_instantiation : (Env.Env, Mod.Mod, Prefix.Prefix,
				   Connect.Sets, SCode.Class)
	  => (Env.Env, DAE.Element list) =

  rule	Prefix.prefix_add(n,[],pre) => pre' &
	inst_class(env,mod,pre',csets,c) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_PACKAGE,_))
	  => (env', dae)

  rule	Prefix.prefix_add(n,[],pre) => pre' &
	inst_class(env,mod,pre',csets,c) => (dae, csets', ty, st) &
	Env.extend_frame_t(env, n, ty) => env'
	--------------------------------------
	implicit_instantiation(env,mod,pre,csets,
			       c as SCode.CLASS(n,_,Absyn.R_FUNCTION,_))
	  => (env', (*dae*) [])

  axiom	implicit_instantiation(env,mod,pre,csets,c) => (env,[])

end

(** relation: dae_declare
 **
 ** Given a global component name, a type, and a set of attributes,
 ** this relation declares a component for the DAE result.  Altough
 ** this relation returns a list of `DAE.Element's, only one component
 ** is actually declared.
 **
 ** The relations `dae_declare2' and `dae_declare3' below are helper
 ** relations that perform parts of the task.
 **)

relation dae_declare : (Exp.ComponentRef,
			Types.Type, SCode.Attributes) => DAE.Element list =

  rule	dae_declare2 (vn, ty, par) => dae
	-----------------------------------
	dae_declare (vn, ty, SCode.ATTR(_,_,_,par,_)) => dae

  rule	print "- dae_declare failed\n"
	------------------------------
	dae_declare(_,_,_) => fail

end

(**)

relation dae_declare2 : (Exp.ComponentRef, Types.Type, Absyn.Variability)
	  => DAE.Element list =

  rule	dae_declare3 (vn, ty, DAE.VARIABLE) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.VAR) => dae

  rule	dae_declare3 (vn, ty, DAE.DISCRETE) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.DISCRETE) => dae

  rule	dae_declare3 (vn, ty, DAE.PARAM) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.PARAM) => dae

  rule	dae_declare3 (vn, ty, DAE.CONST) => dae
	-----------------------------------------
	dae_declare2 (vn, ty, Absyn.CONST) => dae

  rule	print "- dae_declare2 failed\n"
	------------------------------
	dae_declare2(_,_,_) => fail

end

(**)

relation dae_declare3 : (Exp.ComponentRef, Types.Type, DAE.VarKind)
	  => DAE.Element list =

  axiom	dae_declare3 (vn, Types.T_INTEGER, kind)
	  => [DAE.VAR(vn, kind, DAE.INT)]
	
  axiom	dae_declare3 (vn, Types.T_REAL, kind)
	  => [DAE.VAR(vn, kind, DAE.REAL)]
	
  axiom	dae_declare3 (vn, Types.T_BOOL, kind)
	  => [DAE.VAR(vn, kind, DAE.BOOL)]
	
  axiom	dae_declare3 (vn, Types.T_STRING, kind)
	  => [DAE.VAR(vn, kind, DAE.STRING)]

  axiom	dae_declare3 (c,ty,_) => []

end

(** relation: inst_equation
 **
 ** The DAE output of the translation contains equations which
 ** in most cases directly corresponds to equations in the source.
 ** Some of them are also generated from `connect' clauses.
 **
 ** This relation takes an equation from the source and generates DAE
 ** equations and connection sets.
 **)

relation inst_equation : (Env,Mod, Prefix, Connect.Sets, ClassInf.State,
			  SCode.Equation)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

	(**  connect
	 **
	 ** Handle connct statements
	 **)

  rule	inst_connect(csets,env,pre,c1,c2) => csets' &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------------
	inst_equation(env,mods,pre, csets, ci_state, SCode.EQ_CONNECT(c1,c2))
	  => ([],env,csets',ci_state')
	  
	(**  assert
	 **)

  rule	Static.elab_exp(env,e) => (e', Static.PROP(t, c)) &
	inst_assertion (env, e', t, c, d, pre) => dae &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	--------------------------------------------------------------
	inst_equation(env,mods,pre,csets, ci_state,
		      SCode.EQ_EXPR(Absyn.CALL(Absyn.CREF_IDENT("assert",[]),
					       [e,Absyn.STRING(d)])))
	  => (dae,env,csets,ci_state')

	(**  Normal equations *)

  rule	print "- No expression equations yet\n" &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,SCode.EQ_EXPR(_)) => fail

	(** The following rule handles shadowed (replaced) equations. *)
	(** If an equation has a simple name on the left-hand side, *)
	(** and that component has an equation modifier, this equation *)
	(** is discared. *)
  rule	Lookup.lookup_ident_local(env,n)
	  => Types.VAR(_,_,_,_,Types.EQBOUND(_,_)) &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	------------------------------------------------------
	inst_equation(env,mods,pre,csets,ci_state,
		      SCode.EQ_EQUALS(Absyn.CREF(Absyn.CREF_IDENT(n,[])), e2))
	  => ([],env,csets,ci_state')

(* PR. This is probably where type checking of functions happen.*)
  rule	

	(*PR. propx contains the type/types(for functions) of the resulting expression. But why are e1', e2' needed? They are used to generate the dae's. Probably their type may have been modified.  *)
	Debug.print("\n Expressions matched in inst equation:") &

(*	Absyn.print_absyn_exp(e1) &
*)	
	Debug.print(", ") &

(*	Absyn.print_absyn_exp(e2) &
*)	
	Debug.print("\n") &

	(* 
	Do static analysis and constant evaluation of expressions. 
	Gives expression and properties (Type * bool | (Type * Const as (bool | Const list))).
	For a function, it checks the funtion name. 
	Also the function call's in parameters are type checked with the functions definition's inparameters. This is done with regard to the position of the input arguments.

	Returns the output parameters from the funktion.
	*)

	Static.elab_exp(env,e1) => (e1',prop1) &

	Debug.print("\nDebug: did left elab.") &
	Static.elab_exp(env,e2) => (e2',prop2) &
	Debug.print("\nDebug: did right elab.") &
	(*Exp.print_exp(e1') &*)
	Debug.print(", ") &
	(*Exp.print_exp(e2') & *)
	Debug.print("\n") &

	
	Prefix.prefix_exp(env,e1',pre) => e1'' &
	Prefix.prefix_exp(env,e2',pre) => e2'' &
	Debug.print("\nDebug: did prefixes.") &
	(*PR. Check that the lefthandside and the righthandside get along. *)
	inst_eq_equation(e1'',prop1,e2'',prop2) => dae &
	Debug.print("\nDebug: did inst_eq_equation.") &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'  &
	Debug.print("\nDebug: did ClassInf trans.")
	--------------------------------------------------------------
	inst_equation(env, mods, pre, csets, ci_state, SCode.EQ_EQUALS(e1,e2))
	  => (dae, env, csets, ci_state')

	(**  `if' statements
	 **
	 ** If statements are instantiated by evaluating the
	 ** conditional expression, and selecting the branch that
	 ** should be used.
	 **)

  rule	Static.elab_exp(env,e) => (e',Static.PROP(Types.T_BOOL,true)) &
	Static.ceval(env,e') => Values.BOOL(cond) &
	Debug.print("\nEQ_IF: ") &
(*!!	print(cond) &
*)
(*	Dump.print_exp(cond) &
	*)
	select(cond,tb,fb) => b &
	inst_list(env,mod,pre,csets,ci_state,inst_equation, b)
	  => (dae,env',csets', ci_state')
	--------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_IF(e,tb,fb))
	  => (dae,env',csets', ci_state')


	(**  `when equation' statement, modelica 1.1 
	 **
	 ** When statements are instantiated by evaluating the
	 ** conditional expression.
	 **)

(* Test this! 1.1*)
  rule	(* This is only done for 'for' loops. 
	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND)  &  *)

 	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER),
			     true)) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e') => v &
	(* Not possilbe for 'when'.unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') & *)
	inst_list(env,mod,pre,csets,ci_state,inst_equation, el)
	  => (dae,env',csets', ci_state') (*&
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
*)	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_WHEN(e,el))
	  => (dae, env',csets', ci_state')







	(**  `for' loops
	 **
	 ** The loop expression is evaluated to a constant array of
	 ** integers, and then the loop is unrolled.
	 **
	 **)

  rule	Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND) &
	Static.elab_exp (env,e)
	  => (e',Static.PROP(Types.T_ARRAY(Types.DIM(_),
					   Types.T_INTEGER),
			     true)) &
	(* FIXEM: Check bounds *)
	Static.ceval (env,e') => v &
	unroll(env,mod,pre,csets,ci_state,i,v,el) => (dae, csets') &
	ClassInf.trans(ci_state, ClassInf.FOUND_EQUATION) => ci_state'
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => (dae, env,csets', ci_state')

  rule	not Lookup.lookup_var(env, Exp.CREF_IDENT(i,[]))
	  => (Types.ATTR(false, SCode.RW, Absyn.VAR, _),
	      Types.T_INTEGER, Types.UNBOUND) &
	print "# Invalid loop variable: " & print i & print "\n"
	-----------------------------------------------------------
	inst_equation(env,mod,pre,csets,ci_state,SCode.EQ_FOR(i,e,el))
	  => fail

  rule	print "- inst_equation failed\n"
	----------------------------------
	inst_equation(_,_,_,_,_,_) => fail

end

(** relation: inst_eq_equation
 **
 ** Equations follow the same typing rules as equality expressions.
 ** This relation adds the equation to the DAE.
 **
 **)

relation inst_eq_equation : (Exp.Exp, Static.Properties,
			     Exp.Exp, Static.Properties) => DAE.Element list =
	(*PR. e1= lefthandside, e2=righthandside
	* This seem to be a strange relation. 
	* wich rule is matched? or is both rules matched?
	*)
	
	(* This rule is matched first, if it fail the next rule is matched.
	 *)
  rule	Debug.print("\ninst_eq_equation (match e1) PROP, PROP") &
	Static.match_prop(e1, p1, p2) => e1' &
	inst_eq_equation_2(e1', e2, t2) => dae 

	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae

	(* If it fails then this rule is matched. *)
  rule	Debug.print("\ninst_eq_equation (match e2) PROP, PROP") &
	Static.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP(t1,_),
			 e2,p2 as Static.PROP(t2,_))
	  => dae



  rule	
	Debug.print("\ninst_eq_equation(e1) PROP_TUPLE, PROP_TUPLE") &
	(*Exp.print_exp (e1) & *)
	Static.match_prop(e1, p1, p2) => e1' &
	(*Exp.print_exp (e1') & *)
	inst_eq_equation_2(e1', e2, t2) => dae 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,p2 as Static.PROP_TUPLE(t2,_))
	  => dae


(*
  rule
	print("\n So far so good.") &
	
	print("\n  ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,Static.PROP_TUPLE(t2,_))
	  => fail
*)



	(* PR. *)	
  rule 	Debug.print("\ninst_eq_equation(e2) PROP_TUPLE, PROP_TUPLE") &
	Debug.print "\n About to do a static match e2. " &
	Static.match_prop(e2, p2, p1) => e2'&
	Debug.print("\n Second rule of relation inst_eq_equation ") &
	inst_eq_equation_2(e1, e2', t1) => dae &
	Debug.print("\n Second rule complete. ") 
	------------------------------------------
	inst_eq_equation(e1,p1 as Static.PROP_TUPLE(t1,_),
			 e2,p2 as Static.PROP_TUPLE(t2,_))
	  => dae

  rule	(* Types.equivtypes(t1,t2) => false & *)
	print "# Illegal types in equation\n"&
	print "    lhs: " & Exp.print_exp e1 &
	print " :: " & Types.print_type t1 & print "\n" &
	print "    rhs: " & Exp.print_exp e2 &
	print " :: " & Types.print_type t2 & print "\n"
	----------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2,Static.PROP(t2,_)) => fail


(* PR To debug*)

rule	Debug.print("\ne1 is PROP and e2 is PROP_TUPLE.  ")
	----------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2, Static.PROP_TUPLE(_,_)) => fail

rule	Debug.print("e2 is PROP")
	----------
	inst_eq_equation(e1,_,
			 e2,Static.PROP(t2,_)) => fail

rule	Debug.print("e1 is PROP")
	----------
	inst_eq_equation(e1,Static.PROP(t1,_),
			 e2, _) => fail




(* No match. *)
  rule  print ("\n No match in inst_eq_equation. ")
	---------------
	inst_eq_equation(_,_,_,_) => fail

end

(** relation: inst_eq_equation_2
 **
 ** This is the second stage of `inst_eq_equation', when the types are
 ** checked.
 **)

relation inst_eq_equation_2 : (Exp.Exp, Exp.Exp, Types.Type)
	=> DAE.Element list =

  axiom	inst_eq_equation_2(e1,e2,Types.T_INTEGER)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_REAL)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_STRING)
	=> [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1,e2,Types.T_BOOL)
	=> [DAE.EQUATION(e1,e2)]

  rule	RTOpts.split_arrays => true &
	(* For debugging.
	print "  Array equation: " &
	Exp.print_exp e1 & print " = " &
	Exp.print_exp e2 & print "\n" & *)
	inst_array_equation(e1,e2,ad,t) => dae
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t)) => dae


	(* PR. The muliple outputs from functions is outputed as is. *)

  axiom	inst_eq_equation_2(e1,e2,Types.T_TUPLE(_))
	  => [DAE.EQUATION(e1,e2)]


  rule	RTOpts.split_arrays => false
	-----------------------------------------
	inst_eq_equation_2(e1,e2,Types.T_ARRAY(ad,t))
	  => [DAE.EQUATION(e1,e2)]

  axiom	inst_eq_equation_2(e1, e2, Types.T_COMPLEX(_,[])) => []

  rule	Exp.extend_cref(c1,n,[]) => c1' &
	Exp.extend_cref(c2,n,[]) => c2' &
	inst_eq_equation_2(Exp.CREF(c1'), Exp.CREF(c2'), t) => dae1 &
	inst_eq_equation_2(Exp.CREF(c1), Exp.CREF(c2),
			   Types.T_COMPLEX(cs,vs)) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_eq_equation_2(Exp.CREF(c1), Exp.CREF(c2),
			   Types.T_COMPLEX(cs,Types.VAR(n,_,_,t,_)::vs)) => dae

	(** When the type of the expressions is a complex type, and *)
	(** the left-hand side of the equation is not a component *)
	(** reference, a new variable is introduced to be able to *)
	(** dereference components of the expression. *)
	(** *)
	(** This is rather ugly, since it doesn't really solve the *)
	(** problem of describing the semantics.  Now the semantics of *)
	(** composite equations are defined in terms of other *)
	(** composite equations.  To make this a little cleaner, the *)
	(** equation that equates the new name to the expression is *)
	(** stored using DAE.DEFINE rather than DAE.EQUATION.  This *)
	(** makes it a little clearer. *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR))
	  => decl &
	inst_eq_equation_2(Exp.CREF(n), e2, t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e1)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2 as Exp.CREF(_),
			   t as Types.T_COMPLEX(_,_)) => dae

	(** When the right-hand side is not a component reference a *)
	(** similar trick is applied.  This also catched the case *)
	(** where none of the sides is a component reference *)
  rule	new_ident => n &
	dae_declare(n, t, SCode.ATTR([], false, SCode.RW,
				     Absyn.VAR, Absyn.BIDIR))
	  => decl &
	inst_eq_equation_2(e1, Exp.CREF(n), t) => dae1 &
	list_append(decl, DAE.DEFINE(n, e2)::dae1) => dae
	-------------------------------------------------------------
	inst_eq_equation_2(e1, e2, t as Types.T_COMPLEX(_,_)) => dae

  rule	print "- inst_eq_equation_2 failed\n"
	-------------------------------------
	inst_eq_equation_2(_,_,_) => fail

end

(** relation: inst_array_equation
 **
 ** This checks the array size and uses `inst_array_el_eq' to create
 ** equations for each array element.
 **)

relation inst_array_equation : (Exp.Exp, Exp.Exp,
				Types.ArrayDim, Types.Type)
	  => DAE.Element list =

  rule	print "# Cannot instantiate equations with arrays of unknown size\n" &
	print "    " & Exp.print_exp e1 & print " = " & Exp.print_exp e2&
	print "\n"
	----------
	inst_array_equation(e1, e2, Types.DIM(NONE), t) => fail

  rule	inst_array_el_eq(e1, e2, t, 1, sz) => dae
	---------------------------------------------
	inst_array_equation(e1, e2, Types.DIM(SOME(sz)), t) => dae

  rule	print "- inst_array_equation failed\n"
	--------------------------------------
	inst_array_equation (_,_,_,_) => fail

end

(** relation: inst_array_el_eq
 **
 ** This relation loops recursively through all indexes in the two
 ** arrays and generates an equation for each pair of elements.
 **)

relation inst_array_el_eq : (Exp.Exp, Exp.Exp, Types.Type, int, int)
	  => DAE.Element list =

  rule	int_le(i,sz) => true &
	Exp.simplify(Exp.ASUB(e1,i)) => e1' &
	Exp.simplify(Exp.ASUB(e2,i)) => e2' &
	inst_eq_equation_2(e1',e2',t) => dae1 &
	int_add(i,1) => i' &
	inst_array_el_eq(e1,e2,t,i',sz) => dae2 &
	list_append(dae1, dae2) => dae
	------------------------------
	inst_array_el_eq(e1, e2, t, i, sz) => dae

  rule	int_le(i,sz) => false
	---------------------
	inst_array_el_eq(e1, e2, t, i, sz) => []

  rule	print "- inst_array_el_eq failed\n"
	-----------------------------------
	inst_array_el_eq(_,_,_,_,_) => fail

end

(** relation: inst_assertion
 **
 ** Instantiate an assertion.  There are not assertions in the output
 ** currently.
 **)

relation inst_assertion : (Env.Env, Exp.Exp, Types.Type,
			   bool, string, Prefix)
	  => DAE.Element list =

	(* Constant assertions *)
  axiom	inst_assertion (env, e, Types.T_BOOL, true, d, pre) => [(* lost *)]

  axiom	inst_assertion (env, e, Types.T_BOOL, _, d, pre) => [(* lost *)]

  rule	print "# Assertions have to be of type Boolean\n" &
	print "  assertion: (" &
	Prefix.prefix_exp(env,e,pre) => e' & Exp.print_exp e' & print "): " &
 	print d & print "\n"
	-----------------------------
	inst_assertion (env, e, _, _, d, pre) => fail
	
end

(** relation: unroll
 **
 ** Unrolling a loop is a way of removing the non-linear structure of
 ** the `for' clause by explicitly repeating the body of the loop once
 ** for each iteration.
 **)

relation unroll : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		   Ident, Values.Value, SCode.Equation list)
	  => (DAE.Element list, Connect.Sets) =

  axiom	unroll (_,_,_,csets,_,_,Values.ARRAY([]),_) => ([], csets)

  rule	Env.open_scope env => env' &
	Env.extend_frame_v (env',
			    Types.VAR(i, Types.ATTR(false,
						    SCode.RO,
						    Absyn.CONST,
						    Absyn.BIDIR),
				      true,
				      Types.T_INTEGER,
				      Types.VALBOUND(fst))) => env'' &
	inst_list(env'',mods,pre,csets,ci_state,inst_equation, eqs)
	  => (dae1,env''',csets', ci_state') &
	unroll (env, mods, pre, csets', ci_state', i, Values.ARRAY(rest), eqs)
	  => (dae2, csets'') &
	list_append(dae1,dae2) => dae
	-----------------------------
	unroll (env,mods,pre,csets,ci_state,i,Values.ARRAY(fst::rest),eqs)
	  => (dae, csets'')

  rule	print "- unroll " & Values.print_val v & print " failed\n"
	-------------------------
	unroll (_,_,_,_,_,_,v,_) => fail

end

(** relation: inst_algorithm
 **
 ** Algorithms are converted to the representation defined in the
 ** module `Algorithm', and the added to the DAE result.
 **
 ** This relation converts an algorithm section.
 **)

relation inst_algorithm : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
			   SCode.Algorithm)
	  => (DAE.Element list, Env, Connect.Sets, ClassInf.State) =

  rule	inst_statements(env,statements) => statements'
	----------------------------------------------
	inst_algorithm(env,_,_,csets,ci_state,SCode.ALGORITHM(statements))
	  => ([DAE.ALGORITHM(Algorithm.ALGORITHM(statements'))],
	      env,csets,ci_state)

  rule	print "- inst_algorithm failed\n"
	---------------------------------
	inst_algorithm(_,_,_,_,_,_) => fail

end

(** relation: inst_statements
 **
 ** This relation converts a list of algorithm statements.
 **)

relation inst_statements : (Env, Absyn.Algorithm list)
	  => Algorithm.Statement list =

  axiom	inst_statements(env,[]) => []

  rule	inst_statement(env,x) => x' &
	inst_statements(env,xs) => xs'
	------------------------------
	inst_statements(env,x::xs) => x'::xs'

end

(** relation: inst_statement
 **
 ** This relation Looks at an algorithm statement and uses relations
 ** in the `Algorithm' module to build a representation of it that can
 ** be used in the DAE output.
 **)

relation inst_statement : (Env, Absyn.Algorithm) => Algorithm.Statement =

  rule	Static.elab_cref (env,cr) => (ce, cprop, acc) &
	Static.elab_exp (env,e) => (e', eprop) &
	Algorithm.make_assignment(ce,cprop,e',eprop,acc) => stmt
	--------------------------------------------------------
	inst_statement(env,Absyn.ALG_ASSIGN(cr,e)) => stmt

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,tb) => tb' &
	inst_elseifs(env,eib) => eib' &
	inst_statements(env,fb) => fb' &
	Algorithm.make_if(e',prop,tb',eib',fb') => stmt
	--------------------------------------------
	inst_statement(env,Absyn.ALG_IF(e,tb,eib,fb)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_for(i,e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_FOR(i,e,sl)) => stmt

  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_while(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHILE(e,sl)) => stmt


  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_when_a(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN_A(e,sl)) => stmt

(* 1.0
  rule	Static.elab_exp (env,e) => (e',prop) &
	inst_statements(env,sl) => sl' &
	Algorithm.make_when(e',prop,sl') => stmt
	---------------------------------------
	inst_statement(env,Absyn.ALG_WHEN(e,sl)) => stmt
*)
  rule	print "- inst_statement failed\n"
	---------------------------------
	inst_statement(_,_) => fail

end

(** relation: inst_elseifs
 **
 ** This relation helps `inst_statement' to handle `elseif' parts.
 **)

relation inst_elseifs : (Env.Env, (Absyn.Exp * Absyn.Algorithm list) list)
	=> (Exp.Exp * Static.Properties * Algorithm.Statement list) list =

  axiom	inst_elseifs (env,[]) => []

  rule	Static.elab_exp(env,e) => (e',prop) &
	inst_statements(env,l) => stmts &
	inst_elseifs(env,tail) => tail'
	-------------------------------
	inst_elseifs(env,(e,l)::tail) => ((e',prop,stmts)::tail')

  rule	print "- inst_elseifs failed\n"
	-------------------------------
	inst_elseifs(_,_) => fail

end

(** relation: inst_connect
 **)

relation inst_connect: (Connect.Sets, Env, Prefix,
			Absyn.ComponentRef, Absyn.ComponentRef)
	  => Connect.Sets =

  rule	Static.elab_cref(env, c1) => (Exp.CREF(c1'),prop1,acc) &
	Static.elab_cref(env, c2) => (Exp.CREF(c2'),prop2,acc) &
	Static.canon_cref(env, c1') => c1'' &
	Static.canon_cref(env, c2') => c2'' &
	Lookup.lookup_var_local(env,c1'')
	  => (attr1 as Types.ATTR(flow1,_,_,_),ty1,_) &
	Lookup.lookup_var_local(env,c2'') => (attr2,ty2,_) &
	
	(** Check that the types of the connectors are good. *)
	valid_connector(ty1) &
	valid_connector(ty2) &
	check_connect_types(c1'',ty1,attr1,c2'',ty2,attr2) &
	
	component_face(c1'') => f1 &
	component_face(c2'') => f2 &
	connect_components(sets, pre, c1'', f1, ty1, c2'', f2, ty2, flow1)
	  => sets'
	---------------------------------
	inst_connect(sets, env,pre,c1,c2) => sets'

  rule	print "# could not connect\n"
	---------------------------------
	inst_connect(sets,_,_,_,_) => fail

end

(** relation: valid_connector
 **
 ** This relation tests whether a type is a eligible to be used in
 ** connections.
 **
 **)

relation valid_connector : Types.Type => () =

  axiom	valid_connector Types.T_REAL

  rule	ClassInf.valid(state,Absyn.R_CONNECTOR)
	---------------------------------------
	valid_connector Types.T_COMPLEX(state,_)

  rule	print "# Can't connect objects of type " &
	Types.print_type t & print "\n"
	-------------------------------
	valid_connector t => fail
end

(** relation: check_connect_types
 **
 ** Check that the type and type attributes of two connectors match,
 ** so that they really may be connected.
 **
 **)

relation check_connect_types : (Exp.ComponentRef, Types.Type,
				Types.Attributes,
			       	Exp.ComponentRef, Types.Type,
				Types.Attributes) => () =

  rule	print "# Can't connect two input variables\n" &
	print "    while connecting " & Exp.print_component_ref c1 &
	print " to " & Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.INPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.INPUT)) => fail

  rule	print "# Can't connect two output variables\n" &
	print "    while connecting " & Exp.print_component_ref c1 &
	print " to " & Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(_,_,_,Absyn.OUTPUT),
			    c2,_,Types.ATTR(_,_,_,Absyn.OUTPUT)) => fail

  rule	flow1 = flow2 &
	Types.equivtypes(t1, t2) => true
	-------------------------------
	check_connect_types(_,t1,Types.ATTR(flow1,_,_,_),
			    _,t2,Types.ATTR(flow2,_,_,_))

  rule	print "# Can't connect flow component " &
 	Exp.print_component_ref c1 &
	print " to non-flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(true,_,_,_),
			    c2,_,Types.ATTR(false,_,_,_)) => fail

  rule	print "# Can't connect non-flow component " &
 	Exp.print_component_ref c1 &
	print " to flow component " &
 	Exp.print_component_ref c2 & print "\n"
	------------------------------------------------------
	check_connect_types(c1,_,Types.ATTR(false,_,_,_),
			    c2,_,Types.ATTR(true,_,_,_)) => fail

  rule	print "- check_connect_types(" & Exp.print_component_ref c1 &
	print " <-> " & Exp.print_component_ref c2 & print ") failed\n"
	------------------------------------------------------
	check_connect_types(c1,_,_,c2,_,_) => fail

end

(** relation: connect_components
 **
 ** This relation connects two components and generates connection
 ** sets along the way.  For simple components (of type `Real') it
 ** adds the components to the set, and for complex types it traverses
 ** the subcomponents and recursively connects them to each other.
 **)

relation connect_components: (Connect.Sets,
			      Prefix,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      Exp.ComponentRef, Connect.Face, Types.Type,
			      bool) => Connect.Sets =
	
	(**  Flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_flow(sets, c1', f1, c2', f2) => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, f1, Types.T_REAL,
			   c2, f2, Types.T_REAL, true) => sets'
	
	(**  Non-flow type *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	Connect.add_equ(sets, c1', c2') => sets'
	-----------------------------------------
	connect_components(sets, pre, c1, _, Types.T_REAL,
			   c2, _, Types.T_REAL, false) => sets'

	(**  Complex types *)

  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	connect_vars(sets,c1',f1,l1,c2',f2,l2) => sets'
	----------------------------------------
	connect_components(sets,pre,c1,f1, Types.T_COMPLEX(_,l1),
			   c2,f2, Types.T_COMPLEX(_,l2),_) => sets'

	(**  Error *)
	
  rule	Prefix.prefix_cref(pre, c1) => c1' &
	Prefix.prefix_cref(pre, c2) => c2' &
	print "# Wrong type in connection\n"&
 	print "  while making connectiion " &
	Exp.print_component_ref c1 & print " <-> " &
	Exp.print_component_ref c2 & print "\n" &
	print "  The type `" & Types.print_type t1 &
	print "' is not allowed in connections\n"
	----------------------------------------
	connect_components(_,pre,c1,_,t1,c2,_,t2,_) => fail
	
end

(** relation: connect_vars
 **
 ** This relation connects two subcomponents by adding the component
 ** name to the current path and recursively connecting the components
 ** using the relation `connet_components'.
 **)

relation connect_vars : (Connect.Sets,
			 Exp.ComponentRef, Connect.Face, Types.Var list,
			 Exp.ComponentRef, Connect.Face, Types.Var list)
	  => Connect.Sets =

  axiom	connect_vars(sets,_,_,[],_,_,[]) => sets

  rule	Exp.extend_cref(c1, n, []) => c1' &
	Exp.extend_cref(c2, n, []) => c2' &
	check_connect_types(c1', ty1, attr1, c2', ty2, attr2) &
	connect_components(sets,Prefix.NOPRE,
			   c1',f1, ty1,
			   c2',f2, ty2, flow1) => sets' &
	connect_vars(sets',c1,f1,xs1,c2,f2,xs2) => sets''
	--------------------------------------
	connect_vars(sets,
		     c1,f1, Types.VAR(n,attr1 as Types.ATTR(flow1,_,vt1,_),
				      _,ty1,_)::xs1,
		     c2,f2, Types.VAR(_,attr2 as Types.ATTR(flow2,_,vt2,_),
				      _,ty2,_)::xs2)
	  => sets''

end

(** relation: mktype
 **
 ** From a class inference state, and a list of subcomponents, this
 ** relation returns `Types.Type'.  If the class inference state
 ** indicates that the type should be a built-in type, one of the
 ** built-in type constructors is used.  Otherwise, a `T_COMPLEX' is
 ** built.
 **)

relation mktype : (ClassInf.State,Types.Var list) => Types.Type =

  axiom	mktype(ClassInf.TYPE_INTEGER(_),_) => Types.T_INTEGER
  axiom	mktype(ClassInf.TYPE_REAL(_),_)    => Types.T_REAL
  axiom	mktype(ClassInf.TYPE_STRING(_),_)  => Types.T_STRING
  axiom	mktype(ClassInf.TYPE_BOOL(_),_)    => Types.T_BOOL

  axiom	mktype(st,l) => Types.T_COMPLEX(st,l)

end

(** relation: inst_list
 **
 ** This is a utility used to do instantiation of list of things,
 ** collecting the result in another list.
 **)

relation inst_list : (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		      (Env, Mod, Prefix, Connect.Sets, ClassInf.State,
		       'a) => ('b list, Env, Connect.Sets, ClassInf.State),
		      'a list)
	  => ('b list, Env, Connect.Sets, ClassInf.State) =

  axiom inst_list(env,mod,pre,csets,ci_state,r,[]) => ([],env,csets,ci_state)

  rule	r(env,mod,pre,csets,ci_state,e) => (l,env',csets',ci_state') &
	inst_list(env',mod,pre,csets',ci_state',r,es)
	  => (l',env'',csets'',ci_state'') &
	list_append(l,l') => l''
	--------------------------------------------
	inst_list(env,mod,pre,csets,ci_state,r,e::es)
	  => (l'',env'',csets'',ci_state'')

end

(** relation: component_face
 ** 
 ** This relation determines whether a component reference refers to an
 ** inner or outer connector.
 **)

relation component_face : Exp.ComponentRef => Connect.Face =

  axiom component_face Exp.CREF_QUAL(_,_,Exp.CREF_IDENT(_,_)) => Connect.INNER

  axiom	component_face Exp.CREF_IDENT(_,_) => Connect.OUTER

  rule	print "# While connecting " &
	Exp.print_component_ref c & print "\n" &
	print "# Only local or child connectors allowed.\n"
	---------------------------------------------------
	component_face c => fail

end

(** relation: inst_mod_equation
 **
 ** This relation adds the equation in the declaration of a variable,
 ** if such an equation exists.
 **)

relation inst_mod_equation : (Exp.ComponentRef, Types.Type, Mod)
	  => DAE.Element list =

(*!ignorecode*)
	(* This is pretty ugly, but I don't want to infect the report *)
  rule  RTOpts.modelica_output => true
	------------------------------
	inst_mod_equation(cr,ty1, mod as Mod.MOD(_,_,SOME((e,prop2))))
	  => [DAE.VARVAL(e)]
(*!includecode*)
	  
  rule  inst_eq_equation(Exp.CREF(cr),
			 Static.PROP(ty1,false(*FIXME*)), e,prop2) => dae
	-----------------------------------------------
	inst_mod_equation(cr,ty1, mod as Mod.MOD(_,_,SOME((e,prop2))))
	  => dae
	  
  axiom inst_mod_equation(_,_,Mod.MOD(_,_,NONE)) => []
  axiom inst_mod_equation(_,_,Mod.NOMOD) => []

  rule	print "- inst_mod_equation failed\n"
	------------------------------------
  	inst_mod_equation (_,_,_) => fail

end

(** relation: check_prot
 **
 ** This relation is used to check that a protected element is not
 ** modified.
 **)

relation check_prot : (bool, Mod.Mod, Exp.ComponentRef) => () =

  axiom	check_prot(false,_,cref)
	
  axiom check_prot(_,Mod.NOMOD,_)

  rule  print "# Trying to modify protected element " &
	Exp.print_component_ref cref & print "\n"
	-----------------------------------------
	check_prot(true,_,cref) => fail

end

(** relation: make_binding
 **
 ** This relation looks at the equation part of a modification, and if
 ** there is a declaration equation builds a `Types.Binding' for it.
 **
 **)

relation make_binding : (Env.Env, SCode.Attributes, Mod.EqMod option, SCode.Class)
	  => Types.Binding =

  axiom	make_binding (_,_,NONE,_) => Types.UNBOUND

	(* Constant binding *)
  axiom	make_binding (env, SCode.ATTR(_,_,_,Absyn.CONST,_), SOME((e,prop)), cl)
	  => Types.EQBOUND(e,true)

	(* default *)

  axiom	make_binding (_,_, SOME((e,Static.PROP(t,c))),_) => Types.EQBOUND(e,c)

  rule	print "- make_binding failed\n"
	-------------------------------
	make_binding(_,_,_,_) => fail

end
