(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 ModUtil.rml
 ** module:      ModUtil
 ** description: Miscellanous modelica related utilities (The horror, THE HORROR)
 **
 ** RCS: $Id$
 ** 
 ** This module contains various utilities. For example
 ** converting a path to a string and comparing two paths.
 ** It is used pretty much everywhere. The difference between this 
 ** module and the Util module is that ModUtil contains modelica 
 ** related utilities. The Util module only contains "low-level" 
 ** rml utilities, for example finding elements in lists.
 ** 
 **)


module ModUtil :

  with "Absyn.rml"
  with "DAE.rml"
  with "Exp.rml"

  relation path_string: Absyn.Path => string
  relation opt_path_string: Absyn.Path option => string
  relation path_string2: (Absyn.Path, string) => string

  relation string_prefix_component_refs : (string, 
					   (Exp.ComponentRef, 'b) => (), 
					   'b, 
					   Exp.Exp list) => Exp.Exp list

  relation string_prefix_component_ref : (string, 
					  (Exp.ComponentRef, 'b) => (), 
					  'b, 
					  Exp.Exp) => Exp.Exp

  relation string_prefix_elements : (string, 
				     DAE.Element list, 
				     DAE.Element list) => DAE.Element list

  relation string_prefix_params : DAE.DAElist => DAE.DAElist

  relation path_equal : (Absyn.Path, Absyn.Path) => bool
  relation path_subsuffix_equal : (Absyn.Path, Absyn.Path) => bool
end

with "RTOpts.rml"
with "Util.rml"
with "Print.rml"

relation string_prefix_component_refs : (string, (Exp.ComponentRef, 'b) 
					 => (), 'b, Exp.Exp list) 
	  => Exp.Exp list =

  axiom	string_prefix_component_refs (_, _, _, []) => []
	
  rule	string_prefix_component_refs (str, r, rarg, rest) => res &
	string_prefix_component_ref (str, r, rarg, e) => e'
	----------------------------------------------
	string_prefix_component_refs (str, r, rarg, e::rest) => e'::res
end


relation string_prefix_component_ref : (string, (Exp.ComponentRef, 'b) 
					=> (), 'b, Exp.Exp) 
	  => Exp.Exp =

  rule	r(cr, rarg) &
	string_prefix_cref (str, cr) => cr'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CREF(cr,t)) 
	  => Exp.CREF(cr',t)

  rule	not r(cr, rarg)
	----------------------------------------------
	string_prefix_component_ref (_, r, rarg, Exp.CREF(cr,t)) 
	  => Exp.CREF(cr,t)

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.BINARY(e1,op,e2)) 
	  => Exp.BINARY(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.UNARY(op,e1)) 
	  => Exp.UNARY(op,e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.LBINARY(e1,op,e2)) 
	  => Exp.LBINARY(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.LUNARY(op,e1)) 
	  => Exp.LUNARY(op,e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RELATION(e1,op,e2)) 
	  => Exp.RELATION(e1',op,e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2' &
	string_prefix_component_ref (str, r, rarg, e3) => e3'
	----------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.IFEXP(e1,e2,e3)) 
	  => Exp.IFEXP(e1',e2',e3')

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CALL(p, el,b,bi)) 
	  => Exp.CALL(p, el',b,bi)

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.ARRAY(t,a,el)) 
	  => Exp.ARRAY(t,a,el')

  rule	Util.list_list_map(ell,Util.tuple2_1) => el &
	Util.list_list_map(ell,Util.tuple2_2)=> bl &
	string_prefix_component_refs_list (str, r, rarg, el) => el' &
	Util.list_list_thread_tuple(el',bl) => ell'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.MATRIX(t,a,ell)) 
	  => Exp.MATRIX(t,a,ell')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RANGE(t,e1, NONE, e2))
	  => Exp.RANGE(t,e1', NONE, e2')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1' &
	string_prefix_component_ref (str, r, rarg, e2) => e2' &
	string_prefix_component_ref (str, r, rarg, e3) => e3'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.RANGE(t,e1, SOME(e2), e3))
	  => Exp.RANGE(t,e1', SOME(e2'), e3')

  rule	string_prefix_component_refs (str, r, rarg, el) => el'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.TUPLE(el)) 
	  => Exp.TUPLE(el')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.CAST(ty, e1)) 
	  => Exp.CAST(ty, e1')

  rule	string_prefix_component_ref (str, r, rarg, e1) => e1'
	--------------------------------------------
	string_prefix_component_ref (str, r, rarg, Exp.ASUB(e1, i)) 
	  => Exp.ASUB(e1', i)

  axiom	string_prefix_component_ref (str, r, rarg, e) => e

end

relation string_prefix_component_refs_list : 
	(string, (Exp.ComponentRef, 'b) => (), 'b, Exp.Exp list list) => Exp.Exp list list =

  axiom string_prefix_component_refs_list (_, _, _, []) => []

  rule	string_prefix_component_refs (str, r, rarg, el) => el' &
	string_prefix_component_refs_list (str, r, rarg, rest) => res
	----------------------------------------------------
	string_prefix_component_refs_list (str, r, rarg, el::rest) => el'::res

end

relation string_prefix_cref : (string, Exp.ComponentRef) 
	  => Exp.ComponentRef =

  rule	string_append (str, s) => s'
	-----------------------
	string_prefix_cref (str, Exp.CREF_IDENT(s, si)) => Exp.CREF_IDENT(s', si)

  rule	string_append (str, s) => s'
	-----------------------
	string_prefix_cref (str, Exp.CREF_QUAL(s, si, cr)) 
	  => Exp.CREF_QUAL(s', si, cr)

end


relation string_prefix_elements : (string, DAE.Element list, DAE.Element list) 
	  => DAE.Element list =

  axiom	string_prefix_elements (_, _, []) => []

  rule	string_prefix_element (str, dae, el) => el' &
	string_prefix_elements (str, dae, rest) => res
	-----------------------------------------
	string_prefix_elements (str, dae, el::rest) => el'::res

end

relation string_prefix_element : (string, DAE.Element list, DAE.Element) 
	  => DAE.Element =


  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp) => exp'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.VAR(cr,vk,vd,ty,SOME(exp),inst_dims,start,flow,cl,dae_var_attr,comment)) 
	  => DAE.VAR(cr,vk,vd,ty,SOME(exp'),inst_dims,start,flow,cl,dae_var_attr,comment)

  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp) => exp'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.DEFINE(cr,exp)) 
	  => DAE.DEFINE(cr,exp')

  rule	string_prefix_component_ref (str, is_parameter_daelist, dae, exp1) 
	  => exp1' &
	string_prefix_component_ref (str, is_parameter_daelist, dae, exp2) 
	  => exp2'
	-----------------------------------------------------------------
	string_prefix_element (str, dae, DAE.EQUATION(exp1,exp2)) 
	  => DAE.EQUATION(exp1',exp2')

  axiom   string_prefix_element (str, dae, DAE.ALGORITHM(alg)) => DAE.ALGORITHM(alg)


(** What happens if a variable is not found among dae, should we check dae1,
    i.e. where the COMP and FUNCTION was found? **)
  rule	string_prefix_elements (str, dae, dae) => dae'
	----------------------------------------------
	string_prefix_element (str, dae1, DAE.COMP(n, DAE.DAE(dae))) 
	  => DAE.COMP(n, DAE.DAE(dae'))

  rule	string_prefix_elements (str, dae, dae) => dae'
	----------------------------------------------
	string_prefix_element (str, dae1, DAE.FUNCTION(n, DAE.DAE(dae), ty)) 
	  => DAE.FUNCTION(n, DAE.DAE(dae'), ty)

  rule	string_prefix_elements (str, dae, dae) => dae'
	----------------------------------------------
	string_prefix_element (str, dae1, DAE.EXTFUNCTION(n, DAE.DAE(dae), ty,decl)) 
	  => DAE.EXTFUNCTION(n, DAE.DAE(dae'), ty,decl)

  axiom	string_prefix_element (str, dae, e) => e

end


relation is_parameter_daelist : (Exp.ComponentRef, DAE.Element list) => () =

  rule	Exp.cref_equal (cr, crv) => true
	------------------------
	is_parameter_daelist (cr, DAE.VAR(crv,DAE.PARAM,vd,ty,e,_,_,_,_,_,_)::rest)

  rule	Exp.cref_equal (cr, crv) => true
	------------------------
	is_parameter_daelist (cr, DAE.VAR(crv,vk,vd,ty,e,_,_,_,_,_,_)::rest) => fail

  rule	is_parameter_daelist (cr, rest)
	-------------------------------
	is_parameter_daelist (cr, e::rest)

end

relation string_prefix_params : DAE.DAElist => DAE.DAElist =

  rule	string_prefix_elements ("params->", dae, dae) => dae'
	-----------------------------------------------------
	string_prefix_params DAE.DAE(dae) => DAE.DAE(dae')

end


relation get_component_ref_next : Exp.ComponentRef => Exp.ComponentRef =

  axiom	get_component_ref_next Exp.CREF_QUAL(n, sl, cr) => cr
  rule	Print.print_buf "#-- Cannot get subname of an unqualified component reference\n" &
	Exp.print_component_ref cr
	----------------------------------------------------------------------
	get_component_ref_next (cr as Exp.CREF_IDENT(n, sl)) => fail

end

relation get_var_value_expr : (DAE.Element list, Exp.ComponentRef) 
	  => Exp.Exp =

  rule	find_var (dae, cr) => SOME(DAE.VAR(cr2, vk, vd, ty, NONE,_,_,_,_,_,_)) &
	Print.print_buf "#-- get_var_value_expr: Warning: Variable is not initialized\n" &
	Exp.print_component_ref cr & Print.print_buf "\n"
	---------------------------------------------------------
	get_var_value_expr (dae, cr) => Exp.SCONST("UNDEF")


  rule	find_var (dae, cr) => SOME(DAE.VAR(cr2, vk, vd, ty, SOME(value),_,_,_,_,_,_))
	---------------------------------------------------------
	get_var_value_expr (dae, cr) => value

  rule	Print.print_buf "#-- get_var_value_expr: Error: Variable not found\n" &
	Exp.print_component_ref cr & Print.print_buf "\n"
	---------------------------------------
	get_var_value_expr (dae, cr) => fail

end


relation print_exp_no_funcall : Exp.Exp => () =

  rule	path_string(fcn) => fs &
	Print.print_buf fs
	--------
	print_exp_no_funcall Exp.CALL(fcn, args,_,_)

  rule	Exp.print_exp e
	---------------
	print_exp_no_funcall e
	
end

relation opt_path_string: Absyn.Path option => string =

  axiom	opt_path_string(NONE) => ""

  rule	path_string(p) => str 
	-----------------
	opt_path_string(SOME(p)) => str
end

relation path_string: Absyn.Path => string =

  rule	RTOpts.modelica_output => true &
	path_string2(path,"__") => s
	-------------------------------------
	path_string path => s

  rule	RTOpts.modelica_output => false &
	path_string2(path,".") => s
	-------------------------------------
	path_string path => s
	
end


relation path_string2: (Absyn.Path, string) => string =

  axiom	path_string2(Absyn.IDENT(s),_) => s
  
  rule	path_string2(n,str) => ns &
	string_append(s,str) => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string2(Absyn.QUALIFIED(s,n), str) => ss
	
end




relation find_var : (DAE.Element list, Exp.ComponentRef) => DAE.Element option =

  axiom	find_var ([], _) => NONE

  rule	Exp.cref_equal (cr1, cr2) => true
	--------------------
	find_var ((e as DAE.VAR(cr1, vk, vd, ty, value,_,_,_,_,_,_))::rest, cr2) => SOME(e)

  rule	find_var (rest, cr) => e'
	----------------------------
	find_var (_::rest, cr) => e'

end


relation path_equal : (Absyn.Path, Absyn.Path) => bool =

  rule	id1 = id2 
	----------
	path_equal (Absyn.IDENT(id1), Absyn.IDENT(id2)) => true

  rule	not id1 = id2 
	----------
	path_equal (Absyn.IDENT(id1), Absyn.IDENT(id2)) => false

  rule	id1 = id2 &
	path_equal (path1, path2) => res
	--------------------------------
	path_equal (Absyn.QUALIFIED(id1, path1), Absyn.QUALIFIED(id2, path2)) => res
	
  rule	not id1 = id2
	--------------------------------
	path_equal (Absyn.QUALIFIED(id1, path1), Absyn.QUALIFIED(id2, path2)) => false

  axiom	path_equal (_,_) => false

end

(* This relation returns true if the first argument is a sub suffix of the second argument.*)
(* Examples:
 path_subsuffix_equal(A.B, X.Y.A.B) => true
 path_subsuffix_equal(A.B.C, X.Y.A.B) => false
*)
relation path_subsuffix_equal : (Absyn.Path, Absyn.Path) => bool =

  rule	Absyn.path_last_ident(p1) => p1str &
	Absyn.path_last_ident(p2) => p2str &
	p1str = p2str &
	Absyn.strip_last(p1) => p1' &
	Absyn.strip_last(p2) => p2' &
	path_subsuffix_equal(p1',p2') => res
	------------------------------------
	path_subsuffix_equal(p1 as Absyn.QUALIFIED(_,_), p2 as Absyn.QUALIFIED(_,_)) => res

  rule	Absyn.path_last_ident(p2) => p2str &
	id1 = p2str 
	-------------
	path_subsuffix_equal(p1 as Absyn.IDENT(id1), p2) => true

  axiom	path_subsuffix_equal(_,_) => false
end
