(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 env.rml
 ** module:      Env
 ** description: Environmane management
 **
 ** RCS: $Id$
 **
 ** An environment is a stack of frames, where each frame contains a
 ** number of class and variable bindings.
 **)

module Env:

  with "absyn.rml"
  with "values.rml"
  with "explode.rml"
  with "types.rml"
  with "classinf.rml"
  with "exp.rml"

  type Ident = string

  datatype Frame = FRAME of Ident option *  (* Class name *)
			    BinTree * (* List of classes and variables which must be uniquely named*)
			    BinTree * (* List of types, which DOES NOT be uniquely named, eg. size have several types*)		 
			    Item list * (* list of unnamed items (imports)**) 
			    bool  (* encapsulated *)
  (* bool=true means that FRAME is created due to encapsulated class  *)

  datatype Item = VAR of Types.Var * (SCode.Element*Types.Mod) option * bool
		| CLASS of SCode.Class * Env
		| TYPE of Types.Type list (* list since several types with the same name can exist in the same scope (overloading) *)
		| IMPORT of Absyn.Import

  type Env = Frame list

  datatype BinTree = TREENODE of TreeValue option *
				BinTree option * (* left subtree *)
				BinTree option (* right subtree *)

  datatype TreeValue = TREEVALUE of Key (* Key *)
				* Value (* Value *)

  type Key = Ident

  type Value = Item


  val empty_env   : Env
 
  relation new_frame : (bool) => Frame
  relation open_scope       : (Env,bool, Ident option) => Env
  relation extend_frame_c   : (Env, SCode.Class) => Env
  relation extend_frame_classes   : (Env, SCode.Program) => Env
  relation extend_frame_v   : (Env, Types.Var,(SCode.Element*Types.Mod) option,bool) => Env
  relation update_frame_v   : (Env, Types.Var,bool) => Env
  relation extend_frame_t : (Env,Ident,Types.Type) => Env
  relation extend_frame_i : (Env, Absyn.Import) => Env
  relation top_frame : Env => Frame
  relation get_env_path: (Env) => Absyn.Path option
  relation print_env_path: (Env) => ()
  relation print_env        : Env => ()
	  
  relation print_env_graphviz : (Env * string) => ()

  relation print_frame      : Frame => ()

  relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list
  relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list	  
  relation tree_get: (BinTree, Key, Key => int) => Value 
  relation tree_add: (BinTree, Key, Value, Key => int) => (BinTree) 
  relation myhash: Key => int 
  relation print_bintree: (BinTree ) => ()

end

with "dump.rml"
with "graphviz.rml"
with "dae.rml"
with "print.rml"
with "util.rml"
with "system.rml"

(** - Values *)

val empty_env = []

(** - Relations *)

(** relation: new_frame
 ** This relation creates a new frame, which includes setting up the hashtable for the frame 
**)
relation new_frame: (bool) => Frame =

  rule	tree_new => ht &
	tree_new => httypes 
	--------------------
	new_frame(enc) => FRAME(NONE,ht,httypes,[],enc)	
end		 

(** relation: open_scope
 **
 ** Opening a new scope in the environment mans adding a new frame on
 ** top of the stack of frames.
 **)

relation open_scope: (Env,bool,Ident option) => Env =

  rule	new_frame(encflag) => frame &
	name_scope(frame::env,id) => env' 
	------------------------------
	open_scope(env,encflag, SOME(id)) =>  env'

  rule	new_frame(encflag) => frame
	------------------------------
	open_scope(env,encflag, NONE) =>  frame::env
end

(** relation: name_scope
 **
 ** This relation names the current scope, giving it an identifier.
 ** Scopes needs to be named for several reasons. First, it is needed for debugging purposes, since
 ** it is easier to follow the environment if we know what the current class being instantiated is.
 **
 ** Secondly, it is needed when expanding type names in the context of flattening of the inheritance
 ** hierarchy. The reason for this is that types of inherited components needs to be expanded such that ** the types can be looked up from the environment of the base class.
 **)
 
relation name_scope: (Env,Ident) => Env =

  axiom	name_scope(FRAME(_,ht,httypes,imps,encflag)::res,id) 
	  => FRAME(SOME(id),ht,httypes,imps,encflag)::res
end

(** relation: extend_frame_c
 **
 ** This relation adds a class definition to the environment.
 **)

relation extend_frame_c : (Env, SCode.Class) => Env =

(*
  rule	Print.print_buf "extend_frame_c:\n" &
	print_env env &
	Print.print_buf " + " &
	Print.print_buf n &
	Print.print_buf " = " &
	print_env ((FRAME((n,CLASS(c,env))::items,encflag)::fs)) &
	Print.print_buf "\n" 
	----------------
	extend_frame_c(env as (FRAME(id,items,encflag)::fs),c as SCode.CLASS(n,_,_,_))
	  => ((FRAME(id,(n,CLASS(c,env))::items,encflag)::fs))
*)

  rule	tree_add(ht,n,CLASS(c,env),System.hash) => (ht')
	--------------------------
	extend_frame_c(env as (FRAME(id,ht,httypes,imps,encflag)::fs),c as SCode.CLASS(n,_,_,_,_))
	  => ((FRAME(id,ht',httypes,imps,encflag)::fs))

  rule	print "extend_frame_c FAILED\n" 
	--------------------------
	extend_frame_c(_,_)
	  => fail
end

relation extend_frame_classes : (Env, SCode.Program) => Env =

  axiom	extend_frame_classes(env,[]) => env

  rule	extend_frame_c(env,c) => env' &
	extend_frame_classes(env',cs) => env''
	-------------------------------------
	extend_frame_classes(env,c::cs) => env''
end

(** relation: extend_frame_v
 **
 ** This relation adds a component to the environment.
 **)

relation extend_frame_v : (Env,Types.Var,(SCode.Element*Types.Mod) option,bool) => Env =
	
(*
  rule	Print.print_buf "extend_frame_v:\n" &
   print_env env &
   Print.print_buf " + " &
   Print.print_buf n &
	Print.print_buf " = " &
   print_env (FRAME(id,(n,VAR(v))::items,encflag)::fs) &
   Print.print_buf "\n" 
   ----------------
   extend_frame_v(env as (FRAME(id,items,encflag)::fs),v as Types.VAR(n,_,_,_,_))
   => (FRAME(id,(n,VAR(v))::items,encflag)::fs)
 *)
  rule	tree_add(ht,n,VAR(v,c,i),System.hash) => (ht')
	---------------------------------------
	extend_frame_v(FRAME(id,ht,httypes,imps,encflag)::fs,v as Types.VAR(n,_,_,_,_),c,i)
	    => (FRAME(id,ht',httypes,imps,encflag)::fs)
	    
end
	
(** relation: update_frame_v
 **
 ** This relation updates a component already added to the environment, but that prior to the
 ** update did not have any binding. (I.e this relation is called in the second stage of 
 **  instantiation with declare before use.)
**)
	
	
relation update_frame_v : (Env,Types.Var,bool) => Env =
  axiom	update_frame_v ([],_,i) => []

  rule	tree_get(ht,n,System.hash) => VAR(_,c,_) &
        tree_add(ht,n,VAR(v,c,i),System.hash) => (ht')
	------------------------
	update_frame_v (FRAME(sid,ht,httypes,imps,encflag)::fs, v as Types.VAR(n,_,_,_,_),i)
	  => (FRAME(sid,ht',httypes,imps,encflag)::fs)

  rule	(* Also check frames above, e.g. when variable is in base class *)
	update_frame_v(fs,v,i) => frames
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,encflag)::fs,v as Types.VAR(n,_,_,_,_),i)
	  => (FRAME(sid,ht,httypes,imps,encflag)::frames)

  rule	Print.print_buf "- update_frame_v, variable " & Print.print_buf n &
	Print.print_buf " not found\n rest of env:" &
	print_env fs & Print.print_buf "\n" 
	--------------
	update_frame_v(FRAME(sid,ht,httypes,imps,encflag)::fs, Types.VAR(n,_,_,_,_),_)
	  => (FRAME(sid,ht,httypes,imps,encflag)::fs)

  rule	Print.print_buf "- update_frame_v failed\n" &
	Print.print_buf "  - variable: " & Types.print_var v &
	Print.print_buf "\n" 
	----------------
	update_frame_v(_,v as Types.VAR(id,_,_,_,_),_) => fail
end
	
(** relation: extend_frame_t
 **
 ** This relation adds a type to the environment.  Types in the
 ** environment are used for looking up constants etc. inside class
 ** definitions, such as packages.  For each type in the environment,
 ** there is a class definition with the same name in the
 ** environment.
 **)
		 
relation extend_frame_t : (Env,Ident,Types.Type) => Env =

(*
  rule	Print.print_buf "extend_frame_t:\n" &
	print_env env &
	Print.print_buf " + " &
	Print.print_buf n &
	Print.print_buf " = " &
	print_env (FRAME(sid,(n,TYPE(t))::items,encflag)::fs) &
	Print.print_buf "\n" 
	----------------
	extend_frame_t(env as (FRAME(sid,items,encflag)::fs), n, t)
	  => (FRAME(sid,(n,TYPE(t))::items,encflag)::fs)
*)

	
  rule	(* Other types with that name allready exist, add this type as well *)
	tree_get(httypes,n,System.hash) => TYPE(tps) &
	tree_add(httypes,n,TYPE(t::tps),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,encflag)::fs)

  rule	(* No other types exists *)
	not tree_get(httypes,n,System.hash) => TYPE(_) &
	tree_add(httypes,n,TYPE([t]),System.hash) => (httypes')
	-----------------------------
	extend_frame_t(FRAME(sid,ht,httypes,imps,encflag)::fs, n, t)
	  => (FRAME(sid,ht,httypes',imps,encflag)::fs)
end

relation extend_frame_i : (Env,Absyn.Import) => Env =
	      
  axiom	extend_frame_i(FRAME(sid,ht,httypes,imps,encflag)::fs,imp)
	  => (FRAME(sid,ht,httypes, IMPORT(imp)::imps,encflag)::fs)
end

relation top_frame : Env => Frame =
  axiom	top_frame([fr]) => fr
  rule	top_frame(lst) => fr
	--------------------
	top_frame(elt::(lst as (_::_))) => fr
end

(** relation: get_env_path
 **
 ** This relation returns all partially instantiated parents as an Absyn.Path option
 ** I.e. it collects all identifiers of each frame until it reaches the topmost
 ** unnamed frame. If the environment is only the topmost frame, NONE is returned.
**)
relation get_env_path: Env => Absyn.Path option =

  axiom	get_env_path ([FRAME(SOME(id),_,_,_,_),FRAME(NONE,_,_,_,_)]) => SOME(Absyn.IDENT(id))
	
  rule	get_env_path(rest) => SOME(path) &
	Absyn.join_paths(path,Absyn.IDENT(id)) => path'
	----------------------------------------------
	get_env_path(FRAME(SOME(id),_,_,_,_)::rest) =>SOME(path')

  axiom	get_env_path(_) => NONE
end

relation print_env_path: Env => () =

  rule	get_env_path(env) => SOME(path) &
	Absyn.path_string(path) => pathstr &
	Print.print_buf pathstr
	---------------
	print_env_path(env) => ()

  rule	Print.print_buf "TOPENV"
	---------------
	print_env_path(env) => ()

end
relation print_env : Env => () =

  rule	Print.print_buf "Empty env\n"
	-------------------
	print_env []

  rule	print_frame fr &
	print_env frs
	------------
	print_env fr::frs

end


relation print_frame : Frame => () =

  rule	Print.print_buf "FRAME: " &
	Print.print_buf sid &
	Print.print_buf " (enc=" &
        Dump.print_bool  encflag  &
        Print.print_buf ") \nclasses and vars:\n=============\n" &
	print_bintree ht &
	Print.print_buf "   Types:\n======\n" &
	print_bintree httypes &
	Print.print_buf "   Imports:\n=======\n" &
	print_imports imps &
	Print.print_buf "\n\n\n"
	--------------------------------------------
	print_frame FRAME(SOME(sid),ht,httypes,imps,encflag)

  rule	Print.print_buf "FRAME: " &
	Print.print_buf "unnamed" &
	Print.print_buf " (enc=" &
        Dump.print_bool  encflag  &
        Print.print_buf ")\nclasses and vars:\n=============\n " &
	print_bintree ht &
	Print.print_buf "\n   Types:\n======\n" &
	print_bintree httypes &
	Print.print_buf "\n   Imports:\n========\n" &
	print_imports imps &
	Print.print_buf "\n"
	--------------------------------------------
	print_frame FRAME(NONE,ht,httypes,imps,encflag)

end


relation print_frame_contents: (Ident * Item) list => () =

  axiom	print_frame_contents [] 

  rule	print_frame_element e
	-------------------------
	print_frame_contents [e as (n,i)]

  rule	print_frame_element e & Print.print_buf "\n" & print_frame_contents rst
	------------------------------------------------
	print_frame_contents ((e as (n,i))::rst)
end

relation print_imports:  Item list => () =

  axiom	print_imports [] 

  rule	print_frame_element (("",e))
	-------------------------
	print_imports [e]

  rule	print_frame_element (("",e)) & Print.print_buf "," & print_imports rst
	------------------------------------------------
	print_imports (e::rst)
end


relation print_frame_element: (Ident * Item) => () =

  rule	Print.print_buf "v:" & Print.print_buf n & 
	SCode.variability_string var => s &
	Print.print_buf s &
	Print.print_buf " (" &  SCode.print_element elt & Print.print_buf ") ["  &
	Types.print_type tp & Print.print_buf "]" & Print.print_buf "{" & Types.print_var tv & Print.print_buf "}" &
	Print.print_buf "\n"
	-------
	print_frame_element ((n,VAR(tv as Types.VAR(_,Types.ATTR(_,_,var,_),_,tp,_),SOME((elt,_)),i)))

  rule	Print.print_buf "v:" & Print.print_buf n  & 
	Print.print_buf "\n"
	-------
	print_frame_element ((n,VAR(Types.VAR(_,_,_,_,bnd),NONE,i)))

  rule	Print.print_buf "c:" & Print.print_buf n &
	Print.print_buf "\n"
	-------
	print_frame_element ((n,CLASS(_,_)))

  rule	Print.print_buf "t:" & Print.print_buf n &
	list_length(lst) => len &
	int_string(len) => lenstr &
	Print.print_buf "(" & Print.print_buf lenstr & 
	Print.print_buf ")\n"
	-------
	print_frame_element ((n,TYPE(lst)))

  rule	Print.print_buf "imp:" & Dump.print_import imp &
	Print.print_buf "\n"
	-------
	print_frame_element ((n,IMPORT(imp)))
end


relation print_env_graphviz : (Env * string) => () =

  rule	build_env_graphviz ((env,str)) => r &
	Graphviz.dump(r)
	----------------
	print_env_graphviz ((env,str))

end

relation build_env_graphviz : (Env * string) => Graphviz.Node =

  rule	string_append ("ROOT: ", str) => str' &
	build_env_graphviz_2 env => nodelist
	------------------------------------
	build_env_graphviz ((env,str)) => Graphviz.NODE(str',[],nodelist)

end

relation build_env_graphviz_2 : Env => Graphviz.Node list =

  axiom	build_env_graphviz_2 [] => []

  rule	build_env_graphviz_2 rest => nodelist &
	build_frame_graphviz frame => node
	----------------------------------
	build_env_graphviz_2 frame::rest => node::nodelist

end

relation is_var_item = 
  axiom	is_var_item ((_,VAR(_,_,_))) 
end

relation is_class_item = 
  axiom	is_class_item ((_,CLASS(_,_))) 
end

relation is_type_item = 
  axiom	is_type_item ((_,TYPE(_))) 
end

relation build_frame_graphviz : Frame => Graphviz.Node =

  axiom	build_frame_graphviz FRAME(sid,ht,httypes,imps,encflag) 
	  => Graphviz.NODE("FRAME",[],[])
end

relation build_item_listnode : ((Ident * Item) list, (Ident * Item) => (), string) 
	  => Graphviz.Node =

  rule	DAE.get_matching (items, cond) => selitems &
	build_item_listnode_2 (selitems, 1) => node
	--------------------------------------------------------
	build_item_listnode (items, cond, name) 
	  => Graphviz.NODE(name, [], [node])

end

relation build_item_listnode_2 : ((Ident * Item) list, int) 
	  => Graphviz.Node =

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, []) &
	int_string count => cstr
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [])

  rule	DAE.build_gr_strlist (items, build_item_str, 10) => (strlist, ignored) &
	int_string count => cstr &
	int_add (count, 1) => count' &
	build_item_listnode_2 (ignored, count') => restnode 
	--------------------------------------------------------
	build_item_listnode_2 (items, count) 
	  => Graphviz.LNODE(cstr, strlist, [Graphviz.box], [restnode])

end

relation build_item_str : (Ident * Item) => string =

  rule	string_append ("VAR: ",id) => s
	------------------------------
	build_item_str ((id, VAR(_,_,_))) => s

  rule	(*build_env_graphviz env => r &*)
	string_append ("CLASS: ", id) => s
	----------------------------------
	build_item_str ((id, CLASS(cls, env))) => s

  rule	string_append ("TYPE: ", id) => s
	---------------------------------
	build_item_str ((id, TYPE(_))) => s

end

(*
relation build_item_graphviz : (Ident, Item) => Graphviz.Node =

  axiom	build_item_graphviz (id, VAR(_)) => Graphviz.LNODE("VAR",[id],[],[])

  axiom	build_item_graphviz (id, CLASS(cls, env)) => Graphviz.LNODE("CLASS",[id],[],[])

  axiom	build_item_graphviz (id, TYPE(_)) => Graphviz.LNODE("TYPE",[id],[],[])

end
*)


(** BinTree implementation *)

relation myhash: Key => int =

  rule	System.hash str => res
	------------
	myhash(str) => res
end


relation tree_new: () => BinTree =

  axiom	tree_new()  => TREENODE(NONE,NONE,NONE)

end

relation tree_add: (BinTree, Key, Value, Key => int) => (BinTree) =

  axiom	tree_add (TREENODE(NONE,NONE,NONE),key,value,_) 
	  => TREENODE(SOME(TREEVALUE(key,value)),NONE,NONE)

  rule	(* Replace this node *)
	rkey = key
	---------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),key,value,hashfunc)
	  => (TREENODE(SOME(TREEVALUE(rkey,value)),left,right))

  rule	(* Insert to right subtree*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as SOME(t)),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(t')))

  rule	(* Insert to right node*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => right'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right as NONE),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right')))

  rule	(* Insert to left subtree*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(t,key,value,hashfunc) => t'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as SOME(t),right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(t'),right))

  rule	(* Insert to left node*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_add(TREENODE(NONE,NONE,NONE),key,value,hashfunc) => left'
	------------------------
	tree_add (TREENODE(SOME(TREEVALUE(rkey,rval)),left as NONE,right),key,value,hashfunc) 
	  => (TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left'),right))

  rule	print "tree_add failed\n"
	-----------------------
	tree_add(_,_,_,_) => fail
end 


relation local_outside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_outside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_outside_connector_flowvars(FRAME(sid,ht,_,_,_)::_) => res
end

relation local_outside_connector_flowvars2: (BinTree option) => Exp.ComponentRef list =

  axiom	local_outside_connector_flowvars2(NONE) => []
	
  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	Types.flow_variables(vars,Exp.CREF_IDENT(id,[])) => lst3 &
	Util.list_flatten([lst1,lst2,lst3])=> res
	-----------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_),_,_))),l,r)))
	=> res

  rule	local_outside_connector_flowvars2(l) => lst1 &
	local_outside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_outside_connector_flowvars2(SOME(TREENODE(SOME(_),l,r)))
	  => res
end

relation local_inside_connector_flowvars: (Env) => Exp.ComponentRef list =

  rule	local_inside_connector_flowvars2(SOME(ht)) => res
	--------------------------------
	local_inside_connector_flowvars(FRAME(sid,ht,_,_,_)::_) => res
end

relation local_inside_connector_flowvars2:(BinTree option) => Exp.ComponentRef list =

  axiom	local_inside_connector_flowvars2(NONE) => []

  rule	(* If CONNECTOR then  outside and not inside, skip.. *)
	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),_),_),_),_,_))),l,r)))
	=> res
	
  rule	(* ... else retrieve connectors as subcomponents*)
	local_inside_connector_flowvars3(vars,id) => lst1 &
	local_inside_connector_flowvars2(l) => lst2 &
	local_inside_connector_flowvars2(r) => lst3 &
	Util.list_flatten([lst1,lst2,lst3]) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,(Types.T_COMPLEX(_,vars),_),_),_,_))),l,r)))
	=> res

  rule	(* if not complex, skip *)
	local_inside_connector_flowvars2(l) => lst1 &
	local_inside_connector_flowvars2(r) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------
	local_inside_connector_flowvars2(SOME(TREENODE(SOME(TREEVALUE(_,VAR(Types.VAR(id,_,_,t,_),_,_))),l,r)))
	=> res
end

relation local_inside_connector_flowvars3: (Types.Var list,Ident) => Exp.ComponentRef list =

  axiom	 local_inside_connector_flowvars3 ([],_) => []

  rule	local_inside_connector_flowvars3(xs,oid) => lst1 &
	Types.flow_variables(vars,Exp.CREF_QUAL(oid,[],Exp.CREF_IDENT(id,[]))) => lst2 &
	list_append(lst1,lst2) => res
	---------------------------------------------------
	local_inside_connector_flowvars3 (Types.VAR(id,_,_,(Types.T_COMPLEX(ClassInf.CONNECTOR(_),vars),_),_)::xs,oid) => res

  rule	local_inside_connector_flowvars3(xs,oid) => res
	-----------------------------------------------
	local_inside_connector_flowvars3 (_::xs,oid) => res

end

relation tree_get: (BinTree, Key, Key => int) => Value =

  rule	rkey = key 
	---------------
	tree_get (TREENODE(SOME(TREEVALUE(rkey,rval)),left,right),
		  key,hashfunc) 
	  => rval

  rule	(* Search to the right*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_gt(hval,rhval) => true &
	tree_get(right,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),left,SOME(right)),key,hashfunc)
	  => res

  rule	(* Search to the left*)
	hashfunc(key) => hval &
	hashfunc(rkey) => rhval &
	int_le(hval,rhval) => true &
	tree_get(left,key,hashfunc) => res
	--------------------
	tree_get(TREENODE(SOME(TREEVALUE(rkey,rval)),SOME(left),right),key,hashfunc)
	  => res
	
(*  rule	print "tree_get failed\n" 
	---------------
	tree_get(_,_,_) => fail*)
end

relation print_bintree: (BinTree ) => () =

  rule	print_frame_element((rkey,rval)) &
	Dump.print_option(l,print_bintree) &
	Dump.print_option(r,print_bintree)
	----------------------
	print_bintree(TREENODE(SOME(TREEVALUE(rkey,rval)),l,r))

rule	Dump.print_option(l,print_bintree) &
	Dump.print_option(r,print_bintree)
	----------------------
	print_bintree(TREENODE(NONE,l,r))
end


