(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 simcodegen.rml
 ** module:      SimCodegen
 ** description: Generate Simulation code for connecting to solver.
 ** This can be done in two different ways.
 ** 1. Generation of simulation code on residual form. This will generate 
 ** code on the form g(\dot{x},x,y,t)=0.
 ** 2. Generation of simulation code on solved form. This will generate
 ** code on ode form. \dot{x} = f(x,y,t). This means that "function" f will
 ** contain code for solving states from equations, some of them might be 
 ** system of equations, linear or non-linear.
 **
 ** Outputs: the simulation code in C/C++ to a given filename.
 ** Input: DAELow
 ** Uses: DAELow, Absyn, Exp
 **
 **
 ** RCS: $Id$
 **
 **)


module SimCodegen:

  with "daelow.rml"
  with "absyn.rml"
  with "exp.rml"

relation generate_residual_code: (DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string) => ()

relation generate_ode_code: (DAELow.DAELow, Absyn.Path, string) => ()

relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
			      string,real,real,real)  => ()

relation generate_makefile: (string (*filename*), 
			     Absyn.Path (* classname *)
			     ) => ()

relation print_exp_cpp_str : Exp.Exp => string 

relation cref_modelica_str : Exp.ComponentRef => string 


end

with "util.rml"
with "rtopts.rml"
with "debug.rml"
with "system.rml"
with "values.rml"

(** relation generate_makefile
 ** This relation generates a makefile for the simulation code.
 ** It uses MOSHHOME as a reference to find c_runtime with libraries.
 **)
relation generate_makefile: (string, Absyn.Path) => () =
			     
  rule	Absyn.path_string(class) => cname &
	Util.string_append_list([cname,".cpp"]) => cpp_file &
	Util.string_append_list([cname,".h"]) => h_file &
	Util.string_append_list(["#Makefile generated by OpenModelica\n\n",
				 "CC=g++\n",
				 cname,": ",cpp_file," ", h_file, "\n",
				 "\t $(CC) -o ",cname," ",cpp_file, 
				 " $(MOSHHOME)/../c_runtime/libsim.a ",
				 " -lg2c\n"
				 ]) => str &
	System.write_file(filename,str) 
	-------------------------
	generate_makefile(filename,class)
end


(** relation generate_residual_code
 ** Outputs simulation code from a DAELow suitable for connection to DASSL.
 ** The state calculations are generated on residual form, i.e. 
 ** g(\dot{x},x,y,t) = 0.
 **)
relation generate_residual_code: (DAELow.DAELow, 		      
				  int vector, (* ass1 *)
				  int vector, (* ass2 *)
				  DAELow.IncidenceMatrix,
				  DAELow.IncidenceMatrixT,
				  int list list, (* blocks*)
				  Absyn.Path,  (* classname *)
				  string) => () =

  rule	Absyn.path_string(class) => cname &
        DAELow.generate_state_partition(comps,dae,ass1,ass2,m,mt) 
	  => (blt_states,blt_no_states) &
	generate_global_data(class,dae) => cglobal &  
        generate_compute_output(cname,dae,ass1,ass2,blt_no_states) 
	  => coutput &
        generate_compute_residual_state(cname,dae,ass1,ass2,blt_states) 
	  => cstate &
	Util.string_append_list(["//Simulation code for ",cname,
				 "\n//Generated by OpenModelica.\n",
				 cglobal,coutput,cstate]) => res &
	System.write_file(filename,res) 
	---------------------------------------------------------------------
	generate_residual_code(dae,ass1,ass2,m,mt,comps,class,filename) => ()


  rule	print "-generate_residual_code failed\n" 
	-----------------------
	generate_residual_code(_,_,_,_,_,_,_,_) => fail
end

(** relation: generate_global_data
 ** This relation generates the C-code for the global data: arrays for states, derivatives
 ** and algebraic variables, etc.
**)
relation generate_global_data:(Absyn.Path,DAELow.DAELow) => string  =

  rule	DAELow.calculate_sizes(dae) => (nx,ny,np) &
	Absyn.path_string(class) => class_str &
	int_string(nx) => nx_str &
	int_string(ny) => ny_str &
	int_string(np) => np_str &
	Util.string_append_list(["\n",
				 "#define NX ",nx_str,"\n",
				 "#define NY ",ny_str,"\n",
				 "#define NP ",np_str,"\n",
				 "#define MAXORD 5\n",
				 "\n",
				 "double x[NX];\n",
				 "double xd[NX];\n",
				 "double y[NY];\n",
				 "double p[NP];\n",
				 "double rwork[50+(MAXORD+4)*NX+NX*NX];\n",
				 "long iwork[20+NX];\n",
				 "long liw = 20+NX;\n",
				 "long lrw = 50+(MAXORD+4)*NX+NX*NX;\n",
				 "long nx = NX;\n",
				 "long ny = NY;\n",
				 "long np = NP;\n",
				 "char *init_file=\"",class_str,
				 "_init.txt\";\n"]
				 )  => str 
	---------------------------
	generate_global_data(class, dae) => str
	
end

(** relation generate_ode_code
 ** Outputs simulation code from a DAELow. 
 ** The state calculations are generated on explicit ode form: 
 ** x_dot := f(x,y,t)
**)
relation generate_ode_code: (DAELow.DAELow, Absyn.Path, string) => () =

  rule	
	-------------------------------------------
	generate_ode_code(dae,class,filename) => ()
end


(** relation generate_init_data
 ** This relation generates initial values for the simulation
 ** by investigating values of variables.
 **)
relation generate_init_data: (DAELow.DAELow, Absyn.Path(* classname *), 
			      string(* filename *),
			      real, (* start time*)
			      real, (* stop time *)
			      real) (* step size *)
	  => () =

   rule	real_string(start) => start_str &
	real_string(stop) => stop_str &
	real_string(step) => step_str &
 	DAELow.calculate_sizes(dae) => (nx,ny,np) &
 	int_string(nx) => nx_str &
 	int_string(ny) => ny_str &
 	int_string(np) => np_str &
 	generate_init_data2(dae,nx,ny,np) => init_str &
 	Util.string_append_list([start_str, " // start value\n",
				 stop_str, " // stop value\n",
 				 step_str, " // step value\n",
 				 nx_str, " // n states\n",
 				 ny_str, " // n alg vars\n",
 				 np_str, " //n parameters\n",
 				 init_str]) => str &
 	System.write_file(filename,str) 
 	--------------------------
 	generate_init_data(dae,class,filename,start,stop,step)

  rule	print "-generate_init_data failed\n"
 	------------------------------------
	generate_init_data(_,_,_,_,_,_) => fail
end

(** relation: generate_init_data2
 ** Helper relation to generate_init_data
 ** Generates init data for states, variables and parameters.
 ** nx - number of states.
 ** ny - number of alg. vars. 
 ** np - number of parameters.
 **)
relation generate_init_data2:(DAELow.DAELow,
			      int(*nx*),
			      int(*ny*),
			      int(*np*)) 
	  => string =

  rule	DAELow.var_list(vars) => var_lst &
	DAELow.var_list(knvars) => knvar_lst &
	array_create(nx,"") => nxarr &
	array_create(nx,"0.0") => nxdarr &
	array_create(ny,"") => nyarr &
	array_create(np,"") => nparr &
	generate_init_data3(var_lst,nxarr,nxdarr,nyarr,nparr) 
	  =>(nxarr',nxdarr',nyarr',nparr') &
	generate_init_data4(knvar_lst,nxarr',nxdarr',nyarr',nparr')  
	  =>(nxarr'',nxdarr'',nyarr'',nparr'') &
	array_list(nxarr'') => nx_lst &
	array_list(nxdarr'') => nxd_lst &
	array_list(nyarr'') => ny_lst &
	array_list(nparr'') => np_lst &
	Util.list_flatten([nx_lst,nxd_lst,ny_lst,np_lst]) => whole_lst &
	Util.string_delimit_list(whole_lst,"\n") => res
	-----------------------------
	generate_init_data2(DAELow.DAELOW(vars,knvars,_,_,initeqn,alg),nx,ny,np) => res

end

(** relation: print_exp_str_opt
 ** Helper relation to generate_init_data2
 ** Prints expression value that is opional for initial values.
 ** If NONE is passed. The default value 0.0 is returned.
 **)
relation print_exp_str_opt: Exp.Exp option => string =

  axiom	print_exp_str_opt NONE => "0.0"

  rule	Exp.print_exp_str e => str 
 	--------------------------
 	print_exp_str_opt SOME(e) => str 
end

(** relation generate_init_data3
 ** This relation is a help relation to generate_init_data2
 ** It Traverses Var lists and adds initial values to the specific
 ** string array depending on the type of the variable.
 ** For instance, state variables write their start value to the
 ** x array at given index.
**)
relation generate_init_data3:(DAELow.Var list,
			      string array, (* state strings *)
			      string array, (* derivative strings*)
			      string array, (* alg. var strings *)
			      string array) (* param. strings *)
	  => (string array, (* updated state strings *)
	      string array, (* updated derivative strings*)
	      string array, (* updated alg. var strings *)
	      string array) (* updated param. strings *)
	=

  axiom	generate_init_data3([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	  =>  (nxarr,nxdarr,nyarr,nparr)
	--------------------
	generate_init_data3(DAELow.VAR(cr,DAELow.VARIABLE,_,_,_,_,
				_,value,indx,origname,_)::rest,
 			    nxarr,nxdarr,nyarr,nparr)
 	  => (nxarr,nxdarr,nyarr,nparr)

   rule	(* State variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nxarr,indx,str) => nxarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)
	--------------------
	 generate_init_data3(DAELow.VAR(_,DAELow.STATE,_,_,_,_,_,value,indx,origname,_)::rest,nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* dummy derivatives => algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr)
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_DER,_,_,_,_,_,value,indx,origname,_)::rest,nxarr,nxdarr,nyarr,nparr)
	=> (nxarr,nxdarr,nyarr,nparr)

  rule	(* Dummy states => algebraic variables *)
	print_exp_str_opt(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nyarr,indx,str) => nyarr &
 	generate_init_data3(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
 	--------------------
 	generate_init_data3(DAELow.VAR(_,DAELow.DUMMY_STATE,_,_,_,_,
				       _,value,indx,origname,_)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)
end

(** relation: generate_init_data4
 ** Helper relation to generate_init_data2
** Traverses parameters 
 **)
relation generate_init_data4: (DAELow.Var list, 
			       string array,
			       string array,
			       string array,
			       string array)  
	  => (string array,
	      string array,
	      string array,
	      string array)   =
  axiom	generate_init_data4([],nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr,nxdarr,nyarr,nparr) 
	
  rule	(* Parameters *)
	Values.val_string(value) => v &
	Util.string_append_list([v, " // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,SOME(value),_,
				_,indx,origname,_)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Parameters without value binding. Should normally not happen *)
	Util.string_append_list(["0.0  // ",origname]) => str &
	array_setnth(nparr,indx,str) => nparr &
	generate_init_data4(rest,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr,nxdarr,nyarr,nparr) 
	--------------------
	generate_init_data4(DAELow.VAR(_,DAELow.PARAM,_,_,_,NONE,_,
				_,indx,origname,_)::rest,
			    nxarr,nxdarr,nyarr,nparr)
	  => (nxarr,nxdarr,nyarr,nparr)

  rule	(* Skip alg. vars that are removed 
	 In future we should compare eliminated variables 
	 intial values to their aliases to detect inconsistent
	 initial values.
	 *)
	generate_init_data4(vs,nxarr,nxdarr,nyarr,nparr) 
	  => (nxarr',nxdarr',nyarr',nparr')
	-----------------------------------
	generate_init_data4(_::vs,nxarr,nxdarr,nyarr,nparr) 
	=> (nxarr',nxdarr',nyarr',nparr')
end

(** relation: generate_compute_residual_state
 ** This relation generates the code for the calculation of the 
 ** state variables on residual form. Called from generate_residual_code.
 **)
relation generate_compute_residual_state:(string,
					  DAELow.DAELow,
					  int vector, (* assignments1 *) 
					  int vector, (* assignments2 *)
					  int list list) (* blocks *) 
	  => string =
          
  rule	
        build_residual_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cstate &
        Util.string_append_list(["int\nfunctionDAE_res(double *t, double *x, double *xprime, double *delta, long int *ires, double *rpar, long int* ipar)\n{\n",cstate,"\n}\n"]) 
	  => res
        -------------------------------------------------------------
        generate_compute_residual_state(cname,dae,ass1,ass2,blocks) => res
end


(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output
 ** variables.
 **)
 relation generate_compute_output:(string,
                                   DAELow.DAELow,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule	let func_header = "int\nfunctionDAE_output(double *t, double* x, double* xprime, double* y)\n{\n" &
	 let func_footer = "\n}\n" &
	 build_solved_blocks(dae,ass1,ass2,blocks) => eqn_str_lst &
	 Util.list_flatten([[func_header],eqn_str_lst,[func_footer]]) => res &
         Util.string_append_list(res) => coutput 
         -------------------------------------------------------------
         generate_compute_output(cname,dae,ass1,ass2,blocks) => coutput
 end

(** relation: build_solved_blocks
 ** This relation generates code for blocks on solved form, i.e. 
 ** \dot{x} = f(x,y,t) 
 **)
 relation build_solved_blocks:(DAELow.DAELow, int vector, int vector, int list list) => string list =

  axiom	build_solved_blocks(_,_,_,[]) => []
	     
  rule	(* for single equations *)
	 build_equation(dae,ass1,ass2,eqn) => eqn_str &
	 build_solved_blocks(dae,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_solved_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res
	 
  rule	print "-build_solved_blocks failed\n" 
	 -----------------
	 build_solved_blocks(_,_,_,_) => fail
 end


(** relation build_equation 
 ** This returns the code string for a specific equation in the dae.
 ** It is used both for state variables and regular variables
 **)
relation build_equation:(DAELow.DAELow, int vector, int vector, int) => string =
	     
  rule  (* Solving for non-states *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_)) &  
	DAELow.is_non_state kind &
	let varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,varexp) => expr &
        
        Exp.simplify(expr) => simplify_exp &
	build_assignment(cr,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string	
        
	
  rule	(* Solving the state s means solving for der(s) *)
	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v &
	(* v == variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_) &
	let new_varexp = Exp.CREF(cr,Exp.REAL) &
	Exp.solve(e1,e2,new_varexp) => expr &
        Exp.simplify(expr) => simplify_exp &
	build_assignment(cr ,simplify_exp,origname)  => assigment_string
	--------------------------------
	build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string 
	
  rule	(* probably, solved failed in rule above. This means that we have 
	 a non-linear equation. *)
 	int_sub(e,1) => e' &
 	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
 	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => fail
        
  rule	print "-build_equation failed\n" 
	--------------------------------
	build_equation(_,_,_,_) => "//build_equation failed\n" 
end

(** relation build_residual_blocks
 ** This relation generates code for blocks on residual form, i.e.
 ** g(\dot{x},x,y,t) = 0
 **)
 relation build_residual_blocks:(DAELow.DAELow, int vector, int vector, int list list) => string list =

  axiom	build_residual_blocks(_,_,_,[]) => []
	 
         (* rule	(* For system of equations *) *)
	 (* build_system(dae,ass1,ass2,block) &
	  build_residual_blocks(dae,ass1,ass2,blocks)
	  -------------------------------------
	  build_residual_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks)*)
	 
  rule	(* for single equations *)
	 build_residual_equation(dae,ass1,ass2,eqn) => eqn_str &
	 build_residual_blocks(dae,ass1,ass2,blocks) => res
	 -------------------------------------
	 build_residual_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_residual_blocks failed\n" 
	 -----------------
	 build_residual_blocks(_,_,_,_) => fail
 end

(** relation build_residual_equation 
 ** This relation generates code on residual form for one equation.
 ** It is used both for state variables and algebraic variables.
 **)
 relation build_residual_equation:(DAELow.DAELow, 
				   int vector, (* assignments1*)
				   int vector, (* assignments2*)
				   int (* equation no. *)
				   ) => string =
	 
  rule  (* Solving for non-states *)
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_)) &  
	 DAELow.is_non_state kind &
	 (*print "Solving for non-states\n" &*)
	 
	 let varexp = Exp.CREF(cr,Exp.REAL) &
	 Exp.solve(e1,e2,varexp) => expr &
         Exp.simplify(expr) => simplify_exp &
	 build_assignment(cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string	
         
	 
  rule  (* Solving the state s, caluate residual form. *) 
	 int_sub(e,1) => e' &
	 DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	 vector_nth(ass2,e') => v &
	 int_sub(v,1) => v' &
	 DAELow.vararray_nth(vararr,v') 
	  => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_) &
	 int_string(indx) => indx_str &
	 let exp = Exp.BINARY(e1,Exp.SUB(Exp.REAL),e2) &
	 Exp.simplify(exp) => simplify_exp &
	 (* Use array named 'delta' for residuals *)
	 Util.string_append_list(["delta[",indx_str,"]"]) => cr_str &
	 let new_cr = Exp.CREF_IDENT(cr_str,[]) &
	 build_assignment(new_cr,simplify_exp,origname)  => assigment_string
	 --------------------------------
	 build_residual_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string 
	 
  rule	int_sub(e,1) => e' &
	DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	int_sub(v,1) => v' &
	DAELow.vararray_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_) &  
	let varexp = Exp.CREF(cr,Exp.REAL) &
	not Exp.solve(e1,e2,varexp) => _ &
	print "nonlinear equation not implemented yet\n" 
	--------------------------------
	build_residual_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => fail
         
  rule  print "-build_residual_equation failed\n" 
	--------------------------------
	build_residual_equation(_,_,_,_) 
	  => "//build_residual_equation failed\n" 
end

(** relation build_assignment 
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)
relation build_assignment: (Exp.ComponentRef, (* varname *)
			    Exp.Exp, (*expression*) 
			    string) (* orig. name*) 
	  => string =
	  
  rule  Exp.print_component_ref_str(cr) => cr_str &
        print_exp_cpp_str(exp) => exp_str & 
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
        --------------------------------
	build_assignment(cr,exp,origname) => eqn_str
        
  rule	print "-build_assignment failed\n" 
	------------------------
	build_assignment(cr,exp,origname) => fail
end


(** relation: print_exp_cpp_str
 **
 ** This relation prints a complete expression on a C/C++ format.
 **)
 relation print_exp_cpp_str : Exp.Exp => string =
         
  rule  print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s
         
 end

(** relation: print_exp2_str
 ** Helper relation to print_exp_str
 **)
 relation print_exp2_str : (Exp.Exp,int) => string =

  rule  print "# equation contain undefined symbols"
        --------------------------
        print_exp2_str(Exp.END,_) => fail
         
         
  rule  int_string(x) => s
	 ----------------------------
         print_exp2_str(Exp.ICONST(x),_) => s
         
  rule  real_string(x) => s
	 -----------------------------
         print_exp2_str(Exp.RCONST(x),_) => s

  rule  string_append ("\"", s) => s' &
	 string_append (s', "\"") => s''
         ---------------------------------
         print_exp2_str(Exp.SCONST(s),_) => s''
         
  axiom print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"

  rule  (*cref_modelica_str(c) => res *)
	 Exp.print_component_ref_str c => res
         --------------------------------
         print_exp2_str(Exp.CREF(c,_),_) => res

  rule  Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority(op) => pri2' &
         int_add(pri2',1) => pri2 & (* binary minus have higher priority than itself *)
         Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
         print_exp2_str (e1,pri3) => s2 & 
         print_exp2_str (e2,pri2) => s3 &
         Exp.print_rightpar_str (pri1,pri2) => s4 &
         string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
         string_append("pow(",s) => s' &
         string_append(s',",") => s'' &
         string_append(s'',s3) => s''' &
         string_append(s''',")") => res &
	     string_append (res, s4) => res'
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, (op as Exp.POW(_)), e2),pri1) => res'

  rule	Exp.binop_symbol(op) => sym &
 	 Exp.binop_priority op => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ------------------------
	 print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	 Exp.unaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ----------------------------
	 print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	Exp.lbinop_symbol(op) => sym &
	 Exp.lbinop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e1,pri3) => s2 & 
	 print_exp2_str (e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 ----------------------------------------------------------------
	 print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	Exp.lunaryop_symbol(op) => sym &
 	 Exp.lunaryop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str (e,pri3) => s2 &
	 Exp.print_rightpar_str (pri1,pri2) => s3 &
	 string_append (s1, sym) => s &
	 string_append (s, s2) => s' &
	 string_append (s', s3) => s''
	 ---------------------------------------------------
	 print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	Exp.relop_symbol(op) => sym &
 	 Exp.relop_priority(op) => pri2 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	 print_exp2_str(e1,pri3) => s2 & 
	 print_exp2_str(e2,pri2) => s3 &
	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, sym) => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -----------------------------------------------------------------
	 print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	 print_exp2_str(t,0) => thenstr &
	 print_exp2_str(f,0) => elsestr &
	 string_append ("( ", ifstr) => s &
	 string_append (s, " ) ? ( ") => s' &
	 string_append (s', thenstr) => s'' &
	 string_append (s'', " ) : ( ") => s''' &
	 string_append (s''', elsestr) => s'''' &
	 string_append (s'''', " ) ") => slast 
	 ----------------------------
	 print_exp2_str(Exp.IFEXP(c,t,f),_) => slast

  rule	Absyn.path_string(fcn) => fs &
	 Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	 string_append(fs, "(") => s &
	 string_append(s, argstr) => s' &
	 string_append(s', ")") => s''
	 ---------------------------------------------
	 print_exp2_str(Exp.CALL(fcn, args,_,_),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("{",s) => s' &
	 string_append (s',"}") => s''
	 -----------------------------
	 print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	 string_append ("(",s) => s' &
	 string_append (s',")") => s''
	 -----------------------------
	 print_exp2_str (Exp.TUPLE(es),_) => s''
	 
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	 string_append ("{{",s) => s' &
	 string_append (s',"}}") => s''
	 -----------------------------
	 print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (stop,pri3) => s3 &
 	 Exp.print_rightpar_str (pri1,pri2) => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', s4) => s'''
	 -------------------------------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	 Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	 print_exp2_str (start,pri3) => s2 &
	 print_exp2_str (step,pri3) => s3 &
 	 print_exp2_str (stop,pri3) => s4 &
 	 Exp.print_rightpar_str (pri1,pri2) => s5 &
	 string_append (s1, s2) => s &
	 string_append (s, ":") => s' &
	 string_append (s', s3) => s'' &
	 string_append (s'', ":") => s''' &
	 string_append (s''', s4) => s'''' &
	 string_append (s'''', s5) => s'''''
	 -------------------------------------
	 print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	 int_real ival => rval &
	 real_string rval => res &
	 string_append("-",res) => res2
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	 print_exp_cpp_str e => s & 
	 string_append ("(float)(", s) => s' &
	 string_append (s', ")") => s''
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	 print_exp_cpp_str e => s
	 ---------------------------------------
	 print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
         Exp.get_cref_from_exp(e) => cref_list &
	 Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	 print_exp2_str (e,pri3) => s2 &
 	 Exp.print_rightpar_str (pri1,pri2) => s3 &
 	 int_string i => s4 &
	 string_append (s1, s2) => s &
	 string_append (s, s3) => s' &
	 string_append (s', "[") => s'' &
	 string_append (s'', s4) => s''' &
	 string_append (s''', "]") => s''''
	 ---------------------------------------
	 print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	 print_exp_cpp_str dim => dimstr &
	 Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	 Util.string_append_list(["size(",crstr,")"]) => str
	 ------------------------
	 print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	 print_exp_cpp_str exp => expstr &
	 print_exp_cpp_str iterexp => iterstr &
	 Util.string_append_list(["<reduction>",
				  fs,"(",expstr," for ",
				  id," in ",iterstr,")"]) => str
	 -------------------------------------------------------
	 print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

 end

(** relation: cref_modelica_str
 ** Converts Exp.ComponentRef, i.e. variables, to Modelica friendly variables.
 ** This means that dots are converted to underscore, etc.
 **)
relation cref_modelica_str : Exp.ComponentRef => string =

  rule  Util.string_replace_char(s,#".",#"_") => res' &
        Util.string_replace_char(res',#"[",#"_") => res'' &
        Util.string_replace_char(res'',#"]",#"_") => res''' 
        (* & Util.string_append_list(["_",res,"_"]) => res'*)
        ------------------------------
        cref_modelica_str(Exp.CREF_IDENT(s,_)) => res'''
        
  rule	cref_modelica_str(n) => ns &
(*  	string_append(s,"_") => s1 &  *)
	string_append(s(*s1*),ns) => ss
	-------------------------------------
	 cref_modelica_str(Exp.CREF_QUAL(s,_,n)) => ss
end

