(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module does static analysis and constant evaluation of
 ** expressions.  The analyzed expressions are built using the
 ** constructors in the `Exp' module.  Also, a set of properties of
 ** the expressions is calculated during analysis.
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"

  type Ident = string

  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
 datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Types.Type (* type *)
			      * bool (* if the type is a tuple, each element have a const flag. *)
(*			      * bool *)       (* constant *)
(* Types.Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Types.Type * Const (* The elements might be tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)



  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)

  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties)
  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility)
  relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool)

  (* Constant propagation *)
  relation ceval : (Env.Env, Exp.Exp)	  => Values.Value
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  (* Property matching (type conversions etc.) *)
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list

  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp

end

with "dump.rml"

(**
 ** - Expression elaboration
 **)

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) =

  axiom	elab_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), PROP(Types.T_INTEGER,true))
  axiom	elab_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), PROP(Types.T_REAL,   true))
  axiom	elab_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), PROP(Types.T_STRING, true))
  axiom	elab_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), PROP(Types.T_BOOL,   true))

  rule	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (exp,prop)

	(**  Binary and unary operations *)

  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),PROP(rtype,c))

  rule	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),PROP(rtype,c))
	
  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),PROP(rtype,c))

  rule	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),PROP(rtype,c))

  rule	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),PROP(rtype,c))

	(**  Conditional expressions *)

  rule	elab_exp (env,e1) => (e1', prop1) &
	elab_exp (env,e2) => (e2', prop2) &
	elab_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3)) => (e,prop)

	(**  Function calls *)

  rule	elab_call(env,fn,args) => (e,prop)
	-------------------------------------
	elab_exp (env,Absyn.CALL(fn,args)) => (e,prop)




	(*PR. Get the properties for each expression in the tuplel. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	print "\n#####################elab_exp tuple.####################" &
	elab_tuple(env,e) => (e', props) &
	print "\nThe elaborated tuple." &
	split_props(props) => (types, consts)
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e)) => (Exp.TUPLE(e'),PROP_TUPLE(Types.T_TUPLE(types), TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start',NONE,stop',const) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(start',NONE,stop'), PROP(t, const))

  rule	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, step) => (step', PROP(Types.T_INTEGER, c_step)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start',SOME(step'),stop',const) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(start',SOME(step'),stop'), PROP(t, const))

  rule	elab_array (env, es) => (es', PROP(t, const)) & list_length es' => l
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const))
	
  rule	elab_matrix (env, es) => (es', t, dim, const) & list_length es' => l
	--------------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)),
				 Types.T_ARRAY(Types.DIM(SOME(dim)), t)),
		   const))

  rule	print "- elab_exp failed: " & Dump.print_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,e) => fail

end

(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool) => Types.Type =

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_INTEGER)

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,step) => Values.INTEGER(stepv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_INTEGER)

  axiom	elab_range_type (_,_,_,_,false)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_INTEGER)

end

relation elab_tuple : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties list) =

  rule	elab_exp (env,e) => (e',p) &
	elab_tuple(env,exps) => (exps',props)
	-----------------------------
	elab_tuple(env,e::exps) => (e'::exps', p::props) 

  axiom elab_tuple(env,[]) => ([], []) 

end

(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties) =

  rule	elab_exp (env,e) => (e',prop)
	-----------------------------
	elab_array (env,[e]) => ([e'],prop)

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es) => (e'::es',PROP(t1,c))

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	not t1 = t2 &
	print "# Incompatible types in array expression\n" &
	print "  " & Dump.print_exp e & print " is of type " &
 	Types.print_type t1 & print "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	print "] are of type " & Types.print_type t2 & print "\n"
	---------------------------------------------------------
	elab_array (env,e::es) => fail

  rule	print "- elab_array failed\n"
	-----------------------------
	elab_array (_,_) => fail

end

(** relation: elab_matrix *)

relation elab_matrix : (Env.Env, Absyn.Exp list list)
	=> (Exp.Exp list list, Types.Type, int, bool) =

  rule	list_length(el) => dim &
	elab_array(env,el) => (el', PROP(t, c))
	---------------------------------
	elab_matrix(env,[el]) => ([el'], t, dim, c)

  rule	list_length(el) => dim1 &
	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	t1 = t2 & dim1 = dim2 &
	bool_and(c1,c2) => c
	--------------------
	elab_matrix(env,el::els) => (el'::els',t1,dim1,c)

	(**  Error messages *)

  rule	print "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix(_,[]) => fail

  rule	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	print "# Incompatible types in matrix rows\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of " & Types.print_type t1 & print "\n" &
	print "    the rest of the matrix is of " &
	Types.print_type t2 & print "\n"
	--------------------------------
	elab_matrix(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	print "# Incompatible row length in matrix expression\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of size " &
	int_string dim1 => s & print s & print "\n" &
	print "    the rest of the matrix rows are of size " &
	int_string dim2 => s & print s & print "\n"
	--------------------------------------------
	elab_matrix(env,el::els) => fail

end





(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args) => (e,prop)
	------------------------------------
	elab_call (env,fn,args) => (e,prop)

  rule	print "- elab_call failed\n"
	----------------------------
	elab_call (env,fn,args) => fail

end

(** relation: elab_call_args
 **
 ** Given the name of a function and a list of expressions to be used
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

	(* This rule finds user-defined functions. *)

  rule	
	(* PR. We found a function definition of fn. *)
	Lookup.lookup_type(env,fn) => (t as Types.T_COMPLEX(st,vl)) &
	(* ClassInf.valid(st, Absyn.R_FUNCTION) & *)
	print("Did lookup.") &
	(*PR. Find function parameters in the function definition.*)
	function_params(vl) => (in,out) & (*P.R 1.1 Many outputs are possible *)
	print("Did function_params") &
	get_types(out) => types &
	print("\nGot types.") &
	(*PR. elaborate input parameters from the function call(args).
	* In are the in-parameters specified in the function declaration.
	* c indicate if all input parameters are constant, this means that
	* all output parameters are constant as well, since they only 
	* depends on the input parameters.
	* c is true if all input arguments are constant.
	*)
	elab_input_args(env, args, in) => (args', c) &

	(*PR. !! Fix this. The function body is examined to determine the 
	* constness of each output argument.
	 At the moment this just gives a false list.
	*)
	elab_consts(out) => const &	

	print("Did elab_input_args")
	--------------------------------------------
	elab_call_args(env,fn,args) => (Exp.CALL(fn,args'), PROP_TUPLE(Types.T_TUPLE(types), const))

	(* This rule finds the built-in functions *)

  rule	

	
	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(params,restype)) &
	(*P.R: When is T_FUNCTION ouputted from lookup_type? *)
	print "Debug: We did a lookup T_FUNCTION " &
	elab_input_args(env, args, params) => (args',c)
	-----------------------------------------------
	elab_call_args (env,fn,args) => (Exp.CALL(fn,args'), PROP(restype, c))


  rule	not Lookup.lookup_type(env,fn) => _ &
	print "# Couldn't find function " & Dump.print_path fn & print "\n"
	-------------------------------------------------------------------
	elab_call_args(env,fn,_) => fail

  rule	print "- elab_call_args failed\n"
	---------------------------------
	elab_call_args(_,_,_) => fail

end





(** PR. assisting routines
 ** This just splits the properties list into a type list and a const list. 
 **)

relation elab_consts : ((Ident * Types.Type) list) => Const =
  rule	check_consts out => consts
	-------------------------------
	elab_consts out => TUPLE_CONST(consts)
end

relation check_consts : ((Ident * Types.Type) list) => Const list =	
  rule  check_const(a) => c &
	check_consts(rest) => rest'
	-------------------------------
	check_consts a::rest=> c::rest'

  axiom check_consts [] => []
end



(*PR. !! At the moment this matke all outputs non cons.
* All ouputs sholud be checked in the function body for constness. 
*)
relation check_const : (Ident*Types.Type) => Const  =	
	
rule	print("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const((_, Types.T_TUPLE(_))) => fail

axiom	check_const((_, _)) => CONST(true)

end


relation split_props : (Properties list) => (Types.Type list, Const list) =
  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props)=> (t::types,CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end










(* obsolete
relation split_props: (Properties list, Types.Type list, Const list) => (Types.Type list, Const list) =
  rule 	list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
	split_props(props, t1, t2) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props, ts, cs)=> (types,consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	list_append(cs, t_c::[]) => cs' & 
	split_props(props, [], cs') => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props, ts, cs)=> (types,consts)
  
  axiom	split_props([],ts,cs) => (ts, cs)
end
*)










relation get_types :((Ident * Types.Type) list) => Types.Type list =

rule	print("\nDebug: Got a type for output of function. ") &
	get_types(rest) => types 
	-----------------
	get_types ((i,t)::rest) => t::types

axiom	get_types ([]) => []
	
end


(** relation: function_params
 **
 ** A function definition is just a class definition where all public
 ** components are declared as either `input' or `output'.  This
 ** relation find all those components and separates them into two
 ** separate lists.
 **)

relation function_params : Types.Var list => ((Ident * Types.Type) list,
					      (Ident * Types.Type) list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	print("protected") &
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	print("not protected. intput") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	print("not protected. output") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	print "# Components in functions must be INPUT or OUTPUT\n" &
	print "    component: " & print n & print "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	print "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(** relation: elab_input_args
 **
 ** This relation elaborates on a number of expressions and matches
 ** them to a number of `Types.Var' object, applying type conversions
 ** on the expressions when necessary to match the type of the
 ** `Types.Var'.
 **)

(*PR. env, input args from the function call, in arguments in the function definition. *)
relation elab_input_args : (Env.Env, Absyn.Exp list, (Ident * Types.Type) list)
	  => (Exp.Exp list, bool) =

  axiom	elab_input_args(_, [], []) => ([], true)
	(*PR. What is the c for. If all input arguments from the function 
	* call are constants then the result is a constant. 
 	* Of course the output variable must be a constant since all 
	* input variables are constant and the output do not depend on 
	* any other variable.
	*
	* This is also true for multiple output arguments. But if some input arguments are constant then some output argument may be constant too. In this case the function body  have to be analysed in more detail. 
	
	Which is not done at all now??
	*)

  rule	elab_exp(env, e) => (e',PROP(t, c1)) &
	match_type(e', t, vt) => e'' &
	elab_input_args(env, es, vs) => (args', c2) &
	bool_and(c1, c2) => c
	-------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => (e''::args', c)

  rule	elab_exp(env, e) => (e',PROP(t,_)) &
	print "# Argument (" & Dump.print_exp e &
 	print ") doesn't match parameter type\n" &
	print "    parameter type: " & Types.print_type vt & print "\n" &
	print "    argument type: " & Types.print_type t & print "\n"
	-------------------------------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => fail

end

(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility) =

  rule	elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc')
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c) => (exp, PROP(t, const), acc')

  rule	elab_cref_subs (env,c) => (c', const) &
	print "# Unknown component: " & Dump.print_component_ref c & print "\n"
	-----------------------------------------------------
	elab_cref(env, c) => fail

  rule	print "- elab_cref failed\n"
	------------------------------
	elab_cref (_,_) => fail

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, Absyn.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,bool,SCode.Accessibility) =

  axiom	elab_cref2 (_,cr, acc, Absyn.VAR, _,_) => (Exp.CREF(cr),false, acc)
  axiom	elab_cref2 (_,cr, acc, Absyn.DISCRETE, _,_) => (Exp.CREF(cr),false,acc)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,_,t, Types.VALBOUND(v)) => (e,true,SCode.RO)

  axiom	elab_cref2 (env,cr,acc,_,t, Types.EQBOUND(exp,true))
	  => (Exp.CREF(cr),true,acc)

  rule	print "# Constant or parameter with a non-constant initializer\n" &
	print "# component: " & Exp.print_component_ref cr & print " = " &
	Exp.print_exp exp & print "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,false)) => fail

  rule	print "# Constant or parameter without a value\n" &
	print "# component: " & Exp.print_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,cr,_,_,_,Types.UNBOUND) => fail

  rule	print "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & print ")\n"
	----------------------------------------
	elab_cref2 (_,cr,_,_,_,_) => fail

end	

(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => true &
	ceval_subscripts(env, sub'::subs') => ss
	-----------------------------------
	elab_subscripts (env,sub::subs) => (ss,true)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.WHOLEDIM, true)

  rule	elab_exp (env,sub) => (sub', PROP(ty, const)) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end

(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type (Types.T_INTEGER,_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER),_,sub)
	  => Exp.SLICE(sub)

  rule	print "# Subscript is not an integer or integer array\n" &
	print "    expression: " & Dump.print_exp e &
 	print " :: " & Types.print_type t & print "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type (Types.T_ARRAY(Types.DIM(_),t),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.SLICE(_)::subs)
	  => Types.T_ARRAY(dim,t')

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.WHOLEDIM::subs)
	  => Types.T_ARRAY(dim,t')

  rule	print "- subscript_type failed (" & Types.print_type t &
	print " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Exp.Exp, Properties,
		       Exp.Exp, Properties,
		       Exp.Exp, Properties)
	  => (Exp.Exp, Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),
		   e3,PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), PROP(t2, c))

  rule	not t1 = Types.T_BOOL &
	print "# conditional in if expression has to be boolean\n" &
	print "    got type: " & Types.print_type t1 & print "\n" &
	print "    expression: " & Exp.print_exp e1 & print "\n"
	--------------------------------------------------------
	elab_ifexp(e1,PROP(t1,c1),e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	print "# Type mismatch in if-expression\n" &
	print "    true branch : " & Exp.print_exp e2 &
 	print " :: " & Types.print_type t2 & print "\n" &
	print "    false branch: " & Exp.print_exp e3 &
 	print " :: " & Types.print_type t3 & print "\n"
	-----------------------------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	print "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(** relation: ceval
 **
 ** This relations is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **)

relation ceval : (Env.Env, Exp.Exp) => Values.Value =

  axiom	ceval (_,Exp.ICONST(x)) => Values.INTEGER(x)
  axiom	ceval (_,Exp.RCONST(x)) => Values.REAL(x)
  axiom ceval (_,Exp.SCONST(x)) => Values.STRING(x)
  axiom ceval (_,Exp.BCONST(x)) => Values.BOOL(x)

  rule	ceval_list (env,es) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(es)) => Values.ARRAY(es')

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c)) => v

  rule	print "# Can't call functions at compile time\n" &
	print "    expression: " & Exp.print_exp e & print "\n"
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(_,_)) => fail

	(**  Numerical *)

  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh))
	  => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh)) => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp))
	  => Values.INTEGER(x')
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp))
	  => Values.INTEGER(x')

	(**  Logical *)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh))
	  => Values.BOOL(x)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh))
	  => Values.BOOL(x)

  rule	ceval (env,e) => Values.BOOL(b) &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e)) => Values.BOOL(b')

	(**  Relations *)

  rule	ceval (env, lhs) => lhs' &
	ceval (env, rhs) => rhs' &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs)) => v

	(**)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, NONE, stop)) => Values.ARRAY(arr)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, step) => Values.INTEGER(step') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, SOME(step), stop)) => Values.ARRAY(arr)

  rule	ceval (env,e) => Values.INTEGER(i) &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e)) => Values.REAL(r)

  rule	print "- ceval " & Exp.print_exp e & print " failed\n"
	-----------------------------------------------------
	ceval (_,e) => fail
	
end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	print "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** This relation evaluates a range expression.  It only handles integers.
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list) => Values.Value list =
	  
  rule	ceval (env, exp) => v
	----------------------------
	ceval_list (env, [exp]) => [v]

  rule	ceval (env,exp) => v &
	ceval_list (env, exps) => vs
	------------------------------
	ceval_list (env, exp::exps) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,binding) => v
	-------------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref c & print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Types.Binding) => Values.Value =

  axiom	ceval_cref_binding (env,Types.VALBOUND(v)) => v

  rule	print "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,Types.UNBOUND) => fail
	
  rule	ceval (env,exp) => v
	------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,true)) => v

  rule	print "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & print ")\n"
	--------------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,false)) => fail
	
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY([])

  rule	value_exp x => x' &
  	value_exp Values.ARRAY(xs) => Exp.ARRAY(xs')
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(x'::xs')

  rule	print "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	print "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.WHOLEDIM) => Exp.WHOLEDIM

  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1)) => Exp.INDEX(e1')
	
  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1)) => Exp.SLICE(e1')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> Exp.Exp list =

  axiom	elab_arglist ([],[]) => []

  rule	match_type(arg, atype, pt) => arg' &
	elab_arglist (pts, args) => args'
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => arg'::args'

end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	print "Debug: match prop." &
	match_type(e, gt, et) => e'
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => e'
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end

(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Types.Type, Types.Type) => Exp.Exp =
  rule	Types.subtype(e_type, expected_type) => true
	--------------------------------------------
	match_type(e, e_type, expected_type) => e

  rule	Types.subtype(e_type, expected_type) => false &
	type_convert(e, e_type, expected_type) => e'
	--------------------------------------------
	match_type(e, e_type, expected_type) => e'

end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Types.Type, Types.Type) => Exp.Exp =

  axiom	type_convert(e, Types.T_INTEGER, Types.T_REAL) => Exp.CAST(Exp.REAL,e)

end

(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	elab_arglist (params, args) => args'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype)

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	print "# Can't resolve type of expression: " &
	Dump.print_exp exp & print "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  axiom	operators Absyn.ADD
	  => [(Exp.ADD(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.ADD(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL),
	      (Exp.ADD(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_STRING)]

  axiom	operators Absyn.SUB
	  => [(Exp.SUB(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.SUB(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.MUL
	  => [(Exp.MUL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.MUL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.DIV
	  => [(Exp.DIV(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UMINUS
	  => [(Exp.UMINUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UMINUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UPLUS
	  => [(Exp.UPLUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UPLUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

	(**  Logical operators *)

  axiom	operators Absyn.AND
	  => [(Exp.AND,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.OR
	  => [(Exp.OR,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NOT
	  => [(Exp.NOT,
	       [Types.T_BOOL],
	       Types.T_BOOL)]

	(**  Relational operators *)

  axiom	operators Absyn.LESS
	  => [(Exp.LESS(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESS(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.LESSEQ
	  => [(Exp.LESSEQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESSEQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATER
	  => [(Exp.GREATER(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATER(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATEREQ
	  => [(Exp.GREATEREQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATEREQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.EQUAL
	  => [(Exp.EQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NEQUAL
	  => [(Exp.NEQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]


  rule	print "- operators(" & Dump.op_symbol op => s &
 	print s & print ") failed\n"
	----------------------------
	operators op => fail

end

