module StaticExp :

  with "absyn.rml"
  with "exp.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"

  type Type = Types.BasicType
  type Ident = string

  relation elab_exp : (Env.Env,
		       Absyn.Exp)           => (Exp.Exp, Types.BasicType, bool)
  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, Types.BasicType, bool)
  relation elab_relop : (Absyn.RelOp, Types.BasicType) => Exp.RelOp
  relation ceval : (Env.Env, Exp.Exp)	  => (Values.Value, Types.BasicType)

end

with "dump.rml"

(**
 ** - Expression elaboration
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Types.BasicType, bool) =

  axiom	elab_exp(_, Absyn.INTEGER(x)) => (Exp.ICONST(x), Types.T_INTEGER,true)
  axiom	elab_exp(_, Absyn.REAL(x))    => (Exp.RCONST(x), Types.T_REAL,   true)
  axiom	elab_exp(_, Absyn.STRING(x))  => (Exp.SCONST(x), Types.T_STRING, true)
  axiom	elab_exp(_, Absyn.BOOL(x))    => (Exp.BCONST(x), Types.T_BOOL,   true)

  rule	elab_cref(env, cr) => (cr',t,c)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (Exp.CREF(cr'),t,c)

  rule	elab_exp (env,e1) => (e1', t1, c1) &
	elab_exp (env,e2) => (e2', t2, c2) &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t) &
	elab_binary (e1'', t, c1, op, e2'', t, c2) => (e, t', c)
	-------------------------------------------------------
	elab_exp (env,Absyn.BINARY(e1,op,e2)) => (e,t',c)

  rule	elab_exp (env,e1) => (e1', t1, c1) &
	elab_exp (env,e2) => (e2', t2, c2) &
	elab_numtypes (e1',t1,e2',t2) => (e1'',e2'',t) &
	elab_relation (e1'', c1, t, op, e2'', c2) => (e, t', c)
	----------------------------------------------
	elab_exp (env,Absyn.RELATION(e1,op,e2))
	  => (e,t',c)

  rule	(* FIXME: lookup function *)
	elab_exp_list (env,args) => (args',c)
	-------------------------------------
	elab_exp (env,Absyn.CALL(fn,args)) => (Exp.CALL(fn,args'),
					       Types.T_REAL (*FIXME*),
					       c)

  rule	elab_exp (env, start) => (start', Types.T_INTEGER, c_start) &
	elab_exp (env, stop) => (stop', Types.T_INTEGER, c_stop) &
	bool_and (c_start, c_stop) => const
	-------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(start',NONE,stop'),
	      Types.T_ARRAY(1, Types.T_INTEGER),
	      const)

  rule	elab_exp (env, start) => (start', Types.T_INTEGER, c_start) &
	elab_exp (env, step) => (step', Types.T_INTEGER, c_step) &
	elab_exp (env, stop) => (stop', Types.T_INTEGER, c_stop) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const
	-------------------------------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(start',SOME(step'),stop'),
	      Types.T_ARRAY(1, Types.T_INTEGER),
	      const)

  rule	print "- elab_exp failed: " & Dump.print_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,e) => fail

end

(**)

relation elab_exp_list : (Env.Env, Absyn.Exp list) => (Exp.Exp list, bool) =

  axiom	elab_exp_list (_,[]) => ([],true)

  rule	elab_exp (env,e) => (e',_,c1) &
	elab_exp_list (env,es) => (es',c2) &
	bool_and (c1,c2) => c
	---------------------------------
	elab_exp_list (env,e::es) => (e'::es',c)

end

(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, Types.BasicType, bool) =

  rule	elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Absyn.ATTR(_,_,vartype,_),
				       Types.TYPE(st, _),
				       binding) &
	Types.known_type st => t &
	elab_cref2 (env, c', vartype, t, binding) => const &
	print "    elab_cref " & Dump.print_component_ref c &
	print " => " & print " (" & Types.print_type t & print ")\n"
	-------------------------
	elab_cref(env, c) => (c', t, const)

  rule	print "- elab_cref failed\n"
	------------------------------
	elab_cref (_,_) => fail

end

(**)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef, Absyn.VarType,
		       Types.BasicType, Env.Binding) => bool =

	(* FIXME: Check type of expression anyway? *)
  axiom	elab_cref2 (_,cr, Absyn.VAR, _, _) => false

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,t, Env.VALBOUND(v)) => true

  rule	elab_exp (env,exp) => (exp', t', c) &
	c = true (* & *)
	(* t = t' *) (* FIXME: cast *)
	------------------------
	elab_cref2 (env,cr,_,t, Env.EQBOUND(exp)) => true

  rule	print "# Constant or parameter without a value (I think)\n" &
	print "# component: " & Exp.print_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,cr, _,_,_) => fail

end	

(**)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(**)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => const
	----------------------------------
	elab_subscripts (env,sub::subs) => (sub'::subs',const)

end

(**)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.NOSUB, true)

  rule	elab_exp (env,sub1) => (sub1', Types.T_INTEGER, const)
	----------------------------------------------------
	elab_subscript (env,Absyn.SUB1(sub1)) => (Exp.SUB1(sub1'), const)

  rule	elab_exp (env,sub1) => (sub1', Types.T_INTEGER, const1) &
	elab_exp (env,sub2) => (sub2', Types.T_INTEGER, const2) &
	bool_and(const1, const2) => const
	---------------------------------
	elab_subscript (env,Absyn.SUB2(sub1,sub2))
	  => (Exp.SUB2(sub1',sub2'), const)

  rule	elab_exp (env,sub1) => (sub1', Types.T_INTEGER, const1) &
	elab_exp (env,sub2) => (sub2', Types.T_INTEGER, const2) &
	elab_exp (env,sub3) => (sub3', Types.T_INTEGER, const3) &
	bool_and(const1, const2) => const3 &
	bool_and(const3, const2) => const
	---------------------------------
	elab_subscript (env,Absyn.SUB3(sub1,sub2,sub3))
	  => (Exp.SUB3(sub1',sub2',sub3'), const)

end

(**)

relation elab_numtypes : (Exp.Exp, Types.BasicType, Exp.Exp, Types.BasicType)
	  => (Exp.Exp, Exp.Exp, Types.BasicType) =

  axiom	elab_numtypes (e1, Types.T_INTEGER, e2, Types.T_INTEGER)
	  => (e1, e2, Types.T_INTEGER)

  axiom	elab_numtypes (e1, Types.T_REAL, e2, Types.T_REAL)
	  => (e1, e2, Types.T_REAL)

  axiom	elab_numtypes (e1, Types.T_INTEGER, e2, Types.T_REAL)
	  => (Exp.CAST_TO_REAL(e1), e2, Types.T_REAL)

  axiom	elab_numtypes (e1, Types.T_REAL, e2, Types.T_INTEGER)
	  => (e1, Exp.CAST_TO_REAL(e2), Types.T_REAL)

  rule	print "- elab_numtypes failes\n"
	----------------------------------
	elab_numtypes (_,_,_,_) => fail

end

(** relation: elab_binary *)

relation elab_binary : (Exp.Exp, Types.BasicType, bool,
			Absyn.BinOp,
			Exp.Exp, Types.BasicType, bool)
	  => (Exp.Exp, Types.BasicType, bool) =

	(**  ADD *)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.ADD,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.INT_ADD,e2), Types.T_INTEGER, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_REAL,c1,Absyn.ADD,e2,Types.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.REAL_ADD,e2), Types.T_REAL, c)

	(**  SUB *)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_INTEGER,c1,Absyn.SUB,e2,Types.T_INTEGER,c2)
	  => (Exp.BINARY(e1,Exp.INT_SUB,e2), Types.T_INTEGER, c)

  rule	bool_and (c1,c2) => c
	---------------------
	elab_binary (e1,Types.T_REAL,c1,Absyn.SUB,e2,Types.T_REAL,c2)
	  => (Exp.BINARY(e1,Exp.REAL_SUB,e2), Types.T_REAL, c)

	(**  Failure *)
  rule	print "- elab_binary failed " (* &
	Absyn.dump_exp e1 & print " (" & Types.print_type t1 & print ") o " &
	Absyn.dump_exp e2 & print " (" & Types.print_type t2 *) & print ")\n"
	---------------------------------------------
	elab_binary(e1, t1, c1, op, e2, t2, c2) => fail
			
end

(** relation: elab_relation *)

relation elab_relation : (Exp.Exp, bool,
			  Types.BasicType, Absyn.RelOp,
			  Exp.Exp, bool)
	  => (Exp.Exp, Types.BasicType, bool) =

  rule	bool_and (c1,c2) => c &
	elab_relop (op,t) => op'
	---------------------
	elab_relation (e1,c1,t,op,e2,c2)
	  => (Exp.RELATION(e1,op',e2), Types.T_BOOL, c)

	(**  Failure *)
  rule	print "- elab_relation failed\n"
	--------------------------------
	elab_relation(_,_,_,_,_,_) => fail
			
end

(** relation: elab_relop *)

relation elab_relop : (Absyn.RelOp, Types.BasicType) => Exp.RelOp =

  axiom	elab_relop (Absyn.LESS,      Types.T_INTEGER) => Exp.INT_LESS
  axiom	elab_relop (Absyn.LESS,      Types.T_REAL)    => Exp.REAL_LESS
  axiom	elab_relop (Absyn.LESSEQ,    Types.T_INTEGER) => Exp.INT_LESSEQ
  axiom	elab_relop (Absyn.LESSEQ,    Types.T_REAL)    => Exp.REAL_LESSEQ
  axiom	elab_relop (Absyn.GREATER,   Types.T_INTEGER) => Exp.INT_GREATER
  axiom	elab_relop (Absyn.GREATER,   Types.T_REAL)    => Exp.REAL_GREATER
  axiom	elab_relop (Absyn.GREATEREQ, Types.T_INTEGER) => Exp.INT_GREATEREQ
  axiom	elab_relop (Absyn.GREATEREQ, Types.T_REAL)    => Exp.REAL_GREATEREQ
  axiom	elab_relop (Absyn.EQUAL,     Types.T_INTEGER) => Exp.INT_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_REAL)    => Exp.REAL_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_BOOL)    => Exp.BOOL_EQUAL
  axiom	elab_relop (Absyn.EQUAL,     Types.T_STRING)  => Exp.STRING_EQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_INTEGER) => Exp.INT_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_REAL)    => Exp.REAL_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_BOOL)    => Exp.BOOL_NEQUAL
  axiom	elab_relop (Absyn.NEQUAL,    Types.T_STRING)  => Exp.STRING_NEQUAL

end

(**)

relation is_const : Exp.Exp => () =

  axiom	is_const Exp.ICONST(_)
  axiom	is_const Exp.RCONST(_)
  axiom	is_const Exp.SCONST(_)
  axiom	is_const Exp.BCONST(_)

end

(**)

relation ceval : (Env.Env, Exp.Exp) => (Values.Value, Types.BasicType) =

  axiom	ceval (_,Exp.ICONST(x)) => (Values.INTEGER(x), Types.T_INTEGER)
  axiom	ceval (_,Exp.RCONST(x)) => (Values.REAL(x),    Types.T_REAL)
  axiom ceval (_,Exp.SCONST(x)) => (Values.STRING(x),  Types.T_STRING)
  axiom ceval (_,Exp.BCONST(x)) => (Values.BOOL(x),    Types.T_BOOL)

  rule	ceval_list (env,es) => (es',t)
	------------------------------
	ceval (env,Exp.ARRAY(es)) => (Values.ARRAY(es'), Types.T_ARRAY(1,t))

  rule	ceval_cref (env,c) => (v,t)
	---------------------------
	ceval (env,Exp.CREF(c)) => (v,t)

	(**  Numerical *)

  rule	ceval (env, lh) => (Values.REAL(lhv), Types.T_REAL) &
	ceval (env, rh) => (Values.REAL(rhv), Types.T_REAL) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.REAL_ADD, rh))
	  => (Values.REAL(sum), Types.T_REAL)

  rule	ceval (env, lh) => (Values.INTEGER(lhv), Types.T_INTEGER) &
	ceval (env, rh) => (Values.INTEGER(rhv), Types.T_INTEGER) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, INT_ADD, rh))
	  => (Values.INTEGER(sum), Types.T_INTEGER)

  rule	ceval (env, lh) => (Values.REAL(lhv), Types.T_REAL) &
	ceval (env, rh) => (Values.REAL(rhv), Types.T_REAL) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.REAL_SUB, rh))
	  => (Values.REAL(sum), Types.T_REAL)

  rule	ceval (env, lh) => (Values.INTEGER(lhv), Types.T_INTEGER) &
	ceval (env, rh) => (Values.INTEGER(rhv), Types.T_INTEGER) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, INT_SUB, rh))
	  => (Values.INTEGER(sum), Types.T_INTEGER)

	(**)

(*
  rule	ceval (lh, Types.T_REAL) => REAL(lhv) &
	ceval (rh, Types.T_REAL) => REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (BINARY(lh, SUB, rh), Types.T_REAL) => REAL(sum)

  rule	ceval (lh, Types.T_INTEGER) => INTEGER(lhv) &
	ceval (rh, Types.T_INTEGER) => INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (BINARY(lh, SUB, rh), Types.T_INTEGER) => INTEGER(sum)

  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, MUL, rh), Types.T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, MUL, rh), Types.T_INTEGER)) => INTEGER(sum)

	(**)

  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_div(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, DIV, rh), Types.T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_div(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, DIV, rh), Types.T_INTEGER)) => INTEGER(sum)

	(**)

  rule	ceval lh => REAL(lhv) &
	ceval rh => REAL(rhv) &
	real_pow(lhv, rhv) => sum
	-------------------------
	ceval ((BINARY(lh, POW, rh), Types.T_REAL)) => REAL(sum)

  rule	ceval lh => INTEGER(lhv) &
	ceval rh => INTEGER(rhv) &
	int_pow(lhv, rhv) => sum
	------------------------
	ceval ((BINARY(lh, POW, rh), Types.T_INTEGER)) => INTEGER(sum)

	(**)

  rule	ceval rh => REAL(rhv) &
	real_neg(rhv) => rhv'
	-------------------------
	ceval ((UNARY(UMINUS, rh), Types.T_REAL)) => REAL(rhv')

  rule	ceval rh => INTEGER(rhv) &
	int_neg(rhv) => rhv'
	--------------------
	ceval ((UNARY(UMINUS, rh), Types.T_INTEGER)) => INTEGER(rhv')


  rule	ceval rh => REAL(rhv)
	---------------------
	ceval ((UNARY(UPLUS, rh), Types.T_REAL)) => REAL(rhv)

  rule	ceval rh => INTEGER(rhv)
	------------------------
	ceval ((UNARY(UPLUS, rh), Types.T_INTEGER)) => INTEGER(rhv)

	(**  Boolean *)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_and(lhv, rhv) => con
	-------------------------
	ceval LBINARY(lh, AND, rh) => BOOL(con)

  rule	ceval lh => BOOL(lhv) &
	ceval rh => BOOL(rhv) &
	bool_or(lhv, rhv) => disj
	-------------------------
	ceval LBINARY(lh, OR, rh) => BOOL(disj)

  rule	ceval rh => BOOL(rhv) &
	bool_not rhv => rhv'
	--------------------
	ceval LUNARY(NOT, rh) => BOOL(rhv')

	(**  Relations *)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_lt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESS, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_le(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, LESSEQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_gt(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATER, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ge(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, GREATEREQ, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_eq(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, EQUAL, rh) => BOOL(b)

  rule	ceval lh => NUMBER(lhv) &
	ceval rh => NUMBER(rhv) &
	real_ne(lhv,rhv) => b
	---------------------
	ceval RELATION(lh, NEQUAL, rh) => BOOL(b)
*)

  rule	ceval (env, start) => (Values.INTEGER(start'), Types.T_INTEGER) &
	ceval (env, stop) => (Values.INTEGER(stop'), Types.T_INTEGER) &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, NONE, stop))
	  => (Values.ARRAY(arr), Types.T_ARRAY(1, Types.T_INTEGER))

  rule	ceval (env, start) => (Values.INTEGER(start'), Types.T_INTEGER) &
	ceval (env, step) => (Values.INTEGER(step'), Types.T_INTEGER) &
	ceval (env, stop) => (Values.INTEGER(stop'), Types.T_INTEGER) &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, SOME(step), stop))
	  => (Values.ARRAY(arr), Types.T_ARRAY(1, Types.T_INTEGER))

  rule	print "- ceval " & Exp.print_exp e & print " failed\n"
	-----------------------------------------------------
	ceval (_,e) => fail
	
end

(** relation: ceval_range
 **
 ** FIXME: Should handle reals too, I guess
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_list
 **
 ** Do a constant evaluation on a number of expressions, and assert
 ** that they are all of the same type.
 **)

relation ceval_list : (Env.Env, Exp.Exp list)
	  => (Values.Value list, Types.BasicType) =
	  
  rule	ceval (env, exp) => (v, t)
	----------------------------
	ceval_list (env, [exp]) => ([v], t)

  rule	ceval (env,exp) => (v, t1) &
	ceval_list (env, exps) => (vs, t2) &
	t1 = t2
	-------
	ceval_list (env, exp::exps) => (v::vs, t1)

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef)
	  => (Values.Value, Types.BasicType) =

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding binding => (v,t)
	-----------------------------------
	ceval_cref (env,c) => (v,t)

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref c & print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : Env.Binding => (Values.Value, Types.BasicType) =

  rule	value_type v => t
	-----------------
	ceval_cref_binding Env.VALBOUND(v) => (v,t)

end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)

  rule	print "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	print "- value_type failed\n"
	----------------------------
	value_type _ => fail

end
