(**
 ** file:	 static.rml
 ** module:      Static
 ** description: Static analysis of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module does static analysis and constant evaluation of
 ** expressions.  The analyzed expressions are built using the
 ** constructors in the `Exp' module.  Also, a set of properties of
 ** the expressions is calculated during analysis.
 **)

module Static :

  with "absyn.rml"
  with "exp.rml"
  with "explode.rml"
  with "types.rml"
  with "env.rml"
  with "values.rml"
  with "classinf.rml"
  with "lookup.rml"
  with "debug.rml"

  type Ident = string

  (** - Expression properties *)
	(* A tuple is added to the Types. This is used by functions whom
returns multiple arguments. *)

(* Used by split_props  *)
 datatype Const = CONST of bool |
		   TUPLE_CONST  of Const list 

  datatype Properties = PROP of Types.Type (* type *)
			      * bool (* if the type is a tuple, each element 
				      have a const flag. *)
(*			      * bool *)       (* constant *)
(* Types.Type is meant to be T_TUPLE *)
			| PROP_TUPLE of Types.Type * Const (* The elements might be 
							    tuple themselfs. *)
	
(*	* P.R 1.1 for multiple return arguments from functions, 
	*  one constant flag for each return argument. 
	*
*)



  (** The datatype `Properties' contain information about an
   ** expression.  The properties are created by analyzing the
   ** expressions. *)

  (* Expression analysis *)
  relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties)
  relation elab_exp_list : (Env.Env, Absyn.Exp list) => (Exp.Exp list, Properties list)
  relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility)
  relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	  => (Exp.Exp list, Properties list, SCode.Accessibility list)
  relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool)

  (* Constant propagation *)
  relation ceval : (Env.Env, Exp.Exp)	  => Values.Value
  relation ceval_list : (Env.Env, Exp.Exp list)	  => Values.Value list
  relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef

  (* Property matching (type conversions etc.) *)
  relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp
  relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
			 (Exp.Exp * Types.Type) list,
			 Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type)
  relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list

  (* Utility relations *)
  relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => ()
  relation value_exp : Values.Value => Exp.Exp
  relation get_prop_type : Properties => Types.Type
  relation is_prop_const: Properties => bool

end

with "dump.rml"

(** LS:
 ** - Expression elaboration
 **)

relation elab_exp_list : (Env.Env, Absyn.Exp list) 
	  => (Exp.Exp list, Properties list) =

  axiom	elab_exp_list (_,[]) => ([],[])

  rule	elab_exp (env, e) => (exp,p) & 
	elab_exp_list (env, rest) => (exps, props)
	-----------------------------------------
	elab_exp_list (env, e::rest) => (exp::exps, p::props) 
end

(** relation: elab_exp
 **
 ** Static analysis of expressions means finding out the properties of
 ** the expression.  These properties are described by the
 ** `Properties' type, and include the type and the variability of the
 ** expression.  This relation performs analysis, and returns an
 ** `Exp.Exp' and the properties.
 **)

relation elab_exp : (Env.Env, Absyn.Exp) => (Exp.Exp, Properties) =

  axiom	elab_exp(_, Absyn.INTEGER(x))
	  => (Exp.ICONST(x), PROP(Types.T_INTEGER,true))
  axiom	elab_exp(_, Absyn.REAL(x))
	  => (Exp.RCONST(x), PROP(Types.T_REAL,   true))
  axiom	elab_exp(_, Absyn.STRING(x))
	  => (Exp.SCONST(x), PROP(Types.T_STRING, true))
  axiom	elab_exp(_, Absyn.BOOL(x))
	  => (Exp.BCONST(x), PROP(Types.T_BOOL,   true))

  rule	Debug.fprintln("setr", "elab_exp_cref") &
	elab_cref(env, cr) => (exp,prop,_)
	---------------------------------------
	elab_exp(env, Absyn.CREF(cr)) => (exp,prop)

	(**  Binary and unary operations *)

  rule	Debug.fprintln("setr", "elab_exp_binary") &
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.BINARY(e1,op,e2))
	  => (Exp.BINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_unary") &
	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.UNARY(op,e))
	  => (Exp.UNARY(op',e''),PROP(rtype,c))
	
  rule	Debug.fprintln("setr", "elab_exp_lbinary") &
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	---------------------------------------------------------------------
	elab_exp (env,exp as Absyn.LBINARY(e1,op,e2))
	  => (Exp.LBINARY(e1'',op',e2''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_lunary") &
	elab_exp (env,e) => (e',PROP(t,c)) &
 	operators op => ops &
	deoverload (ops, [(e',t)], exp) => (op', [e''], rtype)
	------------------------------------------------------
	elab_exp (env,exp as Absyn.LUNARY(op,e))
	  => (Exp.LUNARY(op',e''),PROP(rtype,c))

  rule	Debug.fprintln("setr", "elab_exp_relation") &
	
	elab_exp (env,e1) => (e1', PROP(t1, c1)) &
	
	elab_exp (env,e2) => (e2', PROP(t2, c2)) &
	
	bool_and (c1,c2) => c &
	operators op => ops &
	deoverload (ops, [(e1',t1),(e2',t2)], exp) => (op',[e1'',e2''],rtype)
	----------------------------------------------
	elab_exp (env,exp as Absyn.RELATION(e1,op,e2))
	  => (Exp.RELATION(e1'',op',e2''),PROP(rtype,c))

	(**  Conditional expressions *)

  rule	Debug.fprintln("setr", "elab_exp_ifexp") &
	elab_exp (env,e1) => (e1', prop1) &
	elab_exp (env,e2) => (e2', prop2) &
	elab_exp (env,e3) => (e3', prop3) &
	elab_ifexp(e1',prop1,e2',prop2,e3',prop3) => (e,prop)
	------------------------------------------------------
	elab_exp (env,Absyn.IFEXP(e1,e2,e3)) => (e,prop)

	(**  Function calls *)

  rule	Dump.print_component_ref_str fn => fnstr &
	Debug.fprintl("setr", ["elab_exp_call: ",fnstr,"\n"]) &
	elab_call(env,fn,args) => (e,prop)
	-------------------------------------
	elab_exp (env,Absyn.CALL(fn,args)) => (e,prop)




	(*PR. Get the properties for each expression in the tuple. 
	* Each expression has its own constflag.
	* !!The output from functions does just have one const flag. 
	* Fix this!!
	*)
	
  rule	Debug.fprintln("setr", "elab_exp_tuple") &
	Debug.print "\n#####################elab_exp tuple.####################" &
(*	Dump.print_exp e1 &
*)	Debug.print "\n ###################" &
	elab_tuple(env,e) => (e', props) &
	Debug.print "\nThe elaborated tuple." &
	split_props(props) => (types, consts) &
	Debug.print "\n split_props was just executed."
	-------------------------------------
	elab_exp (env,Absyn.TUPLE(e as e1::rest)) 
	  => (Exp.TUPLE(e'),PROP_TUPLE(Types.T_TUPLE(types), TUPLE_CONST(consts)))


	(**  Array-related expressions *)

  rule	Debug.fprintln("setr", "elab_exp_range1") &
	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_stop) => const &
	elab_range_type (env,start',NONE,stop',const) => t
	--------------------------------------------------
	elab_exp (env, Absyn.RANGE(start, NONE, stop))
	  => (Exp.RANGE(start',NONE,stop'), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_exp_range2") &
	elab_exp (env, start) => (start', PROP(Types.T_INTEGER, c_start)) &
	elab_exp (env, step) => (step', PROP(Types.T_INTEGER, c_step)) &
	elab_exp (env, stop) => (stop', PROP(Types.T_INTEGER, c_stop)) &
	bool_and (c_start, c_step) => c1 &
	bool_and (c1, c_stop) => const &
	elab_range_type (env,start',SOME(step'),stop',const) => t
	---------------------
	elab_exp (env, Absyn.RANGE(start, SOME(step), stop))
	  => (Exp.RANGE(start',SOME(step'),stop'), PROP(t, const))

  rule	Debug.fprintln("setr", "elab_exp_array") &
	elab_array (env, es) => (es', PROP(t, const)) & list_length es' => l
	--------------------------------------------------------------
	elab_exp (env, Absyn.ARRAY(es))
	  => (Exp.ARRAY(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)), t),
		   const))
	
  rule	Debug.fprintln("setr", "elab_exp_matrix") &
	elab_matrix (env, es) => (es', t, dim, const) & list_length es' => l
	--------------------------------------------------------------------
	elab_exp (env, Absyn.MATRIX(es))
	  => (Exp.MATRIX(es'),
	      PROP(Types.T_ARRAY(Types.DIM(SOME(l)),
				 Types.T_ARRAY(Types.DIM(SOME(dim)), t)),
		   const))

  rule	print "- elab_exp failed: " & Dump.print_exp e & print "\n"
	---------------------------------------------------------
	elab_exp(_,e) => fail

end

(** relation: elab_range_type *)

relation elab_range_type : (Env.Env, Exp.Exp,
			    Exp.Exp option, Exp.Exp, bool) => Types.Type =

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n & int_add (n,1) => n'
	-------------------------------------------------
	elab_range_type (env,start,NONE,stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n')), Types.T_INTEGER)

  rule	ceval (env,start) => Values.INTEGER(startv) &
	ceval (env,step) => Values.INTEGER(stepv) &
	ceval (env,stop) => Values.INTEGER(stopv) &
	int_sub (stopv,startv) => n &
	int_div (n,stepv) => n' &
 	int_add (n',1) => n''
	-------------------------------------------------
	elab_range_type (env,start,SOME(step),stop,true)
	  => Types.T_ARRAY(Types.DIM(SOME(n'')), Types.T_INTEGER)

  axiom	elab_range_type (_,_,_,_,false)
	  => Types.T_ARRAY(Types.DIM(NONE), Types.T_INTEGER)

end

relation elab_tuple : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties list) =

  rule	Debug.print "\nEntered elab_tuple." &
	elab_exp (env,e) => (e',p) &
	Debug.print "\nElaborated expression." &
	elab_tuple(env,exps) => (exps',props) &
	Debug.print "\nThe last element was just elaborated."
	-----------------------------
	elab_tuple(env,e::exps) => (e'::exps', p::props) 

(*PR.  rule	elab_exp (env,e) => (e',p) 
	-----------------------------
	elab_tuple(env,e::[]) => (e', p) 
*)
  rule 	Debug.print "elaborating last element."
	----------------
	elab_tuple(env,[]) => ([], []) 

(*  axiom elab_tuple(env,[]) => ([], []) 
*)
end


(** relation: elab_array *)

relation elab_array : (Env.Env, Absyn.Exp list)
	  => (Exp.Exp list, Properties) =

  rule	elab_exp (env,e) => (e',prop)
	-----------------------------
	elab_array (env,[e]) => ([e'],prop)

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	t1 = t2 &
	bool_and (c1,c2) => c
	---------------------------------
	elab_array (env,e::es) => (e'::es',PROP(t1,c))

  rule	elab_exp (env,e) => (e',PROP(t1,c1)) &
	elab_array (env,es) => (es',PROP(t2,c2)) &
	not t1 = t2 &
	print "# Incompatible types in array expression\n" &
	print "  " & Dump.print_exp e & print " is of type " &
 	Types.print_type t1 & print "\n  while the elements [" &
        Dump.print_list (es, Dump.print_exp, ",") &
	print "] are of type " & Types.print_type t2 & print "\n"
	---------------------------------------------------------
	elab_array (env,e::es) => fail

  rule	print "- elab_array failed\n"
	-----------------------------
	elab_array (_,_) => fail

end

(** relation: elab_matrix *)

relation elab_matrix : (Env.Env, Absyn.Exp list list)
	=> (Exp.Exp list list, Types.Type, int, bool) =

  rule	list_length(el) => dim &
	elab_array(env,el) => (el', PROP(t, c))
	---------------------------------
	elab_matrix(env,[el]) => ([el'], t, dim, c)

  rule	list_length(el) => dim1 &
	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	t1 = t2 & dim1 = dim2 &
	bool_and(c1,c2) => c
	--------------------
	elab_matrix(env,el::els) => (el'::els',t1,dim1,c)

	(**  Error messages *)

  rule	print "- How the f*ck did you write an empty matrix?\n"
	-------------------------------------------------------
	elab_matrix(_,[]) => fail

  rule	elab_array(env,el) => (el',PROP(t1,c1)) &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not t1 = t2 &
	print "# Incompatible types in matrix rows\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of " & Types.print_type t1 & print "\n" &
	print "    the rest of the matrix is of " &
	Types.print_type t2 & print "\n"
	--------------------------------
	elab_matrix(env,el::els) => fail

  rule	list_length(el) => dim1 &
	elab_matrix(env,els) => (els',t2,dim2,c2) &
	not dim1 = dim2 &
	print "# Incompatible row length in matrix expression\n" &
	print "    [" & Dump.print_list(el,Dump.print_exp,",") &
	print "] is a row of size " &
	int_string dim1 => s & print s & print "\n" &
	print "    the rest of the matrix rows are of size " &
	int_string dim2 => s & print s & print "\n"
	--------------------------------------------
	elab_matrix(env,el::els) => fail

end

relation elab_builtin_size : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

	(** LS: size(A) that returns an array of sizes for all dimensions is not *)
	(** implemented, just size(A,x) that returns size of x:th dimension *)

  rule	elab_exp (env,ind) => (indexp, PROP(indty, true)) &
	ceval (env, indexp) => Values.INTEGER(value) &
	elab_exp (env,arraycr) => (Exp.CREF(cr), crprop) &
	Lookup.lookup_var (env, cr) => (attr, ty, bnd) &
	elab_builtin_size_2 (env, ty, value) => (exp, prop)
	------------------------------------------------------
	elab_builtin_size (env, [arraycr,ind]) => (exp, prop)

  rule	print "#-- elab_builtin_size: Couldn't elaborate size()\n" &
	print "#-- Wrong args or non-constant dimension\n"
	----------------------------------------------------------
	elab_builtin_size (_,_) => fail

end

relation elab_builtin_size_2 : (Env.Env, Types.Type, int) => (Exp.Exp, Properties) =

  axiom	elab_builtin_size_2 (env, Types.T_ARRAY(Types.DIM(SOME(dim)),ty), 1) 
	  => (Exp.ICONST(dim), PROP(Types.T_INTEGER, true))

  rule	int_sub (ind, 1) => ind' &
	elab_builtin_size_2 (env, ty, ind') => (exp, prop)
	--------------------------------------------------
	elab_builtin_size_2 (env, Types.T_ARRAY(_, ty), ind) => (exp, prop)

  rule	print "#-- elab_builtin_size_2: Couldn't elaborate size()\n" &
	print "#-- Maybe not an array type or not a component reference\n" 
	----------------------------------------------------------
	elab_builtin_size_2 (env, crexp, ind) => fail
end


relation elab_builtin_fill : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties)	=

  rule	elab_exp (env,s) => (s', PROP(sty, sconst)) &
	elab_exp_list (env,dims) => (dims', dimprops) &
	ceval_list (env, dims') => dimvals &
	elab_builtin_fill_2 (env, s', sty, dimvals) => (exp, prop) 
	--------------------------------------------------
	elab_builtin_fill (env, s::dims) => (exp, prop)

  rule	print"#-- elab_builtin_fill: Couldn't elaborate fill()\n"
	---------------------------------------------------------
	elab_builtin_fill (_,_) => fail

end


relation elab_builtin_fill_2 : (Env.Env, Exp.Exp, Types.Type, Values.Value list) 
	  => (Exp.Exp, Properties) =

  rule	build_exp_list (s, v) => arraylist
	----------------------------------
	elab_builtin_fill_2 (env, s, sty, [Values.INTEGER(v)])
	  => (Exp.ARRAY(arraylist), PROP(Types.T_ARRAY(Types.DIM(SOME(v)), sty), true))
			     
  rule	elab_builtin_fill_2 (env, s, sty, rest) 
	  => (exp, PROP(ty,con)) &
        build_exp_list (exp, v) => arraylist
	----------------------------------------------------------
	elab_builtin_fill_2 (env, s, sty, Values.INTEGER(v)::rest) 
	  => (Exp.ARRAY(arraylist), PROP(Types.T_ARRAY(Types.DIM(SOME(v)), ty), true))
	
  rule	print "#-- elab_builtin_fill_2: Failed to elaborate fill()\n"
	-------------------------------------------------------------
	elab_builtin_fill_2 (_,_,_,_) => fail

end

relation build_exp_list : (Exp.Exp, int) => Exp.Exp list =

  axiom	build_exp_list (e,1) => [e]

  rule	int_sub (c,1) => c' &
	build_exp_list (e, c') => rest
	------------------------------
	build_exp_list (e, c) => e::rest

end

relation elab_builtin_zeros : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(0)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_zeros (env, args) => (e,p)
end

relation elab_builtin_ones : (Env.Env, Absyn.Exp list) => (Exp.Exp, Properties) =

  rule	elab_builtin_fill (env, Absyn.INTEGER(1)::args) => (e,p)
	--------------------------------------------------------
	elab_builtin_ones (env, args) => (e,p)
end

relation elab_builtin_handler : Ident => ((Env.Env, Absyn.Exp list) 
					  => (Exp.Exp, Properties)) =

  axiom	elab_builtin_handler "size" => elab_builtin_size
  axiom	elab_builtin_handler "zeros" => elab_builtin_zeros
  axiom	elab_builtin_handler "ones" => elab_builtin_ones
  axiom	elab_builtin_handler "fill" => elab_builtin_fill

end


(** relation: elab_call_builtin
 **
 **)

relation elab_call_builtin : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

  rule	elab_builtin_handler name => handler &
	handler (env, args) => (exp,prop)
	-------------------
	elab_call_builtin (env, Absyn.CREF_IDENT(name,[]), args) => (exp, prop)


end


(** relation: elab_call
 **
 ** This relation elaborates on a function call.  It converts the name
 ** to a `Path', and used the `elab_call_args' to do the rest of the
 ** work.
 **)

relation elab_call : (Env.Env, Absyn.ComponentRef, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

	  (** LS: Check if a builtin function call, e.g. size()
	      and calculate if so **)

  rule	elab_call_builtin (env, fn, args) => (e,prop)
	---------------------------------------------
	elab_call (env,fn,args) => (e,prop)

  rule	Absyn.cref_to_path fn => fn' &
	elab_call_args (env,fn',args) => (e,prop) &
	Debug.fprintln ("sei", "elab_call succeeded")
	------------------------------------
	elab_call (env,fn,args) => (e,prop)

  rule	print "- elab_call failed\n"
	----------------------------
	elab_call (env,fn,args) => fail

end

(** relation: elab_call_args
 **
 ** Given the name of a function and a list of expressions to be used
 ** as actual arguments in a function call to that function, this
 ** relation finds the function definition and matches the actual
 ** arguments to the formal parameters.
 **)

relation elab_call_args : (Env.Env, Absyn.Path, Absyn.Exp list)
	=> (Exp.Exp, Properties) =

	(* This rule finds user-defined functions. *)

  rule	
	(* PR. We found a function definition of fn. *)
	Debug.fprintln ("sei", "Looking up function in elab_call_args.") &
	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(fargs,outtype)) &
	(* ClassInf.valid(st, Absyn.R_FUNCTION) & *)
	Debug.fprint("setr", "Did lookup in elab_call_args.\n") &
	(*PR. Find function parameters in the function definition.*)
	(*LS: Function type implemented, so just take second part of FunctionArg *)
(*	get_types(fargs) => in & *)

	Debug.fprintln ("sei", "Got types.") &
	(*PR. elaborate input parameters from the function call(args).
	* In are the in-parameters specified in the function declaration.
	* c indicate if all input parameters are constant, this means that
	* all output parameters are constant as well, since they only 
	* depends on the input parameters.
	* c is true if all input arguments are constant.
	*)
	elab_input_args(env, args, fargs) => (args', c) &
	Debug.fprintln ("sei", "Did elab_input_args") &
	(*PR. !! Fix this. The function body is examined to determine the 
	* constness of each output argument.
	 At the moment this just gives a false list.
	*)
	elab_consts(outtype) => const &
 	(* Returns PROP_TUPLE if there is more than one element in the list. 
	   If there is only one element then PROP is returned.
	 *)
	Debug.fprintln ("sei", "Elaborated consts") &
	get_properties(outtype, const) => prop &
	
	Debug.fprintln ("setr", "elab_call_args_succeeded")
	--------------------------------------------
(*
	elab_call_args(env,fn,args) 
	  => (Exp.CALL(fn,args'), PROP_TUPLE(Types.T_TUPLE(types), const)) 
 *)
	elab_call_args(env,fn,args) => (Exp.CALL(fn,args'), prop )

	(* 
	 Functions that returns just one argument should not return a
	 tuple. It just returns a simple expression. 
	 *)



	(* This rule finds the built-in functions *)

  rule	

	(* PR. A function can have several types. Taking an array with
	 different dimensions as parameter for example. Because of this we
	 cannot just lookup the function name and trust that it
	 returns the correct function. It returns just one
	 functiontype of several possibilites. The solution is to send
	 in the funktion type of the user function and check both the
	 funktion name and the function's type. 
	 *)

(*	Lookup.lookup_type(env,fn) => (t as Types.T_FUNCTION(params,restype)) & *)
	Lookup.lookup_functions_in_env(env,fn) => typelist &
(*	print "We got the type list\n" & *)
	elab_types (env, args, typelist) => (args', c, restype) &
(*	& print "We just elaborated the types\n"  *)

	(*P.R: When is T_FUNCTION ouputted from lookup_type? *)
(*	print "Debug: We did a lookup T_FUNCTION " &
*)
(*PR.	elab_input_args(env, args, params) => (args',c)  *)
	Debug.fprintln ("sei", "elab_call_args succeeded")
	-----------------------------------------------
	elab_call_args (env,fn,args) => (Exp.CALL(fn,args'), PROP(restype, c))


(*  rule	not Lookup.lookup_type(env,fn) => _ &
	
	print "# Couldn't find function " & Dump.print_path fn & print "\n"
	-------------------------------------------------------------------
	elab_call_args(env,fn,_) => fail
*)
  rule	not Lookup.lookup_type(env,fn) => _ &
	
	print "# Couldn't find function " & Dump.print_path fn & print "\n"
	-------------------------------------------------------------------
	elab_call_args(env,fn,_) => fail

  rule	(*elab_exp(env, e) => (e',PROP(t,_)) &*)
	print "- elab_call_args failed\n"
	---------------------------------
	elab_call_args(_,_,_) => fail

end

(*PR.*)
relation  elab_types:  (Env.Env, Absyn.Exp list,  Types.Type list) 
	  => (Exp.Exp list, bool, Types.Type) =

	(* 
	 We found nothing. This is an error. return to the calling
	 function that writes an error message that makes sense (the
	 name of the funtion etc). 
	 *)
	(* 
	 If trest gets empty then we will return with a missmatch.
	 and write an error message in the calling function. 
	 *)

	(* We found a match.*)
  rule	Debug.fprintln ("sei", "We try the elab_input") &
	elab_input_args(env, args, params ) => (args',c) &
        Debug.fprintln ("sei", "We found a match." )
	------------------
        elab_types(env, args, Types.T_FUNCTION(params,restype)::trest)
	  => (args', c, restype)

	(* We did not found a match, try next. *)
  rule 	Debug.fprintln ("sei", "The elab_input_args failed, try next.") &
	elab_types(env, args, trest) => (args',c, restype) 
        ------------------
        elab_types(env, args, Types.T_FUNCTION(params,restype)::trest) 
	  => (args', c, restype)
       
end


(* PR get_prop 
*)
(* LS: Changed type list to type, since T_TUPLE already fixed before *)
relation get_properties : (Types.Type, Const)  => Properties =

	(* At least two elements in the type list, this is a tuple. *)
	(* LS: Tuples are fixed before here *)
  axiom	get_properties (tt as Types.T_TUPLE(_), const) => PROP_TUPLE(tt, const)

	(* One type, this is a tuple with one element. The resulting properties 
	 * is then identical to that of a single expression. *)
  axiom	get_properties(t, TUPLE_CONST(CONST(b)::[]))  => PROP(t, b)

end


(** PR. assisting routines
 ** This just splits the properties list into a type list and a const list. 
 **)
(* LS: Changed to take a Type, which is the functions return type *)
relation elab_consts : Types.Type  => Const =

  rule	check_consts tys => consts
	-------------------------------
	elab_consts Types.T_TUPLE(tys) => TUPLE_CONST(consts)

  (* LS: If not a tuple then one normal type, T_INTEGER etc, but we make a list of types
     with one element and call the same check_consts, so that we always have TUPLE_CONST as result
   *)
  rule	check_consts [ty] => consts
	-----------------------
	elab_consts ty => TUPLE_CONST(consts)

end

(* LS: Changed to take a Type list, which is the functions return type. Only
   for functions returning a tuple *)
relation check_consts : Types.Type list => Const list =	

  axiom	check_consts [] => []

  rule  check_const(a) => c &
	check_consts(rest) => rest'
	-------------------------------
	check_consts a::rest => c::rest'

end



(*PR. !! At the moment this make all outputs non cons.
* All ouputs sholud be checked in the function body for constness. 
*)
(* LS: but it says true? *)
(* LS: Adapted to check one type instead of funcarg, since it just checks return type *)
relation check_const : Types.Type => Const  =	
	
  rule	print("\n Error. No support for tuples built by tuples. Yet.") 
	-------------------------------
	check_const (Types.T_TUPLE(_)) => fail

  axiom	check_const (_) => CONST(true)
	
end

(* Splits the properties list into the separated types list and const list. *)
relation split_props : (Properties list) => (Types.Type list, Const list) =
  rule 	(*list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props)=> (t::types,CONST(c)::consts)

  rule 	(*list_append(ts,t::[]) => ts' & *)
	(*list_append(cs, t_c::[]) => cs' & 
*)	split_props(props) => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props)=> (t::types,t_c::consts)
  
  axiom	split_props([]) => ([], [])
end










(* obsolete LS: added space to inner comments, for emacs fontify to work
relation split_props: (Properties list, Types.Type list, Const list) => (Types.Type list, Const list) =
  rule 	list_append(ts,t::[]) => t1 &
	list_append(cs,CONST(c)::[]) => t2 &
	split_props(props, t1, t2) => (types, consts)
	-------------------------------------
	split_props (PROP(t,c)::props, ts, cs)=> (types,consts)

  rule 	( *  list_append(ts,t::[]) => ts' &   * )
	list_append(cs, t_c::[]) => cs' & 
	split_props(props, [], cs') => (types, consts)
	-------------------------------------
	split_props (PROP_TUPLE(t,t_c)::props, ts, cs)=> (types,consts)
  
  axiom	split_props([],ts,cs) => (ts, cs)
end
*)









(* LS: Changed to match FuncArg *)
relation get_types :(Types.FuncArg list) => Types.Type list =

  rule	(* print("\nDebug: Got a type for output of function. ") & *)
	get_types(rest) => types 
	-----------------
	get_types ((n,t)::rest) => t::types
	
  axiom	get_types ([]) => []
	
end


(** relation: functio_params
 **
 ** A function definition is just a clas definition where all publi
 ** components are declared as either inpu or outpu.  This
 ** relation_ find all those components and_ separates them into two
 ** separate lists.
 **)

(* LS: This can probably replaced by Types.get_input_vars and
   Types.get_output_vars *)

relation function_params : Types.Var list => (Types.FuncArg list,
					      Types.FuncArg list) =

  axiom	function_params [] => ([],[])

	(* Ignore protected components *)
  rule	Debug.print("protected") &
	function_params vs => (in, out)
	-------------------------------
	function_params((Types.VAR(_,_,true,_,_))::vs) => (in, out)

  rule	Debug.print("not protected. intput") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.INPUT),
				   false,t,Types.UNBOUND)::vs)
	  => ((n,t)::in, out)

  rule	Debug.print("not protected. output") &
	function_params vs => (in, out)
	------------------------------
	function_params (Types.VAR(n,Types.ATTR(_,_,_,Absyn.OUTPUT),
					 false,t,Types.UNBOUND)::vs)
	  => (in, (n,t)::out)

  rule	print "# Components in functions must be INPUT or OUTPUT\n" &
	print "    component: " & print n & print "\n"
	----------------------------------------------
	function_params((v as Types.VAR(n,Types.ATTR(_,_,_,Absyn.BIDIR),_,_,_))
			::vs) => fail

  rule	print "- function_params failed\n"
	----------------------------------
	function_params _ => fail

end

(* * relation_: elab_input_args
 **
 ** This relation_ elaborates on a number of expressions and_ matches
 ** them to a number of `Types.Var' objects, applying type_ conversions
 ** on the expressions when necessary to match the type_ of the
 ** `Types.Var'.
 * *)

(* PR. env, input args from the function call, in arguments in the
 function_ definition. *)
(* LS: inserted FuncArg *)
relation elab_input_args : (Env.Env, Absyn.Exp list, Types.FuncArg list)
	  => (Exp.Exp list, bool) =

  axiom	elab_input_args(_, [], []) => ([], true)
	(*PR. What is the c for. If all input arguments from the function 
	* call are constants then the result is a constant. 
 	* Of course the output variable must be a constant since all 
	* input variables are constant and the output do not depend on 
	* any other variable.
	*
	* This is also true for multiple output arguments. But if some
	 input arguments are constant then some output argument may be
	 constant too. In this case the function body have to be
	 analysed in more detail.
	
	 Which is not done at all now??
	*)

  rule	Debug.fprintln ("sei", "Entering elab_input_args-2") &
	elab_exp(env, e) => (e',PROP(t, c1)) &
	match_type(e', t, vt) => (e'',_) &
	elab_input_args(env, es, vs) => (args', c2) &
	bool_and(c1, c2) => c &
	Debug.fprintln ("sei", "elab_input_args-2 succeeded")
	-------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => (e''::args', c)
(* PR.
  rule	elab_exp(env, e) => (e',PROP(t,_)) &
	print "# Argument (" & Dump.print_exp e &
 	print ") doesn't match parameter type\n" &
	print "    parameter type: " & Types.print_type vt & print "\n" &
	print "    argument type: " & Types.print_type t & print "\n"
	-------------------------------------------------------------
	elab_input_args(env, e::es, (_,vt)::vs) => fail
*)
end

(* LS *)

relation elab_cref_list : (Env.Env, Absyn.ComponentRef list)
	=> (Exp.Exp list, Properties list, SCode.Accessibility list) =

  axiom	elab_cref_list (_, []) => ([], [], [])

  rule	elab_cref (env, cref) => (exp, prop, acc) &
	elab_cref_list (env, creflist) => (explist, proplist, acclist)
	----------------------------------------------------------
	elab_cref_list (env, cref::creflist) 
	  => (exp::explist, prop::proplist, acc::acclist)

end


(** relation: elab_cref
 **
 ** Elaborate on a component reference.  Check the type of the
 ** component referred to, and check if the environment contains
 ** either a constant binding for that variable, or if it contains an
 ** equation binding with a constant expression.
 **)

relation elab_cref : (Env.Env, Absyn.ComponentRef)
	  => (Exp.Exp, Properties, SCode.Accessibility) =

  rule	elab_cref_subs (env,c) => (c', const) &
	Lookup.lookup_var (env,c') => (Types.ATTR(_,acc,variability,_),
				       t,
				       binding) &
	elab_cref2 (env, c', acc, variability, t, binding)
	  => (exp,const,acc')
	(* FIXME subscript_cref_type (exp,t) => t' &  *)
	---------------------------------
	elab_cref(env, c) => (exp, PROP(t, const), acc')

  rule	elab_cref_subs (env,c) => (c', const) &
	print "# Unknown component: " & Dump.print_component_ref c & print "\n" &
	Env.print_env env
	-----------------------------------------------------
	elab_cref(env, c) => fail

  rule	print "- elab_cref failed\n"
	------------------------------
	elab_cref (_,_) => fail

end

(** relation: elab_cref2
 **
 ** This relation check whether the component reference found in
 ** `elab_cref' has a binding, and if that binding is constant.  If
 ** the binding is a `VALBOUND' binding, the value is substituted.
 **)

relation elab_cref2 : (Env.Env,
		       Exp.ComponentRef,
		       SCode.Accessibility, Absyn.Variability,
		       Types.Type, Types.Binding)
	  => (Exp.Exp,bool,SCode.Accessibility) =

  axiom	elab_cref2 (_,cr, acc, Absyn.VAR, _,_) => (Exp.CREF(cr),false, acc)
  axiom	elab_cref2 (_,cr, acc, Absyn.DISCRETE, _,_) => (Exp.CREF(cr),false,acc)

  rule	value_exp v => e
	----------------
	elab_cref2 (_,cr,_,_,t, Types.VALBOUND(v)) => (e,true,SCode.RO)

  axiom	elab_cref2 (env,cr,acc,_,t, Types.EQBOUND(exp,true))
	  => (Exp.CREF(cr),true,acc)

  rule	print "# Constant or parameter with a non-constant initializer\n" &
	print "# component: " & Exp.print_component_ref cr & print " = " &
	Exp.print_exp exp & print "\n"
	------------------------------
	elab_cref2 (_,cr,_, _,_,Types.EQBOUND(exp,false)) => fail

  rule	print "# Constant or parameter without a value\n" &
	print "# component: " & Exp.print_component_ref cr & print "\n"
	----------------------------------------------
	elab_cref2 (_,cr,_,_,_,Types.UNBOUND) => fail

  rule	print "- elab_cref2 failed (component: " &
	Exp.print_component_ref cr & print ")\n"
	----------------------------------------
	elab_cref2 (_,cr,_,_,_,_) => fail

end	

(** relation: elab_cref_subs
 **
 ** This relation elaborates on all subscripts in a component reference.
 **)

relation elab_cref_subs : (Env.Env, Absyn.ComponentRef)
	  => (Exp.ComponentRef, bool) =

  rule	elab_subscripts (env, ss) => (ss', const)
	----------------------------------------------
	elab_cref_subs(env,Absyn.CREF_IDENT(id,ss))
	  => (Exp.CREF_IDENT(id,ss'), const)

  rule	elab_subscripts (env, ss) => (ss', const1) &
	elab_cref_subs(env,subs) => (cr, const2) &
	bool_and(const1, const2) => const
	-------------------------------------
	elab_cref_subs(env,Absyn.CREF_QUAL(id,ss,subs))
	  => (Exp.CREF_QUAL(id,ss',cr), const)

end

(** relation: elab_subscripts
 **
 ** This relation converts a list of `Absyn.Subscript' to a list of
 ** `Exp.Subscript', and checks if all subscripts are constant.
 **)

relation elab_subscripts : (Env.Env, Absyn.Subscript list)
	  => (Exp.Subscript list, bool) =

  axiom	elab_subscripts (_,[]) => ([], true)

  rule	elab_subscript (env,sub) => (sub',const1) &
	elab_subscripts (env,subs) => (subs',const2) &
	bool_and (const1, const2) => true &
	ceval_subscripts(env, sub'::subs') => ss
	-----------------------------------
	elab_subscripts (env,sub::subs) => (ss,true)

end

(** relation: elab_subscript
 **
 ** This relation converts an `Absyn.Subscript' to an
 ** `Exp.Subscript'.
 **)

relation elab_subscript : (Env.Env, Absyn.Subscript)
	  => (Exp.Subscript, bool) =

  axiom	elab_subscript (_,Absyn.NOSUB) => (Exp.WHOLEDIM, true)

  rule	elab_exp (env,sub) => (sub', PROP(ty, const)) &
	elab_subscript_type (ty, sub, sub') => sub''
	--------------------------------------------
	elab_subscript (env,Absyn.SUBSCRIPT(sub)) => (sub'', const)

end

(** relation: elab_subscript_type
 **
 ** This relation is used to find the correct constructor for
 ** `Exp.Subscript' to use for an indexing expression.  If an integer
 ** is given as index, `Exp.INDEX()' is used, and if an integer array
 ** is given, `Exp.SLICE()' is used.
 **)

relation elab_subscript_type : (Types.Type, Absyn.Exp, Exp.Exp)
	  => Exp.Subscript =

  axiom	elab_subscript_type (Types.T_INTEGER,_,sub) => Exp.INDEX(sub)

  axiom	elab_subscript_type (Types.T_ARRAY(_,Types.T_INTEGER),_,sub)
	  => Exp.SLICE(sub)

  rule	print "# Subscript is not an integer or integer array\n" &
	print "    expression: " & Dump.print_exp e &
 	print " :: " & Types.print_type t & print "\n"
	------------------------------------------------------
	elab_subscript_type (t,e,_) => fail

end

(** relation: subscript_cref_type
 **
 ** If a component of an array type is subscripted, the type of the
 ** component reference is of lower dimensionality than the
 ** component.  This relation shows the relation between the component
 ** type and the component reference expression type.
 **
 ** This relation might actually not be needed.
 **)

relation subscript_cref_type : (Exp.Exp, Types.Type) => Types.Type =

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type (Exp.CREF(c), t) => t'

  axiom	subscript_cref_type (e, t) => t

end
(**)
relation subscript_cref_type2 : (Exp.ComponentRef, Types.Type) => Types.Type =

  axiom	subscript_cref_type2 (Exp.CREF_IDENT(_,[]), t) => t

  rule	subscript_type (t,subs) => t'
	----------------------------------------
	subscript_cref_type2 (Exp.CREF_IDENT(_,subs), t) => t'

  rule	subscript_cref_type2 (c, t) => t'
	---------------------------------
	subscript_cref_type2 (Exp.CREF_QUAL(_,_,c), t) => t'

end

(** relation: subscript_type
 **
 ** Given an array dimensionality and a list of subscripts, this
 ** relation reduces the dimensionality.
 **
 ** This does not handle slices or check that subscripts are not out
 ** of bounds.
 **)

relation subscript_type : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom	subscript_type (t,[]) => t

  rule	subscript_type (t, subs) => t'
	----------------------------------
	subscript_type (Types.T_ARRAY(Types.DIM(_),t),
			Exp.INDEX(_)::subs) => t'

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.SLICE(_)::subs)
	  => Types.T_ARRAY(dim,t')

  rule	subscript_type (t, subs) => t'
	------------------------------
	subscript_type (Types.T_ARRAY(dim,t),
			Exp.WHOLEDIM::subs)
	  => Types.T_ARRAY(dim,t')

  rule	print "- subscript_type failed (" & Types.print_type t &
	print " , [...])\n"
	-------------------
	subscript_type (t,_) => fail

end

(** relation: elab_ifexp
 ** 
 ** This relation elaborates on the parts of an if expression.
 **)

relation elab_ifexp : (Exp.Exp, Properties,
		       Exp.Exp, Properties,
		       Exp.Exp, Properties)
	  => (Exp.Exp, Properties) =

  rule	Types.equivtypes(t2,t3) => true &
	const_ifexp(e1,c1,c2,c3) => c
	-----------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),
		   e3,PROP(t3,c3)) => (Exp.IFEXP(e1,e2,e3), PROP(t2, c))

  rule	not t1 = Types.T_BOOL &
	print "# conditional in if expression has to be boolean\n" &
	print "    got type: " & Types.print_type t1 & print "\n" &
	print "    expression: " & Exp.print_exp e1 & print "\n"
	--------------------------------------------------------
	elab_ifexp(e1,PROP(t1,c1),e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	Types.equivtypes(t2,t3) => false &
	print "# Type mismatch in if-expression\n" &
	print "    true branch : " & Exp.print_exp e2 &
 	print " :: " & Types.print_type t2 & print "\n" &
	print "    false branch: " & Exp.print_exp e3 &
 	print " :: " & Types.print_type t3 & print "\n"
	-----------------------------------------------
	elab_ifexp(e1,PROP(Types.T_BOOL,c1),
		   e2,PROP(t2,c2),e3,PROP(t3,c3)) => fail

  rule	print "- elab_ifexp failed\n"
	-----------------------------
	elab_ifexp(_,_,_,_,_,_) => fail

end

(** relation: const_ifexp
 **
 ** Tests wether an `if' expression is constant.  This is done by
 ** first testing if the conditional is constant, and if so evaluating
 ** it to see which branch should be tested for constant-ness.
 **
 ** This will miss some occations where the expression actually is
 ** constant, as in the expression `if x then 1.0 else 1.0'.
 **)

relation const_ifexp : (Exp.Exp, bool, bool, bool) => bool =

  axiom	const_ifexp(_,true,true,true) => true
  axiom	const_ifexp(_,_,_,_) => false

end

(** relation: ceval
 **
 ** This relations is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **)

relation ceval : (Env.Env, Exp.Exp) => Values.Value =

  axiom	ceval (_,Exp.ICONST(x)) => Values.INTEGER(x)
  axiom	ceval (_,Exp.RCONST(x)) => Values.REAL(x)
  axiom ceval (_,Exp.SCONST(x)) => Values.STRING(x)
  axiom ceval (_,Exp.BCONST(x)) => Values.BOOL(x)

  rule	ceval_list (env,es) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(es)) => Values.ARRAY(es')

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c)) => v

  rule	print "# Can't call functions at compile time\n" &
	print "    expression: " & Exp.print_exp e & print "\n"
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(_,_)) => fail

	(**  Numerical *)

  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh))
	  => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_add(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh)) => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, lh) => Values.REAL(lhv) &
	ceval (env, rh) => Values.REAL(rhv) &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh)) => Values.REAL(sum)

  rule	ceval (env, lh) => Values.INTEGER(lhv) &
	ceval (env, rh) => Values.INTEGER(rhv) &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh))
	  => Values.INTEGER(sum)
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp))
	  => Values.INTEGER(x')
	(**)
  rule	ceval (env, exp) => Values.REAL(x) &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp))
	  => Values.REAL(x')

  rule	ceval (env, exp) => Values.INTEGER(x) &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp))
	  => Values.INTEGER(x')

	(**  Logical *)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh))
	  => Values.BOOL(x)

  rule	ceval (env, lh) => Values.BOOL(lhv) &
	ceval (env, rh) => Values.BOOL(rhv) &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh))
	  => Values.BOOL(x)

  rule	ceval (env,e) => Values.BOOL(b) &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e)) => Values.BOOL(b')

	(**  Relations *)

  rule	ceval (env, lhs) => lhs' &
	ceval (env, rhs) => rhs' &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs)) => v

	(**)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, NONE, stop)) => Values.ARRAY(arr)

  rule	ceval (env, start) => Values.INTEGER(start') &
	ceval (env, step) => Values.INTEGER(step') &
	ceval (env, stop) => Values.INTEGER(stop') &
	ceval_range(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(start, SOME(step), stop)) => Values.ARRAY(arr)

  rule	ceval (env,e) => Values.INTEGER(i) &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e)) => Values.REAL(r)

  rule	print "- ceval " & Exp.print_exp e & print " failed\n"
	-----------------------------------------------------
	ceval (_,e) => fail
	
end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	print "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** This relation evaluates a range expression.  It only handles integers.
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range (start,_,stop) => []

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range (next, step, stop) => l
	-----------------------------------
	ceval_range (start, step, stop) => Values.INTEGER(start)::l

end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list) => Values.Value list =
	  
  rule	ceval (env, exp) => v
	----------------------------
	ceval_list (env, [exp]) => [v]

  rule	ceval (env,exp) => v &
	ceval_list (env, exps) => vs
	------------------------------
	ceval_list (env, exp::exps) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,binding) => v
	-------------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref c & print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Types.Binding) => Values.Value =

  axiom	ceval_cref_binding (env,Types.VALBOUND(v)) => v

  rule	print "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,Types.UNBOUND) => fail
	
  rule	ceval (env,exp) => v
	------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,true)) => v

  rule	print "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & print ")\n"
	--------------------------------
	ceval_cref_binding (env,Types.EQBOUND(exp,false)) => fail
	
end

(**)

relation value_exp : Values.Value => Exp.Exp =

  axiom	value_exp (Values.INTEGER(x)) => Exp.ICONST(x)
  axiom	value_exp (Values.REAL(x))    => Exp.RCONST(x)
  axiom value_exp (Values.STRING(x))  => Exp.SCONST(x)
  axiom value_exp (Values.BOOL(x))    => Exp.BCONST(x)
  axiom	value_exp (Values.ARRAY([]))  => Exp.ARRAY([])

  rule	value_exp x => x' &
  	value_exp Values.ARRAY(xs) => Exp.ARRAY(xs')
	--------------------------------------------
	value_exp (Values.ARRAY(x::xs)) => Exp.ARRAY(x'::xs')

  rule	print "- value_exp failed\n"
	----------------------------
	value_exp _ => fail

end

(**)

relation value_type : Values.Value => Types.Type =

  axiom	value_type Values.INTEGER(x) => Types.T_INTEGER
  axiom	value_type Values.REAL(x)    => Types.T_REAL
  axiom value_type Values.STRING(x)  => Types.T_STRING
  axiom value_type Values.BOOL(x)    => Types.T_BOOL

  rule	print "- value_type failed\n"
	----------------------------
	value_type _ => fail

end

(** relation: canon_cref
 **
 ** This relation relates a `Exp.ComponentRef' to its canonical form,
 ** which is when all subscripts are evaluated to constant values.  If
 ** Such an evaluation is not possible, there is no canonical form and
 ** this relation fails.
 **)

relation canon_cref : (Env.Env, Exp.ComponentRef) => Exp.ComponentRef =

  rule	ceval_subscripts (env,ss) => ss'
	--------------------------------
	canon_cref (env, Exp.CREF_IDENT(n,ss)) => Exp.CREF_IDENT(n,ss')

  rule	ceval_subscripts (env,ss) => ss' &
	canon_cref (env,c) => c'
	------------------------
	canon_cref (env, Exp.CREF_QUAL(n,ss,c)) => Exp.CREF_QUAL(n,ss',c')

end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[]) => []

  rule	ceval_subscript (env,sub) => sub' &
	ceval_subscripts (env,subs) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.WHOLEDIM) => Exp.WHOLEDIM

  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1)) => Exp.INDEX(e1')
	
  rule	ceval (env, e1) => v1 &
	value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1)) => Exp.SLICE(e1')
	
end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (Exp.ComponentRef, Exp.ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (Exp.CREF_IDENT(n1,s1), Exp.CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (Exp.CREF_QUAL(n1,s1,c1), Exp.CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Exp.Subscript list, Exp.Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Exp.Subscript, Exp.Subscript) => () =

  axiom	eq_subscript(Exp.WHOLEDIM,Exp.WHOLEDIM)
 	
  rule	s1 = s2
	-------------------------------
	eq_subscript(Exp.INDEX(s1),Exp.INDEX(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(** - Argument type casting and operator de-overloading
 **
 ** If a function is called with arguments that don't match the
 ** expected parameter types, implicit type conversions are performed
 ** in some cases.  Usually it is an integer argument that is promoted
 ** to a real.
 **
 ** Many operators in Modelica are overloaded, meaning that they can
 ** operate on several different types of arguments.  To describe what
 ** it means to add, say, an integer and a real number, the
 ** expressions have to be de-overloaded, with one operator for each
 ** distinct operation.
 **)

(** relation: elab_arglist
 **
 ** Given a list of parameter types and an argument list, this
 ** relation tries to match the two, promoting the type of arguments
 ** when necessary.
 **)

relation elab_arglist : (Types.Type list, (Exp.Exp * Types.Type) list)
	=> (Exp.Exp list,Types.Type list) =

  axiom	elab_arglist ([],[]) => ([],[])

  rule	Debug.fprint("earg","Match: ") & 
	Debug.fcall ("earg",Types.print_type, atype) & 
	Debug.fprint("earg"," == ") & 
	Debug.fcall ("earg",Types.print_type,pt) &
	Debug.fprint("earg","\n") &
	match_type(arg, atype, pt) => (arg',atype') &
	elab_arglist (pts, args) => (args',atypes')
	---------------------------------
	elab_arglist (pt::pts, (arg, atype)::args) => (arg'::args',atype'::atypes')

  rule	Debug.fprint("earg","- Static.elab_arglist failed\n")
	--------------------------------------
	elab_arglist (_,_) => fail
end

(** relation: match_prop
 **
 ** This is basically a wrapper aroune `match_type'.  It matches an
 ** expression with properties with another set of properties.  If
 ** necessary, the expression is modified to match.  The only relevant
 ** property is the type.
 **
 **)

relation match_prop : (Exp.Exp, Properties, Properties) => Exp.Exp =

  rule	Debug.print "Debug: match prop." &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP(gt,_), PROP(et,_)) => e'

  rule	Debug.print "\nDebug: match prop (PROP TUPLE). " &
	match_type(e, gt, et) => (e',_)
	---------------------------
	match_prop(e, PROP_TUPLE(gt,_), PROP_TUPLE(et,_)) => e'

end

(** relation: match_type
 **
 ** This relation matches an expression with an expected type, and
 ** converts the expression to the expected type if necessary.
 **)

relation match_type : (Exp.Exp, Types.Type, Types.Type) => (Exp.Exp, Types.Type) =

  rule	Types.subtype(e_type, expected_type) => true
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e, e_type)

  rule	Types.subtype(e_type, expected_type) => false &
	type_convert(e, e_type, expected_type) => (e',e_type')
	--------------------------------------------
	match_type(e, e_type, expected_type) => (e',e_type')

end

(** relation: type_convert
 **
 ** This relations converts the expression in the first argument to
 ** the type specified in the third argument.  The current type of the
 ** expression is given in the second argument.
 **
 ** If no type conversion is possible, this relation fails.
 **)

relation type_convert : (Exp.Exp, Types.Type, Types.Type) => (Exp.Exp, Types.Type) =

  axiom	type_convert(e, Types.T_INTEGER, Types.T_REAL) => (Exp.CAST(Exp.REAL,e),Types.T_REAL)

  rule	int_eq (dim1, dim2) => true &
	type_convert_array (elist, ty1, ty2) => elist'
	------------------------------------------
	type_convert(Exp.ARRAY(elist), 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)), ty1), 
		     Types.T_ARRAY(Types.DIM(SOME(dim2)), ty2))
	  => (Exp.ARRAY(elist'),Types.T_ARRAY(Types.DIM(SOME(dim1)),ty2))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     Types.T_ARRAY(Types.DIM(NONE), ty1), 
		     Types.T_ARRAY(Types.DIM(SOME(dim2)), ty2))
	  => (e', Types.T_ARRAY(Types.DIM(NONE), t'))

  rule	type_convert (e, ty1, ty2) => (e',t') 
	------------------------------------------
	type_convert(e, 
		     Types.T_ARRAY(Types.DIM(SOME(dim1)), ty1), 
		     Types.T_ARRAY(Types.DIM(NONE), ty2))
	  => (e', Types.T_ARRAY(Types.DIM(SOME(dim1)), t'))

  rule	type_convert_list (elist, tys1, tys2) => (elist',tys')
	------------------------------------------
	type_convert(Exp.TUPLE(elist), 
		     Types.T_TUPLE(tys1), 
		     Types.T_TUPLE(tys2))
	  => (Exp.TUPLE(elist'), Types.T_TUPLE(tys'))

  rule	Debug.fprint("tcvt","- type conversion failed: ") &
	Debug.fcall ("tcvt",Types.print_type,t1) & 
	Debug.fprint("tcvt",", ") & 
	Debug.fcall ("tcvt",Types.print_type,t2) &
	Debug.fprint("tcvt","\n")
	-------------------------------
	type_convert (_,t1,t2) => fail
end

relation type_convert_array : (Exp.Exp list, Types.Type, Types.Type) => Exp.Exp list =

  axiom type_convert_array ([], _, _) => []

  rule	type_convert_array (rest, ty1, ty2) => rest' &
	type_convert (first, ty1, ty2) => (first',_)
	-------------------------------------------
	type_convert_array (first::rest, ty1, ty2) => first'::rest'

  rule	print "- type conversion of array failed\n"
	-------------------------------
	type_convert_array (_,_,_) => fail

end

relation type_convert_list : (Exp.Exp list, Types.Type list, Types.Type list) 
	  => (Exp.Exp list, Types.Type list) =

  axiom type_convert_list ([], _, _) => ([],[])

  rule	type_convert_list (rest, ty1rest, ty2rest) => (rest',tyrest') &
	type_convert (first, ty1, ty2) => (first',ty')
	-------------------------------------------
	type_convert_list (first::rest, ty1::ty1rest, ty2::ty2rest) => (first'::rest',ty'::tyrest')

end




(** relation: deoverlooad
 **
 ** Given several lists of parameter types and one argument list, this
 ** relation tries to find one list of parameter types which is
 ** compatible with the argument list.  It uses `elab_arglist' to do
 ** the matching, which means that automatic type conversions will be
 ** made when necessary.  The new argument list, together with a new
 ** operator that corresponds to the parameter type list is returned.
 **
 ** The basic principle is that the first operator that matches is
 ** chosen.
 **
 ** The third argument to the relation is the expression containing
 ** the operation to be deoverloaded.  It is only used for error
 ** messages.
 **)

relation deoverload : ((Exp.Operator * Types.Type list * Types.Type) list,
		       (Exp.Exp * Types.Type) list,
		       Absyn.Exp)
	  => (Exp.Operator, Exp.Exp list, Types.Type) =

  rule	Debug.fprint_list("dovl",params,Types.print_type,"\n") & 
	Debug.fprint("dovl","\n===\n") &
	elab_arglist (params, args) => (args',types') &
	compute_return_type(op, types', rtype) => rtype'
	------------------------------------
	deoverload ((op, params, rtype)::_, args, _) => (op, args', rtype')

  rule	deoverload (xs, args, exp) => (op, args', rtype)
	------------------------------
	deoverload (_::xs, args, exp) => (op, args', rtype)

  rule	print "# Can't resolve type of expression: " &
	Dump.print_exp exp & print "\n"
	------------------------------
	deoverload([], args, exp) => fail

end

relation compute_return_type : (Exp.Operator, Types.Type list, Types.Type) => Types.Type =

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],rtype) => typ1

  rule	print "# +: Incompatible argument types " &
	Types.print_type typ1 & print ", " & Types.print_type typ2 &
	print "\n"
	----------------------
	compute_return_type (Exp.ADD_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],rtype) => typ1

  rule	print "# -: Incompatible argument types " &
	Types.print_type typ1 & print ", " & Types.print_type typ2 &
	print "\n"
	----------------------
	compute_return_type (Exp.SUB_ARR(_),[typ1,typ2],_) => fail

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	Types.subtype(typ1,typ2) => true
	-----------------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),
			     [typ1,typ2],
			     rtype) => rtype

  rule	print "# *: Incompatible argument types " &
	Types.print_type typ1 & print ", " & Types.print_type typ2 &
	print "\n"
	----------------------
	compute_return_type (Exp.MUL_SCALAR_PRODUCT(_),[typ1,typ2],_) => fail

  rule	n_dims typ1 => 1 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n1 &
	dim_size(typ2,1) => n2 &
	dim_size(typ2,2) => m &
	n1 = n2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(m)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 1 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	m1 = m2 &
	element_type typ2 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),etype)
	----------------------------------------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	n_dims typ1 => 2 &
	n_dims typ2 => 2 &
	dim_size(typ1,1) => n &
	dim_size(typ1,2) => m1 &
	dim_size(typ2,1) => m2 &
	dim_size(typ2,2) => p &
	m1 = m2 &
	element_type typ1 => etype &
	let rtype = Types.T_ARRAY(Types.DIM(SOME(n)),
				  Types.T_ARRAY(Types.DIM(SOME(p)),etype))
	-----------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => rtype

  rule	print "# *: Incompatible argument types " &
	Types.print_type typ1 & print ", " & Types.print_type typ2 &
	print "\n"
	-----------------
	compute_return_type (Exp.MUL_MATRIX_PRODUCT(_),[typ1,typ2],_) => fail

  axiom	compute_return_type (Exp.MUL_SCALAR_ARRAY(_),[typ1,typ2],rtype) => typ2
  axiom	compute_return_type (Exp.MUL_ARRAY_SCALAR(_),[typ1,typ2],rtype) => typ1



  axiom	compute_return_type (Exp.ADD(_),_,typ) => typ
  axiom	compute_return_type (Exp.SUB(_),_,typ) => typ
  axiom	compute_return_type (Exp.MUL(_),_,typ) => typ
  axiom	compute_return_type (Exp.DIV(_),_,typ) => typ
  axiom	compute_return_type (Exp.POW(_),_,typ) => typ
  axiom	compute_return_type (Exp.UMINUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.UPLUS(_),_,typ) => typ
  axiom	compute_return_type (Exp.AND,_,typ) => typ
  axiom	compute_return_type (Exp.OR,_,typ) => typ
  axiom	compute_return_type (Exp.NOT,_,typ) => typ
  axiom	compute_return_type (Exp.LESS(_),_,typ) => typ
  axiom	compute_return_type (Exp.LESSEQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATER(_),_,typ) => typ
  axiom	compute_return_type (Exp.GREATEREQ(_),_,typ) => typ
  axiom	compute_return_type (Exp.EQUAL(_),_,typ) => typ
  axiom	compute_return_type (Exp.NEQUAL(_),_,typ) => typ

end 

relation n_dims : Types.Type => int =
	
  axiom	n_dims Types.T_INTEGER => 0
  axiom	n_dims Types.T_REAL => 0
  axiom	n_dims Types.T_STRING => 0
  axiom	n_dims Types.T_BOOL => 0

  rule	n_dims t => ns &
	int_add(ns,1) => n
	-----------------------------
	n_dims Types.T_ARRAY(_,t) => n

end

relation dim_size : (Types.Type,int) => int =

  axiom	dim_size(Types.T_ARRAY(Types.DIM(SOME(n)),_),1) => n

  rule	int_gt(d,1) => true &
	int_sub(d,1) => d' &
	dim_size(t,d') => n
	----------------------
	dim_size(Types.T_ARRAY(_,t),d) => n



end

relation element_type : Types.Type => Types.Type =
	
  axiom	element_type(t as Types.T_INTEGER) => t
  axiom	element_type(t as Types.T_REAL) => t
  axiom	element_type(t as Types.T_STRING) => t
  axiom	element_type(t as Types.T_BOOL) => t

  rule	element_type(t) => t'
	---------------------------
	element_type(Types.T_ARRAY(_,t)) => t'

end


(** relation: operators
 **
 ** This relation relates the operators in the abstract syntax to the
 ** de-overaloaded operators in the SCode.
 **)

(** LS: POW added
 **)
relation operators : Absyn.Operator
	  => (Exp.Operator * Types.Type list * Types.Type) list =

	(**  Arithmetical operators *)

  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	
	operator_return(Exp.ADD_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.ADD_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.ADD(Exp.INT),
			[Types.T_INTEGER, Types.T_INTEGER],
			Types.T_INTEGER),
		       (Exp.ADD(Exp.REAL),
			[Types.T_REAL, Types.T_REAL],
			Types.T_REAL),
		       (Exp.ADD(Exp.STRING),
			[Types.T_STRING, Types.T_STRING],
			Types.T_STRING)
		       ] &
	
	list_append(intarrs,realarrs) => arrays &
	list_append(scalars,arrays) => types
	------------------------
	operators Absyn.ADD => types


  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	
	operator_return(Exp.SUB_ARR(Exp.INT), 
			intarrtypes, 
			intarrtypes, 
			intarrtypes) => intarrs &

	operator_return(Exp.SUB_ARR(Exp.REAL), 
			realarrtypes, 
			realarrtypes, 
			realarrtypes) => realarrs &
	
	let scalars = [(Exp.SUB(Exp.INT),
			[Types.T_INTEGER, Types.T_INTEGER],
			Types.T_INTEGER),
		       (Exp.SUB(Exp.REAL),
			[Types.T_REAL, Types.T_REAL],
			Types.T_REAL)		  
		       ] &
	
	list_append(intarrs,realarrs) => arrays &
	list_append(scalars,arrays) => types
	---------------------------
	operators Absyn.SUB => types

  rule	array_type_list(9, Types.T_INTEGER) => intarrtypes &
	array_type_list(9, Types.T_REAL) => realarrtypes &
	n_types(9, Types.T_INTEGER) => inttypes &
	n_types(9, Types.T_REAL) => realtypes &
	
	let int_mul = Exp.MUL(Exp.INT) &
	let real_mul = Exp.MUL(Exp.REAL) &
	let int_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.INT) &
	let real_mul_sp = Exp.MUL_SCALAR_PRODUCT(Exp.REAL) &
	let int_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.INT) &
	let real_mul_mp = Exp.MUL_MATRIX_PRODUCT(Exp.REAL) &
	
	let int_scalar = Types.T_INTEGER &
	let int_vector = Types.T_ARRAY(Types.DIM(NONE),int_scalar) &
	let int_matrix = Types.T_ARRAY(Types.DIM(NONE), int_vector) &
	let real_scalar = Types.T_REAL &
	let real_vector = Types.T_ARRAY(Types.DIM(NONE),real_scalar) &
	let real_matrix = Types.T_ARRAY(Types.DIM(NONE), real_vector) &


	let scalars = [
		       (int_mul,[int_scalar, int_scalar], int_scalar),
		       (real_mul,[real_scalar, real_scalar], real_scalar)
		       ] &


	
	let scalarprod = [
			  (int_mul_sp,[int_vector, int_vector],int_scalar),
			  (real_mul_sp,[real_vector,real_vector],real_scalar)
			  ] &
			
	let matrixprod = [
			  (int_mul_mp, [int_vector, int_matrix], int_vector),
			  (int_mul_mp, [int_matrix, int_vector], int_vector),
			  (int_mul_mp, [int_matrix, int_matrix], int_matrix),
			  (real_mul_mp,[real_vector,real_matrix],real_vector),
			  (real_mul_mp,[real_matrix,real_vector],real_vector),
			  (real_mul_mp,[real_matrix, real_matrix],real_matrix)
			  ] &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.INT), 
			inttypes, 
			intarrtypes, 
			intarrtypes) => intscalararrs &

	operator_return(Exp.MUL_SCALAR_ARRAY(Exp.REAL), 
			realtypes, 
			realarrtypes, 
			realarrtypes) => realscalararrs &
	
	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.INT), 
			intarrtypes, 
			inttypes, 
			intarrtypes) => intarrsscalar &

	operator_return(Exp.MUL_ARRAY_SCALAR(Exp.REAL), 
			realarrtypes, 
			realtypes, 
			realarrtypes) => realarrsscalar &	


	list_append(scalars, intscalararrs) => types1 &
	list_append(types1, realscalararrs) => types2 &
	list_append(types2, intarrsscalar) => types3 &
	list_append(types3, realarrsscalar) => types4 &
	list_append(types4, scalarprod) => types5 &
	list_append(types5, matrixprod) => types6 &
	

	let types = types6
	---------------------------
	operators Absyn.MUL => types

  axiom	operators Absyn.DIV
	  => [(Exp.DIV(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.POW
	  => [(Exp.POW(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_REAL)]


  axiom	operators Absyn.UMINUS
	  => [(Exp.UMINUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UMINUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

  axiom	operators Absyn.UPLUS
	  => [(Exp.UPLUS(Exp.INT),
	       [Types.T_INTEGER],
	       Types.T_INTEGER),
	      (Exp.UPLUS(Exp.REAL),
	       [Types.T_REAL],
	       Types.T_REAL)]

	(**  Logical operators *)

  axiom	operators Absyn.AND
	  => [(Exp.AND,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.OR
	  => [(Exp.OR,
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NOT
	  => [(Exp.NOT,
	       [Types.T_BOOL],
	       Types.T_BOOL)]

	(**  Relational operators *)

  axiom	operators Absyn.LESS
	  => [(Exp.LESS(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESS(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.LESSEQ
	  => [(Exp.LESSEQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.LESSEQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATER
	  => [(Exp.GREATER(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATER(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.GREATEREQ
	  => [(Exp.GREATEREQ(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.GREATEREQ(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL)]

  axiom	operators Absyn.EQUAL
	  => [(Exp.EQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.EQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]

  axiom	operators Absyn.NEQUAL
	  => [(Exp.NEQUAL(Exp.INT),
	       [Types.T_INTEGER, Types.T_INTEGER],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.REAL),
	       [Types.T_REAL, Types.T_REAL],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.STRING),
	       [Types.T_STRING, Types.T_STRING],
	       Types.T_BOOL),
	      (Exp.NEQUAL(Exp.BOOL),
	       [Types.T_BOOL, Types.T_BOOL],
	       Types.T_BOOL)]


  rule	print "- operators(" & Dump.op_symbol op => s &
 	print s & print ") failed\n"
	----------------------------
	operators op => fail

end

relation n_dim_array : (int, Types.Type) => Types.Type =

  axiom	n_dim_array (0, t) => t

  rule	int_sub(n,1) => n' &
	n_dim_array (n',t) => t'
	------------------------
	n_dim_array (n, t) => Types.T_ARRAY(Types.DIM(NONE),t')

end
relation n_types : (int, Types.Type) => Types.Type list =

  axiom	n_types (0,_) => []

  rule	int_sub(n,1) => n' &
	n_types(n',t) => l
	-----------------------
	n_types (n, t) => t::l

end

relation operator_return : (Exp.Operator, 
			    Types.Type list, 
			    Types.Type list, 
			    Types.Type list) 
	  =>  (Exp.Operator * Types.Type list * Types.Type) list =

  axiom operator_return (_,[],[],[]) => []

  rule	operator_return (op, lr, rr, rer) => rest &
	let t = (op,[l,r],re)
	---------------------------------------
	operator_return (op, l::lr, r::rr, re::rer) => t::rest

end

relation array_type_list : (int, Types.Type) => Types.Type list =
  
  axiom array_type_list (0,_) => []

  rule	int_sub(n,1) => n' &
	n_dim_array(n,t) => f &
	array_type_list (n', t) => r
	-----------------------------
	array_type_list (n, t) => f::r


end

(** LS: **)
relation get_prop_type: Properties => Types.Type = 

  axiom	get_prop_type PROP(ty,_) => ty
  axiom	get_prop_type PROP_TUPLE(ty,_) => ty

end

(** LS: If PROP_TUPLE, returns true if any of the flags is true **)
relation is_prop_const: Properties => bool =

  axiom	is_prop_const PROP(_,constant) => constant

  rule	is_prop_tuple_const constant => res
	-----------------------------------
	is_prop_const PROP_TUPLE(_,constant) => res

end

(** LS: **)
relation is_prop_tuple_const: Const => bool =

  axiom	is_prop_tuple_const CONST(f) => f

  rule	is_prop_tuple_const first => true
	---------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => true

  rule	is_prop_tuple_const first => false &
	is_prop_tuple_const TUPLE_CONST(rest) => res
	--------------------------------------------
	is_prop_tuple_const TUPLE_CONST(first::rest) => res

end
