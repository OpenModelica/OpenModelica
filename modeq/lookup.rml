(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path) => (Types.Type,Env.Env)
  relation lookup_class      : (Env.Env, Absyn.Path) => (SCode.Class, Env.Env)
  relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) 
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) 
end

with "parse.rml"
with "debug.rml"
with "dump.rml"
with "inst.rml"
with "mod.rml"
with "prefix.rml"
with "print.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path) => (Types.Type, Env.Env) =

  rule	Debug.fprint ("lotr","lookup_type(")	&
	Debug.fcall ("lotr",Env.print_env, env) &
	Debug.fprint ("lotr",", ") & 
	Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") &
	lookup_type_in_env(env,path) => (t,env') &

	Debug.fprint ("lotr", "found type:") &
	Debug.fcall ("lotr",Types.print_type, t) 
	--------------------------------------
	lookup_type(env, path) => (t,env')

  rule	lookup_package_type (env,pack,path) => (t,env')
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack,path)) => (t,env')
	
  rule	Print.print_buf "lookup_type failed!\n" 
	---------------------
	lookup_type(_,_) => fail
end

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_env(env,path) => (c, env') 
	--------------------------------------
	lookup_class(env, path as Absyn.IDENT(_)) => (c, env')

  rule	lookup_qualified_imported_class_in_env(env,env,path) => (c, env')
	----------------------------------------------------------
	lookup_class(env,path as Absyn.IDENT(_)) => (c, env')

  rule	lookup_unqualified_imported_class_in_env(env,env,path) => (c, env') 
	----------------------------------------------------------
	lookup_class(env,path as Absyn.IDENT(_)) => (c, env')

  rule	lookup_class(env,Absyn.IDENT(pack)) => (c as SCode.CLASS(id,_,_,restr,_),env') &
	Env.open_scope(env') => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.inst_class_in(env2,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) => (_,env'',_,_,_) &
	Print.print_buf "instantiated package, env:" &
	Env.print_env env'' &
	lookup_class_in_class(env'',c,path) => (c',env''') 
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path)) => (c', env''')
end

relation lookup_qualified_imported_class_in_env:(Env.Env,Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_qualified_imported_class_in_frame(items,totenv,name) => (c,_)
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(items)::fs),totenv,Absyn.IDENT(name)) => (c,env)

  rule	lookup_qualified_imported_class_in_env(fs,env,id) => (c, _)
	---------------------------------------------
	lookup_qualified_imported_class_in_env(f::fs,env,id) => (c,f::fs)
end

relation lookup_qualified_imported_class_in_frame: ((SCode.Ident * Env.Item) list,Env.Env,
    SCode.Ident)
	    => (SCode.Class, Env.Env) =
	    
  rule	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path) => (c,env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath) =>  (c2,_) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_class_in_frame((_,Env.IMPORT(Absyn.QUAL_IMPORT(path)))::fs,env,ident)
	    => (c,env')

  rule	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path) => (c,env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath) =>  (c2,_) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	----------------------------------
	lookup_qualified_imported_class_in_frame((_,Env.IMPORT(Absyn.QUAL_IMPORT(path)))::fs,env,ident)
	    => fail

  rule	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path) => (c,env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath) =>  (c2,_) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame((_,Env.IMPORT(Absyn.NAMED_IMPORT(id,path)))::fs,env,ident)
	    => (c,env')

  rule	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path) => (c,env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath) =>  (c2,_) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	---------------------------------- 
	lookup_qualified_imported_class_in_frame((_,Env.IMPORT(Absyn.NAMED_IMPORT(id,path)))::fs,env,ident)
	    => fail
	    
  rule	lookup_qualified_imported_class_in_frame(fs,env,ident) => (c,env')
	-----------------------
	lookup_qualified_imported_class_in_frame((_,_)::fs,env,ident) => (c,env')

end

relation lookup_unqualified_imported_class_in_env:(Env.Env,Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_unqualified_imported_class_in_frame(items,totenv,name) => (c,_)
	-----------------------------------------------------------------
	lookup_unqualified_imported_class_in_env(env as (Env.FRAME(items)::fs),totenv,Absyn.IDENT(name)) => (c,env)

  rule	lookup_unqualified_imported_class_in_env(fs,env,id) => (c, _)
	---------------------------------------------
	lookup_unqualified_imported_class_in_env(f::fs,env,id) => (c,f::fs)
end

relation lookup_unqualified_imported_class_in_frame: ((SCode.Ident * Env.Item) list,Env.Env,
    SCode.Ident)
	    => (SCode.Class, Env.Env) =
	    
  rule	Env.top_frame(env) => fr & 
	lookup_class_in_env([fr],path) => (c,env') &
	lookup_class_in_class(env,c,Absyn.IDENT(ident)) => (c',env'') &
	not lookup_unqualified_imported_class_in_frame(fs,env,ident) => (_,_) 
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame((_,Env.IMPORT(Absyn.UNQUAL_IMPORT(path)))::fs,env,ident)
	    => (c',env'')

  rule	Env.top_frame(env) => fr & 
	lookup_class_in_env([fr],path) => (c,env') &
	lookup_class_in_class(env,c,Absyn.IDENT(ident)) => (c',env'') &
	lookup_unqualified_imported_class_in_frame(fs,env,ident) => (_,_) &
	Print.print_buf "# Error, class found in several unqualified import statements\n"
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame((_,Env.IMPORT(Absyn.UNQUAL_IMPORT(path)))::fs,env,ident)
	    => fail

  rule	lookup_unqualified_imported_class_in_frame(fs,env,ident) => (c,env')
	-----------------------
	lookup_unqualified_imported_class_in_frame((_,_)::fs,env,ident) => (c,env')
end

relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	Debug.fprint("lotr","lookup_record_constructor_class(") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr",") called\n") &
	
	lookup_recconst_in_env(env,path) => (c, env') &
	Debug.fprint("lotr", "lookup_class_in_env => ") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr","\n")
	--------------------------------------
	lookup_record_constructor_class(env, path) => (c, env')

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

end

relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	Debug.fprint ("lotr", "lookup_var: Looking in frame\n") &
	lookup_var_f(items,ref) => (attr,ty,binding) &
	Debug.fprint ("lotr", "lookup_var: Done frame\n") 
	--------------------------------------------
	lookup_var_internal (Env.FRAME(items)::fs,ref) => (attr,ty,binding)

  rule	Debug.fprint ("lotr", "lookup_var: next frame\n") &
	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_in_packages
 ** This relation is called when a lookup of a variable with qualified names does 
 ** not have the first element as a component, e.g. A.B.C is looked up where A is not a component.
 ** This implies that A is a class, and this class should be temporary instantiated, and the lookup should ** be performed within that class.
**)

relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	
	lookup_class_in_env(env, Absyn.IDENT(id)) => (c as SCode.CLASS(n,_,_,r,_), env) &
	Debug.fprintl ("lotr", ["lookup_var_in_packages. instantiating class", n, "\n"]) &
	Env.open_scope(env) => env' &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env',Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) => (_,env'',_,_,types) &
	lookup_var(env'',cref) => (attr,ty,bind) &
	Debug.fprint ("lotr", "found var " ) &
	Debug.fcall("lotr", Exp.print_component_ref, cref)  &
	Debug.fprint ("lotr", " = ") &
	Debug.fcall("lotr", Types.print_binding, bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)
end


(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

  rule  lookup_var2(items, id) => (fv,c,i)
	----------------------------
	lookup_ident_local(Env.FRAME(items)::_, id) => (fv,c,i)

end

(* Same as lookup_ident_local, except check all frames *)
relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

	

  rule	lookup_var2(items, id) => (fv,c,i) 
	----------------------------
	lookup_ident(Env.FRAME(items)::_, id) => (fv,c,i)

  rule	lookup_ident(rest,id) => (fv,c,i)
	---------------------------------
	lookup_ident(_::rest,id) => (fv,c,i)

  rule	Print.print_buf "# Error lookup_ident: " &
	Print.print_buf id &
	Print.print_buf " failed\n"
	--------------
	lookup_ident(_,id) => fail	
end


(**  Function lookup *)

(* PR. Returns a list of types that the function has. *)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

        (* PR. Do nothing, could have used a axiom. But this led to an
	 bug unexpected error before. I do not take my chances at the moment.
	 *)
  rule  Debug.fprint ("li", "\n lookup_functions_in_env terminated." )
	---------------------
	lookup_functions_in_env([],id) => []


  rule	Debug.fprint ("lotr", "lookup_functions_in_env") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, items) &
	lookup_functions_in_frame(items,env,id) => c1 &
(*	Print.print_buf "\n Found type." & *)
	lookup_functions_in_env(fs,iid) => c2 &
	list_append (c1,c2) => reslist
	---------------------
	lookup_functions_in_env(env as (Env.FRAME(items)::fs), iid as Absyn.IDENT(id)) => reslist

	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

end


(** - Internal relations *)


(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type,Env.Env) =

  rule	lookup_type_in_frame(items,env,id) => (c,env')
	---------------------
	lookup_type_in_env(env as (Env.FRAME(items)::fs),Absyn.IDENT(id)) => (c,env')

  rule	lookup_type_in_env(fs,id) => (c,env')
	-------------------------------------
	lookup_type_in_env(f::fs,id) => (c,f::env')

end
(**)

relation lookup_type_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => (Types.Type, Env.Env) =

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_type_in_frame((n,Env.TYPE(t))::_,env, id) => (t,env)

  rule	id = n & Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_type_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	(* Each time a record constructor function is looked up, this rule will create the function.*)
	(* An improvement (perhaps needing lot of code) is to add the function to the environment, which is *)
	(* returned from this relation.*)
	id = n & 
	build_record_constructor_varlst (cdef,env) => varlst &
	Types.make_function_type(varlst) => ftype 
	----------------------------------------
	lookup_type_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,Absyn.R_RECORD,_),_))::rest,env,id) 
	    => (ftype,env)

  rule	id = n & 
	not lookup_type_in_frame(rest,env,id) => (_,_) &
	Inst.inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],cdef,[]) =>(_,_,ty,_)  &
	(* This rule is applied when a class definition, "below" in the code is a function and its type is 
	   requested. We should really add the type `ty' to the environment in the future, but that means 
	   a lot of changes......*)
	Env.extend_frame_t(env,id,ty) => (env')
	----------------------------------------
	lookup_type_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,Absyn.R_FUNCTION,_),_))::rest,env,id) => (ty,env')

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_type_in_frame(fs,env,id) => (t,env')
	------------------------------
	lookup_type_in_frame((n,_)::fs,env,id) => (t,env')
end
(**)

(*PR. This actually only looks up the function name and find all
 corresponding types that have this function name.  *)
relation lookup_functions_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => Types.Type list =

(*
  rule  Print.print_buf "\n FRAME IS FINSHED"
	------------------------------------
	lookup_functions_in_frame([],id) => []
*)
  axiom	lookup_functions_in_frame([],env,id) => []

  rule	(* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): " &
	   Print.print_buf n & Print.print_buf "\n" & *)
(*	Print.print_buf ("\n found id in frame.") & *)
	id = n &
	lookup_functions_in_frame(rest, env, id) => t2
	---------------------------------------------------------
	lookup_functions_in_frame((n,Env.TYPE(t))::rest, env, id) => t::t2

  rule	id = n & Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_functions_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	id = n & Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_varlst (cdef,env) => varlst &
	lookup_functions_in_frame(rest,env,id) => t2 &
	Types.make_function_type(varlst) => ftype
	----------------------------------------
	lookup_functions_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,Absyn.R_RECORD,_),_))::rest,env,id) => ftype::t2

  rule	 (* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_functions_in_frame(fs,env,id) => t
	------------------------------
	lookup_functions_in_frame((n,_)::fs,env,id) => t

end

relation lookup_recconst_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_frame(items,env,id) => (c, _) 
	---------------------
	lookup_recconst_in_env(env as (Env.FRAME(items)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_recconst_in_env(fs,id) => (c, _)
	---------------------
	lookup_recconst_in_env(f::fs,id) => (c, f::fs)

end

(** relation: lookup_recconst_in_frame
 **This relation lookups the implicit record constructor class (function) of a record in a frame
**)
relation lookup_recconst_in_frame: ((SCode.Ident * Env.Item) list,
				 Env.Env,
				 SCode.Ident)
	  => (SCode.Class, Env.Env) =



  rule	id = n &
	lookup_recconst_in_frame(rest, env, id) => (c2,env')
	---------------------------------------------------------
	lookup_recconst_in_frame((n,Env.TYPE(t))::rest, env, id) => (c2,env')

  rule	id = n & Print.print_buf "# Error while looking up record constructor class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_recconst_in_frame((n,Env.VAR(_,_,_))::_,env,id) => fail

  rule	id = n & Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_class (cdef,env) => cdef 
	----------------------------------------
	lookup_recconst_in_frame((n,Env.CLASS(cdef as SCode.CLASS(_,_,_,Absyn.R_RECORD,_),_))::rest,env,id) => (cdef,env)

  rule	 (* Print.print_buf "  lookup_type_in_frame(" & Print.print_buf id & Print.print_buf "): not " &
	   Print.print_buf n & Print.print_buf "\n" & *)
	lookup_recconst_in_frame(fs,env,id) => (c,env)
	------------------------------
	lookup_recconst_in_frame((n,_)::fs,env,id) => (c,env)

end

(**)

relation build_record_constructor_class :(SCode.Class, Env.Env) => SCode.Class =

  rule	build_record_constructor_elts(elts,env) => funcelts &
	build_record_constructor_result_elt(elts,id,env) => reselt
	---------------------------------------------------
	build_record_constructor_class (cl as SCode.CLASS(id,_,_,restr,SCode.PARTS(elts,_,_)),env) 
	    => SCode.CLASS(id,false,false,Absyn.R_FUNCTION,SCode.PARTS(reselt::funcelts,[],[]))
end
	
relation build_record_constructor_elts: (SCode.Element list, Env.Env) => SCode.Element list =
  rule	build_record_constructor_elts (rest,env) => res
	-------------------------------------------
	build_record_constructor_elts((comp as SCode.COMPONENT(id,fl,prot,SCode.ATTR(d,f,ac,var,dir),tp,mod))::rest,env)
	    => SCode.COMPONENT(id,fl,prot,SCode.ATTR(d,f,ac,var,Absyn.INPUT),tp,mod)::res
  axiom	build_record_constructor_elts([],_) => []
end
	
(** This relation builds the result element of a record constructor function, i.e. the returned variable *)
relation build_record_constructor_result_elt: (SCode.Element list, SCode.Ident, Env.Env) => SCode.Element =
	
  rule	build_record_constructor_result_mod(elts) => submodlst
	-------------------------------------------------
	build_record_constructor_result_elt (elts,id,env) 
	    => SCode.COMPONENT("result",false,false,SCode.ATTR([],false,SCode.RW,Absyn.VAR,Absyn.OUTPUT),Absyn.IDENT(id),SCode.MOD(false,submodlst,NONE))
end
	
(* This relation builds up the modification list for the output element of a record constructor.
 ** Example: 
 **   record foo
 **      Real x;
 **      String y;
 **      end foo;
 **  => modifier list become 'result.x=x, result.y=y'
 *)
relation build_record_constructor_result_mod: (SCode.Element list) => SCode.SubMod list =
	
  rule	build_record_constructor_result_mod(rest) => restmod
	---------------------------------------------------
	build_record_constructor_result_mod (SCode.COMPONENT(id,_,_,_,_,_)::rest) 
	    => SCode.NAMEMOD("result",SCode.MOD(false,[SCode.NAMEMOD(id,SCode.MOD(false,[],SOME(Absyn.CREF(Absyn.CREF_IDENT(id,[])))))],NONE))::restmod

  axiom	build_record_constructor_result_mod([]) => []
end
(** 
 ** This relation takes a class  (`SCode.Class') which holds a definition of a record
   ** and builds a list of variables of the record used for constructing a record constructor function.
*)
relation build_record_constructor_varlst : (SCode.Class,Env.Env) => Types.Var list =

  rule	build_varlst_from_elts(elts,env) => inputvarlst &
	Inst.inst_class(env,Mod.NOMOD,Prefix.NOPRE,[],cl,[]) => (_,_,ty,_) 
	--------------------------------------
	build_record_constructor_varlst (cl as SCode.CLASS(_,_,_,_,SCode.PARTS(elts,_,_)),env) 
	(* Add the return type of the record constructor *)
	    => Types.VAR("result",Types.ATTR(false,SCode.RW,Absyn.VAR,Absyn.OUTPUT),false,ty,Types.UNBOUND)::inputvarlst
end

relation build_varlst_from_elts: (SCode.Element list,Env.Env ) => Types.Var list =

  rule	build_varlst_from_elts(rest,env) => vars &
  (*P.A Here we need to do a lookup of the type. Therefore we need the env passed along from lookup_xxxx function. *)
	Inst.inst_record_constructor_elt(env,comp) => var
	-------------------------------------
	build_varlst_from_elts ((comp as SCode.COMPONENT(_,_,_,_ ,_,_))::rest,env) 
	    => var::vars

  axiom	build_varlst_from_elts ([],_) => []

  rule	Print.print_buf "ERROR build_varlst_from_elts failed!\n"
	----------------------------------------------
	build_varlst_from_elts(_,_) => fail
end

relation lookup_package_type : (Env.Env, string, Absyn.Path) => (Types.Type,Env.Env) =
	
  rule	locate_package (env,packname) => pack &
 	Print.print_buf "- package lookup of types not implemented\n"
	(* lookup_type_in_package (pack, path) => t *)
	-------------------------------------
	lookup_package_type (env, packname, path) => (* t *) fail

end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_frame(items,id) => (c, _) 
	---------------------
	lookup_class_in_env(env as (Env.FRAME(items)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_class_in_frame(items, id) => (c,  _) &
	lookup_class_in_class(env, c, path) => (c2, _)
	-------------------------------------------	
	lookup_class_in_env(env as (Env.FRAME(items)::fs), Absyn.QUALIFIED(id,path)) 
	    => (c2,env)

  rule	lookup_class_in_env(fs,id) => (c, _)
	---------------------
	lookup_class_in_env(f::fs,id) => (c, f::fs)

end

(** relation: lookup_class_in_class
 ** This relation looks up an inner class of a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 **)
relation lookup_class_in_class: (Env.Env, SCode.Class, Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_parts(env,classname,parts) => (c,env)
	----------------------------------------------------
	lookup_class_in_class (env, SCode.CLASS(_,_,_,_,SCode.PARTS(parts,_,_)),Absyn.IDENT(classname)) => (c,env)
	    
  rule	lookup_class_in_parts (env, c1, parts) => (c,env) &
	lookup_class_in_class (env,c,p1) => (c',env)
	-------------------------------------------
	lookup_class_in_class (env, SCode.CLASS(_,_,_,_,SCode.PARTS(parts,_,_)), Absyn.QUALIFIED(c1,p1)) => (c',env)
	
end
	
(** relation: lookup_class_in_parts
 ** This relation takes an `Env' and an `Ident' and an `Element' list, and returns the `Class' 
 ** having the name specified by the `Ident'. If not found, the relation fails.
 **)
relation lookup_class_in_parts: (Env.Env, SCode.Ident, SCode.Element list) => (SCode.Class, Env.Env) =
	
  rule	name = name2
	------------
	lookup_class_in_parts(env, name,  SCode.CLASSDEF(name2,_,_,c)::xs) => (c, env)


  rule	lookup_class_in_parts(env, name, xs) => (c,env)
	-----------------------------------------------
	lookup_class_in_parts(env, name, _::xs) => (c,env)

  axiom	lookup_class_in_parts(env, name, []) => fail
end

(**)
relation lookup_class_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => (SCode.Class, Env.Env) =

  rule	(*Debug.fprint("lotr", "  lookup_class_in_frame(") & 
	Debug.fprint("lotr", id) & Debug.fprint ("lotr", "): ") &
	Debug.fprint("lotr", n) & Debug.fprint("lotr", "\n") &*)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,Env.CLASS(c, env))::_, id) => (c, env)

(*
  rule	id = n & Print.print_buf "# Error while looking up class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_class_in_frame((n,Env.VAR(_))::_,id) => fail
*)

  rule	lookup_class_in_frame(fs,id) => (c, env)
	------------------------------
	lookup_class_in_frame(_::fs,id) => (c, env)

end
(**)
relation lookup_package_class : (Env.Env, string, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	locate_package (env,packname) => pack &
	lookup_class_in_package (pack, path) => (c, _)
	-------------------------------------
	lookup_package_class (env, packname, path) => (c, env)

end
(**)
relation lookup_var2 : ((SCode.Ident * Env.Item) list,SCode.Ident)
	  => (Types.Var,SCode.Element option, bool) =

  rule	Debug.fprintl ("locom", ["Comparing: ", n, " <=> ", id, "\n"]) &
	id = n
	--------------------------------------------
	lookup_var2((n,Env.VAR(fv,c,i))::_,id) => (fv,c,i)

  rule	lookup_var2(fs,id) => (fv,c,i)
	------------------------
	lookup_var2(_::fs,id) => (fv,c,i)

end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)

relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(dim,t),
			 Exp.WHOLEDIM::ys)
	  => Types.T_ARRAY(dim,t')

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => Types.T_ARRAY(Types.DIM(SOME(dim)),t')

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(NONE),t),
			 Exp.INDEX(_)::ys) => t'

  rule	Print.print_buf "- check_subscripts failed (" &
	Types.print_type t & Print.print_buf ", [" &
 	Exp.print_list(s,Exp.print_subscript,",") & Print.print_buf "])\n"
	-----------------------------------
	check_subscripts(t,s) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_))
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	Print.print_buf "- lookup_in_var failed\n"
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)

relation lookup_var_f : ((SCode.Ident * Env.Item) list,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule  Debug.fprint ("lotr", "lookup_var_f IDENT:") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id)
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	Debug.fprint ("lotr", "lookup_var_f QUAL:") &
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	Debug.fcall ("lotr", print_frame, f) &
	lookup_var2(f, id) => (Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)


  rule	Debug.fprintln ("lotr", "lookup_var_f failed")
	--------------------------------
	lookup_var_f(_,_) => fail

end


relation print_frame : ((SCode.Ident * Env.Item) list) => () =

  rule	Print.print_buf "FRAME: " &
	print_frame_contents cont &
	Print.print_buf "\n"
	--------------------------------------------
	print_frame cont

end


relation print_frame_contents: ((SCode.Ident * Env.Item) list) => () =

  axiom	print_frame_contents [] 

  rule	print_frame_element e
	-------------------------
	print_frame_contents [e as (n,i)]

  rule	print_frame_element e & Print.print_buf "," & print_frame_contents rst
	------------------------------------------------
	print_frame_contents ((e as (n,i))::rst)
end


relation print_frame_element: (SCode.Ident * Env.Item) => () =

  rule	Print.print_buf "v:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.VAR(_,_,_)))

  rule	Print.print_buf "c:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.CLASS(_,_)))

  rule	Print.print_buf "t:" & Print.print_buf n
	-------
	print_frame_element ((n,Env.TYPE(_)))

end




(**
 **  Package handling
 **)

(** relation: locate_package
 **
 ** This relation finds a package in a file and loads it.
 **
 ** It appends `.mo' to the name of the package and tries to load a
 ** file of that name.  This relation should be memoized, as it
 ** currently reloads the package each time it is used.
 **)

relation locate_package : (Env.Env, string) => SCode.Class =

  rule	lookup_class(env, Absyn.IDENT(pack)) => (c, env) &
	assert_package c
	----------------
	locate_package (env, pack) => c

  rule	string_append (pack, ".mo") => filename &
	Print.print_buf "Loading " & Print.print_buf filename & Print.print_buf "...\n" &
	Parser.parse filename => (Absyn.PROGRAM((c as Absyn.CLASS(classname,_,_,_,_))::_,w)) &
	pack = classname &
	SCode.elaborate Absyn.PROGRAM([c],w) => [c'] &
	assert_package c'
	--------------------------------------------
	locate_package(env, pack) => c'

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,_,Absyn.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
 
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,_,
					       SCode.PARTS(els,_,_)),
				 path) => (c, Env.empty_env)

end
(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	

