(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"
  with "cache.rml"

  relation lookup_type       : (Env.Env, Absyn.Path, bool (*msg flag *)) 
	  => (Types.Type,Env.Env)
  relation lookup_class      : (Env.Env, Absyn.Path,bool) 
	  => (SCode.Class, Env.Env)
  relation complete_path     : (Env.Env, Absyn.Path) => Absyn.Path
  relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) 
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool)
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) 
end

with "parse.rml"
with "debug.rml"
with "dump.rml"
with "inst.rml"
with "mod.rml"
with "prefix.rml"
with "print.rml"
with "builtin.rml"
with "util.rml"
with "modutil.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path,bool (* msg flag *)) 
	  => (Types.Type, Env.Env) =

	(* Lookup of simple names *)
  rule	Debug.fprint ("lotype","lookup_type(")	&
	Debug.fcall ("lotype",Env.print_env, env) &
	Debug.fprint ("lotype",", ") & 
	Debug.fcall ("lotype",Dump.print_path,path) &
	Debug.fprint ("lottype",")\n") &
	lookup_type_in_env(env,path) => (t,env') &
	Debug.fprint ("lotype", "found type:") &
	Debug.fcall ("lotype",Types.print_type, t) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env')

  rule	 (* If we didn't find the type, but found a class definition 
	  * that is a function with the same name then we implicitly instantiate that
	  function, and try again. *)
	lookup_class(env, path, false) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					       Prefix.NOPRE, [], c, [], false) 
	  => (env'',_) &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)


  rule	 (* If we didn't find the type, but found a class definition 
	  * that is an external function with the same name then we implicitly 
	  * instantiate that function, and try again. *)
	lookup_class(env, path, msg) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_EXT_FUNCTION,_),env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					       Prefix.NOPRE, [], c, [], false) 
	  => (env'',_) &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)

	(* Lookup of qualified name *)
  rule	lookup_class(env, Absyn.IDENT(pack), false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(env2', Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,env'',_,cistate1,_) &
        not ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has to do additional check for encapsulated classes, see rule below *)
	lookup_type_in_class(env'', c, path, true) => (t, env''') 
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack, path),msg) => (t, env''')


  rule	lookup_class(env, Absyn.IDENT(pack), msg) 
	  => (c as SCode.CLASS(id, _, encflag, restr, _), env') &
	Env.open_scope(env', encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2', Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false)
	  => (_, env'', _, cistate1, _) &
        ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_type_in_class(env'', c, path, false) => (c', env''') 
	--------------------------------------
	lookup_type(env, p as Absyn.QUALIFIED(pack, path), msg) => (c', env''')

  rule	Absyn.path_string path => s1 & 
	Util.string_append_list(["# Error, type ", s1, " not found.\n"]) => s2 &
	Print.print_buf s2
	---------------------
	lookup_type(_,path,true) => fail
end

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env, Absyn.Path, bool) => (SCode.Class, Env.Env) =

(* rule	(* Try to find the class in the cache *)
	Env.get_env_path(env) => envpath &
	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.get_class(envpathstr,pathstr) => (c,env) 
(*	& print "Got cached class: " & print pathstr &
	print "\n"*)
	----------------------------------------
	lookup_class(env,path,_) => (c,env)
*)
  
  rule	Debug.fprint ("lotr","TRIES lookup_class(1)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr","\n") &
        lookup_class_in_env(env,path,false) => (c, env') &
        Debug.fprint ("lotr","IN lookup_class(1)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	&Print.print_buf "Found class " & Print.print_buf name &
	Print.print_buf "in envpath:" &
	Env.print_env_path env' &
	Print.print_buf "\n:" *)

(* 	& Env.get_env_path(env') => envpath &
	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.add_class(c,env',envpathstr,pathstr) => ()*)
	--------------------------------------
	lookup_class(env, path as Absyn.IDENT(name),msgflag) => (c, env')

  rule	Debug.fprint ("lotr","TRIES lookup_class(2)\n") &
        lookup_qualified_imported_class_in_env(env,env,path) 
	  => (c, env') &
        Debug.fprint ("lotr","IN lookup_class(2)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n")  
(* 	& Env.get_env_path(env') => envpath &
 	Absyn.opt_path_string(envpath) => envpathstr &
 	Absyn.path_string(path) => pathstr &
	Cache.add_class(c,env',envpathstr,pathstr) => ()*)
	----------------------------------------------------------
	lookup_class(env, path, _) => (c, env')

  rule	Debug.fprint ("lotr","TRIES lookup_class(3)\n") &
        lookup_unqualified_imported_class_in_env(env, env, path) 
	  => (c, env') &
        Debug.fprint ("lotr","IN lookup_class(3)\n") &
        Debug.fcall ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	& Env.get_env_path(env') => envpath &
	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.add_class(c,env',envpathstr,pathstr) => ()*)
	----------------------------------------------------------
	lookup_class(env, path, _) => (c, env')

  rule	(* If we search for A1.A2....An.x while in scope A1.A2...An
	 , just search for x. Must do like this to ensure finite recursion *)
	Env.get_env_path(env) => SOME(ep) &
	Absyn.strip_last(p) => packp & 
	ModUtil.path_equal(ep,packp) => true &
	Absyn.path_last_ident(p) => id &
	lookup_class(env,Absyn.IDENT(id),msgflag) => (c,env')
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(_,_),msgflag) 
	  => (c, env)

  rule	Debug.fprint ("lotr","TRIES lookup_class(4)\n") &
        lookup_class(env,Absyn.IDENT(pack),msgflag) => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	Env.open_scope(env',encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr,id) => ci_state &
	Inst.inst_class_in(env2',Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (_,env'',_,cistate1,_) &
        not ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has to do additional check for encapsulated classes, see rule below *)

	lookup_class_in_class(env'', c, path, true) => (c', env''') &

	Debug.fprint ("lotr","IN lookup_class(4)\n") &
        Debug.fcall  ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	& Env.get_env_path(env') => envpath &
 	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.add_class(c,env',envpathstr,pathstr) => () *)
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path),msgflag) 
	  => (c', env''')

rule	Debug.fprint ("lotr","TRIES lookup_class(5)\n") &
        lookup_class(env,Absyn.IDENT(pack),msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env1) &
	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (_,env4,_,cistate1,_) &
        ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_class_in_class(env4, c, path, false) 
	  => (c', env5) &

	Debug.fprint ("lotr","IN lookup_class(5)\n") &
        Debug.fcall  ("lotr",Dump.print_path,path) &
	Debug.fprint ("lotr",")\n") 
(*	& Env.get_env_path(env5) => envpath &
	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.add_class(c',env5,envpathstr,pathstr) => ()*)
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path), msgflag) 
	  => (c', env5)

  rule	Absyn.path_string path => s & 
	Print.print_buf "#Error, class " & Print.print_buf s & 
	Print.print_buf " not found.\n" &
	Debug.fprint("failtrace", "- lookup_class failed\n  - looked for ") &
 	Debug.fprint("failtrace",  s) &
	Debug.fprint("failtrace", "\n env:") &
	Debug.fcall("failtrace", Env.print_env, env) &
	Debug.fprint("failtrace", "\n") 
	--------------
	lookup_class(env,path,true)=> fail 
end

(** relation: lookup_qualified_imported_class_in_env
 ** This relation looks up imported names on the qualified form: import A.B;
**)

relation lookup_qualified_imported_class_in_env:(Env.Env, Env.Env,
						 Absyn.Path) 
	  => (SCode.Class, Env.Env) =

  rule	Debug.fprint("loimp","lookup_qualified_imp_cl_in_env IDENT:\n") &
	Debug.fprint("loimp",name) &
	Debug.fprint("loimp","\n") &
	lookup_qualified_imported_class_in_frame(items,totenv,name) => (c,env') &
	Debug.fprint("loimp","lookup_qualified_imp_cl_in_env IDENT succeded\n") 
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,items,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (c, env')

  rule	Debug.fprint("loimp","lookup_qualified_imp_cl_in_env QUAL\n") &
	lookup_qualified_imported_class_in_frame(imps, totenv, pack) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_), env') &
	Debug.fprint("loimp","Found package. Instantiating.\n") &  
       	Env.open_scope(env',encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
	Inst.inst_class_in(env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state,
			   c, false, [], true, true) 
	  => (_,env4,_,_,_) &  
	Debug.fprint("loimp","Instantiated\n") &

	lookup_class_in_class(env4, c, path, false) 
	  => (c', env'')
	& Debug.fprint("loimp","Done\n") 
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,imps,_)::fs),totenv, Absyn.QUALIFIED(pack,path)) 
	  => (c', env'')

  rule	lookup_qualified_imported_class_in_env(fs, env, id) => (c, env')
	---------------------------------------------
	lookup_qualified_imported_class_in_env(f::fs, env, id) => (c, env')
end

relation lookup_qualified_imported_class_in_frame: ( Env.Item list,Env.Env,
    SCode.Ident)
	    => (SCode.Class, Env.Env) =

  rule	(* For imported paths A, not possible to assert sub-path package*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],Absyn.IDENT(id),true) => (c, env') 
	------------------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(Absyn.IDENT(id)))::fs,env,ident)
	    => (c, env')
	    
  rule	(* For imported path A.B.C, assert A.B is package*)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath,true) =>  (c2, _) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => (c, env')

  rule	(* If not package, error *)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2,_) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => fail

  rule	(* Named imports*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr], path, true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => (c, env')

  rule	(* Assert package for Named imports *)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	not assert_package(c2) &
	Print.print_buf "# Error, " & Dump.print_path strippath & Print.print_buf " is not a package\n"  
	& print "# Error xxx is not a package\n" 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => fail
	    
  rule	lookup_qualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env')
	-----------------------
	lookup_qualified_imported_class_in_frame(_::fs,env,ident) 
	  => (c, env')
end

relation lookup_unqualified_imported_class_in_env:(Env.Env, 
						   Env.Env, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_unqualified_imported_class_in_frame(items, totenv, name) 
	  => (c, env')
	-----------------------------------------------------------------
	lookup_unqualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,items,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_env(fs, env, id) => (c, _)
	---------------------------------------------
	lookup_unqualified_imported_class_in_env(f::fs,env,id) => (c,f::fs)
end

relation lookup_unqualified_imported_class_in_frame: (Env.Item list, Env.Env, SCode.Ident)
	    => (SCode.Class, Env.Env) =
	    
  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag) => env2 &
	Env.name_scope (env2,id) => env2' &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2', Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,env'',_,cistate1,_) &

	lookup_class_in_class(env'', c, Absyn.IDENT(ident), false) 
	  => (c', env''') &
	not lookup_unqualified_imported_class_in_frame(fs, env, ident) => (_,_) 
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident)
	    => (c', env''')

  rule	Env.top_frame(env) => fr & 
	lookup_class_in_env([fr], path, false) => (c, env') &
	lookup_class_in_class(env, c, Absyn.IDENT(ident), false) 
	  => (c', env'') &
	lookup_unqualified_imported_class_in_frame(fs, env, ident) => (_,_) &
	Print.print_buf "# Error, class found in several unqualified import statements\n"
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident)
	    => fail

  rule	lookup_unqualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env')
	-----------------------
	lookup_unqualified_imported_class_in_frame(_::fs, env, ident) 
	  => (c, env')
end

relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	Debug.fprint("lotr","lookup_record_constructor_class(") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr",") called\n") &
	
	lookup_recconst_in_env(env,path) => (c, env') &
	Debug.fprint("lotr", "lookup_class_in_env => ") &
	Debug.fcall("lotr",Dump.print_path,path) &
	Debug.fprint("lotr","\n")
	--------------------------------------
	lookup_record_constructor_class(env, path) => (c, env')

end

(** relation: complete_path
 **
 ** This relation takes a type name and an env and looks up the class.
 ** Then it determines the full path for the type, such that it can be looked up
** from any environment.
**)

relation complete_path: (Env.Env, Absyn.Path) => Absyn.Path =

  rule	(* Class found on top level. Nothing to complete. *)
	lookup_class(env,path,true) => (_,Env.FRAME(NONE,_,_,_,_)::_)
	----------------------------------------------
	complete_path(env,path) => path

  rule	lookup_class(env, path, true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,path) => path' 
(*	& Print.print_buf "completed to " &
	Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)
	------------------
	complete_path(env,path as Absyn.IDENT(_)) => path'

  rule	lookup_class(env, Absyn.IDENT(pack), true) 
	  => (_,Env.FRAME(NONE,_,_,_,_)::_)
	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path 

  rule	lookup_class(env,(*Absyn.IDENT(pack)*)path,true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,Absyn.IDENT(id)) => path' 
	
(*	& Print.print_buf "Qualified completed to " 
	& Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\n" &
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)

	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path'

  rule	Debug.fprint("failtrace", "-complete_path failed\n env=") &
	Debug.fcall("failtrace", Env.print_env, env) & 
	Debug.fprint("failtrace", "\ntype: ")  &
	Absyn.path_string path => str & 
	Debug.fprint("failtrace", str )&
	Debug.fprint("failtrace", "\n" )
	--------------------
	complete_path(env,path) => fail

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

  rule	Debug.fprint("failtrace",  "- lookup_var failed\n")
	--------------------
	lookup_var(_,_) => fail
end

relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	Debug.fprint ("lotr", "lookup_var: Looking in frame\n") &
	lookup_var_f(ht,ref) => (attr,ty,binding) &
	Debug.fprint ("lotr", "lookup_var: Done frame\n") 
	--------------------------------------------
	lookup_var_internal (Env.FRAME(sid,ht,_,imps,_)::fs,ref) => (attr,ty,binding)

  rule	Debug.fprint ("lotr", "lookup_var: next frame\n") &
	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_in_packages
 ** This relation is called when a lookup of a variable with qualified names does 
 ** not have the first element as a component, e.g. A.B.C is looked up where A is not a component.
 ** This implies that A is a class, and this class should be temporary instantiated, and the lookup should 
 ** be performed within that class.
**)

relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	(* Special case for looking up enumerations *)
	lookup_class(env, Absyn.IDENT(id1),false) 
	  => (c as SCode.CLASS(n,_,encflag,r as SCode.R_ENUMERATION,_), env2) &
	Env.open_scope(env2,encflag) => env3 &
	Env.name_scope (env3,n) => env4 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env4,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],
			    false,false) 
	  => (_,env5,_,_,types) &
	lookup_var_in_packages(env5,id2) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id1, [], id2 as Exp.CREF_IDENT(_,_))) => (attr,ty,bind)
	

  rule	lookup_class(env, Absyn.IDENT(id),false) => (c as SCode.CLASS(n,_,encflag,r,_), env2) &
	Debug.fprintl ("lotr", ["lookup_var_in_packages, instantiating class: ", n, "\n"]) &
	Env.open_scope(env2,encflag) => env3 &
	Env.name_scope (env3,n) => env4 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env4,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],
			    true,true) 
	  => (_,env5,_,_,types) &
	lookup_var_in_packages(env5,cref) => (attr,ty,bind) &
	Debug.fprint ("lotr", "found var " ) &
	Debug.fcall("lotr", Exp.print_component_ref, cref)  &
	Debug.fprint ("lotr", " = ") &
	Debug.fcall("lotr", Types.print_binding, bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)


  rule	lookup_var_local(env,cr) => (attr,ty,bind)
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)

  rule	not lookup_var_local(env,cr) => (attr,ty,bind) &
	Debug.fprint("failtrace",  "- lookup_var_in_packages failed\n" )
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => fail

  rule	Debug.fprint("failtrace",  "lookup_var_in_packages failed\n exp:" ) &
	Debug.fcall("failtrace", Exp.print_component_ref, cr) &
	Debug.fprint("failtrace", "\n")
	--------------------------------------------------
	lookup_var_in_packages (env, cr) => fail

end


(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(ht,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(sid,ht,_,_,_)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

  rule  lookup_var2(ht, id) => (fv,c,i)
	----------------------------
	lookup_ident_local(Env.FRAME(sid,ht,_,_,_)::_, id) => (fv,c,i)

end

(* Same as lookup_ident_local, except check all frames *)
relation lookup_ident : (Env.Env, SCode.Ident) => (Types.Var,SCode.Element option,bool) =

	

  rule	lookup_var2(ht, id) => (fv,c,i) 
	----------------------------
	lookup_ident(Env.FRAME(sid,ht,_,_,_)::_, id) => (fv,c,i)

  rule	lookup_ident(rest,id) => (fv,c,i)
	---------------------------------
	lookup_ident(_::rest,id) => (fv,c,i)

  rule	Print.print_buf "# Error lookup_ident: " &
	Print.print_buf id &
	Print.print_buf " failed\n"
	--------------
	lookup_ident(_,id) => fail	
end


(**  Function lookup *)

(* PR. Returns a list of types that the function has. *)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

        (* PR. Do nothing, could have used a axiom. But this led to an
	 bug unexpected error before. I do not take my chances at the moment.
	 *)
  rule  Debug.fprint ("li", "\n lookup_functions_in_env terminated." )
	---------------------
	lookup_functions_in_env([],id) => []


  rule	Debug.fprint ("lotr", "lookup_functions_in_env") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	lookup_functions_in_frame(ht,httypes,env,id) => c1 &
(*	Print.print_buf "\n Found type." & *)
	lookup_functions_in_env(fs,iid) => c2 &
	list_append (c1,c2) => reslist
	---------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,ht,httypes,_,_)::fs), iid as Absyn.IDENT(id)) => reslist

	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

end


(** - Internal relations *)


(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type,Env.Env) =

  rule	lookup_type_in_frame(ht,httypes,env,id) => (c,env')
	---------------------
	lookup_type_in_env(env as (Env.FRAME(sid,ht,httypes,_,_)::fs),Absyn.IDENT(id)) => (c,env')

  rule	lookup_type_in_env(fs,id) => (c,env')
	-------------------------------------
	lookup_type_in_env(f::fs,id) => (c,f::env')

end
(**)

relation lookup_type_in_frame: (Env.HashTable, (* Classes and vars*)
				Env.HashTable, (* types *)
				 Env.Env,
				 SCode.Ident)
	  => (Types.Type, Env.Env) =

  rule	Env.hash_get(httypes,id,Env.myhash) => Env.TYPE(t::_)
	---------------------------------------------------------
	lookup_type_in_frame(ht,httypes,env, id) => (t,env)

  rule	Env.hash_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => fail

  rule	(* Each time a record constructor function is looked up, this rule will create the function.*)
	(* An improvement (perhaps needing lot of code) is to add the function to the environment, which is *)
	(* returned from this relation.*)
	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),_) &
	Inst.package_prefix(env,Absyn.IDENT(n)) => fpath &
	build_record_constructor_varlst (cdef,env) => varlst &
	Types.make_function_type(fpath,varlst) => ftype 
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) 
	    => (ftype,env)

  rule	(* If we found class that is function *)
	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Mod.NOMOD,Prefix.NOPRE,[],cdef,[],false) 
	  => (env',_) &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')

  rule	(* If we found class that is external function *)
	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Mod.NOMOD,Prefix.NOPRE,[],cdef,[],false) 
	  => (env',_) &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')
end
(**)

(*PR. This actually only looks up the function name and find all
 corresponding types that have this function name.  *)
relation lookup_functions_in_frame: (Env.HashTable, (*Classes and vars*)
				     Env.HashTable, (*Types *)
				     Env.Env,
				     SCode.Ident)
	  => Types.Type list =


  rule	Env.hash_get(httypes, id, Env.myhash) => Env.TYPE(tps)
	---------------------------------------------------------
	lookup_functions_in_frame(ht,httypes, env, id) => tps

  rule	Env.hash_get(ht, id, Env.myhash) => Env.VAR(_,_,_) &
	Print.print_buf "# Error while looking up type " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => fail

  rule	Env.hash_get(ht, id, Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),cenv) &
	Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_varlst (cdef,env) => varlst &
	Inst.package_prefix(cenv,Absyn.IDENT(n)) => fpath &
	Types.make_function_type(fpath,varlst) => ftype
	----------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => [ftype]

  rule	(* If found class that is function.*)
	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Mod.NOMOD,Prefix.NOPRE,[],cdef,[],false) 
	  => (env',_) &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps

  rule	(* If found class that is external function.*)
	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Mod.NOMOD,Prefix.NOPRE,[],cdef,[],false) 
	  => (env',_) &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps
end

relation lookup_recconst_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_frame(ht,env,id) => (c, _) 
	---------------------
	lookup_recconst_in_env(env as (Env.FRAME(sid,ht,_,imps,_)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_recconst_in_env(fs,id) => (c, _)
	---------------------
	lookup_recconst_in_env(f::fs,id) => (c, f::fs)
end

(** relation: lookup_recconst_in_frame
 **This relation lookups the implicit record constructor class (function) of a record in a frame
**)
relation lookup_recconst_in_frame: (Env.HashTable, Env.Env, SCode.Ident)
	  => (SCode.Class, Env.Env) =

	  
	  
  rule	Env.hash_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_buf "# Error while looking up record constructor class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_recconst_in_frame(ht,env,id) => fail

  rule	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_) &
	Print.print_buf "Found record when looking for function. Assuming implicit record constructor\n" &
	build_record_constructor_class (cdef,env) => cdef 
	----------------------------------------
	lookup_recconst_in_frame(ht,env,id) => (cdef,env)
end

(**)

relation build_record_constructor_class :(SCode.Class, Env.Env) => SCode.Class =

  rule	build_record_constructor_elts(elts,env) => funcelts &
	build_record_constructor_result_elt(elts,id,env) => reselt
	---------------------------------------------------
	build_record_constructor_class (cl as SCode.CLASS(id,_,_,restr,SCode.PARTS(elts,_,_,_,_,_)),env) 
	    => SCode.CLASS(id,false,false,SCode.R_FUNCTION,SCode.PARTS(reselt::funcelts,[],[],[],[],NONE))
end
	
relation build_record_constructor_elts: (SCode.Element list, Env.Env) => SCode.Element list =
  rule	build_record_constructor_elts (rest,env) => res
	-------------------------------------------
	build_record_constructor_elts((comp as SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,dir),tp,mod))::rest,env)
	    => SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,Absyn.INPUT),tp,mod)::res
  axiom	build_record_constructor_elts([],_) => []
end
	
(** This relation builds the result element of a record constructor function, i.e. the returned variable *)
relation build_record_constructor_result_elt: (SCode.Element list, SCode.Ident, Env.Env) => SCode.Element =
	
  rule	build_record_constructor_result_mod(elts) => submodlst
	-------------------------------------------------
	build_record_constructor_result_elt (elts,id,env) 
	    => SCode.COMPONENT("result",false,false,false,SCode.ATTR([],false,SCode.RW,SCode.VAR,Absyn.OUTPUT),Absyn.IDENT(id),SCode.MOD(false,submodlst,NONE))
end
	
(* This relation builds up the modification list for the output element of a record constructor.
 ** Example: 
 **   record foo
 **      Real x;
 **      String y;
 **      end foo;
 **  => modifier list become 'result.x=x, result.y=y'
 *)
relation build_record_constructor_result_mod: (SCode.Element list) => SCode.SubMod list =
	
  rule	build_record_constructor_result_mod(rest) => restmod
	---------------------------------------------------
	build_record_constructor_result_mod (SCode.COMPONENT(id,_,_,_,_,_,_)::rest) 
	    => SCode.NAMEMOD("result",SCode.MOD(false,[SCode.NAMEMOD(id,SCode.MOD(false,[],SOME(Absyn.CREF(Absyn.CREF_IDENT(id,[])))))],NONE))::restmod

  axiom	build_record_constructor_result_mod([]) => []
end
(** 
 ** This relation takes a class  (`SCode.Class') which holds a definition of a record
   ** and builds a list of variables of the record used for constructing a record constructor function.
*)
relation build_record_constructor_varlst : (SCode.Class,Env.Env) => Types.Var list =

  rule	build_varlst_from_elts(elts,env) => inputvarlst &
	Inst.inst_class(env, Mod.NOMOD, Prefix.NOPRE, [], cl, [], true,Inst.TOP_CALL) 
	  => (_,_,_,ty,_) 
	--------------------------------------
	build_record_constructor_varlst (cl as SCode.CLASS(_,_,_,_,SCode.PARTS(elts,_,_,_,_,_)),env) 
	(* Add the return type of the record constructor *)
	    => Types.VAR("result",Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.OUTPUT),false,ty,Types.UNBOUND)::inputvarlst
end

relation build_varlst_from_elts: (SCode.Element list,Env.Env ) => Types.Var list =

  rule	build_varlst_from_elts(rest,env) => vars &
  (*P.A Here we need to do a lookup of the type. Therefore we need the env passed along from lookup_xxxx function. *)
	Inst.inst_record_constructor_elt(env,comp) => var
	-------------------------------------
	build_varlst_from_elts ((comp as SCode.COMPONENT(_,_,_,_ ,_,_,_))::rest,env) 
	    => var::vars

  axiom	build_varlst_from_elts ([],_) => []

  rule	Debug.fprint("failtrace", "- build_varlst_from_elts failed!\n")
	----------------------------------------------
	build_varlst_from_elts(_,_) => fail
end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path,bool) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_frame(ht,id,msg) => (c,_)  
	---------------------
	lookup_class_in_env(env as (Env.FRAME(sid,ht,_,_,_)::fs),Absyn.IDENT(id),msg)
	    => (c,env)

(*  rule	lookup_class_in_frame(items, id, msg) => (c, _) &
	lookup_class_in_class(env, c, path,false) => (c2, env')
	-------------------------------------------	
	lookup_class_in_env(env as (Env.FRAME(sid,items,_)::fs), Absyn.QUALIFIED(id,path),msg) 
	    => (c2,env')*)
(*
  NOW THIS RULES IS SEPARATED INTO TWO CASES

  rule	lookup_class_in_env(fs,id,msgflag) => (c, _)
	---------------------
	lookup_class_in_env(f::fs,id,msgflag) => (c, f::fs)
*)

(*  rule	lookup_class_in_env(fs,id,msgflag) => (c, env')
	---------------------
	lookup_class_in_env(f::fs,id as Absyn.QUALIFIED(_,_),msgflag) => (c, env')*)
	
  rule	(* Special case if looking up the class that -is- encapsulated. That must be allowed. *)
        id = sid &
	lookup_class_in_env(fs,aid,true) => (c,env)
	---------------------
	lookup_class_in_env(env as Env.FRAME(SOME(sid),_,_,_,true)::fs, aid as Absyn.IDENT(id),_) 
	  => (c,env)


  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_) &
        Print.print_buf "# Class " &
        Print.print_buf id       &
        Print.print_buf " not found and the lookup reached an encapsulated class\n"
	&Env.print_env env 
	---------------------
	lookup_class_in_env(env as Env.FRAME(sid,_,_,_,true)::fs, aid as Absyn.IDENT(id),true) => fail

  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_)
	---------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),false) => fail

 rule	Builtin.initial_env() => i_env & 
        lookup_class_in_env(  i_env, aid,msgflag)=> (c,env')
       	---------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),msgflag ) => (c,env')

  rule  lookup_class_in_env(fs,id,msgflag) => (c, env')
	---------------------
	lookup_class_in_env(  (f as Env.FRAME(sid,_,_,_,false)) ::fs,
			    id as Absyn.IDENT(_),msgflag ) 
	  => (c, env')
end

(** relation: lookup_class_in_class
 ** This relation looks up an inner class of a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_class_in_class: (Env.Env, SCode.Class, Absyn.Path, bool) 
	  => (SCode.Class, Env.Env) =
	  
	  (* Look in cache *)
(*rule	Env.get_env_path(env) => envpath &
	Absyn.opt_path_string(envpath) => envpathstr &
	Absyn.path_string(path) => pathstr &
	Cache.get_class(envpathstr,pathstr) => (c,env) 
	----------------------------------------------
	lookup_class_in_class (env, _,path,_) => (c, env)*)

  rule	lookup_class_in_env(env,classname,true) => (c as SCode.CLASS(_,_,true,_,_) ,env') 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_class_in_class (env, cdef,classname as Absyn.IDENT(_),true) 
	  => (c, env')

  rule	lookup_class_in_env(env,classname,false) => (c as SCode.CLASS(_,_,false,_,_) ,env') &
        (* false means here non-encapsulated *)
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is already a simple name: ") &
	Print.print_buf(id) & Print.print_buf(" )\n")
      	----------------------------------------------------
	lookup_class_in_class (env, cdef, classname as Absyn.IDENT(id),true) => fail
	
  rule	lookup_class_in_env(env,classname,false) => (c ,env') 
        (* false means that we do not restrict lookup to encapsulated classes *)
(*	&Print.print_buf " (class in class) Found class " & Print.print_buf name &
	Print.print_buf "in envh:" &
	Env.print_env env' &
	Print.print_buf "\n:" *)

      	----------------------------------------------------
	lookup_class_in_class (env, cdef, classname as Absyn.IDENT(name) ,false) 
	  => (c, env')

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)
	Inst.inst_class_in(env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (_,env4,_,_,_) &
  	lookup_class_in_class (env4, c, p1, false) => (c', env5)
	-------------------------------------------
	lookup_class_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) 
	  => (c',env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is still qualified)\n")
	-------------------------------------------
	lookup_class_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), false) => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env3) &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,true) 
	  => (_,env4,_,_,_) &
  	lookup_class_in_class (env4, c, p1, false) => (c', env5)
	-------------------------------------------
	lookup_class_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),false) 
	  => (c', env5)

  rule	lookup_qualified_imported_class_in_env(env,env,path) 
	  => (c, env') 
	-------------------------
	lookup_class_in_class (env, cdef, path,_) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_env(env, env, path) 
	  => (c, env') 
	-------------------------
	lookup_class_in_class (env, cdef, path ,_) 
	  => (c, env')

  rule	Debug.fprint("failtrace", "- lookup_class_in_class failed\n   - class =") &
	Debug.fprint("failtrace",cname) &
	Debug.fprint("failtrace", "\n  - looked for: ") & Absyn.path_string path => s & 
	Debug.fprint("failtrace", s) & 
	Debug.fprint("failtrace", "\n")
	-----------------
	lookup_class_in_class(env, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end

(** relation: lookup_type_in_class
 ** This relation looks up an type inside a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_type_in_class: (Env.Env, SCode.Class, Absyn.Path, bool) => (Types.Type, Env.Env) =

  rule	lookup_type_in_env(env, classname(*, true*)) => (tp, env')
        (* encapsulated does not matter, _ *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (tp, env')

  rule	(* If not found, look for classdef that is function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_FUNCTION, _), env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					     Prefix.NOPRE, [], c, [], false) 
	  => (env'',_) &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* If not found, look for classdef that is external function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_EXT_FUNCTION, _), env') &
	Inst.implicit_function_instantiation(env', Mod.NOMOD,
					     Prefix.NOPRE, [], c, [], false) 
	  => (env'',_) &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env) &
       	Env.open_scope(env, encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env3, Mod.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,env4,_,_,_) &
  	lookup_type_in_class (env4, c, p1, false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => (t, env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
        Print.print_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is still qualified)\n")
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), false) => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag) => env2 &
	Env.name_scope (env2,id) => env3 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env2') &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(env3,Mod.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,false) 
	  => (_,env4,_,_,_) &
  	lookup_type_in_class (env4,c,p1,false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),false) => (t, env5)

  rule	Debug.fprint("failtrace", "- lookup_class_in_class failed\n   - class =") &
	Debug.fprint("failtrace",cname) &
	Debug.fprint("failtrace", "\n  - looked for: ") & Absyn.path_string path => s & 
	Debug.fprint("failtrace", s) & 
	Debug.fprint("failtrace", "\n")
	-------------------------------
	lookup_type_in_class(_, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end
	
(** relation: lookup_class_in_parts
 ** This relation takes an `Env' and an `Ident' and an `Element' list, and returns the `Class' 
 ** having the name specified by the `Ident'. If not found, the relation fails.
 **)
relation lookup_class_in_parts: (Env.Env, SCode.Ident, SCode.Element list) => (SCode.Class, Env.Env) =
	
  rule	name = name2
	------------
	lookup_class_in_parts(env, name,  SCode.CLASSDEF(name2,_,_,c)::xs) => (c, env)


  rule	lookup_class_in_parts(env, name, xs) => (c,env)
	-----------------------------------------------
	lookup_class_in_parts(env, name, _::xs) => (c,env)

  axiom	lookup_class_in_parts(env, name, []) => fail
end

(**)
relation lookup_class_in_frame: (Env.HashTable,
				 SCode.Ident,bool)
	  => (SCode.Class, Env.Env) =

  rule	Env.hash_get(ht,id,Env.myhash) => Env.CLASS(c,env) 
	---------------------------------------------------------
	lookup_class_in_frame(ht, id,_) => (c, env)

  rule	Env.hash_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_buf "# Error while looking up class " &
	Print.print_buf id & Print.print_buf ": found a component\n"
	------------------------------------
	lookup_class_in_frame(ht,id,true) => fail

end

(**)
relation lookup_var2 : (Env.HashTable, SCode.Ident)
	  => (Types.Var, SCode.Element option, bool) =

  rule	Env.hash_get(ht, id, Env.myhash) => Env.VAR(fv,c,i)
	--------------------------------------------
	lookup_var2(ht,id) => (fv,c,i)
end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)

relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(dim,t),p),
			 Exp.WHOLEDIM::ys)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),p),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => ((Types.T_ARRAY(Types.DIM(SOME(dim)),t'),p))

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	Debug.fprint("failtrace", "- check_subscripts failed ( ") &
	Debug.fcall("failtrace", Types.print_type, t) & 
	Debug.fprint("failtrace", ")\n")
	-----------------------------------
	check_subscripts(t,s) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_)) &
	Print.print_buf "# Error, referencing protected elements not allowed.\n" 
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	Debug.fprint("failtrace", "- lookup_in_var failed\n")
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)

relation lookup_var_f : (Env.HashTable,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule  Debug.fprint ("lotr", "lookup_var_f IDENT:") &	
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	lookup_var2(ht, id)
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(ht,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	Debug.fprint ("lotr", "lookup_var_f(_,CREF_FQUAL(_,_)):\n") &
	Debug.fprintl ("lotr", ["looking up: ", id, "\n"]) &
	lookup_var2(ht, id) => (Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_),_,_) &
	Debug.fprintl ("lotr", ["looking up: found ", id, "\n"]) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(ht,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)


  rule	Debug.fprintln ("lotr", "lookup_var_f failed")
	--------------------------------
	lookup_var_f(_,_) => fail

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,_,SCode.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
 
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,_,
					       SCode.PARTS(els,_,_,_,_,_)),
				 path) => (c, Env.empty_env)

end
(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	