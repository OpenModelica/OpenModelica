(**
 ** file:	 lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "explode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path) => (Types.Type)
  relation lookup_class      : (Env.Env, Absyn.Path) => (SCode.Class, Env.Env)
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) => Types.Var

end

with "parse.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 **)

relation lookup_type: (Env.Env,Absyn.Path) => Types.Type =

  rule	lookup_type_in_env(env,path) => t
	--------------------------------------
	lookup_type(env, path) => t

  rule	lookup_package_type (env,pack,path) => t
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack,path)) => t

end

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_env(env,path) => (c, env)
	--------------------------------------
	lookup_class(env, path) => (c, env)

  rule	lookup_package_class (env,pack,path) => (c, env)
	--------------------------------------
	lookup_class(env, Absyn.QUALIFIED(pack,path)) => (c, env)

end

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	(* print " lookup_var: looking in frame\n" & *)
	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

  rule	(* print " lookup_var: next frame\n" & *)
	lookup_var(fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var(_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **)

relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(items,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(items)::fs,ref) => (attr,ty,binding)

end

relation lookup_ident_local : (Env.Env, SCode.Ident) => Types.Var =

  rule  lookup_var2(items, id) => fv
	----------------------------
	lookup_ident_local(Env.FRAME(items)::_, id) => fv

end

(** - Internal relations *)

(**  Type lookup *)

relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type) =

  rule	lookup_type_in_frame(items,id) => c
	---------------------
	lookup_type_in_env(Env.FRAME(items)::fs,Absyn.IDENT(id)) => c

  rule	lookup_type_in_env(fs,id) => c
	---------------------
	lookup_type_in_env(f::fs,id) => c

end
(**)
relation lookup_type_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => Types.Type =

  rule	(* print "  lookup_type_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_type_in_frame((n,Env.TYPE(t))::_, id) => t

  rule	id = n & print "# Error while looking up type " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_type_in_frame((n,Env.VAR(_))::_,id) => fail

  rule	(* print "  lookup_type_in_frame(" & print id & print "): not " &
	   print n & print "\n" & *)
	lookup_type_in_frame(fs,id) => t
	------------------------------
	lookup_type_in_frame((n,_)::fs,id) => t

end
(**)
relation lookup_package_type : (Env.Env, string, Absyn.Path) => Types.Type =
	
  rule	locate_package (env,packname) => pack &
 	print "- package lookup of types not implemented\n"
	(* lookup_type_in_package (pack, path) => t *)
	-------------------------------------
	lookup_package_type (env, packname, path) => (* t *) fail

end

(**  Class lookup *)

relation lookup_class_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_class_in_frame(items,id) => (c, env)
	---------------------
	lookup_class_in_env(Env.FRAME(items)::fs,Absyn.IDENT(id)) => (c, env)

  rule	lookup_class_in_env(fs,id) => (c, env)
	---------------------
	lookup_class_in_env(f::fs,id) => (c, env)

end
(**)
relation lookup_class_in_frame: ((SCode.Ident * Env.Item) list,
				 SCode.Ident)
	  => (SCode.Class, Env.Env) =

  rule	(* print "  lookup_class_in_frame(" & print id & print "): " &
	   print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,Env.CLASS(c, env))::_, id) => (c, env)

(*
  rule	id = n & print "# Error while looking up class " &
	print id & print ": found a component\n"
	------------------------------------
	lookup_class_in_frame((n,Env.VAR(_))::_,id) => fail
*)

  rule	lookup_class_in_frame(fs,id) => (c, env)
	------------------------------
	lookup_class_in_frame(_::fs,id) => (c, env)

end
(**)
relation lookup_package_class : (Env.Env, string, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	locate_package (env,packname) => pack &
	lookup_class_in_package (pack, path) => (c, env)
	-------------------------------------
	lookup_package_class (env, packname, path) => (c, env)

end
(**)
relation lookup_var2 : ((SCode.Ident * Env.Item) list,SCode.Ident)
	  => Types.Var =

  rule	id = n
	--------------------------------------------
	lookup_var2((n,Env.VAR(fv))::_,id) => fv

  rule	lookup_var2(fs,id) => fv
	------------------------
	lookup_var2(_::fs,id) => fv

end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)

relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(dim,t),
			 Exp.WHOLEDIM::ys)
	  => Types.T_ARRAY(dim,t')

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.SLICE(Exp.ARRAY(se))::ys)
	  => Types.T_ARRAY(Types.DIM(SOME(dim)),t')

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts(Types.T_ARRAY(Types.DIM(SOME(sz)),t),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

  rule	print "- check_subscripts failed (" &
	Types.print_type t & print ", [" &
 	Exp.print_list(s,Exp.print_subscript,",") & print "])\n"
	-----------------------------------
	check_subscripts(t,s) => fail

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_))
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	print "- lookup_in_var failed\n"
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)

relation lookup_var_f : ((SCode.Ident * Env.Item) list,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule  lookup_var2(f, id)
	  => Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	lookup_var2(f, id) => Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)

end

(**
 **  Package handling
 **)

(** relation: locate_package
 **
 ** This relation finds a package in a file and loads it.
 **
 ** It appends `.mo' to the name of the package and tries to load a
 ** file of that name.  This relation should be memoized, as it
 ** currently reloads the package each time it is used.
 **)

relation locate_package : (Env.Env, string) => SCode.Class =

  rule	lookup_class(env, Absyn.IDENT(pack)) => (c, env) &
	assert_package c
	----------------
	locate_package (env, pack) => c

  rule	string_append (pack, ".mo") => filename &
	print "Loading " & print filename & print "...\n" &
	Parser.parse filename => ((c as Absyn.CLASS(classname,_,_,_))::_) &
	pack = classname &
	SCode.elaborate [c] => [c'] &
	assert_package c'
	--------------------------------------------
	locate_package(env, pack) => c'

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,Absyn.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
 
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,
					       SCode.PARTS(els,_,_)),
				 path) => (c, Env.empty_env)

end
(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	

