(** file: lookup.rml
 **)

module Lookup:

  with "classinf.rml"
  with "types.rml"
  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "mod.rml"
  with "explode.rml"

  relation lookup_class     : (Env.Env, Absyn.Path) => (SCode.Class, SCode.Mod)
  relation lookup_var       : (Env.Env,Exp.ComponentRef)
	  			=> (Absyn.VarAttr,Types.Type,Env.Binding)
  relation lookup_var_local : (Env.Env, Absyn.Ident) => Env.FrameVar

end

with "parse.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** nave is looked for in it.
 **)

(** relation: lookup_class
 **)

relation lookup_class: (Env.Env,Absyn.Path) => (SCode.Class,SCode.Mod) =

  rule	lookup_class_in_env(env,path) => (c,m)
	--------------------------------------
	lookup_class(env, path) => (c,m)

  rule	lookup_package_class (env,pack,path) => (c,m)
	--------------------------------------
	lookup_class(env, Absyn.QUALIFIED(pack,path)) => (c,m)

end

(** relation: lookup_var
 **)

relation lookup_var : (Env.Env,Exp.ComponentRef)
	  => (Absyn.VarAttr, Types.Type, Env.Binding) =

  rule	(* print " lookup_var: looking in frame\n" & *)
	lookup_var_f(vs,ref) => (attr,ty,binding)
	-------------------------
	lookup_var(Env.FRAME(vs,_)::fs,ref) => (attr,ty,binding)

  rule	(* print " lookup_var: next frame\n" & *)
	lookup_var(fs,ref) => (attr,ty,binding)
	--------------------
	lookup_var(_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_local
 **)

relation lookup_var_local : (Env.Env, SCode.Ident) => Env.FrameVar =

  rule  lookup_var2(vs, id) => fv
	-------------------------
	lookup_var_local(Env.FRAME(vs,_)::_, id) => fv

end

(** - Internal relations *)

relation lookup_class_in_frame: ((SCode.Ident * SCode.Class *
				  SCode.Mod) list,
				 SCode.Ident)
	  => (SCode.Class,SCode.Mod) =

  rule	(* print "  lookup_class_in_frame(" & print id & print "): " &
	print n & print "\n" & *)
	id = n
	---------------------------------------------------------
	lookup_class_in_frame((n,c,m)::_, id) => (c,m)

  rule	lookup_class_in_frame(fs,id) => (c,m)
	------------------------------
	lookup_class_in_frame(_::fs,id) => (c,m)

end
(**)
relation lookup_class_in_env: (Env.Env,Absyn.Path) => (SCode.Class,SCode.Mod) =

  rule	lookup_class_in_frame(cs,id) => (c,m)
	---------------------
	lookup_class_in_env(Env.FRAME(_,cs)::fs,Absyn.IDENT(id)) => (c,m)

  rule	lookup_class_in_env(fs,id) => (c,m)
	---------------------
	lookup_class_in_env(f::fs,id) => (c,m)

end
(**)
relation lookup_package_class : (Env.Env, string, Absyn.Path)
	  => (SCode.Class, SCode.Mod) =

  rule	locate_package (env,packname) => pack &
	(* FIXME: modifications? *)
	lookup_class_in_package (pack, path) => c
	-------------------------------------
	lookup_package_class (env, packname, path) => (c, SCode.NOMOD)

end
(**)
relation lookup_var2: ((SCode.Ident * Env.FrameVar) list,SCode.Ident)
	  => Env.FrameVar =

  rule	id = n
	--------------------------------------------
	lookup_var2((n,fv)::_,id) => fv

  rule	lookup_var2(fs,id) => fv
	------------------------
	lookup_var2(_::fs,id) => fv

end
(**)
relation check_subscripts : (Absyn.ArrayDim, Exp.Subscript list) => () =

	(* FIXME: Check range too? *)
  axiom check_subscripts(Absyn.NODIM, [])
  axiom check_subscripts(Absyn.ONEDIM(_), [_])
  axiom check_subscripts(Absyn.TWODIM(_,_), [_,_])

end
(**)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Absyn.VarAttr,Types.Type) =

	(* FIXME: Check protected flag *)

	(* FIXME: Should I really strip the ArrayDim? *)
  rule  Types.lookup_component(ty, id)
	  => ((_,Absyn.ATTR(ad,fl,vt,di),ty')) &
	check_subscripts(ad, ss)
	------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Absyn.ATTR(Absyn.NODIM,fl,vt,di),ty')

  rule  Types.lookup_component(ty, id)
	  => ((_,Absyn.ATTR(ad,fl,vt,di),ty')) &
	check_subscripts(ad, ss) &
	lookup_in_var(ty', vs) => (attr, ty'')
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty'')

end	
(**)
relation lookup_var_f : ((SCode.Ident * Env.FrameVar) list,
			 Exp.ComponentRef)
	  => (Absyn.VarAttr, Types.Type, Env.Binding) =

  rule  (* print " lookup_var_f 1: " & print id & print "\n" & *)
	lookup_var2(f, id) => Env.FRAMEVAR(n,Absyn.ATTR(ad,f,vt,di),ty,bind) &
	check_subscripts(ad,ss)
	----------------------------------
	lookup_var_f(f,Exp.CREF_IDENT(id,ss))
	  => (Absyn.ATTR(Absyn.NODIM,f,vt,di),ty,bind)

  rule  (* print " lookup_var_f 2: " & print id & print "\n" & *)
	lookup_var2(f, id) => Env.FRAMEVAR(n,Absyn.ATTR(ad,_,_,_),ty,ass) &
	check_subscripts(ad,ss) &
	lookup_in_var(ty, ids) => (attr,ty)
	----------------------------------
	lookup_var_f(f,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty,ass)

end


(**
 **  Package handling
 **)

relation locate_package : (Env.Env, string) => SCode.Class =

  rule	lookup_class(env, Absyn.IDENT(pack)) => (c,_) &
	(* FIXME: modifications? *)
	assert_package c
	----------------
	locate_package (env, pack) => c

  rule	string_append (pack, ".mo") => filename &
	print "Loading " & print filename & print "...\n" &
	Parser.parse filename => ((c as Absyn.CLASS(classname,_,_,_))::_) &
	pack = classname &
	SCode.elaborate [c] => [c'] &
	assert_package c'
	--------------------------------------------
	locate_package(env, pack) => c'

end

relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,Absyn.R_PACKAGE,_)

end

relation lookup_class_in_package : (SCode.Class, Absyn.Path) => SCode.Class =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,
					       SCode.PARTS(els,_,_)),
				 path) => c

end

relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

	(* FIXME: Doesn't complain about an identifier being used for *)
	(* both a variable and a class *)
  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => c'
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	

