(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 prefix.rml
 ** module:      Prefix
 ** description: Prefix management
 **
 ** RCS: $Id$
 **
 ** When instantiating an expression, there is a prefix that has to be
 ** added to each variable name to be able to use it in the flattened
 ** equation set. These relations take care of adding the prefixes.
 **)

module Prefix:

  with "absyn.rml"
  with "exp.rml"
  with "env.rml"
  with "lookup.rml"
  
  datatype Prefix = NOPRE
		  | PRE of string * int list * Prefix

  relation prefix_add : (Exp.Ident, int list, Prefix) => Prefix
  relation prefix_to_cref : Prefix => Exp.ComponentRef
  relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef
  relation prefix_cref_list : (Prefix, Exp.ComponentRef list) =>
	  Exp.ComponentRef list
  relation prefix_exp  : (Env.Env,Exp.Exp, Prefix) => Exp.Exp
  relation prefix_exp_list  : (Env.Env,Exp.Exp list, Prefix) => Exp.Exp list
  relation prefix_path : (Absyn.Path,Prefix) => Absyn.Path
  relation print_prefix_str : Prefix => string
  relation print_prefix : Prefix => ()
  relation prefix_to_path: Prefix => Absyn.Path

end


with "util.rml"
with "print.rml"

relation print_prefix_str : Prefix => string =

  axiom	print_prefix_str NOPRE => "<NOPRE>"

  axiom	print_prefix_str PRE(str, [], NOPRE) => str

  rule	string_append (str, "[]") => s
	------------------------------
	print_prefix_str PRE(str, _, NOPRE) => s

  rule	print_prefix_str rest => rest' &
	string_append (rest', ".") => s &
	string_append (s, str) => s'
	----------------------------
	print_prefix_str PRE(str, [], rest) => s'

  rule	print_prefix_str rest => rest' &
	string_append (rest', ".") => s &
	string_append (s, str) => s' &
	string_append (s', "[]") => s''
	----------------------------
	print_prefix_str PRE(str, _, rest) => s''

end

relation print_prefix : Prefix => () =


  rule	print_prefix_str p => s &
	Print.print_buf s
	------------------------------
	print_prefix p

end
	

(** relation: prefix_add
 **
 ** This relation is used to extend a prefix with another level.  If
 ** the prefix `a.b[10].c' is extended with `d' and an empty subscript
 ** list, the resulting prefix is `a.b[10].c.d'.  Remember that
 ** prefixes components are stored in the opposite order from the
 ** normal order used when displaying them.
 **)

relation prefix_add : (Exp.Ident, int list, Prefix) => Prefix =

  axiom prefix_add(i,s,p) => PRE(i,s,p)

end

(** relation: prefix_path
 **
 ** Prefix a `Path' variable by adding the supplied prefix to it and
 ** returning a new `Path'.
 **)

relation prefix_path: (Absyn.Path,Prefix) => Absyn.Path =

  axiom	prefix_path(p,NOPRE) => p
  
  rule	prefix_path(Absyn.QUALIFIED(s,p),ss) => p'
	---------------------------
	prefix_path(p,PRE(s,_,ss)) => p'

end

(** relation: prefix_to_path
 **
 ** Convert a Prefix to a `Path'
 **)

relation prefix_to_path: Prefix => Absyn.Path =

  rule	Print.print_buf "#-- Error: Cannot convert empty prefix to a path\n"
	---------------------------------------------------------
	prefix_to_path NOPRE => fail

  axiom	prefix_to_path PRE(s,_,NOPRE) => Absyn.IDENT(s)
  
  rule	prefix_to_path ss => p
	---------------------------
	prefix_to_path PRE(s,_,ss) => Absyn.QUALIFIED(s,p)

end

(** relation: prefix_cref
 **
 ** Prefix a `ComponentRef' variable by adding the supplied prefix to
 ** it and returning a new `ComponentRef'.
 **
 ** LS: Changed to call prefix_to_cref which is more general now
 **)

relation prefix_cref : (Prefix, Exp.ComponentRef) => Exp.ComponentRef =

  rule	prefix_to_cref2 (pre, SOME(cref)) => cref'
	---------------------------------
	prefix_cref (pre, cref) => cref'

end


(** relation: prefix_to_cref
 **
 ** Convert a prefix to a component reference.
 **)

relation prefix_to_cref : Prefix => Exp.ComponentRef =

  rule	prefix_to_cref2 (pre, NONE) => cref'
	-----------------------------------
	prefix_to_cref pre => cref'

end


(** relation: prefix_to_cref2
 **
 ** Convert a prefix to a component reference. Converting NOPRE with no
 ** component reference is an error because a component reference cannot be
 ** empty
 **)

relation prefix_to_cref2 : (Prefix, Exp.ComponentRef option) => Exp.ComponentRef =

  rule	Print.print_buf "#-- Cannot convert empty prefix to component reference\n"
	----------------------------------------------------------------
	prefix_to_cref2 (NOPRE, NONE) => fail

  axiom	prefix_to_cref2 (NOPRE, SOME(cref)) => cref

  rule	Exp.int_subscripts s => s' &
	prefix_to_cref2 (xs, SOME(Exp.CREF_IDENT(i,s'))) => cref'
	--------------------------
	prefix_to_cref2 (PRE(i,s,xs), NONE) => cref'

  rule	Exp.int_subscripts s => s' &
	prefix_to_cref2 (xs, SOME(Exp.CREF_QUAL(i,s',cref))) => cref'
	--------------------------
	prefix_to_cref2 (PRE(i,s,xs), SOME(cref)) => cref'

end


(** relation: prefix_exp
 **
 ** Add the supplied prefix to all component references in an
 ** expression.
 **)

relation prefix_exp : (Env.Env,Exp.Exp,Prefix) => Exp.Exp =

  axiom	prefix_exp(_,e as Exp.ICONST(_),_) => e
  axiom	prefix_exp(_,e as Exp.RCONST(_),_) => e
  axiom	prefix_exp(_,e as Exp.SCONST(_),_) => e
  axiom	prefix_exp(_,e as Exp.BCONST(_),_) => e

  rule	Lookup.lookup_var_local(env,p) => (_,_,_) &
	prefix_cref(pre,p) => p'
	--------------------------
	prefix_exp(env,Exp.CREF(p,t),pre) => Exp.CREF(p',t)

  rule	not Lookup.lookup_var_local(env,p) => (_,_,_)
	--------------------------
	prefix_exp(env,e as Exp.CREF(p,_),pre) => e

  rule	prefix_exp(env,e1,p) => e1' &
	prefix_exp(env,e2,p) => e2'
	-----------------------
	prefix_exp(env,Exp.BINARY(e1,o,e2),p) => Exp.BINARY(e1',o,e2')

  rule	prefix_exp(env,e1,p) => e1'
	-----------------------
	prefix_exp(env,Exp.UNARY(o,e1),p) => Exp.UNARY(o,e1')

  rule	prefix_exp(env,e1,p) => e1' &
	prefix_exp(env,e2,p) => e2'
	-----------------------
	prefix_exp(env,Exp.LBINARY(e1,o,e2),p) => Exp.LBINARY(e1',o,e2')

  rule	prefix_exp(env,e1,p) => e1'
	-----------------------
	prefix_exp(env,Exp.LUNARY(o,e1),p) => Exp.LUNARY(o,e1')

  rule	prefix_exp(env,e1,p) => e1' &
	prefix_exp(env,e2,p) => e2'
	-----------------------
	prefix_exp(env,Exp.RELATION(e1,o,e2),p) => Exp.RELATION(e1',o,e2')

  rule	prefix_exp(env,e1,p) => e1' &
	prefix_exp(env,e2,p) => e2' &
	prefix_exp(env,e3,p) => e3'
	-----------------------
	prefix_exp(env,Exp.IFEXP(e1,e2,e3),p) => Exp.IFEXP(e1',e2',e3')

  rule	prefix_exp(env,cref,p) => cref' &
	prefix_exp(env,dim,p) => dim'
	----------------------------
	prefix_exp(env,Exp.SIZE(cref,SOME(dim)),p) => Exp.SIZE(cref',SOME(dim'))

  rule	prefix_exp(env,cref,p) => cref'
	-------------------------------
	prefix_exp(env,Exp.SIZE(cref,NONE),p) => Exp.SIZE(cref',NONE)

  rule	prefix_exp_list(env,es,p) => es'
	-----------------------
	prefix_exp(env,Exp.CALL(f,es,b,bi),p) => Exp.CALL(f,es',b,bi)

	(**)
  axiom	prefix_exp(env,Exp.ARRAY(t,a,[]),p) => Exp.ARRAY(t,a,[])

  rule	prefix_exp_list(env,es,p) => es'
	-------------------------------
	prefix_exp(env,Exp.ARRAY(t,a,es),p) => Exp.ARRAY(t,a,es')


(* PR. *)
  rule	prefix_exp_list(env,es,p) => es'
	-------------------------------
	prefix_exp(env,Exp.TUPLE(es),p) => Exp.TUPLE(es')

  axiom	prefix_exp(env,Exp.MATRIX(t,a,[]),p) => Exp.MATRIX(t,a,[])

  rule	Util.list_map(x,Util.tuple2_1) => el &
	Util.list_map(x,Util.tuple2_2) => bl &
	prefix_exp_list(env,el,p) => el' &
	Util.list_thread_tuple(el',bl) => x' &
	prefix_exp(env,Exp.MATRIX(t,a,xs),p) => Exp.MATRIX(t,b,xs')
	----------------------------------------
	prefix_exp(env,Exp.MATRIX(t,a,x::xs),p) => Exp.MATRIX(t,a,(x'::xs'))

  rule	prefix_exp(env,start, p) => start' &
	prefix_exp(env,stop, p) => stop'
	------------------------------
	prefix_exp(env,Exp.RANGE(t,start,NONE,stop), p)
	  => Exp.RANGE(t,start',NONE,stop')

  rule	prefix_exp(env,start, p) => start' &
	prefix_exp(env,step, p) => step' &
	prefix_exp(env,stop, p) => stop'
	------------------------------
	prefix_exp(env,Exp.RANGE(t,start,SOME(step),stop), p)
	  => Exp.RANGE(t,start',SOME(step'),stop')

  rule	prefix_exp(env,e,p) => e'
	-----------------------
	prefix_exp(env,Exp.CAST(Exp.REAL,e), p) => Exp.CAST(Exp.REAL,e')

  rule	prefix_exp(env,exp,p) => exp' &
	prefix_exp(env,iterexp,p) => iterexp'
	-------------------------------------
	prefix_exp(env,Exp.REDUCTION(fcn,exp,id,iterexp), p) => Exp.REDUCTION(fcn,exp',id,iterexp')

  rule	Print.print_buf "- prefix_exp failed\n" &
	Print.print_buf "  expression: " & Exp.print_exp e & Print.print_buf "\n"
	-----------------------------------------------------
	prefix_exp(_,e,_) => fail

end

(** relation: prefix_exp_list
 ** 
 ** This relation prefixes a list of expressions using the
 ** `prefix_exp' relation.
 **)

relation prefix_exp_list: (Env.Env,Exp.Exp list,Prefix) => Exp.Exp list =

  axiom	prefix_exp_list(_,[],_) => []

  rule	prefix_exp(env,e,p) => e' &
	prefix_exp_list(env,es,p) => es'
	---------------------------
	prefix_exp_list(env,e::es,p) => (e'::es')

end	

(** relation: prefix_cref_list
 ** 
 ** This relation prefixes a list of component references using the
 ** `prefix_cref relation.
 **)

relation prefix_cref_list: (Prefix, Exp.ComponentRef list) => Exp.ComponentRef list =

  axiom	prefix_cref_list(_, []) => []

  rule	prefix_cref(p,cr) => cr' &
	prefix_cref_list(p, crlist) => crlist'
	---------------------------
	prefix_cref_list(p,cr::crlist) => (cr'::crlist')

end	
