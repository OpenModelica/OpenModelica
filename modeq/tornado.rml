(* 
 Copyright MathCore Engineering 2004-10-21
 This source is non-free and should not be included in OpenModelica
 *)

(**
 **
 ** file:	 tornado.rml
 ** module:		 Tornado
 ** description: Code generation of Nodelica models including equation
 ** code and symbolic information to the Tornado-1 format.
 ** Part of the Hemmis project at MathCore Engineering AB.
 **
 ** RCS: $Id$
 ** 
 **)
 module Tornado:
  
  with "dae.rml"
with "absyn.rml"

(* Generates code according to the Tornado-1 format *)
  relation generate_code: (Absyn.Program, DAE.DAElist, Absyn.Path) => ()
	      
	      
	      
  end
with "interactive.rml"
with "util.rml"
with "system.rml"
with "daelow.rml"
with "exp.rml"
with "debug.rml"
with "rtopts.rml"
with "inst.rml"
with "values.rml"
with "tornadoext.rml"
with "explode.rml"
with "lookup.rml"
with "env.rml"
with "simcodegen.rml"

(** relation: generate_code
 ** This is the main relation that generates Tornado1 C++ code from the flat Modelica model
 ** It will generate two files <modelname>.cpp and <modelname>.hpp, the implementation file and 
 ** the header file. Those will currently be put in the current directory.
 ** The implementation uses the DAELow module to lower the flat modelica model such that it
 ** can be BLT sorted and indexed, etc.
 **)

 relation generate_code:	 (Absyn.Program, DAE.DAElist, Absyn.Path) => () =
	     
  rule	DAELow.lower(dae) => dae' &
         generate_blt(dae') => (dae'',blt,ass1,ass2) &
	     DAELow.calculate_values(dae'') => dae''' & 
	     Absyn.path_string(class) => cname &
         generate_code_for_hierarhical_objects(class,dae''',p) => hie_code &
	     generate_header(cname) => header &
	     generate_impl_header(cname) => implheader &
	     generate_constructor(cname,p,dae''') => constr &
	     generate_var_defines(dae''') => defines &
	     generate_compute_methods(cname,dae''',p,blt,ass1,ass2) => cmethods &
         generate_dll_code(cname) => dll_code &
         TORNADOEXT.get_hierachical_code(cname) => (hierachical_header_code,hierachical_code) &
         (*TORNADOEXT.dump_testing() &  *)
         Util.string_append_list([implheader,hierachical_code,constr,defines,cmethods]) => impl &
         Util.string_append_list([header,hierachical_header_code,"#endif\n"]) => header' &
	     string_append(cname,".h") => headerfile &
	     string_append(cname,".cpp") => implfile &
	     string_append(cname,"DLL.cpp") => dllfile &
	     print "Generating: " & print headerfile & print "\n" &
	     System.write_file(headerfile,header') &
	     print "Generating: " & print implfile & print "\n" &
	     System.write_file(implfile,impl) &
	     print "Generating: " & print dllfile & print "\n" &
	     System.write_file(dllfile,dll_code) 
	     -------------------------------------------------------------------
	     generate_code(p,dae,class) => 
         
  rule	print "generate_code failed\n" 
	     ------------------------------
	     generate_code(_,_,_) => fail
 end

(** relation generate_dll_code 
 ** This relation generate the code that is needed in the file
 ** used for generation of the dll. 
 **)
 relation generate_dll_code: (string) => string =

  rule  Util.string_append_list(["#ifdef _MSC_VER\n",
                                 "#pragma warning(disable:4250)\n",
                                 "#pragma warning(disable:4786)\n",
                                 "#endif\n",
                                 "\n",
                                 "#include \"Tornado/EE/Common/DLL.h\"\n",
                                 "\n",
                                 "#include \"",cname,".h\"\n",
                                 "\n",
                                 "using  namespace std;\n",
                                 "using namespace Common;\n",
                                 "using namespace Tornado;\n",
                                 "\n",
                                 "#ifdef _WIN32\n",
                                 "#include <windows.h>\n",
                                 
                                 "BOOL APIENTRY\n",
                                 "DllMain(HANDLE hModule,\n",
                                 "        DWORD ul_reason_for_call,\n",
                                 "        LPVOID lpReserved)\n",
                                 "{\n",
                                 "  switch (ul_reason_for_call)\n",
                                 "  {\n",
                                 "    case DLL_PROCESS_ATTACH:\n",
                                 "    case DLL_THREAD_ATTACH:\n",
                                 "    case DLL_THREAD_DETACH:\n",
                                 "    case DLL_PROCESS_DETACH:\n",
                                 "      break;\n",
                                 "  }\n",
                                 "  return TRUE;\n",
                                 "}\n",
                                 "#endif\n",
                                 "\n",
                                 "static wstring g_ID = L\"Tornado.MSLE.DAEModel.",cname,"\";\n",
                                 "\n",
                                 "void*\n",
                                 "GetID()\n",
                                 "{\n",
                                 "  return (void*)g_ID.c_str();\n",
                                 "}\n",
                                 "\n",
                                 "void*\n",
                                 "Create()\n",
                                 "{\n",
                                 "  CDAEModel* pDAEModel = new C",cname,"(L\"\");\n",
                                 "\n",
                                 "  return (void*)pDAEModel;\n",
                                 "}\n"]) => res
         ------------------------------
         generate_dll_code(cname) => res
         

         
  rule  print "generate_dll_code failed\n" 
	     ------------------------------
	     generate_dll_code(_) => fail
         
 end        

 relation generate_code_for_hierarhical_objects: (Absyn.Path,DAELow.DAELow,Absyn.Program)
          => string =

  rule  SCode.elaborate(program) => p' &
 	     Inst.make_env_from_program(p',Absyn.IDENT("")) => env  & 
         Absyn.path_string(class_path) => str &
         (*         TORNADOEXT.set_top_model(str) & *)
         generate_code_from_class(class_path,dae,p',program,env) => res 
         
         (*         list_length(elements) => tmp_int & int_string(tmp_int) => tmp_int_str &  *)
         (*         print "LIST LENGTH: " & print tmp_int_str  *)
         (*Util.string_delimit_list(class_,"\n") => str & *)
         
         (*& Util.string_append_list(comp_name_list) => str_res &
          print "COMPONENTS " & print str_res & print "\n" *)
         --------------------------------------
         generate_code_for_hierarhical_objects(class_path,dae,program) => res
         
 end
(*         Interactive.get_component_name_and_type_and_comment(elements)   *)

 relation generate_code_from_class:(Absyn.Path,DAELow.DAELow,
                                    SCode.Program,Absyn.Program,Env.Env) 
          => string =
           
  rule  Interactive.get_pathed_class_in_program(class_path,a_program) => cdef & 
         Lookup.lookup_class(env,class_path,false) => (class,env') &
         
         Interactive.get_components_in_class(cdef) => elements &
         Absyn.path_string(class_path) => str &
         (*         print "\n--------------------------------\n" & print str & print ":\n" & *)
         generate_code_from_elements(class_path,elements,dae,program,a_program,env') => res 
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) => res
         
  rule  Absyn.path_string(class_path) => str &
         Interactive.is_primitive(Absyn.CREF_IDENT(str,[]),a_program) => true 
         (*         print "\n-----------PRIMITIVE--------------\n" & print str & print ":\n" *)
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) => ""
         
  rule  Absyn.path_string(class_path) => str 
         (*         print "\n-----------NO MATCH--------------\n" & print str & print ":\n" *)
         --------------------------------------
         generate_code_from_class(class_path,dae,program,a_program,env) => ""
         
         
         
 end

 relation generate_code_from_elements:(Absyn.Path,Absyn.Element list,  DAELow.DAELow,
                                       SCode.Program,Absyn.Program, Env.Env) 
          => string =
           
  axiom generate_code_from_elements(_,[],_,_,_,_) => "" 
         
         (*   rule  Interactive.get_component_name_and_type_and_comment(element,env)  *)
         (*           => type_str::res & *)
         (*         print "TYpe: " & print type_str & print "\n"  *)
         (*         -------------------------------------- *)
         (*         generate_code_from_elements(element::rest,dae,env) => "" *)
         
         (*   rule print "generate_code_from_elements failed"  *)
         (*         -------------------------------------- *)
         (*         generate_code_from_elements(_,_,_) => fail *)
         
         
  rule  Lookup.lookup_class(env,p,true) => (c,env') &
	     Env.get_env_path(env') => SOME(envpath) &
	     Absyn.path_last_ident(p) => tpname &
         Absyn.join_paths(envpath,Absyn.IDENT(tpname)) => p' &
	     Absyn.path_string(p') => typename &
         
         Interactive.get_componentitems_name(lst) => str_lst &
         Util.string_append_list(str_lst) => tml_str &
         
         (*         print "TYPE: " & print typename & print " " & print tml_str & print "\n"  & *)
         generate_code_from_elements(class_path,rest,dae,program,a_program,env') => res &
         generate_code_from_class(p,dae,program,a_program,env') => res' & 
         get_componentitems_name(lst) => name_list &
         add_variable_to_list(class_path,p,name_list,dae,program,a_program,env') 
         (* 	    get_componentitems_name(lst) => names & *)
         (* 	    prefix_typename(typename,names) => lst *)
	     -------------------------------------------
	     generate_code_from_elements(class_path,
                                     Absyn.ELEMENT(_,_,_,_,
                                                   Absyn.COMPONENTS(_,p,lst),_,_,_)::rest,
                                     dae,
                                     program,a_program,
                                     env) => ""
         
         
  rule  Absyn.path_string(p) => typename &
         
         get_componentitems_name(lst) => str_lst &
         Util.string_append_list(str_lst) => tml_str &
         
         (*         print "bape: " & print typename & print " " & print tml_str & print "\n"  & *)
         generate_code_from_elements(class_path,rest,dae,program,a_program,env) => res &
         generate_code_from_class(p,dae,program,a_program,env) => res' &
         get_componentitems_name(lst) => name_list &
         add_variable_to_list(class_path,p,name_list,dae,program,a_program,env) 
         
         (* 	    get_componentitems_name(lst) => names & *)
         (* 	    prefix_typename(typename,names) => lst *)
         -------------------------------------------
         generate_code_from_elements(class_path,
                                     Absyn.ELEMENT(_,_,_,_,Absyn.COMPONENTS(_,p,lst),_,_,_)::rest,
                                     dae,
                                     program,a_program,
                                     env) => ""
         
  rule  print "lalalalalalalalalala" 
         ------------------------------------------
	 generate_code_from_elements(class_path,_,dae,program,a_program,env) => ""
         
  rule  print "generate_code_from_elements failed\n"
	     -------------------------------------------
	     generate_code_from_elements(_,_,_,_,_,_) => fail
         
         
 end

(**
 ** arg1 the name for the top class
 ** arg2 the name for the class of type
 ** arg3 the names of variables - this is a list because of the possibility of 
 **      writing Real x,y,z;
 **)
 relation add_variable_to_list:(Absyn.Path,Absyn.Path,string list,DAELow.DAELow,
                                SCode.Program,Absyn.Program,Env.Env) 
          => () =

  axiom add_variable_to_list(_,_,[],_,_,_,_) => ()
         
  rule  Interactive.get_pathed_class_in_program(variable_class_path,a_program) => 
         (cdef as Absyn.CLASS(_,_,_,_,_,Absyn.DERIVED(_,_,_,_,_))) &
         Absyn.path_string(variable_class_path) => str &
         Absyn.path_string(class_path) => str' &
         get_direction_for_variable(variable_name,str',dae) => (var_type,direction) &
         TORNADOEXT.add_variable_to_class(str',variable_name,var_type,direction) &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*          & print str' & print "\nA-----------derived-------------\n" *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
  rule  Absyn.path_string(variable_class_path) => str &
         Interactive.is_primitive(Absyn.CREF_IDENT(str,[]),a_program) => true & 
         Absyn.path_string(variable_class_path) => str &
         Absyn.path_string(class_path) => str' &
         get_direction_for_variable(variable_name,str',dae) => (var_type,direction) &
         TORNADOEXT.add_variable_to_class(str',variable_name,var_type,direction) &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*           & print variable_name & print " " & print str'  & print "\nA-----------PRIMITIVE--------------\n"   *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()

  rule  Interactive.get_pathed_class_in_program(variable_class_path,a_program) => cdef & 
         Lookup.lookup_class(env,variable_class_path,false) => (class,env') &
         Absyn.path_string(class_path) => str' &
         Absyn.path_string(variable_class_path) => var_str' &
         
         
         Absyn.path_string(variable_class_path) => str &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) &
         TORNADOEXT.add_variable_to_class(str',variable_name,"class",var_str') 
         (*          & print str' & print "\nA--------------------------------\n"   *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,

                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
         
         
  rule  Absyn.path_string(variable_class_path) => str &
         add_variable_to_list(class_path,variable_class_path, rest, dae,program,a_program,env) 
         (*          & print str &  print "\nA-----------NO MATCH--------------\n"  *)
         --------------------------------------
         add_variable_to_list(class_path,
                              variable_class_path,
                              variable_name::rest,
                              dae,program,a_program,env) => ()
         
         
         
 end

(**
 ** arg1 name of the variable
 ** arg2 name of the class where the variable is
 ** arg2 the DAELow.DAELow that contains all the varialbles
 ** 
 ** return (type,direction) as string 
 **)

 relation get_direction_for_variable:(string, string,DAELow.DAELow) 
          => (string,string) = 
           
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","output")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","bidir")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("variable","input")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("parameter","")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.CONST,_,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("parameter","")

  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("dummy_der","")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.DUMMY_DER,_,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("dummy_state","")
         
  rule  find_dae_var(name,class_name,dae)
          => DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,start,_,_,_)
           --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("state","")
         
  rule  find_dae_var(name,class_name,dae)
          => var & DAELow.dump_vars([var]) &
           print "unknown type adn direction on variable\n"
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => ("<unknown>","<unknown>")
         
  rule  print "-get_direction_for_variable failed: " & print name  
         & print " in class " & print class_name  & print "\n" 
         --------------------------------------
         get_direction_for_variable(name,class_name,dae) => fail
         
 end

(** relation find_dae_var
 ** arg1 name of the variable
 ** arg2 name of the class where the variable is
 ** arg2 the DAELow.DAELow that contains all the varialbles
 **)
            
relation find_dae_var:(string, string,DAELow.DAELow) => DAELow.Var =  
        
  rule array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(vars,knvars) => allvars &
        find_dae_var2(name,class_name,allvars) => var 
        --------------------------------------
        find_dae_var(name,
                     class_name,
                     DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                   DAELow.VARIABLES(_,knvararr,_,_),
                                   eqn,seqn,_,_))
          => var
          
  rule  (*print "find_dae_var failed\n " *)
        --------------------------------------
        find_dae_var(_,_,_) => fail
        
end


relation find_dae_var2:(string,string,DAELow.Var list) => DAELow.Var =

        
  rule  (*print "no such variable\n "*)
        -------------------------------------
        find_dae_var2(name,class_name,[]) => fail


  rule  Exp.cref_str(cr) => cr_str &
        (* pick out the last of the names "a" in the name Temp3.a *)
        Util.string_split_at_char(cr_str,#".") => str_list &
        Util.list_last(str_list) => var_name &
	list_reverse(class_paths) => from_class::_ &
        Absyn.path_string(from_class) => from_class_str &
        Util.string_equal(class_name,from_class_str) => true &
        Util.string_equal(var_name,name) => true 
        
        (*          & print var_name & print " = " & print name & print " " &  *)
        (*         print from_class_str & print " = " & print class_name & print "\n"  *)
        -------------------------------------
        find_dae_var2(name,
                      class_name,
                      (var as DAELow.VAR(cr,_,_,_,_,_,_,start,_,org_name,class_paths))::rest) 
          => var
          
  rule  find_dae_var2(name,class_name,rest) => var 
        -------------------------------------
        find_dae_var2(name,
                      class_name,
                      DAELow.VAR(cr,_,_,_,_,_,_,start,_,org_name,from_class)::rest) 
          => var
          
end



(** relation_get_componentitems_name
 ** This relation takes a `ComponentItems' list and returns a  list of all
 ** component names (if any).
 **)
relation get_componentitems_name: Absyn.ComponentItem list => string list =
	
  rule	(* When component has array dimensions *)
	get_componentitems_name(rest) => lst &
	string_append(c1,"[1]") => c1'
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_::_,_),_)::rest)
          => c1'::lst
	  
  rule  (* .. otherwise if no dimensions *)
	get_componentitems_name(rest) => lst 
	----------------------------
	get_componentitems_name(Absyn.COMPONENTITEM(Absyn.COMPONENT(c1,_,_),
                                                    _)::rest) 
          => c1::lst
          
  rule	get_componentitems_name(rest) => res
	------------------------------------
	get_componentitems_name(_::rest) => res
         
  axiom	get_componentitems_name([]) => []
end
(** relation: generate_header
 ** Generate the content of the header file. It only needs the name of the Modelica model.
 **)
relation generate_header: string => string =

  rule  System.toupper cname => CNAME &
	    Util.string_append_list(["#ifndef __",CNAME,"_H__\n"]) => r1 &
	    Util.string_append_list(["#define __",CNAME,"_H__\n"]) => r2 &
	    Util.string_append_list(["\n#include \"Tornado/EE/MSLE/MSLE.h\"\n",
				                 "\n\nclass C",cname," : public Tornado::CDAEModel\n"]) => r3 &
	    Util.string_append_list(["{\n  public:\n\n     C",cname,"(const wchar_t* Name);\n",
				                 "\n  public:\n\n",
				                 "    void ComputeInitial();\n",
				                 "    void ComputeTerminal();\n",
				                 "    void ComputeState();\n",
				                 "    void ComputeOutput();\n",
				                 "};\n\n"]) => r4 &
        (* 				 "#endif\n"]) => r4 & *)
	    Util.string_append_list([r1,r2,r3,r4]) => header
	    ------------------------------------------------
	    generate_header(cname) => header


  rule	print "-generate_header failed\n" 
	    ---------------------------------
	    generate_header(_) => fail
end

(** relation generate_impl_header
 ** generate the "header" of the implementation file, i.e. includes, ifdefs etc. 
 ** It is NOT the generation of the headerfile. (That is in the relation generate_header above)
 *)
 relation generate_impl_header: string => string =

  rule	Util.string_append_list(["#ifdef _MSC_VER\n",
				                 "#pragma warning(disable:4250)\n",
				                 "#pragma warning(disable:4786)\n",
				                 "#endif\n",
				                 "\n",
				                 "#include \"",cname,".h\"\n",
				                 "\n",
				                 "#include <math.h>\n",
				                 "\n",
				                 "using namespace Common;\n",
				                 "using namespace Tornado;\n",
				                 "\n"]) => implheader
	     ----------------------
	     generate_impl_header(cname) => implheader
	     
  rule	print "-generate_impl_header failed\n" 
	     -------------------
	     generate_impl_header(_) => fail
 end


(** relation generate_constructor:
 ** Generates the implementation for the constructor which sets up the variables (names)
 ** and their initial values.
 **)
 relation generate_constructor: (string, Absyn.Program, DAELow.DAELow) => string =
	     
	     
  rule	generate_constructor_component_initialization(cname,p) => (initializationvars,comp_name_list) &
         generate_constructor_outputvars(dae) => (outputvars,noOutputVar_str) &
         generate_constructor_inputvars(dae) => (inputvars,noInputVar_str) &
         generate_constructor_algvars(dae) => (algvars,noAlgVar_str',no_alg_vars) &
	     generate_constructor_statevars(dae) => (statevars,noStateVar_str) &
         generate_constructor_parameters(dae) => (parameters,noParamsVar_str) &
         generate_links(dae,comp_name_list) => (links,no_alg_values) &
         int_add(no_alg_vars,no_alg_values) => no_alg_values' &
         generate_no_of_strings(no_alg_values') => noAlgVar_str &
         Util.string_append_list(["C",cname,"::\n",
				                  "C",cname,"(const wchar_t* Name)\n",
				                  "{\n",
				                  "  SetName(Name);\n",
				                  "  SetDesc(L\"",cname," test.\");\n",
				                  "\n",
				                  parameters,
				                  "\n",
				                  "  SetNoIndepVars(1);\n",
				                  "  SetIndepVar(0, new CIndepVar(L\"t\",L\"s\"));\n",
				                  "\n",
				                  outputvars,
				                  "\n",
				                  inputvars,
				                  "\n",
				                  statevars,
				                  "\n",
                                  algvars,
                                  "\n",
				                  "  SetNoIndepVarValues(1);\n",
                                  noOutputVar_str,
                                  noInputVar_str,
                                  noStateVar_str,
                                  noAlgVar_str,
                                  noParamsVar_str,
				                  "\n",
				                  "  Link();\n",
				                  initializationvars,
				                  "\n",
                                  "std::cout << \"linking\" << std::endl;\n",
                                  links,
                                  "\n",
                                  "  Reset();\n",
		                          "}\n",
				                  "\n"]) => constr
	     -----------------------------------------
	     generate_constructor(cname,p,dae) => constr
         
         
  rule	print "-generate_constructor failed\n" 
	     -------------------------------------
	     generate_constructor(_,_,_) => fail
         
 end

(**
 ** generates the strings for "SetNo<...>VarValues(<int>)"
 **)
 relation generate_no_of_strings:(int) => string =
	     
  rule	no_alg_values = 0
         -------------------------------------
         generate_no_of_strings(no_alg_values) => ""
	     
  rule	int_string(no_alg_values) => no_alg_values_str &
         Util.string_append_list(["  SetNoAlgStateVarValues(",
                                  no_alg_values_str,");\n"]) => res_str
         -------------------------------------
         generate_no_of_strings(no_alg_values) => res_str
         
 end

(**
 ** returns the string and numberOfAlgValues
 **)
 relation generate_links:(DAELow.DAELow,string list) => (string, int) = 
         
         
  rule	array_list(vararr) => varlst &
         array_list(knvararr) => knvarlst &
	     Util.list_select(knvarlst,is_param) => knvarlst' &
         list_append(knvarlst',varlst) => all_vars &
         generate_indep_var(comp_name_list,0) => indep_var_list &
         generate_links2(all_vars,0,0,comp_name_list) => (vars_params_list_str,vars_lst,no_alg_values) &
	     
	     generate_simple_equation_links(comp_name_list,seqn,vars,vars2) => simple_equation_links &
	     Util.list_flatten([vars_params_list_str, ["\n"],indep_var_list,vars_lst, 
			                simple_equation_links]) => res_lst &
	     Util.string_append_list(res_lst) => res
         -------------------------------------------
         generate_links(DAELow.DAELOW(vars as DAELow.VARIABLES(_,vararr,_,_),
                                      vars2 as DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_),
		                comp_name_list) => (res,no_alg_values)        
	     
  axiom generate_links(_,_) => ("/* generation of variables linking has failed */",42)
 end

(** relation: generate_simple_equation_links
 ** Generates links for those variables that are eliminated from the equations.
 ** For instance, a=b with 'b'ä eliminated will generate a link to 'a'.
 **)
relation generate_simple_equation_links: (string list, 
					                      DAELow.EquationArray, 
					                      DAELow.Variables,
					                      DAELow.Variables) 
	      => string list =
	      
  rule	DAELow.equation_list(seqns) => eqn_lst  &
	    generate_simple_equation_links2(comp_name_list,eqn_lst,vars,knvars) => res 
	    -----------------------------------------------
	    generate_simple_equation_links(comp_name_list,seqns,vars,knvars) => res

        axiom generate_simple_equation_links(_,_,_,_) => ["/* generation simple_equation_links has failed */"]
end 


(** relation generate_getsubmodel_code
 ** generates the code for GetSubModel(<value>)
 ** TODO: in future this should be GetSubModel(<value>)->GetSubmodel(<value2>)...
 ** if several hireactical levels are present
 **)
relation generate_getsubmodel_code:(string list, Exp.ComponentRef) => string =
  rule	
	    Exp.cref_str(cr) => crs &
        Util.string_split_at_char(crs,#".") => comp_name::_ &
        Util.list_position(comp_name,comp_name_list) => index &
        int_string(index) => index_str &
	    Util.string_append_list(["  ((CDAEModel*)GetSubModel(",index_str,"))"]) => res
	    -------------------------
	    generate_getsubmodel_code(comp_name_list,cr) => res

        (*this print is removed because the model does not need to have submodels*)
  rule	Util.string_append_list(["  this"]) => res
	----------------
	generate_getsubmodel_code(comp_name_list,cr) => res
end

relation generate_simple_equation_links2: (string list, 
					                       DAELow.Equation list,
					                       DAELow.Variables,
					                       DAELow.Variables)
	      => string list =
	      
(*   rule  print "v----------------------\n" & *)
(*         DAELow.get_var(cr,knvars) => (var1 as DAELow.VAR(_,_,_,_,_,_,_,_,_,_,class_path),_) & *)
(*         DAELow.get_var(cr2,vars) => (var2 as DAELow.VAR(_,_,_,_,_,_,_,_,_,_,class_path),_) & *)
(*         DAELow.dump_vars([var1,var2]) & *)
(*         print "^----------------------\n" & *)
(*         int_eq(1,0) => true *)

(*         -------------------------------- *)
(* 	    generate_simple_equation_links2(comp_name_list, *)
(*                                         DAELow.SOLVED_EQUATION(cr,Exp.CREF(cr2,_))::eqns, *)
(*                                         vars, *)
(*                                         knvars) => [""]  *)
        
  axiom generate_simple_equation_links2(_,[],_,_) => []
	    
        
        (* this checks if the the var is a DAELow.Variable *)
        (*if it is then it must decide the direction*)
  rule  generate_getsubmodel_code(comp_name_list,cr) => sub_model_code  &
        Exp.cref_str(cr) => crs &
        Exp.cref_str(cr2) => crs2 &
        Util.string_split_at_char(crs,#".") => comp_path_string_list &
        Util.list_last(comp_path_string_list) => comp_name &
        DAELow.get_var(cr2,vars) 
	      => (to_var as DAELow.VAR(_,_(*DAELow.VARIABLE*),dir',_,_,_,_,_,_,_,_),varindx) &
          DAELow.get_var(cr,knvars) 
	      => (DAELow.VAR(_,DAELow.VARIABLE,dir,_,_,_,_,_,_,_,class_paths),_) &
          (* print "80 \n" &	      list_reverse(class_paths) => _::class_path::_ &  *)
        list_reverse(class_paths) => class_path::_ &  
        Absyn.path_string(class_path) => class_path_str &
        TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &
        int_string(input_number) => input_number_str &
        tornado_direction(dir) => dir_kind &
        int_sub(varindx,1) => varindx' &
        (*         int_string(varindx') => varindxstr & *)
        (* 	    Util.string_append_list([sub_model_code,"->Get",dir_kind,"Var(",input_number_str, *)
                                        (* 				                 ")->LinkValue(this, MSLE_ALG_STATE_VAR, ",  *)
                                        (*                                  varindxstr,"); //", crs," -> ",crs2,"\n"]) => linkstr & *)
        
       	Util.string_append_list([sub_model_code,"->Get",dir_kind,"Var(",input_number_str,")"]) => prefix &
        
        get_TO_link_string_from_dae_var(prefix,to_var,varindx') => linkstr &
        generate_simple_equation_links2(comp_name_list,eqns,vars,knvars) => rest
	    --------------------------------
	    generate_simple_equation_links2(comp_name_list,
                                        DAELow.SOLVED_EQUATION(cr,Exp.CREF(cr2,_))::eqns,
                                        vars,
                                        knvars) 
	      =>  linkstr::rest
	      
  rule	generate_getsubmodel_code(comp_name_list,cr) => sub_model_code  &
	    Exp.cref_str(cr) => crs &
	    Exp.cref_str(cr2) => crs2 &
        Util.string_split_at_char(crs,#".") => comp_path_string_list &
        Util.list_last(comp_path_string_list) => comp_name &
	    DAELow.get_var(cr,knvars)
          => (DAELow.VAR(_,kind,dir,_,_,_,_,_,_,_,class_path),_) &
	      DAELow.get_var(cr2,vars)
 	      => (to_var as DAELow.VAR(_,kind,dir,_,_,_,_,_,_,_,class_paths),varindx) &
	      list_reverse(class_paths) => _::class_path::_ & 
        Absyn.path_string(class_path) => class_path_str &
        print "1 \n" &
        TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &
        int_string(input_number) => input_number_str &
        tornado_from_kind(kind) => tkind &
        int_sub(varindx,1) => varindx' &
        (*         int_string(varindx) => varindxstr & *)
        (* 	    Util.string_append_list([sub_model_code,"->Get",tkind,"Var(",input_number_str, *)
                                        (* 				                 ")->LinkValue(this, MSLE_ALG_STATE_VAR, ", varindxstr,");\n"]) => linkstr & *)

	    Util.string_append_list([sub_model_code,"->Get",tkind,"Var(",input_number_str,")"]) => prefix &
		get_TO_link_string_from_dae_var(prefix,to_var,varindx') => linkstr &
	    generate_simple_equation_links2(comp_name_list,eqns,vars,knvars) => rest
	    --------------------------------
	    generate_simple_equation_links2(comp_name_list,DAELow.SOLVED_EQUATION(cr,Exp.CREF(cr2,_))::eqns,
                                        vars,knvars) 
	      =>  linkstr::rest
	      
  rule	generate_simple_equation_links2(comp_name_list,eqns,vars,knvars) => rest
	    --------------------------------
	    generate_simple_equation_links2(comp_name_list,_::eqns,vars,knvars) 
	      =>  rest	  
          
  rule	print "ERROR, EQUATION in simple equations\n" 
	    --------------------------
	    generate_simple_equation_links2(_,DAELow.EQUATION(_,_)::_,_,_) => fail
        
  rule  print "ERROR, ALGORITHM in simple equations\n" 
	    --------------------------
	    generate_simple_equation_links2(_,DAELow.ALGORITHM(_,_,_)::_,_,_) => fail
        
  rule  print "-generate_simple_equation_links2 failed\n" 
	    --------------------------
	    generate_simple_equation_links2(_,_,_,_) => fail

end

relation tornado_from_kind: (DAELow.VarKind) => string =

  axiom	tornado_from_kind(DAELow.VARIABLE) => "Variable"
  axiom	tornado_from_kind(DAELow.STATE) => "DerState"
  axiom	tornado_from_kind(DAELow.DUMMY_DER) => "AlgState"
  axiom	tornado_from_kind(DAELow.DUMMY_STATE) => "AlgState"
  axiom	tornado_from_kind(DAELow.DISCRETE) => "AlgState"
  axiom	tornado_from_kind(DAELow.PARAM) => "Param"
  axiom	tornado_from_kind(DAELow.CONST) => "Param"
  axiom	tornado_from_kind(_) => "unknown kind"
end

(** 
 ** this relation return the TO kind: MSLE_ALG_STATE_VAR
 ** depe
 **)

                 (* relation tornado_to_kind: (DAELow.VarKind,bool) => string = *)

                            (*   axiom	tornado_to_kind(DAELow.VARIABLE) => "Variable" *)
                            (*   axiom	tornado_to_kind(DAELow.STATE) => "DerState" *)
                            (*   axiom	tornado_to_kind(DAELow.DUMMY_DER) => "AlgState" *)
                            (*   axiom	tornado_to_kind(DAELow.DUMMY_STATE) => "AlgState" *)
                            (*   axiom	tornado_to_kind(DAELow.DISCRETE) => "AlgState" *)
                            (*   axiom	tornado_to_kind(DAELow.PARAM) => "Param" *)
                            (*   axiom	tornado_to_kind(DAELow.CONST) => "Param" *)
                            (*   axiom	tornado_to_kind(_) => "unknown kind" *)
                            (* end *)

                            relation tornado_direction: (DAE.VarDirection) => string =

  axiom	tornado_direction(DAE.INPUT) => "Input"
  axiom	tornado_direction(DAE.OUTPUT) => "Output"
  axiom	tornado_direction(DAE.BIDIR) => "AlgState"
  axiom	tornado_direction(_) => "unknown kind"
                            end


(**
 ** this combines the getSubModel(...)->get<type>(index)-> with
 ** the string )->LinkValue(this, , ", varindxstr,");\n"]
**)
 relation get_TO_link_string_from_dae_var:(string,DAELow.Var, int) => string =
         

  rule  is_var_on_top_model(cr) => true &
         int_string(index) => index_str &
         Exp.cref_str(cr) => crs &
         Util.string_append_list(["  this->GetDerStateVar(",index_str,")",
                                  "->LinkInitialValue(this, ",
                                  index_str,");\n",
                                  "// simple eqn rem: ",crs,
                                  "  this->GetDerStateVar(",index_str,")",
                                  "->LinkDerivative(this, ",
                                  index_str,");\n",
                                  "// simple eqn rem: ",crs,
                                  "  this->GetDerStateVar(",index_str,")",
                                  "->LinkValue(this, ",
                                  "MSLE_DER_STATE_VAR, ",
                                  index_str,");\n\n",
                                  "// simple eqn rem: ",crs,
                                  prefix,
                                  "->LinkValue(this, MSLE_DER_STATE_VAR, ",
                                  index_str,");\n\n"
                                  ]) => res
         -----------------------------------------
         get_TO_link_string_from_dae_var(prefix,
                                         DAELow.VAR(cr,DAELow.STATE,dir,_,_,_,_,_,_,_,class_path),
                                         index) => res


         
  rule (*   is_var_on_top_model(cr) => true & *)
         int_string(index) => index_str &
         Exp.cref_str(cr) => crs &
         Util.string_append_list([prefix,
                                  "->LinkValue(this, ",
                                  "MSLE_ALG_STATE_VAR, ",
                                  index_str,");",
                                  "// simple eqn rem: ",crs,
                                  "\n"]) => res
         -----------------------------------------
         get_TO_link_string_from_dae_var(prefix,
                                         DAELow.VAR(cr,_,dir,_,_,_,_,_,_,_,class_path),
                                         index) => res

  rule print "get_TO_link_string_from_dae_var failed"
         -----------------------------------------
         get_TO_link_string_from_dae_var(prefix,
                                         DAELow.VAR(cr,_,dir,_,_,_,_,_,_,_,class_path),
                                         index) => fail

         
 end


(** relation generate_indep_var 
 ** This return the string list for each component index:
 ** GetSubModel(<index>)->GetIndepVar(0)->LinkValue(this, MSLE_INDEP_VAR, 0);
 **)
relation generate_indep_var : (string list, int) => string list =

  axiom generate_indep_var([],_) => [""]
        
  rule  int_string(index) => index_str &
        Util.string_append_list(["  GetSubModel(",
                                 index_str,
                                 ")->GetIndepVar(0)->LinkValue(this, MSLE_INDEP_VAR, 0);\n"]) => comp_str &
        int_add(index,1) => index_inc &
        generate_indep_var(rest,index_inc) => res
        ---------------------------------------------
        generate_indep_var(component_name::rest,index) => comp_str::res
end

(** relation generate_links2
 ** This relation generates links for parameters and for algebraic variables.
 ** It returns a string list for the parameters links and a string list for the 
 ** algebraic variable links.
 ** ARG1 the daelow.var list
 ** ARG2 the index for the variables (output, input)
 ** ARG3 the index for the parameter
 ** ARG4 the component list to get the submodel. The submodel is the index in this list
 ** [GetSubModel(<component index>)->GetParam(0)->LinkValue(this, MSLE_PARAM, <param index>);,...]
 ** [GetSubModel(<component index>)->Get___Var(0)->LinkValue(this, MSLE_INDEP_VAR, <variable index>);]
 ** int - the number of algstatevars 
 **)
 relation generate_links2:(DAELow.Var list,int,int,string list) => (string list, string list,int) = 
	     
  axiom	generate_links2([],_,_,_) => ([],[],0)
         
(*   rule print "IN generate_links2\n"& *)
(*          int_eq(1,0) => true *)
(*          ------------------------------ *)
(*          generate_links2(_,_,_,_) => ([],[],0) *)

         (* check first if output variable is on the top model.*)
  rule	int_add(var_index,1) => var_index' & int_string(var_index) => is &
         SimCodegen.cref_modelica_str(cr) => crs &
         is_var_on_top_model(cr) => true &
         Util.string_append_list([""]) => r1 &
         generate_links2(rest,var_index',param_index,comp_name_list) => (params_str,res,no_alg_vars) 
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_,_)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (params_str,(r1::res),no_alg_vars)

	       
	       (*if the output variable is not on the top model then generate link*)
  rule  int_add(var_index,1) => var_index' & int_string(var_index) => is &
	     
         Exp.cref_str(cr) => crs &
         Util.string_split_at_char(crs,#".") => comp_path_string_list &
         Util.list_last(comp_path_string_list) => comp_name &
	     list_reverse(class_paths) => class_path::_ & 
         Absyn.path_string(class_path) => class_path_str &
         TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &

         int_string(input_number) => input_number_str &
         Util.list_first(comp_path_string_list) => comp_name' &
         Util.list_position(comp_name',comp_name_list) => index &
         int_string(index) => index_str &
         Util.string_append_list(["  GetSubModel(",
                                  index_str,
                                  ")->GetOutputVar(",
                                  input_number_str,
                                  ")->LinkValue(this, MSLE_ALG_STATE_VAR, ",
                                  is,");", " // ",crs,"\n"]) => r1 &

         generate_links2(rest,var_index',param_index,comp_name_list) 
	      => (params_str,res,no_alg_vars) &
           int_add(no_alg_vars,1) => no_alg_vars'
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_
                                    ,_,class_paths)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (params_str,(r1::res),no_alg_vars')
	       
  rule  int_add(var_index,1) => var_index' & int_string(var_index) => is &
         SimCodegen.cref_modelica_str(cr) => crs &
         is_var_on_top_model(cr) => true &
         Util.string_append_list([""]) => r1 &
         generate_links2(rest,var_index',param_index,comp_name_list) => (params_str,res,no_alg_vars) 
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,start,_,_,_)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (params_str,(r1::res),no_alg_vars)
	       
  rule  int_add(var_index,1) => var_index' & int_string(var_index) => is &

         Exp.cref_str(cr) => crs &
         Util.string_split_at_char(crs,#".") => comp_path_string_list &
         Util.list_last(comp_path_string_list) => comp_name &
         list_reverse(class_paths) => class_path::_ & 
         Absyn.path_string(class_path) => class_path_str &
         TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &
         int_string(input_number) => input_number_str &
         Util.list_first(comp_path_string_list) => comp_name' &
         Util.list_position(comp_name',comp_name_list) => index &
         int_string(index) => index_str &
         Util.string_append_list(["  GetSubModel(",
                                  index_str,
                                  ")->GetInputVar(",
                                  input_number_str,
                                  ")->LinkValue(this, MSLE_ALG_STATE_VAR, ",
                                  is,");", " // ",crs,"\n"]) => r1 &
         generate_links2(rest,var_index',param_index,comp_name_list) => (params_str,res,no_alg_vars) &
         int_add(no_alg_vars,1) => no_alg_vars'
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,start,_,org_name,class_paths)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (params_str,(r1::res),no_alg_vars')
	       
           (* this rule take care of BIDIR variables *)
  rule  int_add(var_index,1) => var_index' & int_string(var_index) => is &
         

         Exp.cref_str(cr) => crs &

         Util.string_split_at_char(crs,#".") => comp_path_string_list &
         Util.list_last(comp_path_string_list) => comp_name &
         list_reverse(class_paths) => class_path::_ & 
         Absyn.path_string(class_path) => class_path_str &
         TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &
         
         int_string(input_number) => input_number_str &
         Util.list_first(comp_path_string_list) => comp_name' &
         Util.list_position(comp_name',comp_name_list) => index &
         int_string(index) => index_str &
         Util.string_append_list(["  GetSubModel(",
                                  index_str,
                                  ")->GetAlgStateVar(",
                                  input_number_str,
                                  ")->LinkValue(this, MSLE_ALG_STATE_VAR, ",
                                  is,");", " // ",crs,"\n"]) => r1 &
         generate_links2(rest,var_index',param_index,comp_name_list) => (params,res,no_alg_vars) &
         int_add(no_alg_vars,1) => no_alg_vars'
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,start,_,_,class_paths)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (params,(r1::res),no_alg_vars')
	       
  rule	int_add(param_index,1) => param_index' & int_string(param_index) => is &
         Exp.cref_str(cr) => crs &

         Util.string_split_at_char(crs,#".") => comp_path_string_list &
         Util.list_last(comp_path_string_list) => comp_name &
         list_reverse(class_paths) => class_path::_ & 
         Absyn.path_string(class_path) => class_path_str &
         TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &

         int_string(input_number) => input_number_str &
         Util.list_first(comp_path_string_list) => comp_name' &
         Util.list_position(comp_name',comp_name_list) => index &
         int_string(index) => index_str &
         Util.string_append_list(["  GetSubModel(",
                                  index_str,
                                  ")->GetParam(",
                                  input_number_str,
                                  ")->LinkValue(this, MSLE_PARAM, ",
                                  is,");", " // ",crs,"\n"]) => r1 &
         generate_links2(rest,var_index,param_index',comp_name_list) => (params,res,no_alg_vars) 
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,_,start,_,org_name,class_paths)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (r1::params,res,no_alg_vars)

  rule	int_add(param_index,1) => param_index' & int_string(param_index) => is &
         Exp.cref_str(cr) => crs &

         Util.string_split_at_char(crs,#".") => comp_path_string_list &
         Util.list_last(comp_path_string_list) => comp_name &
         list_reverse(class_paths) => class_path::_ & 
         Absyn.path_string(class_path) => class_path_str &
         TORNADOEXT.get_var_index(comp_name,class_path_str) => input_number &

         int_string(input_number) => input_number_str &
         Util.list_first(comp_path_string_list) => comp_name' &
         Util.list_position(comp_name',comp_name_list) => index &
         int_string(index) => index_str &
         Util.string_append_list(["  ((CDAEModel*)GetSubModel(",
                                  index_str,
                                  "))->GetDerStateVar(",
                                  input_number_str,
                                  ")->LinkValue(this, MSLE_DER_STATE_VAR, ",
                                  is,");", " // ",crs,"\n",
                                  "  ((CDAEModel*)GetSubModel(",
                                  index_str,
                                  "))->GetDerStateVar(",
                                  input_number_str,
                                  ")->LinkInitialValue(this, ",
                                  is,");", " // ",crs,"\n",
                                  "  ((CDAEModel*)GetSubModel(",
                                  index_str,
                                  "))->GetDerStateVar(",
                                  input_number_str,
                                  ")->LinkDerivative(this, ",
                                  is,");", " // ",crs,"\n"

                                  ]) => r1 &
         generate_links2(rest,var_index,param_index',comp_name_list) => (params,res,no_alg_vars) 
         ---------------------------------------------
         generate_links2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,start,_,org_name,class_paths)::rest,
                         var_index,
                         param_index,
                         comp_name_list) 
          => (r1::params,res,no_alg_vars)
           
  rule  generate_links2(rest,var_index,param_index,comp_name_list) => (params, res,no_alg_vars)
         -----------------------------------------------
         generate_links2(_::rest,var_index,param_index,comp_name_list) 
          => (params,res,no_alg_vars)
	       
  rule  print "-generate_links2 failed\n" 
         ----------------------
         generate_links2(_,_,_,_) => (["TEST"],["/* not yet implemented */"],42)
 end



(* relation generate_constructor_inputvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_inputvars:(DAELow.DAELow) => (string, string) = 
        
  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(vars,knvars) => all_vars &
        generate_constructor_inputvars2(all_vars,0) => (lst,no_of_vars) &
        no_of_vars = 0
        
        -------------------------------------------
        generate_constructor_inputvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                     DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) => 
        ("","")

  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(vars,knvars) => all_vars &
        generate_constructor_inputvars2(all_vars,0) => (lst,no_of_vars) &
        
	    Util.string_delimit_list(lst,"\n") => res &
	    int_string no_of_vars => lenstr &
        Util.string_append_list(["  SetNoInputVars(",lenstr,");\n"]) => prefix1 &
        Util.string_append_list(["  SetNoInputVarValues(",lenstr,");\n"]) => prefix2 &
        Util.string_append_list([prefix1,res,"\n"]) => res' 
        -------------------------------------------
        generate_constructor_inputvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                     DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) => (res',prefix2)

end

relation generate_constructor_inputvars2:(DAELow.Var list,int) => (string list, int) = 
        
  rule (* special case for when called second time and first time gave 
        list length zero *)
        generate_constructor_inputvars2(lst,0) => (res,no_of_vars)
        ----------------------------------------------
        generate_constructor_inputvars2(lst,-1) => (res,no_of_vars)
        
  axiom generate_constructor_inputvars2([],_) => ([],0)
        
	    
  rule  int_add(i,1) => i' & int_string(i) => is &
        is_var_on_top_model(cr) => true &
        generate_constructor_inputvars2(rest,i') => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars' &
        SimCodegen.cref_modelica_str(cr) => crs &
        Util.string_append_list(["  SetInputVar(",
                                 is,
                                 ", new CInputVar(L\"",
                                 crs,"\", L\"\",0));"]) => r1
        
        ---------------------------------------------
        generate_constructor_inputvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,_,_,_,_)::rest,i) 
          => (r1::res,no_of_vars')
	      
	      (*   rule  generate_constructor_inputvars2(rest,i) => (res,no_of_vars) & *)
	    (*         int_add(no_of_vars,1) => no_of_vars' *)
	    (*         --------------------------------------------- *)
	    (*         generate_constructor_inputvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,_,_,_,_)::rest,i)  *)
	    (*           => (res,no_of_vars') *)
        
  rule  generate_constructor_inputvars2(rest,i) => (res,no_of_vars)
        -----------------------------------------------
        generate_constructor_inputvars2(_::rest,i) 
          => (res,no_of_vars)

  rule  print "-generate_constructor_inputvars2 failed\n" 
        ----------------------
        generate_constructor_inputvars2(_,_) => fail
  end


(* relation generate_constructor_algvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 ** 
 *)
relation generate_constructor_algvars:(DAELow.DAELow) => (string, string,int) = 
        
  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(knvars,vars) => all_vars &       
        generate_constructor_algvars2(all_vars,0) => (lst,no_of_vars) &
        
	    no_of_vars = 0 
        -------------------------------------------
        generate_constructor_algvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                   DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
          => ("","",0)

  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(knvars,vars) => all_vars &       
        generate_constructor_algvars2(all_vars,0) => (lst,no_of_vars) &
        
	    Util.string_delimit_list(lst,"\n") => res &


	    int_string no_of_vars => lenstr &
        Util.string_append_list(["  SetNoAlgStateVars(",lenstr,");\n"]) => prefix1 &
        Util.string_append_list(["  SetNoAlgStateVarValues(",lenstr,");\n"]) => prefix2 &
        Util.string_append_list([prefix1,res,"\n"]) => res' 
        -------------------------------------------
        generate_constructor_algvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                   DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
	      => (res',prefix2,no_of_vars)
end

relation generate_constructor_algvars2:(DAELow.Var list,int) => (string list, int) = 
        
  rule (* special case for when called second time and first time gave 
        list length zero *)
        generate_constructor_algvars2(lst,0) => (res,no_of_vars)
        ----------------------------------------------
        generate_constructor_algvars2(lst,-1) => (res,no_of_vars)
        
  axiom generate_constructor_algvars2([],_) => ([],0)
        
	    
        (* this rule take care of BIDIR variables *)
  rule  int_add(i,1) => i' & int_string(i) => is &
        is_var_on_top_model(cr) => true &
        generate_constructor_algvars2(rest,i') => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars' &
        SimCodegen.cref_modelica_str(cr) => crs &
        Util.string_append_list(["  SetAlgStateVar(",
                                 is,
                                 ", new CAlgStateVar(L\"",
                                 crs,"\", L\"\",0));"]) => r1 
        ---------------------------------------------
        generate_constructor_algvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,start,_,_,_)::rest,i) 
          => (r1::res,no_of_vars')
	      
  rule  generate_constructor_algvars2(rest,i) => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars'
        ---------------------------------------------
        generate_constructor_algvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,start,_,_,_)::rest,i) 
          => (res,no_of_vars')
	      
  rule  generate_constructor_algvars2(rest,i) => (res,no_of_vars)
        -----------------------------------------------
        generate_constructor_algvars2(_::rest,i) 
          => (res,no_of_vars)

  rule  print "-generate_constructor_algvars2 failed\n" 
        ----------------------
        generate_constructor_algvars2(_,_) => fail
  end



(* relation generate_constructor_outputvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_outputvars:(DAELow.DAELow) => (string, string) = 
        
  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        generate_constructor_outputvars2(vars,0) => (lst,no_of_vars') &
        generate_constructor_outputvars2(knvars,0) => (knlst,no_of_vars'') &
        
        int_add(no_of_vars',no_of_vars'') => no_of_vars &
        no_of_vars = 0 
        -------------------------------------------
        generate_constructor_outputvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                      DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
          => ("","")

  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        generate_constructor_outputvars2(vars,0) => (lst,no_of_vars') &
        generate_constructor_outputvars2(knvars,0) => (knlst,no_of_vars'') &
        
        int_add(no_of_vars',no_of_vars'') => no_of_vars &
        list_append(lst,knlst) => lst' &
	    Util.string_delimit_list(lst',"\n") => res &
        
        
	    int_string no_of_vars => lenstr &
        Util.string_append_list(["  SetNoOutputVars(",lenstr,");\n"]) => prefix1 &
        Util.string_append_list(["  SetNoOutputVarValues(",lenstr,");\n"]) => prefix2 &
        Util.string_append_list([prefix1,res,"\n"]) => res' 
        -------------------------------------------
        generate_constructor_outputvars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                      DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
	      => (res',prefix2)
end

relation generate_constructor_outputvars2:(DAELow.Var list,int) => (string list, int) = 
        
  rule (* special case for when called second time and first time gave 
        list length zero *)
        generate_constructor_outputvars2(lst,0) => (res,i)
        ----------------------------------------------
        generate_constructor_outputvars2(lst,-1) => (res,i)
        
  axiom generate_constructor_outputvars2([],_) => ([],0)
        
  rule  int_add(i,1) => i' & int_string(i) => is &
        is_var_on_top_model(cr) => true &

        generate_constructor_outputvars2(rest,i') => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars' &
        SimCodegen.cref_modelica_str(cr) => crs &
        Util.string_append_list(["  SetOutputVar(",
                                 is,
                                 ", new COutputVar(L\"",
                                 crs,"\", L\"\",0));"]) => r1 
        ---------------------------------------------
        generate_constructor_outputvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_,_)::rest,i) 
          => (r1::res,no_of_vars')

	      (*   rule  generate_constructor_outputvars2(rest,i) => (res,no_of_vars) & *)
	    (*         int_add(no_of_vars,1) => no_of_vars' *)
	    (*           --------------------------------------------- *)
	    (*         generate_constructor_outputvars2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_,_)::rest,i)  *)
	    (*           => (res,no_of_vars') *)

	    
  rule  generate_constructor_outputvars2(rest,i) => (res,no_of_vars)
        -----------------------------------------------
        generate_constructor_outputvars2(_::rest,i) 
          => (res,no_of_vars)

  rule  print "-generate_constructor_outputvars2 failed\n" 
        ----------------------
        generate_constructor_outputvars2(_,_) => fail
  end


  relation is_var_on_top_model:(Exp.ComponentRef) => bool =

  rule  (*this checks if the variable is on the top model*)
          Util.string_split_at_char(cr,#".") => string_list &
          list_length(string_list) => string_list_len &
          string_list_len = 1 
	      
	      ----------------------------------------
          is_var_on_top_model(Exp.CREF_IDENT(cr,_)) => true

  axiom is_var_on_top_model(_) => false

  end 

(* relation: generate_constructor_statevars
 **  This relation is similar to the generate_constructor_outputvars relation above.
 ** It also generates code placed in the contstructor, but for state variables.
 ** They are also indexed in the order they appear in the DAELow representation, starting
 ** with index 0.
 *)
 relation generate_constructor_statevars:(DAELow.DAELow) => (string,string) = 
	     
  rule	array_list(vararr) => vars &
         array_list(knvararr) => knvars &
         list_append(vars,knvars) => all_vars &
         generate_constructor_statevars2(all_vars,0) => (lst, no_of_vars') &
         Util.string_delimit_list(lst,"\n")=> res & 
         int_string no_of_vars' => lenstr &
         Util.string_append_list(["  SetNoDerStateVars(",lenstr,");\n"]) => prefix1 &
         Util.string_append_list(["  SetNoDerStateVarValues(",lenstr,");\n"]) => prefix2 &
         Util.string_append_list([prefix1,res,"\n"]) => res' 
         ----------------------
         generate_constructor_statevars(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
	      => (res',prefix2)
 end

 relation generate_constructor_statevars2: (DAELow.Var list,int) => (string list,int) =

  axiom generate_constructor_statevars2([],_) => ([],0)

  rule (* When start value is present*)
         int_add(i,1) => i' & int_string(i) => is &
         is_var_on_top_model(cr) => true &
         generate_constructor_statevars2(rest,i') => (res,no_of_vars) &
         int_add(no_of_vars,1) => no_of_vars' &
         SimCodegen.cref_modelica_str(cr) => crs & 
         (*Exp.print_exp_str start => startstr &*)
         SimCodegen.print_exp_cpp_str(start) => startstr &
         Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",",
                                  startstr,"));"]) 
          => r1 
           --------------------
         generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,SOME(start),_,_,_)::rest,i) 
          => (r1::res,no_of_vars')

  rule (* If no start value is present*)
         int_add(i,1) => i' & int_string(i) => is &
         is_var_on_top_model(cr) => true &
         generate_constructor_statevars2(rest,i') => (res,no_of_vars) &
         int_add(no_of_vars,1) => no_of_vars' &
         SimCodegen.cref_modelica_str(cr) => crs & 
         
         Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",0));"]) 
          => r1 
           --------------------
         generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,NONE,_,_,_)::rest,i) 
          => (r1::res, no_of_vars')

  rule  generate_constructor_statevars2(rest,i) => (res,no_of_vars) &
         int_add(no_of_vars,1) => no_of_vars'
         ---------------------------------------------
         generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,start,_,_,_)::rest,i)
          => (res,no_of_vars')
           

  rule generate_constructor_statevars2(rest,i) => (res,no_of_vars)
         -----------------------------------------------
         generate_constructor_statevars2(_::rest,i) 
          => (res,no_of_vars)

  rule print "-generate_constructor_statevars2 failed\n" 
         ----------------------
         generate_constructor_statevars2(_,_) => fail
 end



(* relation generate_constructor_parameters
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_parameters:(DAELow.DAELow) => (string, string) = 
        
  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(vars,knvars) => all_vars &
        generate_constructor_parameters2(all_vars,0) => (lst,no_of_vars) &

        no_of_vars = 0 
        -------------------------------------------
        generate_constructor_parameters(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                      DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) 
          => ("","")

  rule  array_list(vararr) => vars &
        array_list(knvararr) => knvars &
        list_append(vars,knvars) => all_vars &
        generate_constructor_parameters2(all_vars,0) => (lst,no_of_vars) &
        
	    Util.string_delimit_list(lst,"\n") => res &
        
	    int_string no_of_vars => lenstr &
        Util.string_append_list(["  "(*SetNoParams(",lenstr,");\n"*)]) => prefix1 &
        Util.string_append_list(["  SetNoParamValues(",lenstr,");\n"]) => prefix2 &
        Util.string_append_list([prefix1,res,"\n"]) => res' 
        -------------------------------------------
        generate_constructor_parameters(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                                      DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_)) => (res',prefix2)
end

relation generate_constructor_parameters2:(DAELow.Var list,int) => (string list, int) = 
        
  rule (* special case for when called second time and first time gave 
        list length zero *)
        generate_constructor_parameters2(lst,0) => (res,i)
        ----------------------------------------------
        generate_constructor_parameters2(lst,-1) => (res,i)
        
  axiom generate_constructor_parameters2([],_) => ([],0)
        

  rule  int_add(i,1) => i' & int_string(i) => is &
        is_var_on_top_model(cr) => true &

        generate_constructor_parameters2(rest,i') => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars' &
        Values.val_string(v) => vs & 
        SimCodegen.cref_modelica_str(cr) => crs &
        Util.string_append_list(["  SetParam(",is,", new CParam(L\"",crs,"\", L\"\",",vs, 
 				                 ", MSLE_MIN_INF, MSLE_PLUS_INF, L\"",crs,"\"));"])  
          => r1 
          ---------------------------------------------
        generate_constructor_parameters2(DAELow.VAR(cr,DAELow.PARAM,_,_,_,SOME(v),_,start,_,_,_)::rest,i) 
          => (r1::res,no_of_vars')


  rule  int_add(i,1) => i' & int_string(i) => is &
        is_var_on_top_model(cr) => true &

        generate_constructor_parameters2(rest,i') => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars' &
        SimCodegen.cref_modelica_str(cr) => crs &
        Util.string_append_list(["  SetParam(",is,", new CParam(L\"",crs,"\", L\"\",","0.0", 
 				                 ", MSLE_MIN_INF, MSLE_PLUS_INF, L\"",crs,"\"));"])  
          => r1  
          ---------------------------------------------
        generate_constructor_parameters2(DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,_,start,_,_,_)::rest,i) 
          => (r1::res,no_of_vars')

  rule  generate_constructor_parameters2(rest,i) => (res,no_of_vars) &
        int_add(no_of_vars,1) => no_of_vars'
        ---------------------------------------------
        generate_constructor_parameters2(DAELow.VAR(cr,DAELow.PARAM,_,_,_,_,_,start,_,_,_)::rest,i) 
          => (res,no_of_vars')

	      
  rule  generate_constructor_parameters2(rest,i) => (res,no_of_vars)
        -----------------------------------------------
        generate_constructor_parameters2(_::rest,i) 
          => (res,no_of_vars)
	      
  rule  print "-generate_constructor_parameters2 failed\n" 
        ----------------------
        generate_constructor_parameters2(_,_) => fail
  end

  relation generate_var_defines: (DAELow.DAELow) => string =
	      
  rule	array_list(vararr) => vars &
          array_list(knvararr) => knvars &
	      
	      (* Varaibles in known variables are removed alg.vars, 
           they should not generate code.*)
	      Util.list_select(knvars,is_param) => knvars' & 
          (* this is to generate the correct index for all the vars *)
          list_append(knvars',vars) => all_vars &
          generate_var_defines2(all_vars,0,0,0,0) => vdefs1list &
          Util.string_append_list(vdefs1list) => vdefs1 &
          Util.string_append_list(["#define _t_ m_IndepVarValues[0]\n\n",vdefs1,"\n"]) => vdefs
          ---------------------
          generate_var_defines(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),
                                             DAELow.VARIABLES(_,knvararr,_,_),
                                             eqn,seqn,_,_)) => vdefs
          
  rule	print "-generate_var_defines failed\n"
          --------------------------------------
          generate_var_defines(_) => fail
  end

  relation is_not_param: (DAELow.Var ) => bool =
	      
  axiom	is_not_param(DAELow.VAR(_,DAELow.PARAM,_,_,_,_,_,_,_,_,_)) => false
  axiom	is_not_param(_) => true
	      
  end

  relation is_param: (DAELow.Var ) => bool =

  axiom	is_param(DAELow.VAR(_,DAELow.PARAM,_,_,_,_,_,_,_,_,_)) => true
  axiom	is_param(_) => false
  end



(** Helper function for generate_var_defines
 ** Recursively traverses the list of variables and generates the defines 
 ** in the tornado format for them.
 ** Arg1 is the list of variables
 ** Arg2 is the counter for Output variables
 ** Arg3 is the counter for DerState and derivative variables
 ** Arg4 is the counter for parameters
 **)
 relation generate_var_defines2: (DAELow.Var list,int,int,int,int) 
	      => string list =
  axiom generate_var_defines2([],_,_,_,_) => []
         
  rule int_string(outputCounter) => outputCounterString &
         Exp.cref_str(cr) => modelicaStr &
         is_var_on_top_model(cr) => true &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_OutputVarValues[",outputCounterString,"])\n"]) => r1 &
         int_add(outputCounter,1) => outputCounter' & 
         generate_var_defines2(rest,outputCounter', inputCounter,
			                   derStateCounter,algVarCounter) => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule int_string(outputCounter) => outputCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_AlgStateVarValues[",outputCounterString,"])\n"]) => r1 &
         int_add(outputCounter,1) => outputCounter' & 
         generate_var_defines2(rest,outputCounter', inputCounter,
			                   derStateCounter,algVarCounter) => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.OUTPUT,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule int_string(inputCounter) => inputCounterString &
         Exp.cref_str(cr) => modelicaStr &
         is_var_on_top_model(cr) => true &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_InputVarValues[",inputCounterString,"])\n"]) => r1 &
         int_add(inputCounter,1) => inputCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter',derStateCounter,algVarCounter) => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule int_string(inputCounter) => inputCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_AlgStateVarValues[",inputCounterString,"])\n"]) => r1 &
         int_add(inputCounter,1) => inputCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter',derStateCounter,algVarCounter) => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.INPUT,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule int_string(algVarCounter) => algVarCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_AlgStateVarValues[",algVarCounterString,"])\n"]) => r1 &
         int_add(algVarCounter,1) => algVarCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter,
			                   derStateCounter,algVarCounter') => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,DAE.BIDIR,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res
           
  rule int_string(algVarCounter) => algVarCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_AlgStateVarValues[",algVarCounterString,"])\n"]) => r1 &
         int_add(algVarCounter,1) => algVarCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter,
			                   derStateCounter,algVarCounter') => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.DUMMY_DER,dir,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res
           
  rule int_string(algVarCounter) => algVarCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_AlgStateVarValues[",algVarCounterString,"])\n"]) => r1 &
         int_add(algVarCounter,1) => algVarCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter,
			                   derStateCounter,algVarCounter') => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.DUMMY_STATE,dir,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule int_string(derStateCounter) => derStateCounterString &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_DerStateVarValues[",derStateCounterString,"])\n",
                                  "#define _D_",crs," (m_Derivatives[",derStateCounterString,"])\n"]) => r1 &
         int_add(derStateCounter,1) => derStateCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter,
			                   derStateCounter',algVarCounter) => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.STATE,dir,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) 
          => r1::res

  rule  int_string(paramCounter) => paramCounterString &
         Exp.cref_str(cr) => modelicaStr &
         SimCodegen.cref_modelica_str(cr) => crs &
         Util.string_append_list(["#define ",crs," (m_ParamValues[",paramCounterString,"])\n"]) => r1 &
         int_add(paramCounter,1) => paramCounter' & 
         generate_var_defines2(rest,outputCounter,inputCounter,
                               derStateCounter,paramCounter') => res
         ----------------------------------------------
         generate_var_defines2(DAELow.VAR(cr,DAELow.PARAM,dir,_,_,_,_,_,_,_,_)::rest,
                               outputCounter,inputCounter,
			                   derStateCounter,paramCounter) 
          => r1::res
           
  rule generate_var_defines2(rest,outputCounter,inputCounter,
			                 derStateCounter,algVarCounter) => res 
         -----------------------------------------------
         generate_var_defines2(_::rest,outputCounter,inputCounter,
			                   derStateCounter,algVarCounter) => res
         
  rule print "-generate_var_defines2 failed\n"
         --------------------------------------
         generate_var_defines2(_,_,_,_,_) => fail

 end

(** relation: generate_constructor_component_initialization
 ** this relation generates the code for initialization of internal
 ** components for a model. The components are non-primitive types.
 ** The string list that is return is a list of the names of the components 
 ** in the main model. This is needed for extracting the index of the components.
 ** 
 **)
 relation generate_constructor_component_initialization: (string,Absyn.Program) => (string,string list) =
	     
	     
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
	     (* call to helper function *)
         count_and_generate_initializations(cdef,program,0,[]) => (ini_str_list,nr_of_comp,comp_name_list) &         
         (* if there are no components then it will not generate constructors *)
         int_eq(nr_of_comp,0) => true
         (*& Util.string_append_list(comp_name_list) => str_res &
          print "COMPONENTS " & print str_res & print "\n" *)
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => ("", comp_name_list)
         
         
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
	     (* call to helper function *)
         count_and_generate_initializations(cdef,program,0,[]) => (ini_str_list,nr_of_comp,comp_name_list) &         
         int_string(nr_of_comp) => res &
	     (* Generate the nr of submodels declaration *)
         Util.string_append_list(["  SetNoSubModels(",res,");\n"]) => res1 &
         Util.string_append_list(res1::ini_str_list) => res2 
         (*& Util.string_append_list(comp_name_list) => str_res &
          print "COMPONENTS " & print str_res & print "\n" *)
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => (res2,comp_name_list)
         
  rule  print "generate_constructor_component_initialization failed\n"
         --------------------------------------
         generate_constructor_component_initialization(_,_) => fail
         
 end

 relation count_and_generate_initializations: (Absyn.Class,Absyn.Program,int,string list) => (string list, int,string list) =
         
  rule  (* For public declarations *)
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),
                                            program, 
                                            nr_of_found_components,
                                            comp_name_list) => (str,c1,comp_name_list1) & 
	     count_and_generate_initializations_in_elts(elt,program,nr_of_found_components,comp_name_list1) => (strlist,c2,comp_name_list2) &
	     int_add(c1,c2) => res &
         list_append(str,strlist) => string_list 
         --------------------------------------
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)),
                                            program, 
                                            nr_of_found_components,
                                            comp_name_list)
	      => (string_list,res,comp_name_list2)
           
  rule	(* For protected declarations *)
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),
                                            program, 
                                            nr_of_found_components,
                                            comp_name_list) => (str,c1,comp_name_list1) &
	     count_and_generate_initializations_in_elts(elt,program,nr_of_found_components,comp_name_list1) => (strlist,c2,comp_name_list2) &
	     int_add(c1,c2) => res &
         list_append(str,strlist) => string_list
	     -------------------------------------
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt)),
                                            program, 
                                            nr_of_found_components,
                                            comp_name_list)
	      => (string_list,res,comp_name_list2)

  rule	(* Non-public, non protected, -> Throw it away*)
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),
                                            program,
                                            nr_of_found_components,
                                            comp_name_list) => (str,c1,comp_name_list1)
	     -----------------------------------------------------
	     count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(_::lst,cmt)),
                                            program,
                                            nr_of_found_components,
                                            comp_name_list) => (str,c1,comp_name_list1)
	     
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS([],_)),_,_,comp_name_list) => ([""],0,comp_name_list)
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.DERIVED(_,_,_,_,_)),_,_,comp_name_list) => ([""],-1,comp_name_list)
         
  rule print "count_and_generate_initializations failed\n"
         --------------------------------------
         count_and_generate_initializations(_,_,_,_) => fail
         
 end

 relation count_and_generate_initializations_in_elts: (Absyn.ElementItem list,Absyn.Program,int, string list) => (string list, int,string list) =         

  rule  Interactive.is_primitive(Absyn.CREF_IDENT(ident,[]),program) => false & 
         generate_components_initializations(ident,componentItemList,index,[]) => (comp_str_list,nrOfComponents,comp_name_list1) &
	     int_add(index,nrOfComponents) => inc_index1 &
         
 	     int_add(index,1) => inc_index2 &
	     count_and_generate_initializations_in_elts(lst,program,inc_index2,comp_name_list) => (strlist,c1,comp_name_list2) &
	     list_append(comp_str_list,strlist) => str_list_res &
         list_append(comp_name_list1,comp_name_list2) => comp_name_res 
	     --------------------------
	     count_and_generate_initializations_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,
                                                                                    Absyn.COMPONENTS(_,
                                                                                                     Absyn.IDENT(ident),
                                                                                                     componentItemList)
                                                                                    ,_,_,NONE))::lst,
                                                    program,
                                                    index,
                                                    comp_name_list) => (str_list_res,c1,comp_name_res)
	     
  rule  count_and_generate_initializations_in_elts(lst,program,index,comp_name_list) => (strlist,res,comp_name_res)
	     ----------------------------
	     count_and_generate_initializations_in_elts(_::lst,program,index,comp_name_list) => (strlist,res,comp_name_res)
         
  axiom	count_and_generate_initializations_in_elts([],_,index,comp_name_res) => ([""],index,comp_name_res)
         
  rule	print "count_and_generate_initializations_in_elts failed\n"
	     ----------------------------
	     count_and_generate_initializations_in_elts(_,_,_,_) => fail

 end

 relation generate_components_initializations: (Absyn.Ident, Absyn.ComponentItem list, int,string list) => (string list, int, string list) =
	     
  rule  int_string(index) => current_index_string &
         int_add(index,1) => inc_index &	
         generate_components_initializations(componentType,
                                             rest,
                                             inc_index,
                                             comp_name_list) => (res,ret_index,comp_name_res) &
         Util.string_append_list(["  SetSubModel(",current_index_string,
                                  ", new C",componentType,"(L\"",componentIdent,"\"));\n"]) => gen_string
         -------------------------------------
         generate_components_initializations(componentType,
                                             Absyn.COMPONENTITEM(Absyn.COMPONENT(componentIdent,_,_),_)::rest, 
                                             index,
                                             comp_name_list) => (gen_string::res, 
                                                                 ret_index,
                                                                 componentIdent::comp_name_res)

  axiom	generate_components_initializations(componentType,[],index,comp_name_list) => ([""],index,comp_name_list)

 end


(** relation: generate_compute_methods
 ** This relation generates the code for the computation of the equations
 ** They are separated into four parts.
 ** - computing the output variables (algebraic variables)
 ** - computing the state variables
 ** - computing the initial conditions
 ** - computing the terminal conditions
 **)
 relation generate_compute_methods: (string,DAELow.DAELow,Absyn.Program, int list list, int vector, int vector) => string =

  rule	(** ass1 is what var is solved in what eqn **)
         (** ass2 is what eqn is solves what var **)
         DAELow.generate_state_partition(blt,dae,ass1,ass2) => (blt_states,blt_no_states) &
	     
         translate_dae(dae) => dae' &

         generate_compute_output(cname,dae',p,ass1,ass2,blt_no_states) => coutput &
         generate_compute_initial(cname,dae',p) => cinitial &
         generate_compute_state(cname,dae',p,ass1,ass2,blt_states) => cstate &
         (*generate_compute_terminal(cname,dae',p) => cterm &*)
         generate_compute_terminal(cname,dae',p,ass1,ass2,blt) => cterm &
         Util.string_append_list(["void C",cname,"::\n",
                                  "ComputeOutput()\n",
                                  "{\n",
                                  coutput,
                                  "}\n",
                                  "\n",
                                  "void C",cname,"::\n",
                                  "ComputeInitial()\n",
                                  "{\n",
                                  cinitial,
                                  "}\n",
                                  "\n",
                                  "void C",cname,"::\n",
                                  "ComputeState()\n",
                                  "{\n",
                                  cstate,
                                  "}\n",
                                  "\n",
                                  "void C",cname,"::\n",
                                  "ComputeTerminal()\n",
                                  "{\n",
                                  cterm,
                                  "}\n", 
                                  "\n"]) => methods
         ---------------------------
         generate_compute_methods(cname,dae,p,blt,ass1,ass2) => methods
         
  rule  print "-generate_compute_methods failed\n" 
         -----------------------------------------
         generate_compute_methods(_,_,_,_,_,_) => fail
 end 


(** relation generate_blt
 ** This relation computes the block lower triangular form of the equation 
 ** system using a list of the DAEs. 
 **
 **)
 relation generate_blt:(DAELow.DAELow) => (DAELow.DAELow,int list list,int vector, int vector) =
         
	     
  rule  (*DAELow.lower(d) => d' *)
         Debug.fcall("dumpdaelow", DAELow.dump, d') 
         & DAELow.incidence_matrix(d') => m 
         & DAELow.transpose_matrix(m) => mT 
         & DAELow.matching_algorithm(d',m,mT) => (v1,v2,d'',m,mT) 
         & Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
         (* & Debug.fcall("bltdump", DAELow.dump_incidence_matrix_t, mT) *)
         & Debug.fcall("bltdump", DAELow.dump,d'')
         & Debug.fcall("bltdump", DAELow.dump_matching, v1)
         & DAELow.strong_components(m,mT,v1,v2) => (comps) 
         (*& DAELow.dump_components(comps) *)
         -------------------------------------------------------------
         generate_blt(d') => (d'',comps,v1,v2)
         
  rule  print "-generate_blt failed\n" 
         -------------------------------------------------
         generate_blt(_) => fail
         
 end

(** relation translate_dae 
 ** This relation translates the DAE so that all the der(x) is _D_X in the equations
 **
 **)    
 relation translate_dae: DAELow.DAELow => DAELow.DAELow =
         
  rule  array_list(vararr) => var_list &
         extract_der_from_var_list(var_list) => (from_list,to_list) &
	     DAELow.equation_list(eqns) => eqn_list &
         replace_exp_in_eqns(eqn_list,from_list,to_list) => res_eqns &
	     DAELow.list_equation(res_eqns) => eqns' 
         -------------------------------------------------------------
         translate_dae(dae as DAELow.DAELOW(vars as DAELow.VARIABLES(_,vararr,_,_),a,eqns,b,c,d)) 
          => DAELow.DAELOW(vars,a,eqns',b,c,d)



  rule  print "-translate_dae failed\n"
         -------------------------------------------------------------
         translate_dae(dae) => fail



 end

(** relation extract_der_from_var_list 
 ** This relation generates to Exp.Exp list of the form:
 ** [Exp.CALL("der",Exp.Exp("x")...)] and [Exp.cref("x")]
 ** 
 **)
 relation extract_der_from_var_list: DAELow.Var list => (Exp.Exp list, Exp.Exp list) =
         
  rule  
         -------------------------------------------------------------
         extract_der_from_var_list([]) => ([],[])
	     
  rule  DAELow.is_non_state kind &
         (*print "extract_der_from_var_list Is not state\n" &*)
         extract_der_from_var_list(var_list) => (res1,res2)
         -------------------------------------------------------------
         extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_))::var_list)  
          => (res1,res2)

  rule  (*print "extract_der_from_var_list Is state" &*)

         (*Exp.print_component_ref_str(cr) => cr_str &*)
         SimCodegen.cref_modelica_str(cr) => cr_str &

	     let old_varexp = Exp.CREF(cr,Exp.REAL) &

         let dercall = Exp.CALL(Absyn.IDENT("der"),
			                    [old_varexp], 
			                    false,
			                    false) &
	     
         Util.string_append_list(["_D_",cr_str]) => new_id &
	     let new_cr = Exp.CREF_IDENT(new_id,[]) &
	     let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


         (* 	      print " from \"" & print cr_str & print "\" to \"" & print new_id  & print "\"\n" &  *)

         extract_der_from_var_list(var_list) => (res1,res2)
         -------------------------------------------------------------
         extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_))::var_list)  
          => (dercall::res1, new_varexp::res2)


  rule  print "-extract_der_from_var_list failed\n"
         -------------------------------------------------------------
         extract_der_from_var_list(_) => fail
 end

(** relation replace_exp_in_eqns
 ** This takes a DAELow.Equation list and two Exp.Exp lists: ("from","to") and does
 ** a "replace" all on the equations;
 **
 **)

 relation replace_exp_in_eqns:(DAELow.Equation list, Exp.Exp list, Exp.Exp list) => DAELow.Equation list =
         
  rule  
         -------------------------------------------------------------
         replace_exp_in_eqns([],from_exp,to_exp) => []

  rule  (*print "replace_exp_in_eqns not list" &*)
         Exp.replace_exp_list(exp1,from_exp,to_exp) => (res_exp1,nr_of_times1) &
         Exp.replace_exp_list(exp2,from_exp,to_exp) => (res_exp2,nr_of_times2) & 
         replace_exp_in_eqns(eqns_rest,from_exp,to_exp) => res_eqns
         -------------------------------------------------------------
         replace_exp_in_eqns(DAELow.EQUATION(exp1,exp2)::eqns_rest,from_exp,to_exp) => (DAELow.EQUATION(res_exp1,res_exp2)::res_eqns)


  rule  print "-replace_exp_in_eqns failed\n"
         -------------------------------------------------------------
         replace_exp_in_eqns(_,_,_) => fail
 end



(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output variables.
 **)
 relation generate_compute_output:(string,
                                   DAELow.DAELow,
                                   Absyn.Program,
                                   int vector, 
                                   int vector, 
                                   int list list) => string =
         
  rule  (*Util.string_append_list(["/* output code here*/\n"]) => coutput &*)
         build_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
         Util.string_append_list(eqn_str_list) => coutput 
         -------------------------------------------------------------
         generate_compute_output(cname,
                                 dae as DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),DAELow.VARIABLES(_,knvararr,_,_),eqn,seqn,_,_),
                                 p,ass1,ass2,blocks) => coutput
         
 end

 relation build_simple_equation:(DAELow.Var array, DAELow.Equation list) 
	      => string =
           
	       
           
  rule	
         --------------------------------
	     build_simple_equation(knvars,[]) => ""
	     
  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr1) => true &
         DAELow.is_var_known(knvarslist,cr2) => true &
         Util.string_append_list(["  ",exp1_str, " = ", exp2_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str

  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr1) => true &
         Util.string_append_list(["  ",exp1_str, " = ", exp2_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str

  rule  build_simple_equation(knvars,rest) => rest_res &
         SimCodegen.print_exp_cpp_str(exp1) => exp1_str & 
         SimCodegen.print_exp_cpp_str(exp2) => exp2_str &
         array_list(knvars) => knvarslist &
         DAELow.is_var_known(knvarslist,cr2) => true &
         Util.string_append_list(["  ",exp2_str, " = ", exp1_str, ";\n",rest_res]) => eqn_str 
         (*& print "\n build_simple_equation: " & print(eqn_str) *)
         --------------------------------
	     build_simple_equation(knvars,DAELow.EQUATION(exp1 as Exp.CREF(cr1,_),exp2 as Exp.CREF(cr2,_))::rest) => eqn_str
         
  rule  
         -------------------------------------------------------------
         build_simple_equation(_,_) => "// generating simple equation failed"

 end


(** relation: generate_compute_initial
 ** This relation generates the code for the calculation of the initial conditions.
 **)
 relation generate_compute_initial:(string,DAELow.DAELow,Absyn.Program) => string =

  rule  Util.string_append_list(["/* initial code here*/\n"]) => cinit
         -------------------------------------------------------------
         generate_compute_initial(cname,dae,p) => cinit
         
 end

(** relation: generate_compute_state
 ** This relation generates the code for the calculation of the state variables.
 **)
 relation generate_compute_state:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => string =
         
  rule  (*Util.string_append_list(["/* state code here*/\n"]) => cstate &*)
         (*print("----------- START building block STATE---------------\n") &*)
         build_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
         Util.string_append_list(eqn_str_list) => cstate 
         (*print("----------- END building block STATE---------------\n") *)
         
         -------------------------------------------------------------
         generate_compute_state(cname,dae,p,ass1,ass2,blocks) => cstate

 end


(** relation: generate_compute_terminal
 ** This relation generates the code for the calculation of the terminal behavior.
 ** This can be expressed in Modelica using when statements:
 ** when terminal() then
 **   x:=do_calc(x,y);
 ** e n d when
 *)
 relation generate_compute_terminal:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => string =
	     
  rule Util.string_append_list(["/* terminal code here*/\n"]) => cterm
	     -------------------------------------------------------------
	     generate_compute_terminal(cname,dae,p,_,_,_) => cterm
 end


(** relation build_blocks
 ** this is copied from taskgraph.rml and constructs the blocks in the incident matrix
 ** for the equations.
 ** It is NOT done for system of equations!
 **)
 relation build_blocks:(DAELow.DAELow, int vector, int vector, int list list) => string list =

  axiom	build_blocks(_,_,_,[]) => []

         (* rule	(* For system of equations *) *)
	     (* build_system(dae,ass1,ass2,block) &
	      build_blocks(dae,ass1,ass2,blocks)
	      -------------------------------------
	      build_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks)*)
	     
  rule	(* for single equations *)
	     build_equation(dae,ass1,ass2,eqn) => eqn_str &
	     build_blocks(dae,ass1,ass2,blocks) => res
	     -------------------------------------
	     build_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_blocks failed\n" 
	     -----------------
	     build_blocks(_,_,_,_) => fail
 end


(** relation build_equation 
 ** This returns the string for a specific equation in the 
 ** incidence matrix.
 ** It is used both for state variables and regular variables
 **)
 relation build_equation:(DAELow.DAELow, int vector, int vector, int) => string =
	     
  rule  (* Solving for non-states *)
	     int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v &
	     int_sub(v,1) => v' &
	     array_nth(vararr,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname,_)) &  
	     DAELow.is_non_state kind &
	     (*print "Solving for non-states\n" &*)

	     let varexp = Exp.CREF(cr,Exp.REAL) &
	     Exp.solve(e1,e2,varexp) => expr &
	     
         (* start debug output *)
         Exp.print_exp_str e1 => e1s &
	     Exp.print_exp_str e2 => e2s &
         int_string(e) => eqn_nr &
         int_string(v) => var_nr &
	     (*    print "Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print e1s & print " = " & print e2s &
	      print "\nsolved for:\n " & Exp.print_exp_str varexp => s &
	      print s & print "\ngiving:\n " &
          Exp.print_exp_str expr => s2 & print s2 & print "\n" &*)
         
         Exp.simplify(expr) => simplify_exp &
	     build_assignment(cr,simplify_exp,origname)  => assigment_string
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string	
         

  rule  (* Solving the state s means solving for der(s) *)
	     int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v &
	     (* v == variable no solved in this equation *)
	     int_sub(v,1) => v' &
	     array_nth(vararr,v') => DAELow.VAR(cr,kind,_,_,_,_,_,_,indx,origname,_) &

	     (*print "solving for state\n" &*)
         SimCodegen.cref_modelica_str(cr) => cr_str &


 	     Util.string_append_list(["_D_",cr_str]) => new_id &
	     let new_cr = Exp.CREF_IDENT(new_id,[]) &
	     let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


	     Exp.solve(e1,e2,new_varexp) => expr &
         
         (*Exp.print_exp_str e1 => new_e1s &
	      Exp.print_exp_str e2 => new_e2s &
          int_string(e) => eqn_nr &
          int_string(v) => var_nr &
	      print "STATE Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print new_e1s & print " = " & print new_e2s &
	      print " solved for " & Exp.print_exp_str new_varexp => s &
	      print s & print " giving " &
	      Exp.print_exp_str expr => s2 & print s2 & print "\n" & *)

         Exp.simplify(expr) => simplify_exp &
	     build_assignment(new_cr ,simplify_exp,origname)  => assigment_string
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => assigment_string 

  rule	int_sub(e,1) => e' &
	     DAELow.equation_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	     vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	     int_sub(v,1) => v' &
	     array_nth(vararr,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname,_) &  
	     let varexp = Exp.CREF(cr,Exp.REAL) &
	     not Exp.solve(e1,e2,varexp) => _ &
	     print "nonlinear equation not implemented yet\n" 
	     --------------------------------
	     build_equation(DAELow.DAELOW(DAELow.VARIABLES(_,vararr,_,_),_,eqns,_,_,_),ass1,ass2,e) => fail
         
  rule  print "-build_equation failed\n" 
	     --------------------------------
	     build_equation(_,_,_,_) => "//build_equation failed\n" 
 end

(** relation build_assignment 
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)

 relation build_assignment: (Exp.ComponentRef, (* varname *)
			                 Exp.Exp, (*expression*) 
			                 string) (* orig. name*) 
	      => string =
	       
  rule  SimCodegen.cref_modelica_str(cr) => cr_str & 
         SimCodegen.print_exp_cpp_str(exp) => exp_str & 
         (*Exp.print_exp_str(exp) => exp_str & *)
         Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str 
         --------------------------------
	     build_assignment(cr,exp,origname) => eqn_str
         
  rule	print "-build_assignment failed\n" 
	     ------------------------
	     build_assignment(cr,exp,origname) => fail
         
	     
 end


