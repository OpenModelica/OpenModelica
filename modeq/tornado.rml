(* 
 Copyright MathCore Engineering 2004-10-21
 This source is non-free and should not be included in OpenModelica
*)

(**
 **
 ** file:	 tornado.rml
 ** module:		 Tornado
 ** description: Code generation of Nodelica models including equation
 ** code and symbolic information to the Tornado-1 format.
 ** Part of the Hemmis project at MathCore Engineering AB.
 **
 ** RCS: $Id$
 ** 
 **)
module Tornado:
  
  with "dae.rml"
  with "absyn.rml"

(* Generates code according to the Tornado-1 format *)
  relation generate_code: (Absyn.Program, DAE.DAElist, Absyn.Path) => ()
	  
	  
	  
  end
with "interactive.rml"
with "util.rml"
with "system.rml"
with "daelow.rml"
with "exp.rml"
with "debug.rml"
with "rtopts.rml"

(** relation: generate_code
 ** This is the main relation that generates Tornado1 C++ code from the flat Modelica model
 ** It will generate two files <modelname>.cpp and <modelname>.hpp, the implementation file and 
 ** the header file. Those will currently be put in the current directory.
 ** The implementation uses the DAELow module to lower the flat modelica model such that it
 ** can be BLT sorted and indexed, etc.
 **)
relation generate_code:	 (Absyn.Program, DAE.DAElist, Absyn.Path) => () =

  rule	DAELow.lower(dae) => dae' &
	    Absyn.path_string(class) => cname &
	    generate_header(cname) => header &
	    generate_impl_header(cname) => implheader &
	    generate_constructor(cname,p,dae') => constr &
	    generate_var_defines(dae') => defines &
	    generate_compute_methods(cname,dae',p) => cmethods &
	    Util.string_append_list([implheader,constr,defines,cmethods]) => impl &
	    string_append(cname,".h") => headerfile &
	    string_append(cname,".cpp") => implfile &
	    System.write_file(headerfile,header) &
	    System.write_file(implfile,impl) 
	    -------------------------------------------------------------------
	    generate_code(p,dae,class) => 
        
  rule  print "generate_code failed\n" 
	    ------------------------------
	    generate_code(_,_,_) => fail
end

(** relation: generate_header
 ** Generate the content of the header file. It only needs the name of the Modelica model.
 **)
relation generate_header: string => string =

  rule	System.toupper cname => CNAME &
	Util.string_append_list(["#ifndef __",CNAME,"_H__\n"]) => r1 &
	Util.string_append_list(["#define __",CNAME,"_H__\n"]) => r2 &
	Util.string_append_list(["\n#include \"Tornado/EE/MSLE/MSLE.h\"\n",
				 "\n\nclass C",cname," : public Tornado::CDAEModel\n"]) => r3 &
	Util.string_append_list(["{\n  public:\n\n     C",cname,"(const wchar_t* Name);\n",
				 "\n  public:\n\n",
				 "    void ComputeInitial();\n",
				 "    void ComputeTerminal();\n",
				 "    void ComputeState();\n",
				 "    void ComputeOutput();\n",
				 "};\n\n",
				 "#endif\n"]) => r4 &
	Util.string_append_list([r1,r2,r3,r4]) => header
	------------------------------------------------
	generate_header(cname) => header


  rule	print "-generate_header failed\n" 
	---------------------------------
	generate_header(_) => fail
end

(** relation generate_impl_header
 ** generate the "header" of the implementation file, i.e. includes, ifdefs etc. 
 ** It is NOT the generation of the headerfile. (That is in the relation generate_header above)
 *)
relation generate_impl_header: string => string =

  rule	Util.string_append_list(["#ifdef _MSC_VER\n",
				 "#pragma warning(disable:4250)\n",
				 "#pragma warning(diable:4786)\n",
				 "#endif\n",
				 "\n",
				 "#include \"",cname,".h\"\n",
				 "\n",
				 "#include <math.h>\n",
				 "\n",
				 "using namespace Common;\n",
				 "using namespace Tornado;\n",
				 "\n"]) => implheader
	----------------------
	generate_impl_header(cname) => implheader
	
  rule	print "-generate_impl_header failed\n" 
	-------------------
	generate_impl_header(_) => fail
end

(** relation generate_constructor:
 ** Generates the implementation for the constructor which sets up the variables (names)
 ** and their initial values.
**)
relation generate_constructor: (string, Absyn.Program, DAELow.DAELow) => string =
	
	
  rule  generate_constructor_outputvars(dae) => outputvars &
		generate_constructor_statevars(dae) => statevars &
		generate_constructor_component_initialization(cname,p) => initializationvars &
		Util.string_append_list(["C",cname,"::\n",
				 "C",cname,"(const wchar_t* Name)\n",
				 "{\n",
				 "  SetName(Name);\n",
				 "  SetDesc(L\"",cname," test.\");\n",
				 "\n",
				 "  SetNoIndepVars(1);\n",
				 "  SetIndepVar(0, new CIndepVar(L\"t\",L\"s\"));\n",
				 "\n",
				 outputvars,
				 "\n",
				 "\n",
				 statevars,
				 "\n",
				 "  SetNoIndepVarValues(1);\n",
				 "\n",
				 "  Link();\n",
				 initializationvars,
				 "  Reset();\n",
				 "}\n",
				 "\n"]) => constr
	-----------------------------------------
	generate_constructor(cname,p,dae) => constr


  rule	print "-generate_constructor failed\n" 
	-------------------------------------
	generate_constructor(_,_,_) => fail

end

(* relation generate_constructor_outputvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_outputvars:(DAELow.DAELow) => string= 
        
  rule  generate_constructor_outputvars2(vars,0) => lst1 &
	    list_length(lst1) => len &
	    int_sub(len,1) => len' &
	    generate_constructor_outputvars2(knvars,len') => lst2 &
	    list_append(lst1,lst2) => lst &
	    Util.string_delimit_list(lst,"\n") => res &
	    list_length(lst) => len &
	    int_string len => lenstr &
        Util.string_append_list(["  SetNoOutputVars(",lenstr,");\n"]) => prefix &
        Util.string_append_list(["  SetNoOutputVarValues(",lenstr,");\n"]) => prefix &
        string_append(prefix,res) => res'
        -------------------------------------------
        generate_constructor_outputvars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_outputvars2:(DAELow.Var list,int) => string list = 

  rule (* special case for when called second time and first time gave 
  list length zero *)
 generate_constructor_outputvars2(lst,0) => res
 ----------------------------------------------
 generate_constructor_outputvars2(lst,-1) => res

  axiom generate_constructor_outputvars2([],_) => []

  rule int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_outputvars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs &
 Util.string_append_list([" SetOutputVar(",is,", new COutputVar(L\"",crs,"\", L\"\",0);"]) 
   => r1 
 --------------------
 generate_constructor_outputvars2(DAELow.VAR(cr,VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_)::rest,i) 
   => r1::res

  rule generate_constructor_outputvars2(rest,i) => res 
 -----------------------------------------------
 generate_constructor_outputvars2(_::rest,i) 
   => res

  rule print "-generate_constructor_outputvars2 failed\n" 
 ----------------------
 generate_constructor_outputvars2(_,_) => fail
end


(* relation: generate_constructor_statevars
 **  This relation is similar to the generate_constructor_outputvars relation above.
 ** It also generates code placed in the contstructor, but for state variables.
 ** They are also indexed in the order they appear in the DAELow representation, starting
 ** with index 0.
 *)
relation generate_constructor_statevars:(DAELow.DAELow) => string = 

  rule generate_constructor_statevars2(vars,0) => lst &
 Util.string_delimit_list(lst,"\n")=> res & 
 list_length(lst) => len &
 int_string len => lenstr &
 Util.string_append_list(["  SetNoDerStateVars(",lenstr,");\n"]) => prefix &
 Util.string_append_list(["  SetNoDerStateVarValues(",lenstr,");\n"]) => prefix &
 string_append(prefix,res) => res'
 ----------------------
 generate_constructor_statevars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_statevars2: (DAELow.Var list,int) => string list =

  axiom generate_constructor_statevars2([],_) => []

  rule (* When start value is present*)
 int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_statevars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs & 
 Exp.print_exp_str start => startstr &
 Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",",
     startstr,");"]) 
   => r1 
 --------------------
 generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,SOME(start),_,_)::rest,i) 
   => r1::res

  rule (* If no start value is present*)
 int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_statevars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs & 
 
 Util.string_append_list(["  SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",0);"]) 
   => r1 
 --------------------
 generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,NONE,_,_)::rest,i) 
   => r1::res

  rule generate_constructor_statevars2(rest,i) => res 
 -----------------------------------------------
 generate_constructor_statevars2(_::rest,i) 
   => res

  rule print "-generate_constructor_statevars2 failed\n" 
 ----------------------
 generate_constructor_statevars2(_,_) => fail
end

relation generate_var_defines: (DAELow.DAELow) => string =

  rule  generate_var_defines2(vars,0,0) => vdefs1list &
        list_length(vdefs1list) => len &
        int_sub(len,1) => len' &
        Util.string_append_list(vdefs1list) => vdefs1 &
        generate_var_defines2(knvars,0,0) => vdefs2list &
        Util.string_append_list(vdefs2list) => vdefs2 &
        Util.string_append_list(["#define _t_ m_IndepVarValues[0]\n",vdefs1,vdefs2,"\n"]) => vdefs
        ---------------------
        generate_var_defines(DAELow.DAELOW(vars,knvars,eqn,seqn)) => vdefs
        
  rule  print "-generate_var_defines failed\n"
        --------------------------------------
        generate_var_defines(_) => fail
end


(** Helper function for generate_var_defines
 ** Recursively traverses the list of variables and generates the defines 
 ** in the tornado format for them.
 ** Arg1 is the list of variables
 ** Arg2 is the counter for Output variables
 ** Arg3 is the counter for DerState and derivative variables
**)
relation generate_var_defines2: (DAELow.Var list,int,int) => string list =

  axiom generate_var_defines2([],_,_) => []
        
  rule int_string(outputCounter) => outputCounterString &
        Exp.cref_modelica_str(cr) => crs &
        Util.string_append_list(["#define ",crs," m_OutputVarValues[",outputCounterString,"]\n"]) => r1 &
        int_add(outputCounter,1) => outputCounter' & 
        generate_var_defines2(rest,outputCounter',derStateCounter) => res
        ----------------------------------------------
        generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,dir,_,_,_,_,_,_,_)::rest,
                              outputCounter,derStateCounter) 
          => r1::res
          
  rule int_string(derStateCounter) => derStateCounterString &
        Exp.cref_modelica_str(cr) => crs &
        Util.string_append_list(["#define ",crs," m_DerStateVarValues[",derStateCounterString,"]\n",
                                 "#define _D_",crs,"_ m_Derivatives[",derStateCounterString,"]\n"]) => r1 &
        int_add(derStateCounter,1) => derStateCounter' & 
        generate_var_defines2(rest,outputCounter,derStateCounter') => res
        ----------------------------------------------
        generate_var_defines2(DAELow.VAR(cr,DAELow.STATE,dir,_,_,_,_,_,_,_)::rest,
                              outputCounter,derStateCounter) 
          => r1::res
          
  rule generate_var_defines2(rest,outputCounter,derStateCounter) => res 
        -----------------------------------------------
        generate_var_defines2(_::rest,outputCounter,derStateCounter) => res
        
  rule print "-generate_var_defines2 failed\n"
        --------------------------------------
        generate_var_defines2(_,_,_) => fail
end

(** relation: generate_constructor_component_initialization
 ** this relation generates the code for initialization of internal
 ** components for a model. The components are non-primitive types.
 ** 
 **)
 relation generate_constructor_component_initialization: (string,Absyn.Program) => string =
  
 
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
	 (* call to helper function *)
         count_and_generate_initializations(cdef,program,0) => (ini_str_list,nr_of_comp) &         
         (* if there are no components then it will not generate constructors *)
         int_eq(nr_of_comp,0) => true
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => ""
         
         
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
	 (* call to helper function *)
         count_and_generate_initializations(cdef,program,0) => (ini_str_list,nr_of_comp) &         
         int_string(nr_of_comp) => res &
	 (* Generate the nr of submodels declaration *)
         Util.string_append_list(["  SetNoSubModels(",res,");\n"]) => res1 &
         Util.string_append_list(res1::ini_str_list) => res2 
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => res2
         
  rule  print "generate_constructor_component_initialization failed\n"
         --------------------------------------
         generate_constructor_component_initialization(_,_) => fail
         
 end

 relation count_and_generate_initializations: (Absyn.Class,Absyn.Program,int) => (string list, int) =
         
  rule	 (* For public declarations *)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1) & 
	 count_and_generate_initializations_in_elts(elt,program,nr_of_found_components) => (strlist,c2) &
	 int_add(c1,c2) => res &
         list_append(str,strlist) => string_list
         --------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)),program, nr_of_found_components)
	      => (string_list,res)
           
  rule	(* For protected declarations *)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1) &
	 count_and_generate_initializations_in_elts(elt,program,nr_of_found_components) => (strlist,c2) &
	 int_add(c1,c2) => res &
         list_append(str,strlist) => string_list
	 -------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt)),program, nr_of_found_components)
	  => (string_list,res)

  rule	(* Non-public, non protected, -> Throw it away*)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1)
	 -----------------------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(_::lst,cmt)),program, nr_of_found_components) => (str,c1)
	     
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS([],_)),_,_) => ([" "],0)
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.DERIVED(_,_,_,_,_)),_,_) => ([" "],-1)
         
  rule print "count_and_generate_initializations failed\n"
         --------------------------------------
         count_and_generate_initializations(_,_,_) => fail
         
 end

 relation count_and_generate_initializations_in_elts: (Absyn.ElementItem list,Absyn.Program,int) => (string list, int) =         

  rule	Interactive.is_primitive(Absyn.CREF_IDENT(ident,[]),program) => false & 
         generate_components_initializations(ident,componentItemList,index) => (comp_str_list,nrOfComponents) &
	 int_add(index,nrOfComponents) => inc_index1 &

 	 int_add(index,1) => inc_index2 &
	 count_and_generate_initializations_in_elts(lst,program,inc_index2) => (strlist,c1) &
	 list_append(comp_str_list,strlist) => str_list_res 
	 --------------------------
	 count_and_generate_initializations_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,
            Absyn.COMPONENTS(_,Absyn.IDENT(ident),componentItemList),_,_,NONE))::lst,program,index) => (str_list_res,c1)
	     
  rule	count_and_generate_initializations_in_elts(lst,program,index) => (strlist,res)
	 ----------------------------
	 count_and_generate_initializations_in_elts(_::lst,program,index) => (strlist,res)
         
  axiom	count_and_generate_initializations_in_elts([],_,index) => ([""],index)

  rule	print "count_and_generate_initializations_in_elts failed\n"
	     ----------------------------
	     count_and_generate_initializations_in_elts(_,_,_) => fail

end

relation generate_components_initializations: (Absyn.Ident, Absyn.ComponentItem list, int) => (string list, int) =
  
  rule  int_string(index) => current_index_string &
        int_add(index,1) => inc_index &	
        generate_components_initializations(componentType,rest,inc_index) => (res,ret_index) &
        Util.string_append_list(["  SetSubModel(",current_index_string,
                                 ", new C",componentType,"(L\"",componentIdent,"\"));\n"]) => gen_string
        -------------------------------------
        generate_components_initializations(componentType,
                                            Absyn.COMPONENTITEM(Absyn.COMPONENT(componentIdent,_,_),_)::rest, 
                                            index) => (gen_string::res, ret_index)

  axiom	generate_components_initializations(componentType,[],index) => ([""],index)

end


(** relation: generate_compute_methods
 ** This relation generates the code for the computation of the equations
 ** They are separated into four parts.
 ** - computing the output variables (algebraic variables)
 ** - computing the state variables
 ** - computing the initial conditions
 ** - computing the terminal conditions
 **)
relation generate_compute_methods: (string,DAELow.DAELow,Absyn.Program) => string =

  rule  
        generate_blt(dae) => (blt,ass1,ass2) &
        
        (** ass1 is what var is solved in what eqn **)
        (** ass2 is what eqn is solves what var **)
        generate_state_partition(blt,dae,ass1,ass2) => (blt_states,blt_no_states) &


        translate_dae(dae) => dae' &

        generate_compute_output(cname,dae',p,ass1,ass2,blt_no_states) => coutput &
        generate_compute_initial(cname,dae',p) => cinitial &
        generate_compute_state(cname,dae',p,ass1,ass2,blt_states) => cstate &
        (*generate_compute_terminal(cname,dae',p) => cterm &*)
        generate_compute_terminal(cname,dae',p,ass1,ass2,blt) => cterm &
        Util.string_append_list(["void C",cname,"::\n",
                                 "ComputeOutput()\n",
                                 "{\n",
                                 coutput,
                                 "}\n",
                                 "\n",
                                 "void C",cname,"::\n",
                                 "ComputeInitial()\n",
                                 "{\n",
                                 cinitial,
                                 "}\n",
                                 "\n",
                                 "void C",cname,"::\n",
                                 "ComputeState()\n",
                                 "{\n",
                                 cstate,
                                 "}\n",
                                 "\n",
                                 "void C",cname,"::\n",
                                 "ComputeTerminal()\n",
                                 "{\n",
                                 cterm,
                                 "}\n", 
                                 "\n"]) => methods
        ---------------------------
        generate_compute_methods(cname,dae,p) => methods
        
  rule  print "-generate_compute_methods failed\n" 
        -----------------------------------------
        generate_compute_methods(_,_,_) => fail
end 


(** relation generate_blt
 ** This relation computes the block lower triangular form of the equation 
 ** system using a list of the DAEs. 
 **
 **)
 relation generate_blt:(DAELow.DAELow) => (int list list,int vector, int vector) =
         
 
  rule  (*DAELow.lower(d) => d' *)
         Debug.fcall("dumpdaelow", DAELow.dump, d') 
         & DAELow.incidence_matrix(d') => m 
         & DAELow.transpose_matrix(m) => mT 
         & DAELow.matching_algorithm(d',m,mT) => (v1,v2,d'',m,mT) 
         & Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
         (* & Debug.fcall("bltdump", DAELow.dump_incidence_matrix_inv, mT) *)
         & Debug.fcall("bltdump", DAELow.dump,d'')
         & Debug.fcall("bltdump", DAELow.dump_matching, v1)
         & DAELow.strong_components(m,mT,v1,v2) => (comps) 
         & DAELow.dump_components(comps) 
         -------------------------------------------------------------
         generate_blt(d') => (comps,v1,v2)
         
  rule  print "-generate_blt failed\n" 
         -------------------------------------------------
         generate_blt(_) => fail
         
end


(** relation:generate_state_partition
 ** this relation extracts the rightmost part 
 **
 ** returns two incidencematrices, the first one including blocks with 
 ** all state variables (and of course some other variables as well) 
 ** and the second one including no state variables. No reordering
 ** of blocks is performed.
 **) 
relation generate_state_partition:(int list list,DAELow.DAELow,int vector,int vector) => 
 (int list list, int list list) =
        
  rule  list_reverse(blt) => reversed_blt &
        has_state_var(0,reversed_blt,dae,ass1,ass2) => state_component_number &
        list_length(blt) => nr_of_components &
        int_sub(nr_of_components,state_component_number) => component_offset & 
        print "(non-reversed): " &
        int_string(component_offset) => component_offset_string &
        print component_offset_string &
        print "\n" &
        
        Util.list_split(blt,component_offset) => (blt_states,blt_no_states) 
        -----------------------------------------
        generate_state_partition(blt,dae,ass1,ass2) => (blt_states,blt_no_states)
        
  rule  print "-generate_state_partition failed\n" 
        -----------------------------------------
        generate_state_partition(_,_,_,_) => fail
        
end

(** Helper relation for generate state partition
 ** Determines which list of coefficients contains the first 
 ** statevariable
 ** 
 ** Returns the first component number (counted from the end of the list)
 ** which contais a state variable.
 **) 
relation has_state_var:(int, int list list, DAELow.DAELow,int vector, int vector) => int =
   
  rule  (*if this component contains a statevar, return index *)
        check_component_for_statevars(0,element,dae,ass1,ass2) => true
        -----------------------------------------
        has_state_var(index,element::reversed_blt,dae,ass1,ass2) => index

        (* If we have no more components return 0 *)
  axiom has_state_var(_,[],_,_,_) => 0
        
  rule  (* If no statevars found in this component, continue with the next one*)
        int_add(1,index) => next_index &
        has_state_var(next_index,reversed_blt,dae,ass1,ass2) => ret_value
        -----------------------------------------
        has_state_var(index,element::reversed_blt,dae,ass1,ass2) => ret_value
        
  rule  print "-generate_state_partition2 failed\n" 
        -----------------------------------------
        has_state_var(_,_,_,_,_) => fail
end

(** relation:check_component_for_statevars
 ** Arg 1 is the index in the component to the current variable to check
 ** Arg 2 is the component itself
 ** Arg 3 is the DAEs
 ** Returns true if this component contains a statevar
 **)
relation check_component_for_statevars:(int, int list, DAELow.DAELow,int vector, int vector) => bool =
        
  rule  print "check_component_for_statevars failed: Empty component\n" 
        -------------------------------------------------------------
        check_component_for_statevars(_,[],_,_,_) => fail
        
        
  rule  (* Termination condition. variables checked.
         This means that the component did not contain any state vars *)
        list_length(component) => nr_of_variables &
        int_eq(nr_of_variables,i) => true
        -------------------------------------------------------------
        check_component_for_statevars(i,component,_,ass1,ass2) => false
        
  rule  (* If this variable is a state variable, return true *)
        list_nth(component,i) => variable_index_to_check &
        (* Variable indexing starts from 1 but lists start from 0.
         Thus decrease index by one*) 
        int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
	    vector_nth(ass2,adjusted_variable_index_to_check) => v &
	    int_sub(v,1) => v' &
	    list_nth(var_list,v') => (v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname)) &  
	    not is_non_state(kind)
        -------------------------------------------------------------
        check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_),ass1,ass2) => true

  rule  (* If this variable is nt state variable, try the next one *)
        list_nth(component,i) => variable_index_to_check &
        (* Variable indexing starts from 1 but lists start from 0.
         Thus decrease index by one*) 
        int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
	    vector_nth(ass2,adjusted_variable_index_to_check) => v &
	    int_sub(v,1) => v' &
	    list_nth(var_list,v') => (v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname)) &  
        int_add(i,1) => next_i &
        check_component_for_statevars(next_i,component,dae,ass1,ass2) => result
        -------------------------------------------------------------
        check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_),ass1,ass2) 
          => result

  rule  print "check_component_for_statevars failed" 
        -------------------------------------------------------------
        check_component_for_statevars(_,_,_,_,_) => fail
        
end 

(** relation translate_dae 
 ** This relation translates the DAE so that all the der(x) is _D_X in the equations
 **
 **)    
relation translate_dae: DAELow.DAELow => DAELow.DAELow =

  rule  extract_der_from_var_list(var_list) => (from_list,to_list) &
        replace_exp_in_eqns(eqn_list,from_list,to_list) => res_eqns
        -------------------------------------------------------------
        translate_dae(dae as DAELow.DAELOW(var_list,a,eqn_list,b)) 
          => DAELow.DAELOW(var_list,a,res_eqns,b)



  rule  print "-translate_dae failed\n"
        -------------------------------------------------------------
        translate_dae(dae) => fail



end

(** relation extract_der_from_var_list 
 ** This relation generates to Exp.Exp list of the form:
 ** [Exp.CALL("der,Exp.Exp("x")...)] and [Exp.cref("x")]
 **
 **)
relation extract_der_from_var_list: DAELow.Var list => (Exp.Exp list, Exp.Exp list) =
  
  rule  
        -------------------------------------------------------------
        extract_der_from_var_list([]) => ([],[])
   
  rule  is_non_state kind &
        (*print "extract_der_from_var_list Is not state\n" &*)
        extract_der_from_var_list(var_list) => (res1,res2)
        -------------------------------------------------------------
        extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname))::var_list)  
          => (res1,res2)

  rule  (*print "extract_der_from_var_list Is state" &*)

        Exp.print_component_ref_str(cr) => cr_str &

	    let old_varexp = Exp.CREF(cr,Exp.REAL) &

        let dercall = Exp.CALL(Absyn.IDENT("der"),
			                   [old_varexp], 
			                   false,
			                   false) &
	
        Util.string_append_list(["_D_",cr_str]) => new_id &
	    let new_cr = Exp.CREF_IDENT(new_id,[]) &
	    let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


	   (* print " from \"" & print cr_str & print "\" to \"" & print new_id  & print "\"\n" & *)

        extract_der_from_var_list(var_list) => (res1,res2)
        -------------------------------------------------------------
        extract_der_from_var_list((v as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname))::var_list)  
          => (dercall::res1, new_varexp::res2)


  rule  print "-extract_der_from_var_list failed\n"
        -------------------------------------------------------------
        extract_der_from_var_list(_) => fail
end

(** relation replace_exp_in_eqns
 ** This takes a DAELow.Equation list and two Exp.Exp lists: ("from","to") and does
 ** a "replace" all on the equations;
 **
 **)

relation replace_exp_in_eqns:(DAELow.Equation list, Exp.Exp list, Exp.Exp list) => DAELow.Equation list =
        
  rule  
        -------------------------------------------------------------
        replace_exp_in_eqns([],from_exp,to_exp) => []

  rule  (*print "replace_exp_in_eqns not list" &*)
        Exp.replace_exp_list(exp1,from_exp,to_exp) => (res_exp1,nr_of_times1) &
        Exp.replace_exp_list(exp2,from_exp,to_exp) => (res_exp2,nr_of_times2) & 
        replace_exp_in_eqns(eqns_rest,from_exp,to_exp) => res_eqns
        -------------------------------------------------------------
        replace_exp_in_eqns(DAELow.EQUATION(exp1,exp2)::eqns_rest,from_exp,to_exp) => (DAELow.EQUATION(res_exp1,res_exp2)::res_eqns)


  rule  print "-replace_exp_in_eqns failed\n"
        -------------------------------------------------------------
        replace_exp_in_eqns(_,_,_) => fail
end



(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output variables.
 **)
relation generate_compute_output:(string,
                                  DAELow.DAELow,
                                  Absyn.Program,
                                  int vector, 
                                  int vector, 
                                  int list list) => string =

  rule  (*Util.string_append_list(["/* output code here*/\n"]) => coutput &*)
        print("----------- START building block OUTPUT---------------\n") &
        build_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
        Util.list_map(seqn,build_simple_equation) => simple_eqn_list &
        Util.string_append_list(simple_eqn_list) => coutput1 &
        Util.string_append_list(eqn_str_list) => coutput2 &
        Util.string_append_list([coutput1,coutput2]) => coutput &
        print("----------- END building block OUTPUT---------------\n") 
        
        -------------------------------------------------------------
        generate_compute_output(cname,
                                dae as DAELow.DAELOW(vars,knvars,eqn,seqn),
                                p,ass1,ass2,blocks) => coutput
        
end


relation build_simple_equation:(DAELow.Equation) => string =
        
  rule  Exp.print_exp_str(exp1) => exp1_str & 
        Exp.print_exp_str(exp2) => exp2_str & 
        Util.string_append_list(["  ",exp1_str, " = ", exp2_str, ";\n"]) => eqn_str &
        print "\n build_simple_equation: " & print(eqn_str) 
        --------------------------------
	    build_simple_equation(DAELow.EQUATION(exp1,exp2)) => eqn_str

        
  rule  
        -------------------------------------------------------------
        build_simple_equation(DAELow.EQUATION(exp1,exp2)) => "// generating simple equation failed"

end
(** relation: generate_compute_initial
 ** This relation generates the code for the calculation of the initial conditions.
 **)
relation generate_compute_initial:(string,DAELow.DAELow,Absyn.Program) => string =

  rule  Util.string_append_list(["/* initial code here*/\n"]) => cinit
        -------------------------------------------------------------
        generate_compute_initial(cname,dae,p) => cinit
        
end

(** relation: generate_compute_state
 ** This relation generates the code for the calculation of the state variables.
 **)
relation generate_compute_state:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => string =

  rule  (*Util.string_append_list(["/* state code here*/\n"]) => cstate &*)
        (*print("----------- START building block STATE---------------\n") &*)
        build_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cstate 
        (*print("----------- END building block STATE---------------\n") *)
        
        -------------------------------------------------------------
        generate_compute_state(cname,dae,p,ass1,ass2,blocks) => cstate

end


(** relation: generate_compute_terminal
 ** This relation generates the code for the calculation of the terminal behavior.
 ** This can be expressed in Modelica using when statements:
 ** when terminal() then
 **   x:=do_calc(x,y);
 ** end when
 *)
relation generate_compute_terminal:(string,DAELow.DAELow,Absyn.Program,int vector, int vector, int list list) => string =
        
  rule  (*Util.string_append_list(["/* state code here*/\n"]) => cstate &*)
        print("----------- START building block TERMINAL---------------\n") &
        build_blocks(dae,ass1,ass2,blocks) => eqn_str_list &
        Util.string_append_list(eqn_str_list) => cterminal &
        print("----------- END building block TERMINAL---------------\n") 
        
        -------------------------------------------------------------
        generate_compute_terminal(cname,dae,p,ass1,ass2,blocks) => cterminal



  rule Util.string_append_list(["/* terminal code here*/\n"]) => cterm
     -------------------------------------------------------------
     generate_compute_terminal(cname,dae,p,_,_,_) => cterm
end


(** relation build_blocks
 ** this is copied from taskgraph.rml and constructs the blocks in the incident matrix
 ** for the equations.
 ** It is NOT done for system of equations!
 **)
relation build_blocks:(DAELow.DAELow, int vector, int vector, int list list) => string list =

  axiom	build_blocks(_,_,_,[]) => []

        (* rule	(* For system of equations *)*)
         (* build_system(dae,ass1,ass2,block) &
	      build_blocks(dae,ass1,ass2,blocks)
	      -------------------------------------
	      build_blocks(dae,ass1,ass2,(block as (_::_::_))::blocks)*)
	     
  rule	(* for single equations *)
	build_equation(dae,ass1,ass2,eqn) => eqn_str &
	build_blocks(dae,ass1,ass2,blocks) => res
	-------------------------------------
	build_blocks(dae,ass1,ass2,(block as [eqn])::blocks) => eqn_str::res

  rule	print "-build_blocks failed\n" 
	-----------------
	build_blocks(_,_,_,_) => fail
end


  
(** relation is_non_state 
 ** this equation checks if the the varkind is state of variable
 ** used both in build_equation and generate_compute_state
 **)
relation is_non_state: DAELow.VarKind => () =

  axiom	is_non_state (DAELow.VARIABLE) => ()
  axiom	is_non_state (DAELow.DUMMY_DER) => ()
  axiom	is_non_state (DAELow.DUMMY_STATE) => ()
end


(** relation build_equation 
 ** This returns the string for a specific equation in the 
 ** incidence matrix.
 ** It is used both for state variables and regular variables
 **)
relation build_equation:(DAELow.DAELow, int vector, int vector, int) => string =
	
  rule  (* Solving for non-states *)
        int_sub(e,1) => e' &
	    list_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	    vector_nth(ass2,e') => v &
	    int_sub(v,1) => v' &
	    list_nth(vars,v') => (va as DAELow.VAR(cr,kind,_,_,_,_,_,_,_,origname)) &  
	    is_non_state kind &
	    print "Solving for non-states\n" &

	    let varexp = Exp.CREF(cr,Exp.REAL) &
	    Exp.solve(e1,e2,varexp) => expr &
	    
        (* start debug output *)
        Exp.print_exp_str e1 => e1s &
	    Exp.print_exp_str e2 => e2s &
        int_string(e) => eqn_nr &
        int_string(v) => var_nr &
	    print "Equation nr: " & print eqn_nr & print " var nr: " & print var_nr &print " :\n" & print e1s & print " = " & print e2s &
	    print "\nsolved for:\n " & Exp.print_exp_str varexp => s &
	    print s & print "\ngiving:\n " &
	    Exp.print_exp_str expr => s2 & print s2 & print "\n" &
        
	    build_assignment(cr,expr,origname)  => assigment_string
	    --------------------------------
	    build_equation(DAELow.DAELOW(vars,_,eqns,_),ass1,ass2,e) => assigment_string	
        

  rule  (* Solving the state s means solving for der(s) *)
	    int_sub(e,1) => e' &
	    list_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	    vector_nth(ass2,e') => v &
	    (* v == variable no solved in this equation *)
	    int_sub(v,1) => v' &
	    list_nth(vars,v') => DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,_,indx,origname) &
	    print "solving for state\n" &
	    int_string(indx) => indxs &

        Exp.print_component_ref_str(cr) => cr_str &


 	    Util.string_append_list(["_D_",cr_str]) => new_id &
	    let new_cr = Exp.CREF_IDENT(new_id,[]) &
	    let new_varexp = Exp.CREF(new_cr,Exp.REAL) &


	    Exp.solve(e1,e2,new_varexp) => expr &
        
        Exp.print_exp_str e1 => new_e1s &
	    Exp.print_exp_str e2 => new_e2s &
	    print " Equation " & print new_e1s & print " = " & print new_e2s &
	    print " solved for " & Exp.print_exp_str new_varexp => s &
	    print s & print " giving " &
	    Exp.print_exp_str expr => s2 & print s2 & print "\n" & 


	    build_assignment(new_cr ,expr,origname)  => assigment_string
	    --------------------------------
	    build_equation(DAELow.DAELOW(vars,_,eqns,_),ass1,ass2,e) => assigment_string 

  rule	int_sub(e,1) => e' &
	    list_nth(eqns,e') => DAELow.EQUATION(e1,e2) &
	    vector_nth(ass2,e') => v & (* v==variable no solved in this equation *)
	    int_sub(v,1) => v' &
	    list_nth(vars,v') => DAELow.VAR(cr,_,_,_,_,_,_,_,_,origname) &  
	    let varexp = Exp.CREF(cr,Exp.REAL) &
	    not Exp.solve(e1,e2,varexp) => _ &
	    print "nonlinear equation not implemented yet\n" 
	    --------------------------------
	    build_equation(DAELow.DAELOW(vars,_,eqns,_),ass1,ass2,e) => fail
        
  rule  print "-build_equation failed\n" 
	    --------------------------------
	    build_equation(_,_,_,_) => "//build_equation failed\n" 
end

(** relation build_assignment 
 ** This relation takes a ComponentRef(cr) and an expression(exp)
 ** and makes a C++ assignment: cr = exp;
 **)

relation build_assignment: (Exp.ComponentRef, (* varname *)
			                Exp.Exp, (*expression*) 
			                string) (* orig. name*) 
	      => string =
   
  rule  Exp.print_component_ref_str(cr) => cr_str & 
        print_exp_cpp_str(exp) => exp_str & 
        (*Exp.print_exp_str(exp) => exp_str & *)
        Util.string_append_list(["  ",cr_str, " = ", exp_str, ";\n"]) => eqn_str &
        print "\n build_assigment: " & print(eqn_str) & print("-------------------------\n") 
        --------------------------------
	    build_assignment(cr,exp,origname) => eqn_str

  rule	print "-build_assignment failed\n" 
	    ------------------------
	    build_assignment(cr,exp,origname) => fail
        
       
end



(** relation: print_exp_str
 **
 ** This relation prints a complete expression.
 **)

relation print_exp_cpp_str : Exp.Exp => string =

  rule	print_exp2_str (e,0) => s
	--------------------
	print_exp_cpp_str e => s

end


relation print_exp2_str : (Exp.Exp,int) => string =
	
  axiom print_exp2_str(Exp.END,_) => "end"
  
  rule	int_string(x) => s
	----------------------------
	print_exp2_str(Exp.ICONST(x),_) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp2_str(Exp.RCONST(x),_) => s

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	print_exp2_str(Exp.SCONST(s),_) => s''

  axiom	print_exp2_str(Exp.BCONST(false),_) => "false"

  axiom	print_exp2_str(Exp.BCONST(true),_) => "true"

  rule	Exp.print_component_ref_str (c) => s
	--------------------------------
	print_exp2_str(Exp.CREF(c,_),_) => s

  rule	Exp.binop_symbol(op) => sym &
 	Exp.binop_priority op => pri2' &
	int_add (pri2',1) => pri2 & (* binary minus have higher priority than itself *)
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	Exp.print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (Exp.BINARY(e1, op as Exp.SUB(ty), e2 as Exp.BINARY(e21, Exp.SUB(ty2), e22)),pri1) => s'''

  rule	Exp.binop_symbol(op) => sym &
 	Exp.binop_priority op => pri2 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	Exp.print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (Exp.BINARY(e1, op, e2),pri1) => s'''

  rule	Exp.unaryop_symbol(op) => sym &
	Exp.unaryop_priority(op) => pri2 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
	Exp.print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	----------------------------
	print_exp2_str(Exp.UNARY(op, e),pri1) => s''

  rule	Exp.lbinop_symbol(op) => sym &
	Exp.lbinop_priority(op) => pri2 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri2) => s3 &
	Exp.print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	----------------------------------------------------------------
	print_exp2_str(Exp.LBINARY(e1, op, e2),pri1) => s'''

  rule	Exp.lunaryop_symbol(op) => sym &
 	Exp.lunaryop_priority(op) => pri2 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str (e,pri3) => s2 &
	Exp.print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	---------------------------------------------------
	print_exp2_str(Exp.LUNARY(op, e),pri1) => s''

  rule	Exp.relop_symbol(op) => sym &
 	Exp.relop_priority(op) => pri2 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str(e1,pri3) => s2 & 
	print_exp2_str(e2,pri2) => s3 &
	Exp.print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-----------------------------------------------------------------
	print_exp2_str(Exp.RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	print_exp2_str(t,0) => thenstr &
	print_exp2_str(f,0) => elsestr &
	string_append ("( ", ifstr) => s &
	string_append (s, " ) ? ( ") => s' &
	string_append (s', thenstr) => s'' &
	string_append (s'', " ) : ( ") => s''' &
	string_append (s''', elsestr) => s'''' &
	string_append (s'''', " ) ") => slast 
	----------------------------
	print_exp2_str(Exp.IFEXP(c,t,f),_) => slast

  rule	Absyn.path_string(fcn) => fs &
	Exp.print_list_str(args,print_exp_cpp_str,",") => argstr &
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp2_str(Exp.CALL(fcn, args,_,_),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp2_str (Exp.ARRAY(_,_,es),_) => s''

  rule	Exp.print_list_str(es, print_exp_cpp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp2_str (Exp.TUPLE(es),_) => s''
	
  rule	Exp.print_list_str(es, Exp.print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	print_exp2_str (Exp.MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (stop,pri3) => s3 &
 	Exp.print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-------------------------------------------------------------
	print_exp2_str (Exp.RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	Exp.print_leftpar_str (pri1,pri2) => (s1,pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (step,pri3) => s3 &
 	print_exp2_str (stop,pri3) => s4 &
 	Exp.print_rightpar_str (pri1,pri2) => s5 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s4) => s'''' &
	string_append (s'''', s5) => s'''''
	-------------------------------------
	print_exp2_str (Exp.RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res
	---------------------------------------
	print_exp2_str (Exp.CAST(REAL,Exp.ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res &
	string_append("-",res) => res2
	---------------------------------------
	print_exp2_str (Exp.CAST(REAL,Exp.UNARY(Exp.UMINUS(_),Exp.ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	print_exp_cpp_str e => s & 
	string_append ("Real(", s) => s' &
	string_append (s', ")") => s''
	---------------------------------------
	print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	print_exp_cpp_str e => s
	---------------------------------------
	print_exp2_str (Exp.CAST(Exp.REAL,e),_) => s

  rule	let pri2 = 51 &
	Exp.print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
 	Exp.print_rightpar_str (pri1,pri2) => s3 &
 	int_string i => s4 &
	string_append (s1, s2) => s &
	string_append (s, s3) => s' &
	string_append (s', "[") => s'' &
	string_append (s'', s4) => s''' &
	string_append (s''', "]") => s''''
	---------------------------------------
	print_exp2_str (Exp.ASUB(e,i),pri1) => s''''

  rule	print_exp_cpp_str cr => crstr &
	print_exp_cpp_str dim => dimstr &
	Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	------------------------
	print_exp2_str (Exp.SIZE(cr,SOME(dim)),_) => str

  rule	print_exp_cpp_str cr => crstr &
	Util.string_append_list(["size(",crstr,")"]) => str
	------------------------
	print_exp2_str (Exp.SIZE(cr,NONE),_) => str


  rule	Absyn.path_string fcn => fs &
	print_exp_cpp_str exp => expstr &
	print_exp_cpp_str iterexp => iterstr &
	Util.string_append_list(["<reduction>",
				 fs,"(",expstr," for ",
				 id," in ",iterstr,")"]) => str
	-------------------------------------------------------
	print_exp2_str (Exp.REDUCTION(fcn,exp,id,iterexp),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

end


