(* 
 Copyright MathCore Engineering 2004-10-21
 This source is non-free and should not be included in OpenModelica
*)

(**
**
  ** file:	 tornado.rml
 ** module:		 Tornado
 ** description: Code generation of Nodelica models including equation
 ** code and symbolic information to the Tornado-1 format.
 ** Part of the Hemmis project at MathCore Engineering AB.
 **
 ** RCS: $Id$
 ** 
 **)
module Tornado:
  
  with "dae.rml"
  with "absyn.rml"

(* Generates code according to the Tornado-1 format *)
  relation generate_code: (Absyn.Program, DAE.DAElist, Absyn.Path) => ()
	  
	  
	  
  end
with "interactive.rml"
with "util.rml"
with "system.rml"
with "daelow.rml"
with "exp.rml"
with "debug.rml"


(** relation: generate_code
 ** This is the main relation that generates Tornado1 C++ code from the flat Modelica model
 ** It will generate two files <modelname>.cpp and <modelname>.hpp, the implementation file and 
 ** the header file. Those will currently be put in the current directory.
 ** The implementation uses the DAELow module to lower the flat modelica model such that it
 ** can be BLT sorted and indexed, etc.
 **)
relation generate_code:	 (Absyn.Program, DAE.DAElist, Absyn.Path) => () =

  rule	DAELow.lower(dae) => dae' &
	Absyn.path_string(class) => cname &
	generate_header(cname) => header &
	generate_impl_header(cname) => implheader &
	generate_constructor(cname,p,dae') => constr &
	generate_var_defines(dae') => defines &
	generate_compute_methods(cname,dae',p) => cmethods &
	Util.string_append_list([implheader,constr,defines,cmethods]) => impl &
	string_append(cname,".h") => headerfile &
	string_append(cname,".cpp") => implfile &
	System.write_file(headerfile,header) &
	System.write_file(implfile,impl) 
	-------------------------------------------------------------------
	generate_code(p,dae,class) => 

  rule	print "generate_code failed\n" 
	------------------------------
	generate_code(_,_,_) => fail
end

(** relation: generate_header
 ** Generate the content of the header file. It only needs the name of the Modelica model.
 **)
relation generate_header: string => string =

  rule	System.toupper cname => CNAME &
	Util.string_append_list(["#ifndef __",CNAME,"_H__\n"]) => r1 &
	Util.string_append_list(["#define __",CNAME,"_H__\n"]) => r2 &
	Util.string_append_list(["\n#include \"Tornado/EE/MSLE/MSLE.h\"\n",
				 "\n\nclass C",cname," : public Tornado::CDAEModel\n"]) => r3 &
	Util.string_append_list(["{\n  public:\n\n     C",cname,"(const wchar_t* Name);\n",
				 "\n  public:\n\n",
				 "    void ComputeInitial();\n",
				 "    void ComputeTerminal();\n",
				 "    void ComputeState();\n",
				 "    void ComputeOutput();\n",
				 "};\n\n",
				 "#endif\n"]) => r4 &
	Util.string_append_list([r1,r2,r3,r4]) => header
	------------------------------------------------
	generate_header(cname) => header


  rule	print "-generate_header failed\n" 
	---------------------------------
	generate_header(_) => fail
end

(** relation generate_impl_header
 ** generate the "header" of the implementation file, i.e. includes, ifdefs etc. 
 ** It is NOT the generation of the headerfile. (That is in the relation generate_header above)
 *)
relation generate_impl_header: string => string =

  rule	Util.string_append_list(["#ifdef _MSC_VER\n",
				 "#pragma warning(disable:4250)\n",
				 "#pragma warning(diable:4786)\n",
				 "#endif\n",
				 "\n",
				 "#include \"",cname,".h\"\n",
				 "\n",
				 "#include <math.h>\n",
				 "\n",
				 "using namespace Common;\n",
				 "using namespace Tornado;\n",
				 "\n"]) => implheader
	----------------------
	generate_impl_header(cname) => implheader
	
  rule	print "-generate_impl_header failed\n" 
	-------------------
	generate_impl_header(_) => fail
end

(** relation generate_constructor:
 ** Generates the implementation for the constructor which sets up the variables (names)
 ** and their initial values.
**)
relation generate_constructor: (string, Absyn.Program, DAELow.DAELow) => string =
	
	
  rule	
		generate_constructor_outputvars(dae) => outputvars &
		generate_constructor_statevars(dae) => statevars &
		generate_constructor_component_initialization(cname,p) => initializationvars &
		Util.string_append_list(["C",cname,"::\n",
				 "C",cname,"(const wchar_t* Name)\n",
				 "{\n",
				 "  SetName(Name);\n",
				 "  SetDesc(L\"",cname," test.\");\n",
				 "\n",
				 "  SetNoIndepVars(1);\n",
				 "  SetIndepVar(0, new CIndepVar(L\"t\",L\"s\"));\n",
				 "\n",
				 outputvars,
				 "\n",
				 "\n",
				 statevars,
				 "\n",
				 "  SetNoIndepVarValues(1);\n",
				 "\n",
				 "  Link(); sadfj====>\n",
				 initializationvars,
				 "  Reset();\n",
				 "}\n",
				 "\n"]) => constr
	-----------------------------------------
	generate_constructor(cname,p,dae) => constr


  rule	print "-generate_constructor failed\n" 
	-------------------------------------
	generate_constructor(_,_,_) => fail

end

(* relation generate_constructor_outputvars
 ** Generates the outputvars methodcalls in the constructor.
 ** The variables are indexed in the order they appear in the DAELow representation.
 ** The first output variable has the index 0. 
 *)
relation generate_constructor_outputvars:(DAELow.DAELow) => string= 
        
  rule  generate_constructor_outputvars2(vars,0) => lst1 &
	    list_length(lst1) => len &
	    int_sub(len,1) => len' &
	    generate_constructor_outputvars2(knvars,len') => lst2 &
	    list_append(lst1,lst2) => lst &
	    Util.string_delimit_list(lst,"\n") => res &
	    list_length(lst) => len &
	    int_string len => lenstr &
        Util.string_append_list([" SetNoOutputVars(",lenstr,");\n"]) => prefix &
        Util.string_append_list([" SetNoOutputVarValues(",lenstr,");\n"]) => prefix &
        string_append(prefix,res) => res'
        -------------------------------------------
        generate_constructor_outputvars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_outputvars2:(DAELow.Var list,int) => string list = 

  rule (* special case for when called second time and first time gave 
  list length zero *)
 generate_constructor_outputvars2(lst,0) => res
 ----------------------------------------------
 generate_constructor_outputvars2(lst,-1) => res

  axiom generate_constructor_outputvars2([],_) => []

  rule int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_outputvars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs &
 Util.string_append_list([" SetOutputVar(",is,", new COutputVar(L\"",crs,"\", L\"\",0);"]) 
   => r1 
 --------------------
 generate_constructor_outputvars2(DAELow.VAR(cr,VARIABLE,DAE.OUTPUT,_,_,_,_,start,_,_)::rest,i) 
   => r1::res

  rule generate_constructor_outputvars2(rest,i) => res 
 -----------------------------------------------
 generate_constructor_outputvars2(_::rest,i) 
   => res

  rule print "-generate_constructor_outputvars2 failed\n" 
 ----------------------
 generate_constructor_outputvars2(_,_) => fail
end


(* relation: generate_constructor_statevars
 **  This relation is similar to the generate_constructor_outputvars relation above.
 ** It also generates code placed in the contstructor, but for state variables.
 ** They are also indexed in the order they appear in the DAELow representation, starting
 ** with index 0.
 *)
relation generate_constructor_statevars:(DAELow.DAELow) => string = 

  rule generate_constructor_statevars2(vars,0) => lst &
 Util.string_delimit_list(lst,"\n")=> res & 
 list_length(lst) => len &
 int_string len => lenstr &
 Util.string_append_list([" SetNoDerStateVars(",lenstr,");\n"]) => prefix &
 Util.string_append_list([" SetNoDerStateVarValues(",lenstr,");\n"]) => prefix &
 string_append(prefix,res) => res'
 ----------------------
 generate_constructor_statevars(DAELow.DAELOW(vars,knvars,eqn,seqn)) => res'
end

relation generate_constructor_statevars2: (DAELow.Var list,int) => string list =

  axiom generate_constructor_statevars2([],_) => []

  rule (* When start value is present*)
 int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_statevars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs & 
 Exp.print_exp_str start => startstr &
 Util.string_append_list([" SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",",
     startstr,");"]) 
   => r1 
 --------------------
 generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,SOME(start),_,_)::rest,i) 
   => r1::res

  rule (* If no start value is present*)
 int_add(i,1) => i' & int_string(i) => is &
 generate_constructor_statevars2(rest,i') => res &
 Exp.cref_modelica_str(cr) => crs & 
 
 Util.string_append_list([" SetDerStateVar(",is,", new CDerStateVar(L\"",crs,"\", L\"\",0);"]) 
   => r1 
 --------------------
 generate_constructor_statevars2(DAELow.VAR(cr,DAELow.STATE,_,_,_,_,_,NONE,_,_)::rest,i) 
   => r1::res

  rule generate_constructor_statevars2(rest,i) => res 
 -----------------------------------------------
 generate_constructor_statevars2(_::rest,i) 
   => res

  rule print "-generate_constructor_statevars2 failed\n" 
 ----------------------
 generate_constructor_statevars2(_,_) => fail
end

relation generate_var_defines: (DAELow.DAELow) => string =

  rule generate_var_defines2(vars,0,0) => vdefs1list &
 list_length(vdefs1list) => len &
 int_sub(len,1) => len' &
 Util.string_append_list(vdefs1list) => vdefs1 &
 generate_var_defines2(knvars,0,0) => vdefs2list &
 Util.string_append_list(vdefs2list) => vdefs2 &
 Util.string_append_list(["#define _t_ m_IndepVarValues[0]\n",vdefs1,vdefs2,"\n"]) => vdefs
 ---------------------
 generate_var_defines(DAELow.DAELOW(vars,knvars,eqn,seqn)) => vdefs

  rule print "-generate_var_defines failed\n"
 --------------------------------------
 generate_var_defines(_) => fail
end


(** Helper function for generate_var_defines
 ** Recursively traverses the list of variables and generates the defines 
 ** in the tornado format for them.
 ** Arg1 is the list of variables
 ** Arg2 is the counter for Output variables
 ** Arg3 is the counter for DerState and derivative variables
**)
relation generate_var_defines2: (DAELow.Var list,int,int) => string list =

  axiom generate_var_defines2([],_,_) => []
        
  rule int_string(outputCounter) => outputCounterString &
        Exp.cref_modelica_str(cr) => crs &
        Util.string_append_list(["#define ",crs,"_ m_OutputVarValues[",outputCounterString,"]\n"]) => r1 &
        int_add(outputCounter,1) => outputCounter' & 
        generate_var_defines2(rest,outputCounter',derStateCounter) => res
        ----------------------------------------------
        generate_var_defines2(DAELow.VAR(cr,DAELow.VARIABLE,dir,_,_,_,_,_,_,_)::rest,
                              outputCounter,derStateCounter) 
          => r1::res
          
  rule int_string(derStateCounter) => derStateCounterString &
        Exp.cref_modelica_str(cr) => crs &
        Util.string_append_list(["#define ",crs,"_ m_DerStateVarValues[",derStateCounterString,"]\n",
                                 "#define _D_",crs,"_ m_Derivatives[",derStateCounterString,"]\n"]) => r1 &
        int_add(derStateCounter,1) => derStateCounter' & 
        generate_var_defines2(rest,outputCounter,derStateCounter') => res
        ----------------------------------------------
        generate_var_defines2(DAELow.VAR(cr,DAELow.STATE,dir,_,_,_,_,_,_,_)::rest,
                              outputCounter,derStateCounter) 
          => r1::res
          
  rule generate_var_defines2(rest,outputCounter,derStateCounter) => res 
        -----------------------------------------------
        generate_var_defines2(_::rest,outputCounter,derStateCounter) => res
        
  rule print "-generate_var_defines2 failed\n"
        --------------------------------------
        generate_var_defines2(_,_,_) => fail
end

(** relation: generate_constructor_component_initialization
 ** this relation generates the code for initialization of internal
 ** components for a model. The components are non-primitive types.
 ** x02lucpo
 **)
 relation generate_constructor_component_initialization: (string,Absyn.Program) => string =
         
  rule  Interactive.get_pathed_class_in_program(Absyn.IDENT(cname),program) => cdef &
	 (* call to helper function *)
         count_and_generate_initializations(cdef,program,0) => (ini_str_list,nr_of_comp) &         
         int_string(nr_of_comp) => res &
	 (* Generate the nr of submodels declaration *)
         Util.string_append_list(["  SetNoSubModels(",res,");\n"]) => res1 &
         Util.string_append_list(res1::ini_str_list) => res2 
         --------------------------------------
         generate_constructor_component_initialization(cname,program) => res2
         
  rule  print "generate_constructor_component_initialization failed\n"
         --------------------------------------
         generate_constructor_component_initialization(_,_) => fail
         
 end

 relation count_and_generate_initializations: (Absyn.Class,Absyn.Program,int) => (string list, int) =
         
  rule	 (* For public declarations *)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1) & 
	 count_and_generate_initializations_in_elts(elt,program,nr_of_found_components) => (strlist,c2) &
	 int_add(c1,c2) => res &
         list_append(str,strlist) => string_list
         --------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PUBLIC(elt)::lst,cmt)),program, nr_of_found_components)
	      => (string_list,res)
           
  rule	(* For protected declarations *)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1) &
	 count_and_generate_initializations_in_elts(elt,program,nr_of_found_components) => (strlist,c2) &
	 int_add(c1,c2) => res &
         list_append(str,strlist) => string_list
	 -------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(Absyn.PROTECTED(elt)::lst,cmt)),program, nr_of_found_components)
	  => (string_list,res)

  rule	(* Non-public, non protected, -> Throw it away*)
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(lst,cmt)),program, nr_of_found_components) => (str,c1)
	 -----------------------------------------------------
	 count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS(_::lst,cmt)),program, nr_of_found_components) => (str,c1)
	     
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.PARTS([],_)),_,_) => ([" "],0)
  axiom count_and_generate_initializations(Absyn.CLASS(a,b,c,d,Absyn.R_MODEL,Absyn.DERIVED(_,_,_,_,_)),_,_) => ([" "],-1)
         
  rule print "count_and_generate_initializations failed\n"
         --------------------------------------
         count_and_generate_initializations(_,_,_) => fail
         
 end

 relation count_and_generate_initializations_in_elts: (Absyn.ElementItem list,Absyn.Program,int) => (string list, int) =         

  rule	Interactive.is_primitive(Absyn.CREF_IDENT(ident,[]),program) => false & 
         generate_components_initializations(ident,componentItemList,index) => (comp_str_list,nrOfComponents) &
	 int_add(index,nrOfComponents) => inc_index1 &

 	 int_add(index,1) => inc_index2 &
	 count_and_generate_initializations_in_elts(lst,program,inc_index2) => (strlist,c1) &
	 list_append(comp_str_list,strlist) => str_list_res 
	 --------------------------
	 count_and_generate_initializations_in_elts(Absyn.ELEMENTITEM(Absyn.ELEMENT(_,_,_,_,
            Absyn.COMPONENTS(_,Absyn.IDENT(ident),componentItemList),_,_,NONE))::lst,program,index) => (str_list_res,c1)
	     
  rule	count_and_generate_initializations_in_elts(lst,program,index) => (strlist,res)
	 ----------------------------
	 count_and_generate_initializations_in_elts(_::lst,program,index) => (strlist,res)
         
  axiom	count_and_generate_initializations_in_elts([],_,index) => ([""],index)

  rule	print "count_and_generate_initializations_in_elts failed\n"
	     ----------------------------
	     count_and_generate_initializations_in_elts(_,_,_) => fail

end

relation generate_components_initializations: (Absyn.Ident, Absyn.ComponentItem list, int) => (string list, int) =
  
  rule  int_string(index) => current_index_string &
        int_add(index,1) => inc_index &	
        generate_components_initializations(componentType,rest,inc_index) => (res,ret_index) &
        Util.string_append_list(["  SetSubModel(",current_index_string,", new C",componentType,"(L\"",componentIdent,"\"));\n"]) => gen_string
        -------------------------------------
        generate_components_initializations(componentType,Absyn.COMPONENTITEM(Absyn.COMPONENT(componentIdent,_,_),_)::rest, index) => (gen_string::res, ret_index)

  axiom	generate_components_initializations(componentType,[],index) => ([""],index)

end


(** relation: generate_compute_methods
 ** This relation generates the code for the computation of the equations
 ** They are separated into four parts.
 ** - computing the output variables (algebraic variables)
 ** - computing the state variables
 ** - computing the initial conditions
 ** - computing the terminal conditions
 **)
relation generate_compute_methods: (string,DAELow.DAELow,Absyn.Program) => string =

  rule generate_blt(dae) => blt &
  generate_state_partition(blt,dae) => (blt_states,blt_no_states) &
  Debug.fcall("bltdump", DAELow.dump_components, blt_states) &
  Debug.fcall("bltdump", DAELow.dump_components, blt_no_states) &
  generate_compute_output(cname,dae,p) => coutput &
 generate_compute_initial(cname,dae,p) => cinitial &
 generate_compute_state(cname,dae,p) => cstate &
 generate_compute_terminal(cname,dae,p) => cterm &
 Util.string_append_list(["void C",cname,"::\n",
     "ComputeOutput()\n",
     "{\n",
     coutput,
     "}\n",
     "\n",
     "void C",cname,"::\n",
     "ComputeInitial()\n",
     "{\n",
     cinitial,
     "}\n",
     "\n",
     "void C",cname,"::\n",
     "ComputeState()\n",
     "{\n",
     cstate,
     "}\n",
     "\n",
     "void C",cname,"::\n",
     "ComputeTerminal()\n",
     "{\n",
     cterm,
     "}\n",
     "\n"]) => methods
 ---------------------------
 generate_compute_methods(cname,dae,p) => methods

  rule print "-generate_compute_methods failed\n" 
 -----------------------------------------
 generate_compute_methods(_,_,_) => fail
end 


(** relation generate_blt
 ** This relation computes the block lower triangular form of the equation 
 ** system using a list of the DAEs. 
 **
 **)
relation generate_blt:(DAELow.DAELow) => (int list list) =

 
  rule (*DAELow.lower(d) => d' *)
 Debug.fcall("dumpdaelow", DAELow.dump, d') 
 & DAELow.incidence_matrix(d') => m 
 & DAELow.transpose_matrix(m) => mT 
 & DAELow.matching_algorithm(d',m,mT) => (v1,v2,d'',m,mT) 
 & Debug.fcall("bltdump", DAELow.dump_incidence_matrix, m) 
(* & Debug.fcall("bltdump", DAELow.dump_incidence_matrix_inv, mT) *)
 & Debug.fcall("bltdump", DAELow.dump,d'')
 & Debug.fcall("bltdump", DAELow.dump_matching, v1)
 & DAELow.strong_components(m,mT,v1,v2) => (comps) 
 & DAELow.dump_components(comps) 
 -------------------------------------------------------------
 generate_blt(d') => (comps)

  rule print "-generate_blt failed\n" 
 -----------------------------------------
 generate_blt(_) => fail

end


(** relation:generate_state_partition
 ** this relation extracts the rightmost part 
 **
 ** returns two incidencematrices, the first one including blocks with 
 ** all state variables (and of course some other variables as well) 
 ** and the second one including no state variables. No reordering
 ** of blocks is performed.
 **) 
relation generate_state_partition:(int list list,DAELow.DAELow) => 
 (int list list, int list list) =

  rule  list_reverse(blt) => reversed_blt &
 has_state_var(0,reversed_blt,dae) => state_component_number &
 list_length(blt) => nr_of_components &
 int_sub(nr_of_components,state_component_number) => component_offset & 
 print "(non-reversed): " &
 int_string(component_offset) => component_offset_string &
 print component_offset_string &
 print "\n" &
 Util.list_split(blt,component_offset) => (blt_states,blt_no_states) 
 -----------------------------------------
 generate_state_partition(blt,dae) => (blt_states,blt_no_states)

  rule print "-generate_state_partition failed\n" 
 -----------------------------------------
 generate_state_partition(_,_) => fail

end

(** Helper relation for generate state partition
 ** Determines which list of coefficients contains the first 
 ** statevariable
 ** 
 ** Returns the first component number (counted from the end of the list)
 ** which contais a state variable.
 **) 
relation has_state_var:(int, int list list, DAELow.DAELow) => int =
   
  rule (*if this component contains a statevar, return index *)
 check_component_for_statevars(0,element,dae) => true
 -----------------------------------------
 has_state_var(index,element::reversed_blt,dae) => index

 (* If we have no more components return 0 *)
  axiom has_state_var(_,[],_) => 0
 
  rule (* If no statevars found in this component, continue with the next one*)
 int_add(1,index) => next_index &
 has_state_var(next_index,reversed_blt,dae) => ret_value
 -----------------------------------------
 has_state_var(index,element::reversed_blt,dae) => ret_value

  rule print "-generate_state_partition2 failed\n" 
 -----------------------------------------
 has_state_var(_,_,_) => fail
end

(** relation:check_component_for_statevars
 ** Arg 1 is the index in the component to the current variable to check
 ** Arg 2 is the component itself
 ** Arg 3 is the DAEs
 ** Returns true if this component contains a statevar
 **)
relation check_component_for_statevars:(int, int list, DAELow.DAELow) => bool =

  rule print "check_component_for_statevars failed: Empty component\n" 
 -------------------------------------------------------------
 check_component_for_statevars(_,[],_) => fail


  rule (* Termination condition. variables checked.
    This means that the component did not contain any state vars *)
 list_length(component) => nr_of_variables &
 int_eq(nr_of_variables,i) => true
 -------------------------------------------------------------
 check_component_for_statevars(i,component,_) => false

  rule (* If this variable is a state variable, return true *)
 list_nth(component,i) => variable_index_to_check &
 (* Variable indexing starts from 1 but lists start from 0.
  Thus decrease index by one*) 
 int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
  list_nth(var_list,adjusted_variable_index_to_check) => 
   (hej as DAELow.VAR(cref,DAELow.STATE,_,_,_,_,_,_,_,_))
 -------------------------------------------------------------
 check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_)) => true

  rule (* If this variable is nt state variable, try the next one *)
 list_nth(component,i) => variable_index_to_check &
 (* Variable indexing starts from 1 but lists start from 0.
  Thus decrease index by one*) 
 int_sub(variable_index_to_check,1) => adjusted_variable_index_to_check &
  list_nth(var_list,adjusted_variable_index_to_check) => 
   DAELow.VAR(cref,_,_,_,_,_,_,_,_,_) &
 int_add(i,1) => next_i &
 check_component_for_statevars(next_i,component,dae) => result
 -------------------------------------------------------------
 check_component_for_statevars(i,component,dae as DAELow.DAELOW(var_list,_,_,_)) 
   => result

  rule print "check_component_for_statevars failed" 
 -------------------------------------------------------------
 check_component_for_statevars(_,_,_) => fail

end 



(** relation: generate_compute_output
 ** This relation generates the code for the calculation of the output variables.
 **)
relation generate_compute_output:(string,DAELow.DAELow,Absyn.Program) => string =

  rule Util.string_append_list(["/* output code here*/\n"]) => coutput
 -------------------------------------------------------------
 generate_compute_output(cname,dae,p) => coutput

end

(** relation: generate_compute_initial
 ** This relation generates the code for the calculation of the initial conditions.
 **)
relation generate_compute_initial:(string,DAELow.DAELow,Absyn.Program) => string =

  rule Util.string_append_list(["/* initial code here*/\n"]) => cinit
 -------------------------------------------------------------
 generate_compute_initial(cname,dae,p) => cinit

end

(** relation: generate_compute_state
 ** This relation generates the code for the calculation of the state variables.
 **)
relation generate_compute_state:(string,DAELow.DAELow,Absyn.Program) => string =

  rule Util.string_append_list(["/* state code here*/\n"]) => cstate 
 
 -------------------------------------------------------------
 generate_compute_state(cname,dae,p) => cstate

end

(** relation: generate_compute_terminal
 ** This relation generates the code for the calculation of the terminal behavior.
 ** This can be expressed in Modelica using when statements:
 ** when terminal() then
 **   x:=do_calc(x,y);
 ** end when
 *)
relation generate_compute_terminal:(string,DAELow.DAELow,Absyn.Program) => string =
        
  rule Util.string_append_list(["/* terminal code here*/\n"]) => cterm
     -------------------------------------------------------------
     generate_compute_terminal(cname,dae,p) => cterm
end
