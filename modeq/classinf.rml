(**
 ** file:	 classinf.rml
 ** description: Class restrictions
 **
 ** RCS:	 $Id$
 **
 ** This module deals with class inference, i.e. determining if a
 ** class definition adhers to one of the class restrictions, and, if
 ** specifically declared in a restrictied form, if it breaks that
 ** restriction.
 **
 ** The inference is implemented as a finite state machine.  The
 ** relation `start' initializes a new machine, and the relation
 ** `trans' signals transitions in the machine.  Finally, the state
 ** can be checked agains a restriction with the `valid' relation.
 **
 **)

module ClassInf :

  with "absyn.rml"

  (** - Machine states *)
  datatype State = UNKNOWN       of string
		 | MODEL	 of string
		 | RECORD	 of string
		 | BLOCK	 of string
		 | CONNECTOR	 of string
		 | TYPE		 of string
		 | PACKAGE	 of string
		 | FUNCTION	 of string
		 | HAS_EQUATIONS of string
		 | IS_NEW        of string
		 | TYPE_INTEGER  of string
		 | TYPE_REAL     of string
		 | TYPE_STRING   of string
		 | TYPE_BOOL     of string

  (** - Events *)
  datatype Event = FOUND_EQUATION     (* There are definitions inside *)
				      (* the current definition *)
		 | NEWDEF	      (* This is not a derived class *)
  (** The `Event' type contains the different events during *)
  (** instantiation that signals a possible machine transition. *)

  (** - Exported relations *)

  relation start : (Absyn.Restriction, string) => State
  relation trans : (State, Event) => State

  relation valid : (State, Absyn.Restriction) => ()
  (* `assert_valid' is identical to 'valid'.  The only difference is *)
  (* that it prints an error message when it fails. *)
  relation assert_valid : (State, Absyn.Restriction) => ()

  (* Debug relation *)
  relation print_state : State => ()

end

(** - Printing *)
(**)
(** Some relations for printing error and debug information about the *)
(** state machine.
 **
 ** The code is excluded from the report.
 **)

(*!ignorecode*)

(** relation: print_state *)

relation print_state : State => () =

  rule	print "UNKNOWN " & print s
	----------------------------
	print_state UNKNOWN(s)

  rule	print "MODEL " & print s
	----------------------------
	print_state MODEL(s)

  rule	print "RECORD " & print s
	----------------------------
	print_state RECORD(s)

  rule	print "BLOCK " & print s
	----------------------------
	print_state BLOCK(s)

  rule	print "CONNECTOR " & print s
	----------------------------
	print_state CONNECTOR(s)

  rule	print "TYPE " & print s
	----------------------------
	print_state TYPE(s)

  rule	print "PACKAGE " & print s
	----------------------------
	print_state PACKAGE(s)

  rule	print "FUNCTION " & print s
	----------------------------
	print_state FUNCTION(s)

  rule	print "TYPE_INTEGER " & print s
	----------------------------
	print_state TYPE_INTEGER(s)

  rule	print "TYPE_REAL " & print s
	----------------------------
	print_state TYPE_REAL(s)

  rule	print "TYPE_STRING " & print s
	----------------------------
	print_state TYPE_STRING(s)

  rule	print "TYPE_BOOL " & print s
	----------------------------
	print_state TYPE_BOOL(s)

  rule	print "IS_NEW " & print s
	----------------------------
	print_state IS_NEW(s)

  rule	print "HAS_EQUATIONS " & print s
	----------------------------
	print_state HAS_EQUATIONS(s)

end

(** relation: print_event *)

relation print_event : Event => () =

  rule	print "FOUND_EQUATION"
	----------------------
	print_event FOUND_EQUATION

  rule	print "NEWDEF"
	--------------
	print_event NEWDEF

end

(*!includecode*)

(** - Transitions *)

(** relation: start
 **
 ** This is the  state machine initialization relation.
 **)

relation start : (Absyn.Restriction, string) => State =

  axiom	start (Absyn.R_CLASS, s) 	       => UNKNOWN(s)
  axiom	start (Absyn.R_MODEL, s) 	       => MODEL(s)
  axiom	start (Absyn.R_RECORD, s)            => RECORD(s)
  axiom	start (Absyn.R_BLOCK, s)             => BLOCK(s)
  axiom	start (Absyn.R_CONNECTOR, s)         => CONNECTOR(s)
  axiom	start (Absyn.R_TYPE, s)              => TYPE(s)
  axiom	start (Absyn.R_PACKAGE, s)           => PACKAGE(s)
  axiom	start (Absyn.R_FUNCTION, s)          => FUNCTION(s)
  axiom	start (Absyn.R_PREDEFINED_INT, s)    => TYPE_INTEGER(s)
  axiom	start (Absyn.R_PREDEFINED_REAL, s)   => TYPE_REAL(s)
  axiom	start (Absyn.R_PREDEFINED_STRING, s) => TYPE_STRING(s)
  axiom	start (Absyn.R_PREDEFINED_BOOL, s)   => TYPE_BOOL(s)

end

(** relation: trans
 **
 ** This is the state machine transition relation.  It describes the
 ** transitions between states at different events.
 **)

relation trans : (State, Event) => State =

	(** Event `NEWDEF' *)

  axiom	trans(UNKNOWN(s),        NEWDEF) => IS_NEW(s)
  axiom	trans(MODEL(s),          NEWDEF) => MODEL(s)
  axiom	trans(RECORD(s),         NEWDEF) => RECORD(s)
  axiom	trans(BLOCK(s),          NEWDEF) => BLOCK(s)
  axiom	trans(CONNECTOR(s),      NEWDEF) => CONNECTOR(s)

  rule	print "# In class " & print s & print "\n" &
	print "# 'type' can only be derived from predefined types\n"
	-----------------------------------------------
	trans(TYPE(s),           NEWDEF) => fail

  axiom	trans(PACKAGE(s),        NEWDEF) => PACKAGE(s)
  axiom	trans(FUNCTION(s),       NEWDEF) => FUNCTION(s)
  axiom	trans(IS_NEW(s),         NEWDEF) => IS_NEW(s)
  axiom	trans(TYPE_INTEGER(s),   NEWDEF) => TYPE_INTEGER(s)
  axiom	trans(TYPE_REAL(s),      NEWDEF) => TYPE_REAL(s)
  axiom	trans(TYPE_STRING(s),    NEWDEF) => TYPE_STRING(s)
  axiom	trans(TYPE_BOOL(s),      NEWDEF) => TYPE_BOOL(s)

	(** Event `FOUND_EQUATION' *)

  axiom	trans(UNKNOWN(s),        FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(IS_NEW(s),         FOUND_EQUATION) => HAS_EQUATIONS(s)
  axiom	trans(MODEL(s),          FOUND_EQUATION) => MODEL(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in records\n"
	-----------------------------------------------
	trans(RECORD(s),         FOUND_EQUATION) => fail

  axiom	trans(BLOCK(s),          FOUND_EQUATION) => BLOCK(s)

  rule	print "# In class " & print s & print "\n" &
	print "# Equations not allowed in connectors\n"
	-----------------------------------------------
	trans(CONNECTOR(s),      FOUND_EQUATION) => fail

  axiom	trans(TYPE(s),           FOUND_EQUATION) => fail (* CORRECT? *)
  axiom	trans(PACKAGE(s),        FOUND_EQUATION) => fail
  axiom	trans(FUNCTION(s),       FOUND_EQUATION) => fail
  axiom	trans(HAS_EQUATIONS(s),  FOUND_EQUATION) => HAS_EQUATIONS(s)

  rule	print "- trans failed: " & print_state st &
 	print ", " & print_event ev & print "\n"
	--------------------------------------------------------
	trans(st, ev) => fail

end

(** relation: valid
 **
 ** This is the validity relation which determines if a state is valid
 ** according to one of the restrictions.  This means, that if a class
 ** definition is to be used as, say, a connector, the state of the
 ** state machine is checked against the `Absyn.R_CONNECTOR'
 ** restriction using this relation to find out if it is an error to
 ** use this class definition as a connector.
 **)

relation valid : (State, Absyn.Restriction) => () =

  axiom	valid(UNKNOWN(s), _)

  axiom	valid(IS_NEW(s),        Absyn.R_CLASS)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_CLASS)

  axiom	valid(MODEL(s),         Absyn.R_MODEL)
  axiom	valid(IS_NEW(s),        Absyn.R_MODEL)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_MODEL)

  axiom	valid(RECORD(s),        Absyn.R_RECORD)
  axiom	valid(IS_NEW(s),        Absyn.R_RECORD)

  axiom	valid(BLOCK(s),         Absyn.R_BLOCK)
  axiom	valid(HAS_EQUATIONS(s), Absyn.R_BLOCK)

  axiom	valid(CONNECTOR(_),     Absyn.R_CONNECTOR)
  axiom	valid(IS_NEW(_),        Absyn.R_CONNECTOR)
  axiom valid(TYPE_INTEGER(_),	Absyn.R_CONNECTOR)
  axiom valid(TYPE_REAL(_),	Absyn.R_CONNECTOR)
  axiom valid(TYPE_STRING(_),	Absyn.R_CONNECTOR)
  axiom valid(TYPE_BOOL(_),	Absyn.R_CONNECTOR)

  axiom	valid(TYPE(s),          Absyn.R_TYPE)
  axiom	valid(TYPE_INTEGER(s),  Absyn.R_TYPE)
  axiom	valid(TYPE_REAL(s),     Absyn.R_TYPE)
  axiom	valid(TYPE_STRING(s),   Absyn.R_TYPE)
  axiom	valid(TYPE_BOOL(s),     Absyn.R_TYPE)

  axiom	valid(IS_NEW(s),        Absyn.R_PACKAGE)
  axiom	valid(PACKAGE(s),       Absyn.R_PACKAGE)

  axiom	valid(IS_NEW(s),        Absyn.R_FUNCTION)
  axiom	valid(FUNCTION(s),      Absyn.R_FUNCTION)

end

(** relation: assert_valid
 **
 ** This relation has the same semantical meaning as the relation
 ** `valid'.  However, it prints an error message when it faild.
 **)

relation assert_valid : (State, Absyn.Restriction) => () =

  rule	valid(st,re)
	------------
	assert_valid(st,re)

  rule	print "# Restriction violation: " & print_state st &
	print " is not a " & Absyn.print_restr re & print "\n" 
	-------------------------------------------
	assert_valid(st,re) => fail

end
