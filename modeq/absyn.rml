(* absyn.rml *)

module Absyn:

  with "exp.rml"

  type Ident = Exp.Ident

  type Path = Exp.Path

  type Subscript = (Exp.Exp * ((Exp.Exp * (Exp.Exp option)) option)) option

  type ComponentRef = (string * (Subscript list)) list

  datatype ArrayDim = ONEDIM of Subscript
		    | TWODIM of Subscript*Subscript

  datatype ElementArg = MODIFICATION of bool * Path * Modification
		      | REDECLARATION of bool * ElementSpec

  and	   Modification = CLASSMOD of ElementArg list
			| EQUALMOD of Exp.Exp

  and	   Component = COMPONENT of Ident	(* component name *)
				  * ArrayDim option
				  * Modification option

  and	   ElementSpec = CLASSDEF of bool		(* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | COMPONENTS of bool	(* flow *)
				     * bool	(* parameter *)
				     * bool	(* constant *)
				     * bool	(* input *)
				     * bool	(* output *)
				     * Path	(* type name *)
				     * Component list

  and	   Element = ELEMENT of bool		(* final *)
			      * Ident
			      * ElementSpec

  and	   ClassRestriction = CL_CLASS
			    | CL_MODEL
			    | CL_RECORD
			    | CL_BLOCK
			    | CL_CONNECTOR
			    | CL_TYPE
			    | CL_PACKAGE
			    | CL_FUNCTION

  and	   Class = CLASS of Ident             (* Name *)
			  * bool			(* Partial *)
			  * ClassRestriction      (* Restricion *)
			  * ClassDef		(* Parts *)

  and	   ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * ArrayDim option
			       * ElementArg list

  and	   ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list

  and	   Equation = EQ_EXPR of Exp.Exp (* more later *)
		    | EQ_EQUALS of Exp.Exp * Exp.Exp

  and	   Algorithm = ALGORITHM (* Fill in later *)

  type Program = Class list

  relation element_spec_name : ElementSpec => Ident

end

(**********************************************************************)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,_,_,_,_,[COMPONENT(n,_,_)]) => n

  rule  print "# element_spec_name EXTENDS\n" & fail
	--------------------------------------------
	element_spec_name EXTENDS(_,_) => "#error#"

end
