(*
   Copyright PELAB, Linkoping University
   
   This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 absyn.rml
 ** module:      Absyn
 ** description: Abstract syntax
 **
 ** RCS: $Id$
 **
 ** This file defines the abstract syntax for Modelica.  It mainly
 ** contains datatypes for constructing the abstract syntax tree
 ** (AST), and a few relations for printing the AST.
 **)



module Absyn:
    with "debug.rml"
							  
  type Ident = string

  (** - Programs *)
  datatype Program = PROGRAM of Class list (* List of classes *)
				* Within (* Within statement *)

  (** A program is simply a list of class definitions declared at top
   ** level in the source file, combined with a within statement that
   ** indicates the hieractical position of the program. 
   **)

  (** Within *)
  datatype Within = WITHIN of Path | TOP

  (** - Classes *)
  datatype Class = CLASS of Ident		     (* Name *)
			  * bool		     (* Partial *)
			  * Restriction	             (* Restricion *)
			  * ClassDef		     (* Body *)
  (** A class definition consists of a name, a flag to indicate if this *)
  (** class is declared as `partial', the declared class restriction, *)
  (** and the body of the declaration. *)


  datatype ClassDef = PARTS of ClassPart list
		    | DERIVED of Path
			       * ArrayDim option
			       * ElementArg list
  (** The `ClassDef' type contains the definition part of a class *)
  (** declaration.  The definition is either explicit, with a list of *)
  (** parts (`public', `protected', `equation' and `algorithm'), or it *)
  (** is a definition derived from another class.  In the latter case *)
  (** this type contains the name of the derived class and an optional *)
  (** array dimension and a list of modifications. *)

  datatype ClassPart = PUBLIC of ElementItem list
		     | PROTECTED of ElementItem list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list
  (** A class definition contains several parts.  There are public and *)
  (** protected component declarations, type definitions and `extends' *)
  (** clauses, collectively called elements.  There are also equation *)
  (** sections and algorithm sections. *)
  (** - ElementList *)

  datatype ElementItem = ELEMENTITEM of Element 
		       | ANNOTATIONITEM of Annotation 
  (** An element item is either an element or an annotation *)

  (** - Elements *)
  datatype Element = ELEMENT of bool		     (* final *)
			      * InnerOuter	     (* inner/outer *)	     
			      * Ident
			      * ElementSpec

  datatype ElementSpec = CLASSDEF of bool	     (* replaceable *)
				   * Class
		       | EXTENDS of Path * ElementArg list
		       | IMPORT of Import
		       | COMPONENTS of ElementAttributes (*1.1 contains Araydim also.*)
				     * Path	     (* type name *)
				     * ComponentItem list
  (** One of the keyword inner and outer CAN be given to reference an inner or
      outer component. Thus there are three disjoint possibilities. **)		     
  datatype InnerOuter = INNER | OUTER | UNSPECIFIED
				     
  datatype Import = NAMED_IMPORT of Ident * Path
		  | QUAL_IMPORT of Path
		  | UNQUAL_IMPORT of Path

  (** An element is something that occurs in a public or protected
   ** section in a class definition.  There is one constructor in the
   ** `ElementSpec' type for each possible element type.  There are
   ** class definitions (`CLASSDEF'), `extends' clauses (`EXTENDS')
   ** and component declarations (`COMPONENTS').
   ** 
   ** As an example, if the element `extends TwoPin;' appears
   ** in the source, it is represented in the AST as
   ** `EXTENDS(IDENT("TwoPin"),[])'.
   **)
							  
  datatype ComponentItem = COMPONENTITEM of Component
					  * Annotation option

  datatype Component = COMPONENT of Ident 	     (* component name *)
				  * ArrayDim
				  * Modification option
  (** Several component declarations can be grouped together in one *)
  (** `ElementSpec' by writing them on the same line in the source. *)
  (** This type contains the information specific to one component. *)

  datatype Equation = EQ_EXPR of Exp	     (* more later? *)
		    | EQ_IF of Exp
			     * Equation list	     (* true branch *)  
			     * (Exp * Equation list) list (* elseif branches *)
			     * Equation list	     (* else branch *)
		    | EQ_EQUALS of Exp * Exp
		    | EQ_CONNECT of ComponentRef * ComponentRef
		    | EQ_FOR of Ident * Exp * Equation list
		    | EQ_WHEN_E of Exp * Equation list (*1.1*) 
		    | EQ_ASSERT of Assert

  (** The `Equation' type describes one equation in an equation *)
  (** section. *)

  datatype Algorithm = ALG_ASSIGN of ComponentRef * Exp
		     | ALG_IF of Exp
			       * Algorithm list	     (* true branch *)  
			       * (Exp * Algorithm list) list (* elseif *)
			       * Algorithm list	     (* else branch *)
		    | ALG_FOR of Ident * Exp * Algorithm list
		    | ALG_WHILE of Exp * Algorithm list
		(* Old 1.0     | ALG_WHEN of Exp * Algorithm list  *)
		     | ALG_WHEN_A of Exp * Algorithm list (*1.1*)
		     | ALG_ASSERT of Assert
  (** The `Algorithm' type describes one algorithm statement in an *)
  (** algorithm section.  It does not describe a whole algorithm.  The *)
  (** reason this type is named like this is that the name of the *)
  (** grammar rule for algorithm statements is `algorithm'. *)

  datatype Assert = ASSERT of Exp * string list
		  | TERMINATE of string list

  (** - Modifications *)
  datatype Modification = CLASSMOD of ElementArg list * Exp option

  datatype ElementArg = MODIFICATION of bool * ComponentRef * Modification
		      | REDECLARATION of bool * ElementSpec
  (** Modifications are described by the `Modification' type.  There *)
  (** are two forms of modifications: redeclarations and component *)
  (** modifications. *)

  (** - Component attributes *)
  datatype ElementAttributes = ATTR of bool	(* flow *)
			     	     * Variability	(* parameter *)
			     	     * Direction
				     * ArrayDim  (*1.1*)
     
  datatype Variability = VAR | DISCRETE | PARAM | CONST
  datatype Direction = INPUT | OUTPUT | BIDIR
  (** Component attributes are *)
  (** properties of components which are applied by type prefixes. *)
  (** As an example, declaring a component as `input Real x;' will *)
  (** give the attributes `ATTR([],false,VAR,INPUT)'. *)

  (** - Array dimensions *)
  type ArrayDim = Subscript list
  (** Components in Modelica can be scalar or arrays with one or more *)
  (** dimensions. This datatype is used to indicate the dimensionality *)
  (** of a component or a type definition. *)

  (** - Expressions *)

  datatype Exp = INTEGER of int
	       | REAL of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of ComponentRef * Exp list
(*	       | ARRAY of Exp list *)

(*P.R		ARRAY consists of an vector of the dimension sizes and an vector consiting of the vector data.*)	
	       | ARRAY of Exp list

	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
	       | TUPLE of Exp list (*PR.*)

  (** The `Exp' datatype is the container of a Modelica expression. *)

  datatype Operator = ADD   | SUB    | MUL     | DIV       | POW
		    | UPLUS | UMINUS
		    | AND   | OR
		    | NOT
		    | LESS  | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  (** - Subscripts *)
  datatype Subscript = NOSUB
		     | SUBSCRIPT of Exp
  (** The `Subscript' datatype is used both in array declarations and *)
  (** component references.  This might seem strange, but it is *)
  (** inherited from the grammar.  The `NOSUB' constructor means that *)
  (** the dimension size is undefined when used in a declaration, and *)
  (** when it is used in a component reference it means a slice of the *)
  (** whole dimension. *)

  (** - Component references and paths *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Path = QUALIFIED of Ident * Path
	      	| IDENT of Ident
  (** A component reference is the fully or partially qualified name of *)
  (** a component.  It is represented as a list of *)
  (** identifier--subscript pairs.  The type `Path', on the other hand, *)
  (** is used to store references to class names, or names inside *)
  (** class definitions. *)
	      	
  (** - Restrictions *)
  datatype Restriction = R_CLASS
		       | R_MODEL
		       | R_RECORD
		       | R_BLOCK
		       | R_CONNECTOR
		       | R_TYPE
		       | R_PACKAGE
		       | R_FUNCTION
		       | R_PREDEFINED_INT
		       | R_PREDEFINED_REAL
		       | R_PREDEFINED_STRING
		       | R_PREDEFINED_BOOL
  (** These constructors each correspond to a different kind of class *)
  (** declaration in Modelica, except the last four, which are used *)
  (** for the predefined types.  The parser assigns each class *)
  (** declaration one of the restrictions, and the actual class *)
  (** definition is checked for conformance during translation.  The *)
  (** predefined types are created in the `Builtin' module and are *)
  (** assigned special restrictions. *)

  (** Annotation *)
  datatype Annotation = ANNOTATION of ElementArg list
  (** An Annotation is a class_modification. *)


  relation update_program: (Program,Program) => Program
  relation path_string : Path => string
  relation cref_to_path : ComponentRef => Path
  relation element_spec_name : ElementSpec => Ident
  relation print_restr : Restriction => ()
  relation restr_string : Restriction => string
  relation print_absyn_exp : Exp => ()  (*PR. for debugging.*)
end
with "dump.rml"
with "util.rml"
(** relation: update_program
 **
 ** This relation takes an old program (second argument), i.e. the old symboltable, 
 ** and a new program (first argument), i.e. a new set of classes and updates the old 
 ** program with the definitions in the new one
 **)     
relation update_program: (Program,Program) => Program =
(*   rule print "update_program, lstlen =" &
         list_length(l) => len &
         int_string(len) => lstr &
         print lstr &
         print "\n"&
	 int_eq(1,2) => true 
         -----------------
         update_program(PROGRAM(l,_),prg) => prg  *)
     
  axiom	update_program (PROGRAM([],_),prg) => prg
     
  rule	class_in_program(name,p2) => false &
	update_program(PROGRAM(c2,w),PROGRAM((c1::c3),w)) => pnew
	---------------------------------------------------------
	update_program (PROGRAM((c1 as CLASS(name,_,_,_))::c2,w as TOP),p2 as PROGRAM(c3,_)) => pnew

  rule	class_in_program(name,p2) => true &
	update_program(PROGRAM(c2,w),p2) => pnew &
        replace_class_in_program(c1,pnew) => pnew' 
	------------------------------------------
	update_program (PROGRAM((c1 as CLASS(name,_,_,_))::c2,w as TOP),p2) => pnew'
	
  rule	insert_class_in_program(c1,w,p2) => pnew &
	update_program(PROGRAM(c2,w),pnew) => pnew' 
	---------------------------------------------
	update_program(PROGRAM(c1::c2,w as WITHIN(path)),p2) => pnew'
	
  rule	print "Further program merging not implemented yet\n"
	------------------------
	update_program (a,b) => b
end
	
(** relation: replace_class_in_program
 ** This relation takes a `Class' and a `Program' and replaces the class definition 
 ** at the top level in the program by the class definition of the `Class'.
 **)
relation replace_class_in_program: (Class, Program) => Program =
  axiom replace_class_in_program(c, PROGRAM([],w)) => PROGRAM([c],w)
  rule	name1 = name2
	-------------
	replace_class_in_program(c as CLASS(name1,_,_,_),PROGRAM(CLASS(name2,_,_,_)::clst,w))
	    => PROGRAM(c::clst,w)
	    
  rule	not name1 = name2 &
	replace_class_in_program(c, PROGRAM(clst,w)) => PROGRAM(newclst,w)
	-------------------------------------------------------
	replace_class_in_program(c as CLASS(name1,_,_,_),PROGRAM((c1 as CLASS(name2,_,_,_))::clst,w)) => PROGRAM(c1::newclst,w)

  rule	
	print "replace_class_in_program failed \n class:" &
	Debug.fcall ("dump", Dump.dump, PROGRAM([c],TOP)) &
	print "\nprogram: \n" &
	Debug.fcall ("dump", Dump.dump, p)
	----------------------------
	replace_class_in_program(c,p) => fail
end
	
(** relation: insert_class_in_program 
 ** This relation inserts the class into the Program at the scope given by the 
 ** within argument. If the class referenced by the within argument is not 
 **  defined, the relation prints an error message and fails.
 **)
	
relation insert_class_in_program: (Class, Within, Program) => Program =

  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &

	update_program(PROGRAM([c3],TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1,w as WITHIN(QUALIFIED(n1,_)),p) => pnew
	
  rule	get_class_in_program(n1,p) => c2 &
	insert_class_in_class(c1,w,c2) => c3 &
	update_program(PROGRAM([c3],TOP),p) => pnew
	-------------------------------------------------
	insert_class_in_program(c1, w as WITHIN(IDENT(n1)),p) => pnew
	
  rule	print "Error inserting in class, within name, where name is not defined\n" 
	-------------------
	insert_class_in_program(c1,_,p) => fail	
end

(** relation: insert_class_in_class
 ** This relation takes a class to update (the first argument)  and an inner 
 ** class (which is either replacing
 ** an earlier class or is a new inner definition) and a within statement
 ** pointing inside the class (including the class itself in the reference), and updates the class with the inner class.
 **)
relation insert_class_in_class: (Class, Within, Class) => Class =
	
  rule  replace_inner_class(c1,c2) => cnew  	
	----------------------------------
	insert_class_in_class(c1,WITHIN(IDENT(name)),c2) => cnew

  rule  get_first_ident_from_path(path) => name2 &
        get_inner_class(c2,name2) => cinner &
	insert_class_in_class(c1,WITHIN(path),cinner) => cnew &
        replace_inner_class(cnew,c2) => cnew' 
	---------------------------------------------
	insert_class_in_class(c1,WITHIN(QUALIFIED(name,path)),c2) => cnew'
	
  rule print "insert_class_in_class failed\n"
	-------------------------------------
	insert_class_in_class(_,_,_) => fail
end

(** relation: get_first_ident_from_path
 ** This relation takes a `Path` as argument and returns the first `Ident' of the path.
 **)
relation get_first_ident_from_path: Path => Ident =
     axiom get_first_ident_from_path (IDENT(name)) => name
     axiom get_first_ident_from_path (QUALIFIED(name,path)) => name
end

(** relation: replace_inner_class 
 ** This relation takes two class definitions. The first one is inserted/replaced as a local class inside the second one.
 **)
relation replace_inner_class: (Class, Class) => Class =

  rule	get_public_list(parts) => publst &
	replace_class_in_elementitemlist(publst,c1) => publst2 &
	replace_public_list(parts,publst2) => parts2 
	-----------------------------------------------
	replace_inner_class (c1,CLASS(a,b,c,PARTS(parts))) => CLASS(a,b,c,PARTS(parts2))
  rule	print "Failed in replace_inner_class\n"
	---------------------------------------
	replace_inner_class (_,_) => fail
end

(** relation: replace_class_in_elementitemlist
 ** This relation takes an Element list and a Class and returns a modified element list
 ** where the class definition of the class is updated or added.
  **)
relation replace_class_in_elementitemlist: (ElementItem list, Class) => ElementItem list =
	
  rule	replace_class_in_elementitemlist(xs,c) => res
	-----------------------------------------
	replace_class_in_elementitemlist((a1 as ANNOTATIONITEM(_))::xs,c) => a1::res

  rule	not name1 = name &
	replace_class_in_elementitemlist(xs,c) => res
	------------------------------------------
	replace_class_in_elementitemlist((e1 as ELEMENTITEM(ELEMENT(_,_,_,CLASSDEF(_,c1 as CLASS(name1,_,_,_)))))::xs,c as CLASS(name,_,_,_)) => e1::res
	

  rule name1 = name 
	-----------------------------
	replace_class_in_elementitemlist((e1 as ELEMENTITEM(ELEMENT(a,b,c,CLASSDEF(d, CLASS(name1,_,_,_)))))::xs,c2 as CLASS(name,_,_,_)) => ELEMENTITEM(ELEMENT(a,b,c,CLASSDEF(d,c2)))::xs
	
  axiom	 replace_class_in_elementitemlist([],c) => [ELEMENTITEM(ELEMENT(false,UNSPECIFIED,"",CLASSDEF(false,c)))]
end

(** relation: get_inner_class
 ** This relation takes a class name and a class and return the inner class definition 
 ** having that name
**)
relation get_inner_class: (Class, Ident) => Class =
  rule	get_public_list(parts) => publst &
	get_class_from_elementitemlist(publst,name) => c1
	-----------------------------------------------
	get_inner_class (CLASS(_,_,_,PARTS(parts)), name) => c1

  rule	print "get_inner_class failed, c:" &
	Debug.fcall ("dump", Dump.dump,PROGRAM([c],TOP)) &
	print "name :" & print name 
	--------------
	get_inner_class (c,name) => fail
end

(** relation: replace_public_list
 ** This relation replaces the `ElementItem' list in the `ClassPart' list, and returns the updated
 ** list.
*)
relation replace_public_list: (ClassPart list,ElementItem list) => ClassPart list =

  axiom replace_public_list ((lst as PUBLIC(_))::rest,newpublst) => PUBLIC(newpublst)::rest
	
  rule	replace_public_list(xs,new) => ys
	---------------------------------
	replace_public_list(x::xs,new) => x::ys

  axiom replace_public_list([],_) => []
end

(** relation: get_public_list
 ** This relation takes a ClassPart List and returns the first public ElementItem list of the class.
 **
*)
relation get_public_list: ClassPart list => ElementItem list =

  axiom get_public_list PUBLIC(lst)::rest => lst
	
  rule	get_public_list(xs) => ys
	---------------------------
	get_public_list(x::xs) => ys

  axiom get_public_list(_) => []
end

(** relation: get_class_from_elementitemlist
 ** This relation takes an ElementItem list and an Ident and returns the class definition
 ** among the element list having that identifier
  **)
relation get_class_from_elementitemlist: (ElementItem list, Ident) => Class =
	
  rule	get_class_from_elementitemlist(xs,name) => res
	----------------------------------------------
	get_class_from_elementitemlist(ANNOTATIONITEM(_)::xs,name) => res

  rule	name1 = name2
	------------------------------
	get_class_from_elementitemlist(ELEMENTITEM(ELEMENT(_,_,_,CLASSDEF(_,c1 as CLASS(name1,_,_,_))))::xs,name2) => c1

  rule	not name1 = name &
	get_class_from_elementitemlist(xs,name) => res
	------------------------------------------
	get_class_from_elementitemlist(ELEMENTITEM(ELEMENT(_,_,_,CLASSDEF(_,c1 as CLASS(name1,_,_,_))))::xs,name) => res

  axiom	 get_class_from_elementitemlist([],_) => fail
end

(** relation: class_in_program
 ** This relation takes a name and a Program and returns true if the name exists as a top class in the program.
**)

relation class_in_program:(string,Program) => bool = 

  axiom class_in_program (str,PROGRAM([],_)) => false
	
  rule	not str = c1 &
	class_in_program(str,PROGRAM(p,w)) => res
	-----------------------
	class_in_program (str, PROGRAM(CLASS(c1,_,_,_)::p,w)) => res
	
  axiom class_in_program (_,_) => true
end

(** relation: get_class_in_program
 ** This relation takes a name and a Program and returns the class with the name `name'.
 ** If that class does not exist, the relation fail
**)

relation get_class_in_program:(string,Program) => Class = 

  axiom get_class_in_program (str,PROGRAM([],_)) => fail
	
  rule	not str = c1 &
	get_class_in_program(str,PROGRAM(p,w)) => res
	-----------------------------------------
	get_class_in_program (str, PROGRAM(CLASS(c1,_,_,_)::p,w)) => res
	
  rule  str = c1name
	------------
	get_class_in_program (str, PROGRAM((c1 as CLASS(c1name,_,_,_))::p,w)) => c1
end

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

(** relation: cref_to_path
 **
 ** This relation converts a `ComponentRef' to a `Path', if possible.
 ** If the component reference contains subscripts, it will silently
 ** fail.
 **)

relation cref_to_path : ComponentRef => Path =

  axiom	cref_to_path CREF_IDENT(i,[]) => IDENT(i)

  rule	cref_to_path c => p
	-------------------
	cref_to_path CREF_QUAL(i,[],c) => QUALIFIED(i,p)

end

(** relation: element_spec_name
 **
 ** The `ElementSpec' type contans the name of the element, and this
 ** relation extracts this name.
 **)

relation element_spec_name : ElementSpec => Ident =

  axiom element_spec_name CLASSDEF(_,CLASS(n,_,_,_)) => n

  axiom element_spec_name COMPONENTS(_,_,[COMPONENTITEM(COMPONENT(n,_,_),_)]) => n

  rule  print "# element_spec_name EXTENDS\n"
	-------------------------------------
	element_spec_name EXTENDS(_,_) => fail

end

(** relation: print_restr
 **
 ** This is a utility relation for printing a `Restriction'.  The code
 ** is excluded for brevity.
 **)

(*!ignorecode*)

relation restr_string : Restriction => string =

  axiom restr_string R_CLASS			=> "CLASS"
  axiom	restr_string R_MODEL			=> "MODEL"
  axiom	restr_string R_RECORD			=> "RECORD"
  axiom restr_string R_BLOCK			=> "BLOCK"
  axiom restr_string R_CONNECTOR		=> "CONNECTOR"
  axiom restr_string R_TYPE			=> "TYPE"
  axiom restr_string R_PACKAGE			=> "PACKAGE"
  axiom restr_string R_FUNCTION			=> "FUNCTION"
  axiom restr_string R_PREDEFINED_INT		=> "PREDEFINED_INT"
  axiom restr_string R_PREDEFINED_REAL		=> "PREDEFINED_REAL"
  axiom restr_string R_PREDEFINED_STRING	=> "PREDEFINED_STRING"
  axiom restr_string R_PREDEFINED_BOOL		=> "PREDEFINED_BOOL"

end

relation print_restr : Restriction => () =

  rule	restr_string restr => str &
	print str
	----------------
	print_restr restr

end


(* PR. To debug. *)
relation print_absyn_exp : Exp => () =
  rule	Debug.print "This is an array: " &
	Debug.print "[" &

	Debug.print "]"
	---------
	print_absyn_exp (ARRAY(es))

	(*PR.*)
  rule	Debug.print "(" &

	Debug.print ")"
	---------
	print_absyn_exp (TUPLE(es))


  rule	Debug.print "\nNo tuple." 
	---------
	print_absyn_exp (_)
end
