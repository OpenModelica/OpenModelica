List of things to implement:

	
1. Inner/Outer	testcases: InnerOuter1.mo InnerOuter2.mo InnerClass1.mo
	12 days.

2. Modifications not completely implemented. Especically with redeclare.
  testcases: DisturbedResistance3.mo DisturbedResistance4.mo ModificationXX.mo
	ModifyConstantX.mo ModifyUnknownX.mo OverWritingX.mo
	10 days.

3. Each modifier not implemented. Invent testcases.
	12 days.

4.  Final element modification not checked against.
	testcases: ModifyConstant5.mo ModifyConstant6.mo
	8 days.

5.  Lookup not completely fixed. Import statements are not inherited. Invent test cases.
	5 day.

6.  Constraining type on redeclarations not implemented + other redeclaration limitations.
    Invent testcases.
	10 days.

7. Restrictions on redeclarations not implemented (subtype etc.)
	10 days

8. Derivatives of functions. How to specify in flat modelica.
	3 days

9. Components of function type not implemented.
	10 days

10. When clauses not present in equations, not checked. Also check pre operator.
	10 days

11. Restrictions on connections (3.3.6.2) Check that they are fullfilled.
	3 days

12. The following operators in 3.4.2 have not been implemented:
	smooth
	noEvent
	sample
	edge
	change
	reinit
	terminate (check how assert is implemented)
	mod
	delay
	cardinality (Must be able to evaluate during compile time)	
	
	Also check that the other operators in this table are correct.
	15 days.
	
14.	3.4.3.1 Reduction expressions (Not implemented at all). (See also 3.4.4)  15 days.


16.	Slice operation. Works but the resulting component names are sometimes
	messed up. Check this.
	5 days

17.	Vectorized call of functions not implemented. Should be inserted in the lookup rules for functions. (Lookup)
	5 days.

18.	3.4.8.2 Output parameters of functions. Check that it works.
	enable attribute, etc.
	10 days

19.	Code generation
	A lot of stuff missing here, Levon: Fill in.
	External functions.
	30 days?

20.	Flat modelica.
	For now, only the start attribute is visible in the DAE.
	Things to add:
		* declaration comment, e.g. Real x "the comment";
		* unit
		* quantity
		* stateSelect
		* annotation (for Peter B:s debugging info=)
	For the equations:
		defineRoot, etc. for new MultiBody
		other operators that control behaviour of equation opt.

	Flattening of arrays: Option to flatten arrays or not should also
	expand/not expand for loops, etc.
	20 days			

21. 	SaveTotalModel.
	To be able to save a total model we need a dependency analysis.
	This means that we have to traverse the AST to search for models
	15 days	

22.     Better error messages in Parser.
	Kaj has implemented line numbers, but perhaps better messages are needed.
	Investigation & implementation 10 days.

23.	Line number and file information in instantiation.
	Line numbers should also be present in the Absyn and SCode ASTs, such that instantiation 
	errors can be given a line number in a given file.
	25 days (includes detecting errors correctly)

24. 	Updating the testsuite to Modelica2.1, writing new tests.
	12 days

25.	Array construction (3.4.4.1). Using array(... for ...)
	syntax. Related to 14, should be done after or together with 14.
	Partially implemented. Left to do:
	* Constant evaluation and/or optimization. Could be implemented 
	  as function calls with index as argument. Or array can be unrolled and indexed, or if 
	  constant value can be calculated and indexed. Array should then be cached.
	* Automatic type conversion of element type, e.g. (Real[]) a[5] = {(Integer)3 for ...} fails.
	* Handle multiple iterators

26.	Array constructors with iterators. Using {expr for i in ...}
	syntax. Related to 14 and 25.
	Implemented in walker which generates array() call (see 25.).

27.	Deduction of ranges (3.3.3.1). It is allowed to leave out "in
	range" in loops. e.g. 
            for i loop
               ...
            end for;
        according to specification. Implemented in parser but not
	walker and absyn.

28.	Multiple loop ranges, e.g.:
	  for i in 1:5, j in 1:3 loop a[i,j]=i*j; end for;
	Implemented in the parser, but doesn't seem to be in walker.g or in rest of modeq.



29.	 Functions code generation in simulation code

	- Functions are generated on the fly during constant
	evaluation, if they are detected as constant (all arguments
	constants). Compiled functions should be stored so that they
	don't need to be generated when called several times. Checking
	of existing files with same names should be fixed. An existing
	file function.c might be overwritten.  
	Relevant relations: Static.elab_call, Staticexp.generate_compiled_function,
	Ceval.ceval

	- Add going through of algorithms in daelow to get all the expressions
	See DAELow.get_all_exps

	- Add going through functions (algorithms) to find new
	expressions with function calls so that we can generate code
	for those as well. This means we have to go through all DAE also.

	- Only top level functions are checked in DAE.get_named_function
	- External functions in DAE.get_named_function ? 

	- inst_record_constructor_elt uses impl=false for inst_var, but
	  build_record_constructor_varlst uses impl=true for inst_class. How should this be?
	  Added impl argument for inst_record_constructor_elt. Needed
	  for elab_mod. Lookup calls with true. 

	- What should partial instantiation use? Putting impl=false for now.

	- equation_funcall8 doesn't work: translation error.
	- equation_funcall9 doesn't work: function generation of test3
	- equation_funcall10 doesn't work: function generation of test3

	- Fix print_exp_cpp_str call from tornado, add DAE.DAElist and
	  send dae for function lookup. Needed for tuple variable name
	  lookup in function return values.

30. Constant evaluation of record constructors for hierachical records
	Constant evaluation of record constructors is done by converting
	the arguements of the constructor call to modifiers, instantiate
	the record with these modifiers and transform the resulting dae into 
	Values. The problem is in the last part when a dae is translated into
	values, specially if the record contain other records. It is then not
	possible to walk through the equations and find a value for each 
	element. Instead an environment must be built and all bindings of 
	variables must be added. Then the conversion can iterate over the dae 
	variables and lookup each value to produce the Values. This also 
	requires that the dot ('.') operator can be evaluated.

31. Constant evaluation of dot ('.') operator.
	Is required to complete 30. For a record instance a, it should be 
	possible to evaluate a.x for an element x of the record instance a.
	This does not work in the interactive environment.

Specific adaptions:

For SKF:	
	1.	Allow for not expanding classes annotated with
		class bBody 
		   annotation(SKF(dontExpand=true));
		end bBody;
		
		class test
			bBody body1(p1=val1,p2=val2);
			bBody body2;
		end test;
		will produce the flat class.	
		fclass test
			bBody body1(p1=val1,p2=val2);
			bBody body2
		end test;

		4 days work.

	2.	Allow for not expanding connections through option to compiler.
		1 days work.

