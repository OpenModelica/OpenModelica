(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 exp.rml
 ** module:      Exp
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing expressions, after they have been examined by the
 ** static analyzer in the module `StaticExp'.  There are of course
 ** great similarities with the expression types in the `Absyn'
 ** module, but there are also several important differences.
 **
 ** No overloading of operators occur, and subscripts have been
 ** checked to see if they are slices.  All expressions are also type
 ** consistent, and all implicit type conversions in the AST are made
 ** explicit here.
 **)

module Exp:

  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Basic types *)
  datatype Type = INT | REAL | BOOL | STRING | ENUM | OTHER 
  (** These types are not used as expression types (see the `Types'
   ** module for expression types).  They are used to parameterize
   ** operators which may work on several simple types. *)

  (** - Expressions *)
  datatype Exp = ICONST of int
	       | RCONST of real
	       | SCONST of string
	       | BCONST of bool
	       | CREF of ComponentRef * Type
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Absyn.Path * Exp list * bool * bool (* Function call bool1 = tuple bool2 = constant *)
	       | ARRAY of Type * bool * Exp list
	       | MATRIX of Type * int * (Exp*bool) list list
	       | RANGE of Type * Exp * Exp option * Exp
	       | TUPLE of Exp list (*PR.*)
                 (* New constructors *)
	       | CAST of Type * Exp
	       | ASUB of Exp * int
               | SIZE of Exp * Exp
	       | CODE of Absyn.Code * Type
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp'
   ** datatype, but is used for statically analyzed expressions.  It
   ** includes explicit type promotions and typed (non-overloaded)
   ** operators. It also contains expression indexing with the `ASUB'
   ** constructor.  Indexing arbitrary array expressions is currently
   ** not supported in Modelica, but it is needed here. *)
  (** LS: Added size for external function interface **)

  datatype Operator = ADD    	  of Type
		    | SUB    	  of Type
		    | MUL    	  of Type
		    | DIV    	  of Type
		    | POW    	  of Type
		    | UMINUS 	  of Type
		    | UPLUS  	  of Type
		    | UMINUS_ARR  of Type
		    | UPLUS_ARR   of Type
		    | ADD_ARR     of Type
		    | SUB_ARR     of Type
		    | MUL_SCALAR_ARRAY of Type   (* a * { b, c }            *)
		    | MUL_ARRAY_SCALAR of Type   (* {a, b} * c              *)
		    | MUL_SCALAR_PRODUCT of Type (* {a, b} * {c, d}         *)
		    | MUL_MATRIX_PRODUCT of Type (* {{..},..} * {{..},{..}} *)
		    | DIV_ARRAY_SCALAR of Type   (* {a, b} / c              *)
		    | POW_ARR     of Type
		    | AND | OR
		    | NOT
		    | LESS        of Type
		    | LESSEQ      of Type
		    | GREATER     of Type
		    | GREATEREQ   of Type
		    | EQUAL       of Type
		    | NEQUAL      of Type
		    | USERDEFINED of Absyn.Path (* The FQ name of the overloaded operator function *)
  (** Operators which are overloaded in the abstract syntax are here
   ** made type-specific.  The integer addition operator (`ADD(INT)')
   ** and the real addition operator (`ADD(REAL)') are two distinct
   ** operators. *)

  (** - Component references *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Subscript = WHOLEDIM     (* a[:,1] *)
		     | SLICE of Exp (* a[1:3,1], a[1:2:10,2] *)
		     | INDEX of Exp
  (** The `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Absyn' module. *)

  (** - Exported relations *)

  relation is_range : Exp => bool

  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp
  relation unelab_exp : Exp => Absyn.Exp 	   
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_component_ref_str : ComponentRef => string
  relation print_subscript: Subscript => ()
  relation print_subscript_str: Subscript => string
  relation print_list : ('a list, 'a => (), string) => ()
  relation cref_equal : (ComponentRef, ComponentRef) => bool
  relation cref_str : ComponentRef => string
  relation print_list_str : ('a list, 'a => string, string) => string
  relation print_exp_str : Exp => string

end



with "rtopts.rml"
with "util.rml"
with "print.rml"

(** relation: path_string
 **
 ** This relation simply converts a `Path' to a `string'.
 **)

relation cref_str: ComponentRef => string =

  axiom	cref_str(CREF_IDENT(s,_)) => s
  
  rule	cref_str(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	cref_str(CREF_QUAL(s,_,n)) => ss
end

relation is_range : Exp => bool =

  axiom	is_range RANGE(_,_,_,_) => true
  axiom	is_range _ => false

end
(** LS:
 ** Replace this with a call to print_component_ref_str
 ** and comparison of the resulting strings, after the _str relations are 
 ** working
 **)

relation join_crefs : (ComponentRef, ComponentRef) => ComponentRef =

  axiom	join_crefs ( CREF_IDENT(id,sub),cr2) => CREF_QUAL(id,sub,cr2)
	
  rule	join_crefs(cr,cr2) => cr'
	------------------------
	join_crefs (CREF_QUAL(id,sub,cr),cr2) => CREF_QUAL(id,sub,cr')
end 
relation cref_equal : (ComponentRef, ComponentRef) => bool =

	(** IGNORES subscript list (indexes) for now. Too complex **)
	(** Another option is to call print_component_ref_str for both refs and *)
	(** compare the resulting strings *)

  rule	n1 = n2 &
	subscript_equal(idx1,idx2) => true
	-------
	cref_equal (CREF_IDENT(n1, idx1), CREF_IDENT(n2, idx2)) => true

  rule	n1 = n2 &
	subscript_equal(idx1,idx2) => true &
	cref_equal (cr1, cr2) => true
	-----------------------------
	cref_equal (CREF_QUAL(n1, idx1, cr1), CREF_QUAL(n2, idx2, cr2))
	  => true

  axiom	cref_equal (_, _) => false

end

relation subscript_equal: ( Subscript list, Subscript list) => bool =
	(* P.A: Just compare constant integer values for now. Might need to lookup variables
	   in environment for evaluating arbitrary expressions in future impl. *)
  rule	i1 = i2 &
	subscript_equal(xs1,xs2) => res 
	-------------------------------
	subscript_equal(INDEX(ICONST(i1))::xs1,INDEX(ICONST(i2))::xs2) => res

  axiom	subscript_equal([],[]) => true

  axiom	subscript_equal(_,_) => false
end

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

(** relation: int_subscripts
 **
 ** This relation describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer indexing expression.
 **)

relation int_subscripts : int list => Subscript list =

  axiom	int_subscripts [] => []

  rule	int_subscripts xs => xs'
	------------------------
	int_subscripts x::xs => INDEX(ICONST(x))::xs'

end

(** relation: simplify
 **
 ** This relation does some very basic simplification on expressions.
 ** It is not intended to be used to simplify expressions provided by
 ** the model, but to simplify unnecessarily complex expressions
 ** constructed during instantiation.
 **)

relation simplify : Exp => Exp =

  rule	simplify e => ARRAY(t,b,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(e, i) => exp


  rule	simplify e => MATRIX(t,n,exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => (expl) &
	Util.split_tuple2_list(expl) => (expl',bls) &
	Util.bool_and_list(bls) => b
	-----------------------
	simplify ASUB(e, i) => ARRAY(t,b,expl')

  rule	simplify e => IFEXP(c,t,f) &
	simplify ASUB(t,i) => t' &
	simplify ASUB(f,i) => f'
	------------------------
	simplify ASUB(e, i) => IFEXP(c,t',f')

  rule	simplify e => CREF(CREF_IDENT(n,s),t) &
	subscripts_append(s,i) => s'
	------------------------
	simplify ASUB(e, i) => CREF(CREF_IDENT(n,s'),t)

  rule	simplify e => CREF(CREF_QUAL(n,s,c),t) &
	simplify ASUB(CREF(c,t), i) => CREF(c',t)
	-------------------------------------
	simplify ASUB(e, i) => CREF(CREF_QUAL(n,s,c'),t)

  axiom	simplify e => e

end

relation unelab_exp : Exp => Absyn.Exp =

  axiom	unelab_exp(ICONST(i)) => Absyn.INTEGER(i)
  axiom	unelab_exp(RCONST(r)) => Absyn.REAL(r)
  axiom	unelab_exp(SCONST(s)) => Absyn.STRING(s)
  axiom	unelab_exp(BCONST(b)) => Absyn.BOOL(b)

  rule	unelab_cref(cr) => cr'
	----------------
	unelab_exp(CREF(cr,t))=> Absyn.CREF(cr')
end

relation unelab_cref: ComponentRef => Absyn.ComponentRef =

  rule	unelab_subscripts(subs) => subs'
	-------------------------------
	unelab_cref(CREF_IDENT(id,subs)) => Absyn.CREF_IDENT(id,subs')
	
  rule	unelab_cref(cr) => cr' &
	unelab_subscripts(subs)=> subs'
	----------------------
	unelab_cref(CREF_QUAL(id,subs,cr)) => Absyn.CREF_QUAL(id,subs',cr')
end

relation unelab_subscripts: Subscript list => Absyn.Subscript list =
	
  axiom	unelab_subscripts([]) => []

  rule	unelab_subscripts(xs) => xs'
	---------------------------
	unelab_subscripts(WHOLEDIM::xs) => Absyn.NOSUB::xs'
	
  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(SLICE(e)::xs) => Absyn.SUBSCRIPT(e')::xs'

  rule	unelab_subscripts(xs) => xs' &
	unelab_exp(e) => e'
	---------------------------
	unelab_subscripts(INDEX(e)::xs) => Absyn.SUBSCRIPT(e')::xs'
end

(** relation: subscripts_append
 **
 ** This relation takes a subscript list and adds a new subscript.
 ** But there are a few special cases.  When the last existing
 ** subscript is a slice, it is replaced by the slice indexed by the
 ** new subscript.
 **)

relation subscripts_append : (Subscript list, int) => Subscript list =

  axiom	subscripts_append([], i) => [INDEX(ICONST(i))]

  axiom	subscripts_append([WHOLEDIM], i) => [INDEX(ICONST(i))]

  rule	simplify ASUB(e, i) => e'
	-------------------------
	subscripts_append([SLICE(e)], i) => [INDEX(e')]

  axiom	subscripts_append([s as INDEX(_)], i) => [s, INDEX(ICONST(i))]

  rule	subscripts_append(ss, i) => ss'
	-------------------------------
	subscripts_append(s::ss, i) => s::ss'

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)

(*!ignorecode*)

relation type_string : Type => string =

  axiom	type_string INT => "INT"
  axiom	type_string REAL => "REAL"
  axiom	type_string BOOL => "BOOL"
  axiom	type_string STRING => "STRING"

end

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2 (s,subs) &
	Print.print_buf "__" &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

  rule	RTOpts.modelica_output => false &
	print_component_ref2 (s,subs) &
	Print.print_buf "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

end

relation print_component_ref2 =

  rule	Print.print_buf s
	-------
	print_component_ref2 (s,[])

  rule	RTOpts.modelica_output => true &
	Print.print_buf s &
	Print.print_buf "_L" & print_list(l,print_subscript,",") & Print.print_buf "_R"
	-------------------------------------------------------
	print_component_ref2 (s,l)

  rule	RTOpts.modelica_output => false &
	Print.print_buf s &
	Print.print_buf "[" & print_list(l,print_subscript,",") & Print.print_buf "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript
 **
 ** Print a `Subscript'.
 **)

relation print_subscript: Subscript => () =
	
  rule	Print.print_buf ":"
	---------
	print_subscript(WHOLEDIM)
	
  rule	print_exp(e1)
	-------------
	print_subscript(INDEX(e1))
	
  rule	print_exp(e1)
	-------------
	print_subscript(SLICE(e1))
	
end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp : Exp => () =

  rule	print_exp2 (e,0)
	----------------
	print_exp e

end

relation print_exp2 : (Exp,int) => () =
	
  rule	int_string(x) => s & Print.print_buf s
	----------------------------
	print_exp2(ICONST(x),_)

  rule	real_string(x) => s & Print.print_buf s
	-----------------------------
	print_exp2(RCONST(x),_)

  rule	Print.print_buf "\"" & Print.print_buf s & Print.print_buf "\""
	---------------------------------
	print_exp2(SCONST(s),_)

  rule	Print.print_buf "false"
	-------------
	print_exp2(BCONST(false),_)

  rule	Print.print_buf "true"
	-------------
	print_exp2(BCONST(true),_)

  rule	print_component_ref(c)
	---------------------
	print_exp2(CREF(c,_),_)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op, e2),pri1)

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------
	print_exp2(UNARY(op, e),pri1)

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & Print.print_buf sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------------------------------------------
	print_exp2(LBINARY(e1, op, e2),pri1)

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	Print.print_buf sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	---------------------------------------------------
	print_exp2(LUNARY(op, e),pri1)

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print_exp2(e1,pri3) & Print.print_buf sym & print_exp2(e2,pri3) &
	print_rightpar(pri1,pri2)
	-----------------------------------------------------------------
	print_exp2(RELATION(e1, op, e2),pri1)

  rule	Print.print_buf "if " & print_exp2(c,0) &
	Print.print_buf " then " & print_exp2(t,0) &
	Print.print_buf " else " & print_exp2(f,0)
	----------------------------
	print_exp2(IFEXP(c,t,f),_)

  rule	Absyn.path_string(fcn) => fs &
	Print.print_buf fs & Print.print_buf "(" & print_list(args,print_exp,",") & Print.print_buf ")"
	---------------------------------------------
	print_exp2(CALL(fcn, args,_,_),_)

  rule	(* Print.print_buf "This an array: " & *)
	Print.print_buf "{" &
	print_list(es, print_exp, ",") &
	Print.print_buf "}"
	---------
	print_exp2 (ARRAY(_,_,es),_)

	(*PR.*)
  rule	Print.print_buf "(" &
	print_list(es, print_exp, ",") &
	Print.print_buf ")"
	---------
	print_exp2 (TUPLE(es),_)
	
  rule	Print.print_buf "[" &
	print_list(es, print_row, ";") &
	Print.print_buf "]"
	---------
	print_exp2 (MATRIX(_,_,es),_)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" & print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------------------------------------------
	print_exp2 (RANGE(_,start,NONE,stop),pri1)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & Print.print_buf ":" &
	print_exp2 (step,pri3) & Print.print_buf ":" &
 	print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------
	print_exp2 (RANGE(_,start,SOME(step),stop),pri1)

  rule	RTOpts.modelica_output => false &
	int_real(i) => r &
	real_string(r) => rstr &
	Print.print_buf rstr
	---------------------------------------
	print_exp2 (CAST(REAL,ICONST(i)),_)

  rule	RTOpts.modelica_output => false &
	Print.print_buf "Real(" & print_exp e & Print.print_buf ")"
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	RTOpts.modelica_output => true &
	print_exp e
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	let pri2 = 51 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e,pri3) &
 	print_rightpar(pri1,pri2) &
 	Print.print_buf "[" &
 	int_string i => s & Print.print_buf s & Print.print_buf "]"
	---------------------------------------
	print_exp2 (ASUB(e,i),pri1)

  rule	print_exp_str e => str &
	Print.print_buf str
	-------------
	print_exp2 (e as SIZE(cr,dim),_)
	
  rule	Print.print_buf "#UNKNOWN EXPRESSION# ----eee "
        ----------------------------------
	print_exp2 (_,_)

end


relation print_leftpar : (int,int) => int =

  rule	int_gt(x,y) => true & Print.print_buf "("
	-----------------------
	print_leftpar(x,y) => 0

  axiom	print_leftpar(pri1,pri2) => pri2

end

relation print_rightpar : (int,int) => () =

  rule	int_gt(x,y) => true & Print.print_buf ")"
	-----------------------
	print_rightpar(x,y)

  axiom	print_rightpar(_,_)

end

(* priorities:
 *
 *   and, or				10
 *   not				11
 *   <, >, =, != etc.			21
 *   unary +, unary -			31
 *   +, -				32
 *   *					33
 *   /					34
 *   ^					35
 *   :					41
 *   []					51
 *
 *)









relation binop_priority : Operator => int =
  axiom	binop_priority(ADD(_))    	      	 => 32
  axiom	binop_priority(SUB(_))    	      	 => 32
  axiom	binop_priority(ADD_ARR(_))    	      	 => 32
  axiom	binop_priority(SUB_ARR(_))    	      	 => 32
  axiom	binop_priority(MUL(_))    	      	 => 33
  axiom	binop_priority(MUL_SCALAR_ARRAY(_))   	 => 33
  axiom	binop_priority(MUL_ARRAY_SCALAR(_))    	 => 33
  axiom	binop_priority(MUL_SCALAR_PRODUCT(_))  	 => 33
  axiom	binop_priority(MUL_MATRIX_PRODUCT(_))  	 => 33
  axiom	binop_priority(DIV(_))   	      	 => 34
  axiom	binop_priority(DIV_ARRAY_SCALAR(_))    	 => 34
  axiom	binop_priority(POW(_))   	      	 => 35      
end

relation unaryop_priority : Operator => int =
  axiom	unaryop_priority(UMINUS(_))   => 31
  axiom	unaryop_priority(UPLUS(_))    => 31
end

relation lbinop_priority : Operator => int =
  axiom	lbinop_priority(AND) => 10
  axiom	lbinop_priority(OR) => 10
end

relation lunaryop_priority : Operator => int =
  axiom	lunaryop_priority(NOT) => 11
end

relation relop_priority : Operator => int =
  axiom	relop_priority(LESS(_))       => 21
  axiom	relop_priority(LESSEQ(_))     => 21
  axiom	relop_priority(GREATER(_))    => 21
  axiom	relop_priority(GREATEREQ(_))  => 21
  axiom	relop_priority(EQUAL(_))      => 21
  axiom	relop_priority(NEQUAL(_))     => 21
end

(**)

relation binop_symbol : Operator => string =

  rule	RTOpts.typeinfo => false &
	binop_symbol_1 op => s
	----------------------
	binop_symbol op => s

  rule	RTOpts.typeinfo => true &
	binop_symbol_2 op => s
	----------------------
	binop_symbol op => s

end

(**)

relation binop_symbol_1 : Operator => string =
  axiom	binop_symbol_1(ADD(_)) => " + "
  axiom	binop_symbol_1(SUB(_)) => " - "
  axiom	binop_symbol_1(MUL(_)) => " * "
  axiom	binop_symbol_1(DIV(_)) => " / "
  axiom	binop_symbol_1(POW(_)) => " ^ "
  axiom	binop_symbol_1(ADD_ARR(_)) => " + "
  axiom	binop_symbol_1(SUB_ARR(_)) => " - "
  axiom	binop_symbol_1(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_1(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_1(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_1(DIV_ARRAY_SCALAR(_)) => " / "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation binop_symbol_2 : Operator => string =
  rule	type_string t => ts &
	string_append(" +<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(ADD(t)) => s'

  axiom	binop_symbol_2(SUB(t)) => " - "
  axiom	binop_symbol_2(MUL(t)) => " * "

  rule	type_string t => ts &
	string_append(" /<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(DIV(t)) => s'

  axiom	binop_symbol_2(POW(t)) => " ^ "

  axiom	binop_symbol_2(ADD_ARR(_)) => " + "
  axiom	binop_symbol_2(SUB_ARR(_)) => " - "
  axiom	binop_symbol_2(MUL_SCALAR_ARRAY(_)) => " * "
  axiom	binop_symbol_2(MUL_ARRAY_SCALAR(_)) => " * "
  axiom	binop_symbol_2(MUL_SCALAR_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(MUL_MATRIX_PRODUCT(_)) => " * "
  axiom	binop_symbol_2(DIV_ARRAY_SCALAR(_)) => " / "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation unaryop_symbol : Operator => string =
  axiom	unaryop_symbol(UMINUS(_)) => "-"
  axiom	unaryop_symbol(UPLUS(_)) => "+"
end

relation lbinop_symbol : Operator => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol : Operator => string =
  axiom	lunaryop_symbol(NOT) => " NOT "
end

relation relop_symbol : Operator => string =
  axiom	relop_symbol(LESS(_))       => " < "
  axiom	relop_symbol(LESSEQ(_))     => " <= "
  axiom	relop_symbol(GREATER(_))    => " > "
  axiom	relop_symbol(GREATEREQ(_))  => " >= "
  axiom	relop_symbol(EQUAL(_))      => " = "
  axiom	relop_symbol(NEQUAL(_))     => " <> "
end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.print_buf sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(**)

relation print_row : (Exp*bool) list =>() =

  rule	Util.list_map(es,Util.tuple2_1) => es' &
	print_list(es',print_exp,",")
	----------------------------
	print_row es

end

(*!includecode*)



(******************************************************************)
(** LS: print relations that return a string instead of printing **)
(** Had to duplicate the huge print_exp2 and modify              **)
(** An alternative would be to implement "sprint" somehow        **)
(** which would need internal state, with reset and              **)
(** get_string methods                                           **)
(**                                                              **)
(** Once these are tested and ok, the print_exp* above can be    **)
(** replaced by a call to these _str relations and printing      **)
(** the result.                                                  **)
(******************************************************************)

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref_str : ComponentRef => string =

  rule	print_component_ref2_str (s,subs) => str
	----------------------------
	print_component_ref_str CREF_IDENT(s,subs) => str

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, "__") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

  rule	RTOpts.modelica_output => false &
	print_component_ref2_str (s,subs) => str &
	print_component_ref_str cr => strrest &
	string_append (str, ".") => str' &
	string_append (str', strrest) => str''
	---------------------
	print_component_ref_str CREF_QUAL(s,subs,cr) => str''

end

relation print_component_ref2_str : (Ident, Subscript list) => string =

  axiom	print_component_ref2_str (s,[]) => s

  rule	RTOpts.modelica_output => true &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "_L") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "_R") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

  rule	RTOpts.modelica_output => false &
	print_list_str (l, print_subscript_str, ",") => str &
	string_append (s, "[") => str' &
	string_append (str', str) => str'' &
	string_append (str'', "]") => str'''
	-------------------------------------------------------
	print_component_ref2_str (s,l) => str'''

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end



(** relation: print_subscript_str
 **
 ** Print a `Subscript'.
 **)

relation print_subscript_str: Subscript => string =
	
  axiom	print_subscript_str (WHOLEDIM) => ":"
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (INDEX(e1)) => s
	
  rule	print_exp_str (e1) => s
	-------------
	print_subscript_str (SLICE(e1)) => s
	
end


(** relation: print_exp_str
 **
 ** This relation prints a complete expression.
 **)

relation print_exp_str : Exp => string =

  rule	print_exp2_str (e,0) => s
	--------------------
	print_exp_str e => s

end


relation print_exp2_str : (Exp,int) => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp2_str(ICONST(x),_) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp2_str(RCONST(x),_) => s

  rule	string_append ("\"", s) => s' &
	string_append (s', "\"") => s''
	---------------------------------
	print_exp2_str(SCONST(s),_) => s''

  axiom	print_exp2_str(BCONST(false),_) => "false"

  axiom	print_exp2_str(BCONST(true),_) => "true"

  rule	print_component_ref_str (c) => s
	--------------------------------
	print_exp2_str(CREF(c,_),_) => s

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri3) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	------------------------
	print_exp2_str (BINARY(e1, op, e2),pri1) => s'''

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	----------------------------
	print_exp2_str(UNARY(op, e),pri1) => s''

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e1,pri3) => s2 & 
	print_exp2_str (e2,pri3) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	----------------------------------------------------------------
	print_exp2_str(LBINARY(e1, op, e2),pri1) => s'''

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str (e,pri3) => s2 &
	print_rightpar_str (pri1,pri2) => s3 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s' &
	string_append (s', s3) => s''
	---------------------------------------------------
	print_exp2_str(LUNARY(op, e),pri1) => s''

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
 	print_exp2_str(e1,pri3) => s2 & 
	print_exp2_str(e2,pri3) => s3 &
	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, sym) => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-----------------------------------------------------------------
	print_exp2_str(RELATION(e1, op, e2),pri1) => s'''

  rule	print_exp2_str(c,0) => ifstr &
	print_exp2_str(t,0) => thenstr &
	print_exp2_str(f,0) => elsestr &
	string_append ("if ", ifstr) => s &
	string_append (s, " then ") => s' &
	string_append (s', thenstr) => s'' &
	string_append (s'', " else ") => s''' &
	string_append (s''', elsestr) => s''''
	----------------------------
	print_exp2_str(IFEXP(c,t,f),_) => s''''

  rule	Absyn.path_string(fcn) => fs &
	print_list_str(args,print_exp_str,",") => argstr &
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp2_str(CALL(fcn, args,_,_),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("{",s) => s' &
	string_append (s',"}") => s''
	-----------------------------
	print_exp2_str (ARRAY(_,_,es),_) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp2_str (TUPLE(es),_) => s''
	
  rule	print_list_str(es, print_row_str, "},{") => s &
	string_append ("{{",s) => s' &
	string_append (s',"}}") => s''
	-----------------------------
	print_exp2_str (MATRIX(_,_,es),_) => s''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (stop,pri3) => s3 &
 	print_rightpar_str (pri1,pri2) => s4 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', s4) => s'''
	-------------------------------------------------------------
	print_exp2_str (RANGE(_,start,NONE,stop),pri1) => s'''

  rule	let pri2 = 41 &
	print_leftpar_str (pri1,pri2) => (s1,pri3) &
	print_exp2_str (start,pri3) => s2 &
	print_exp2_str (step,pri3) => s3 &
 	print_exp2_str (stop,pri3) => s4 &
 	print_rightpar_str (pri1,pri2) => s5 &
	string_append (s1, s2) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s4) => s'''' &
	string_append (s'''', s5) => s'''''
	-------------------------------------
	print_exp2_str (RANGE(_,start,SOME(step),stop),pri1) => s'''''

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res
	---------------------------------------
	print_exp2_str (CAST(REAL,ICONST(ival)),_) => res

  rule	RTOpts.modelica_output => false &
	int_real ival => rval &
	real_string rval => res &
	string_append("-",res) => res2
	---------------------------------------
	print_exp2_str (CAST(REAL,UNARY(UMINUS(_),ICONST(ival))),_) => res2

  rule	RTOpts.modelica_output => false &
	print_exp_str e => s & 
	string_append ("Real(", s) => s' &
	string_append (s', ")") => s''
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s''

  rule	RTOpts.modelica_output => true &
	print_exp_str e => s
	---------------------------------------
	print_exp2_str (CAST(REAL,e),_) => s

  rule	let pri2 = 51 &
	print_leftpar_str (pri1,pri2) => (s1, pri3) &
	print_exp2_str (e,pri3) => s2 &
 	print_rightpar_str (pri1,pri2) => s3 &
 	int_string i => s4 &
	string_append (s1, s2) => s &
	string_append (s, s3) => s' &
	string_append (s', "[") => s'' &
	string_append (s'', s4) => s''' &
	string_append (s''', "]") => s''''
	---------------------------------------
	print_exp2_str (ASUB(e,i),pri1) => s''''

  rule	print_exp_str cr => crstr &
	print_exp_str dim => dimstr &
	Util.string_append_list(["size(",crstr,",",dimstr]) => str
	------------------------
	print_exp2_str (SIZE(cr,dim),_) => str

  axiom	print_exp2_str (_,_) => "#UNKNOWN EXPRESSION# ----eee "

end

relation print_row_str : (Exp*bool) list => string =

  rule	Util.list_map (es,Util.tuple2_1) => es' &
	print_list_str (es', print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end


relation print_leftpar_str : (int,int) => (string, int) =

  rule	int_gt(x,y) => true
	-----------------------
	print_leftpar_str (x,y) => ("(", 0)

  axiom	print_leftpar_str (pri1,pri2) => ("", pri2)

end

relation print_rightpar_str : (int,int) => string =

  rule	int_gt(x,y) => true
	-----------------------
	print_rightpar_str (x,y) => ")"

  axiom	print_rightpar_str (_,_) => ""

end
