(**
 ** file:	 exp.rml
 ** module:      Exp
 ** description: Expressions
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing expressions, after they have been examined by the
 ** static analyzer in the module `StaticExp'.  There are of course
 ** great similarities with the expression types in the `Absyn'
 ** module, but there are also several important differences.
 **
 ** No overloading of operators occur, and subscripts have been
 ** checked to see if they are slices.  All expressions are also type
 ** consistent, and all implicit type conversions in the AST are made
 ** explicit here.
 **)

module Exp:

  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  (** - Basic types *)
  datatype Type = INT | REAL | BOOL | STRING
  (** These types are not used as expression types (see the `Types'
   ** module for expression types).  They are used to parameterize
   ** operators which may work on several simple types. *)

  (** - Expressions *)
  datatype Exp = ICONST of int
	       | RCONST of real
	       | SCONST of string
	       | BCONST of bool
	       | CREF of ComponentRef
	       | BINARY of Exp * Operator * Exp
	       | UNARY of Operator * Exp
	       | LBINARY of Exp * Operator * Exp
	       | LUNARY of Operator * Exp
	       | RELATION of Exp * Operator * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Absyn.Path * Exp list		(* Function call *)
	       | ARRAY of Exp list
	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
                 (* New constructors *)
	       | CAST of Type * Exp
	       | ASUB of Exp * int
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp'
   ** datatype, but is used for statically analyzed expressions.  It
   ** includes explicit type promotions and typed (non-overloaded)
   ** operators. It also contains expression indexing with the `ASUB'
   ** constructor.  Indexing arbitrary array expressions is currently
   ** not supported in Modelica, but it is needed here. *)

  datatype Operator = ADD    	  of Type
		    | SUB    	  of Type
		    | MUL    	  of Type
		    | DIV    	  of Type
		    | POW    	  of Type
		    | UMINUS 	  of Type
		    | UPLUS  	  of Type
		    | AND | OR
		    | NOT
		    | LESS        of Type
		    | LESSEQ      of Type
		    | GREATER     of Type
		    | GREATEREQ   of Type
		    | EQUAL       of Type
		    | NEQUAL      of Type
  (** Operators which are overloaded in the abstract syntax are here
   ** made type-specific.  The integer addition operator (`ADD(INT)')
   ** and the real addition operator (`ADD(REAL)') are two distinct
   ** operators. *)

  (** - Component references *)
  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)

  datatype Subscript = WHOLEDIM
		     | SLICE of Exp
		     | INDEX of Exp
  (** the `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Absyn' module. *)

  (** - Exported relations *)
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation int_subscripts : int list => Subscript list
  relation simplify : Exp => Exp
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_subscript: Subscript => ()
  relation print_list : ('a list, 'a => (), string) => ()

end

with "rtopts.rml"

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

(** relation: int_subscripts
 **
 ** This relation describes the relation between a list of integers
 ** and a list of `Exp.Subscript' where each integer is converted to
 ** an integer indexing expression.
 **)

relation int_subscripts : int list => Subscript list =

  axiom	int_subscripts [] => []

  rule	int_subscripts xs => xs'
	------------------------
	int_subscripts x::xs => INDEX(ICONST(x))::xs'

end

(** relation: simplify
 **
 ** This relation does some very basic simplification on expressions.
 ** It is not intended to be used to simplify expressions provided by
 ** the model, but to simplify unnecessarily complex expressions
 ** constructed during instantiation.
 **)

relation simplify : Exp => Exp =

  rule	simplify e => ARRAY(exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(e, i) => exp

  rule	simplify e => MATRIX(exps) &
	int_sub (i,1) => i' &
	list_nth(exps,i') => exp
	-----------------------
	simplify ASUB(e, i) => ARRAY(exp)

  rule	simplify e => IFEXP(c,t,f) &
	simplify ASUB(t,i) => t' &
	simplify ASUB(f,i) => f'
	------------------------
	simplify ASUB(e, i) => IFEXP(c,t',f')

  rule	simplify e => CREF(CREF_IDENT(n,s)) &
	subscripts_append(s,i) => s'
	------------------------
	simplify ASUB(e, i) => CREF(CREF_IDENT(n,s'))

  rule	simplify e => CREF(CREF_QUAL(n,s,c)) &
	simplify ASUB(CREF(c), i) => CREF(c')
	-------------------------------------
	simplify ASUB(e, i) => CREF(CREF_QUAL(n,s,c'))

  axiom	simplify e => e

end

(** relation: subscripts_append
 **
 ** This relation takes a subscript list and adds a new subscript.
 ** But there are a few special cases.  When the last existing
 ** subscript is a slice, it is replaced by the slice indexed by the
 ** new subscript.
 **)

relation subscripts_append : (Subscript list, int) => Subscript list =

  axiom	subscripts_append([], i) => [INDEX(ICONST(i))]

  axiom	subscripts_append([WHOLEDIM], i) => [INDEX(ICONST(i))]

  rule	simplify ASUB(e, i) => e'
	-------------------------
	subscripts_append([SLICE(e)], i) => [INDEX(e')]

  axiom	subscripts_append([s as INDEX(_)], i) => [s, INDEX(ICONST(i))]

  rule	subscripts_append(ss, i) => ss'
	-------------------------------
	subscripts_append(s::ss, i) => s::ss'

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)

(*!ignorecode*)

relation type_string : Type => string =

  axiom	type_string INT => "INT"
  axiom	type_string REAL => "REAL"
  axiom	type_string BOOL => "BOOL"
  axiom	type_string STRING => "STRING"

end

(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

	(* Does not handle names with underscores *)
  rule	RTOpts.modelica_output => true &
	print_component_ref2 (s,subs) &
	print "__" &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

  rule	RTOpts.modelica_output => false &
	print_component_ref2 (s,subs) &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)

end

relation print_component_ref2 =

  rule	print s
	-------
	print_component_ref2 (s,[])

  rule	RTOpts.modelica_output => true &
	print s &
	print "_L" & print_list(l,print_subscript,",") & print "_R"
	-------------------------------------------------------
	print_component_ref2 (s,l)

  rule	RTOpts.modelica_output => false &
	print s &
	print "[" & print_list(l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript
 **
 ** Print a `Subscript'.
 **)

relation print_subscript: Subscript => () =
	
  rule	print ":"
	---------
	print_subscript(WHOLEDIM)
	
  rule	print_exp(e1)
	-------------
	print_subscript(INDEX(e1))
	
  rule	print_exp(e1)
	-------------
	print_subscript(SLICE(e1))
	
end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp: Exp => () =

  rule	print_exp2 (e,0)
	----------------
	print_exp e

end

relation print_exp2: (Exp,int) => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp2(ICONST(x),_)

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp2(RCONST(x),_)

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp2(SCONST(s),_)

  rule	print "false"
	-------------
	print_exp2(BCONST(false),_)

  rule	print "true"
	-------------
	print_exp2(BCONST(true),_)

  rule	print_component_ref(c)
	---------------------
	print_exp2(CREF(c),_)

  rule	binop_symbol(op) => sym &
 	binop_priority op => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & print sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	------------------------
	print_exp2(BINARY(e1, op, e2),pri1)

  rule	unaryop_symbol(op) => sym &
	unaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------
	print_exp2(UNARY(op, e),pri1)

  rule	lbinop_symbol(op) => sym &
	lbinop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e1,pri3) & print sym & print_exp2 (e2,pri3) &
	print_rightpar(pri1,pri2)
	----------------------------------------------------------------
	print_exp2(LBINARY(e1, op, e2),pri1)

  rule	lunaryop_symbol(op) => sym &
 	lunaryop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print sym & print_exp2 (e,pri3) &
	print_rightpar(pri1,pri2)
	---------------------------------------------------
	print_exp2(LUNARY(op, e),pri1)

  rule	relop_symbol(op) => sym &
 	relop_priority(op) => pri2 &
	print_leftpar(pri1,pri2) => pri3 &
 	print_exp2(e1,pri3) & print sym & print_exp2(e2,pri3) &
	print_rightpar(pri1,pri2)
	-----------------------------------------------------------------
	print_exp2(RELATION(e1, op, e2),pri1)

  rule	print "if " & print_exp2(c,0) &
	print " then " & print_exp2(t,0) &
	print " else " & print_exp2(f,0)
	----------------------------
	print_exp2(IFEXP(c,t,f),_)

  rule	Absyn.path_string(fcn) => fs &
	print fs & print "(" & print_list(args,print_exp,",") & print ")"
	---------------------------------------------
	print_exp2(CALL(fcn, args),_)

  rule	print "[" &
	print_list(es, print_exp, ",") &
	print "]"
	---------
	print_exp2 (ARRAY(es),_)
	
  rule	print "[" &
	print_list(es, print_row, ";") &
	print "]"
	---------
	print_exp2 (MATRIX(es),_)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & print ":" & print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------------------------------------------
	print_exp2 (RANGE(start,NONE,stop),pri1)

  rule	let pri2 = 41 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (start,pri3) & print ":" &
	print_exp2 (step,pri3) & print ":" &
 	print_exp2 (stop,pri3) &
 	print_rightpar(pri1,pri2)
	-------------------------
	print_exp2 (RANGE(start,SOME(step),stop),pri1)

  rule	RTOpts.modelica_output => false &
	print "Real(" & print_exp e & print ")"
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	RTOpts.modelica_output => true &
	print_exp e
	---------------------------------------
	print_exp2 (CAST(REAL,e),_)

  rule	let pri2 = 51 &
	print_leftpar(pri1,pri2) => pri3 &
	print_exp2 (e,pri3) &
 	print_rightpar(pri1,pri2) &
 	print "[" &
 	int_string i => s & print s & print "]"
	---------------------------------------
	print_exp2 (ASUB(e,i),pri1)
	
  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	print_exp2 (_,_)

end

relation print_leftpar : (int,int) => int =

  rule	int_gt(x,y) => true & print "("
	-----------------------
	print_leftpar(x,y) => 0

  axiom	print_leftpar(pri1,pri2) => pri2

end

relation print_rightpar : (int,int) => () =

  rule	int_gt(x,y) => true & print ")"
	-----------------------
	print_rightpar(x,y)

  axiom	print_rightpar(_,_)

end

(* priorities:
 *
 *   and, or				10
 *   not				11
 *   <, >, =, != etc.			21
 *   unary +, unary -			31
 *   +, -				32
 *   *					33
 *   /					34
 *   ^					35
 *   :					41
 *   []					51
 *
 *)

relation binop_priority : Operator => int =
  axiom	binop_priority(ADD(_))    	      	 => 32
  axiom	binop_priority(SUB(_))    	      	 => 32
  axiom	binop_priority(MUL(_))    	      	 => 33
  axiom	binop_priority(DIV(_))   	      	 => 34
  axiom	binop_priority(POW(_))   	      	 => 35      
end

relation unaryop_priority : Operator => int =
  axiom	unaryop_priority(UMINUS(_))   => 31
  axiom	unaryop_priority(UPLUS(_))    => 31
end

relation lbinop_priority : Operator => int =
  axiom	lbinop_priority(AND) => 10
  axiom	lbinop_priority(OR) => 10
end

relation lunaryop_priority : Operator => int =
  axiom	lunaryop_priority(NOT) => 11
end

relation relop_priority : Operator => int =
  axiom	relop_priority(LESS(_))       => 21
  axiom	relop_priority(LESSEQ(_))     => 21
  axiom	relop_priority(GREATER(_))    => 21
  axiom	relop_priority(GREATEREQ(_))  => 21
  axiom	relop_priority(EQUAL(_))      => 21
  axiom	relop_priority(NEQUAL(_))     => 21
end

(**)

relation binop_symbol : Operator => string =

  rule	RTOpts.typeinfo => false &
	binop_symbol_1 op => s
	----------------------
	binop_symbol op => s

  rule	RTOpts.typeinfo => true &
	binop_symbol_2 op => s
	----------------------
	binop_symbol op => s

end

(**)

relation binop_symbol_1 : Operator => string =
  axiom	binop_symbol_1(ADD(_)) => " + "
  axiom	binop_symbol_1(SUB(_)) => " - "
  axiom	binop_symbol_1(MUL(_)) => " * "
  axiom	binop_symbol_1(DIV(_)) => " / "
  axiom	binop_symbol_1(POW(_)) => " ^ "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation binop_symbol_2 : Operator => string =
  rule	type_string t => ts &
	string_append(" +<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(ADD(t)) => s'

  axiom	binop_symbol_2(SUB(t)) => " - "
  axiom	binop_symbol_2(MUL(t)) => " * "

  rule	type_string t => ts &
	string_append(" /<", ts) => s &
	string_append(s, "> ") => s'
	----------------------------
	binop_symbol_2(DIV(t)) => s'

  axiom	binop_symbol_2(POW(t)) => " ^ "

(*
  rule	int_string dim => s1 &
	string_append(" <int[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(INT_ARRAY_SCALAR_MUL(dim)) => s3

  rule	int_string dim => s1 &
	string_append(" <real[",s1) => s2 &
	string_append(s2,"] *> ") => s3
	-------------------------------
	binop_symbol(REAL_ARRAY_SCALAR_MUL(dim)) => s3

  axiom	binop_symbol(_) => " <unknown binop> "
*)

end

relation unaryop_symbol : Operator => string =
  axiom	unaryop_symbol(UMINUS(_)) => "-"
  axiom	unaryop_symbol(UPLUS(_)) => "+"
end

relation lbinop_symbol : Operator => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol : Operator => string =
  axiom	lunaryop_symbol(NOT) => " NOT "
end

relation relop_symbol : Operator => string =
  axiom	relop_symbol(LESS(_))       => " < "
  axiom	relop_symbol(LESSEQ(_))     => " <= "
  axiom	relop_symbol(GREATER(_))    => " > "
  axiom	relop_symbol(GREATEREQ(_))  => " >= "
  axiom	relop_symbol(EQUAL(_))      => " = "
  axiom	relop_symbol(NEQUAL(_))     => " <> "
end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end

(**)

relation print_row : Exp list =>() =

  rule	print_list(es,print_exp,",")
	----------------------------
	print_row es

end

(*!includecode*)
