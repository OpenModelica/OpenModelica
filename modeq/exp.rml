(*
 * Exp - Modelica expression module
 *)

module Exp:
  
  type Ident = string

  datatype Type = T_INTEGER | T_REAL | T_STRING | T_BOOL | T_OTHER
  
  datatype Subscript = NOSUB
		     | SUB1 of Exp
		     | SUB2 of Exp * Exp
		     | SUB3 of Exp * Exp * Exp
		 
  type ComponentRef = (Ident * (Subscript list)) list
  
  datatype Path = QUALIFIED of string * Path
	      	| IDENT of Ident
	      	
  datatype BinOp = ADD | SUB | MUL | DIV | POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = LESS | LESSEQ | GREATER | GREATEREQ | EQUAL | NEQUAL
  
  datatype Exp = INTEGER of int
	       | REAL of real
	       | CREF of ComponentRef
	       | STRING of string
	       | BOOL of bool
	       
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       
	       | RELATION of Exp * RelOp * Exp
	       
	       | IFEXP of Exp * Exp * Exp
	       
	       | CALL of Path * Exp list		(* Function call *)
	       | TIME

	       | CAST_TO_REAL of Exp

  type TypedExp = Exp * Type
		  
  relation path_string : Path => string
  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation eq_cref : (ComponentRef, ComponentRef) => ()

  relation dump_component_ref : ComponentRef => ()
  relation dump_exp: Exp => ()
  relation print_type : Type => ()
  
end

(**********************************************************************)

relation path_string: Path => string =

  axiom	path_string(IDENT(s)) => s
  
  rule	path_string(n) => ns &
	string_append(s,".") => s1 &
	string_append(s1,ns) => ss
	-------------------------------------
	path_string(QUALIFIED(s,n)) => ss
	
end

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref([], i, s) => [(i,s)]

  rule	extend_cref(xs, i, s) => xs'
	----------------------------
	extend_cref(x::xs, i, s) => x::xs'

end

relation eq_subscript : (Subscript, Subscript) => () =

  axiom	eq_subscript(NOSUB,NOSUB)

	(* FIXME *)
  rule	s1 = s2
	-------------------------------
	eq_subscript(SUB1(s1),SUB1(s2))

end

relation eq_subscripts : (Subscript list, Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

relation eq_cref : (ComponentRef, ComponentRef) => () =

  axiom	eq_cref([],[])

  rule	n1 = n2 &
	eq_subscripts(s1,s2) &
	eq_cref(c1,c2)
	-------------------
	eq_cref((n1,s1)::c1, (n2,s2)::c2)

end

(**********************************************************************
 * Dump
 **********************************************************************)

relation dump_list : ('a list, 'a => (), string) => () =

  axiom	dump_list([],_,_)

  rule	r(h)
	------------------
	dump_list([h],r,_)

  rule	r(h) & print sep & dump_list(t,r,sep)
	-------------------------------------
	dump_list(h::t,r,sep)
end

relation binop_symbol: BinOp => string =
  axiom	binop_symbol(ADD) => " + "
  axiom	binop_symbol(SUB) => " - "
  axiom	binop_symbol(MUL) => "*"
  axiom	binop_symbol(DIV) => "/"
  axiom	binop_symbol(POW) => "^"
end

relation unaryop_symbol: UnaryOp => string =
  axiom	unaryop_symbol(UMINUS) => "-"
  axiom	unaryop_symbol(UPLUS) => "+"
end

relation lbinop_symbol: LBinOp => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol: LUnaryOp => string =
  axiom	lunaryop_symbol(NOT) => "NOT "
end

relation relop_symbol: RelOp => string =
  axiom	relop_symbol(LESS)      => " < "
  axiom	relop_symbol(LESSEQ)    => " <= "
  axiom	relop_symbol(GREATER)   => " > "
  axiom	relop_symbol(GREATEREQ) => " >= "
  axiom	relop_symbol(EQUAL)     => " == "
  axiom	relop_symbol(NEQUAL)    => " <> "
end

relation dump_component_ref : ComponentRef => () =

  rule	dump_list(cr,dump_component_ref2,".")
	-------------------------------------
	dump_component_ref(cr)

end

and dump_component_ref2 =

  rule	print s
	-------------------------
	dump_component_ref2((s,[]))

  rule	print s &
	print "[" & dump_list(l,dump_subscript,",") & print "]"
	-------------------------------------------------------------
	dump_component_ref2((s,l))

end

and dump_subscript: Subscript => () =

  rule	print ":"
	---------
	dump_subscript(NOSUB)

  rule	dump_exp(e1)
	----------
	dump_subscript(SUB1(e1))

  rule	dump_exp(e1) & print ":" & dump_exp(e2)
	-------------
	dump_subscript(SUB2(e1,e2))

  rule	dump_exp(e1) & print ":" &
	dump_exp(e2) & print ":" & dump_exp(e3)
	----------------------------------------------
	dump_subscript(SUB3(e1,e2,e3))

end

and dump_exp: Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	dump_exp(INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	dump_exp(REAL(x))

  rule	dump_component_ref(c)
	---------------------
	dump_exp(CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	dump_exp(STRING(s))

  rule	print "FALSE"
	-------------
	dump_exp(BOOL(false))

  rule	print "TRUE"
	-------------
	dump_exp(BOOL(true))

  rule	binop_symbol(op) => sym &
	dump_exp e1 & print sym & dump_exp e2
	----------------------------
	dump_exp(BINARY(e1, op, e2))

  rule	unaryop_symbol(op) => sym &
	print sym & dump_exp e
	----------------------------
	dump_exp(UNARY(op, e))

  rule	lbinop_symbol(op) => sym &
	dump_exp e1 & print sym & dump_exp e2
	----------------------------
	dump_exp(LBINARY(e1, op, e2))

  rule	lunaryop_symbol(op) => sym &
	print sym & dump_exp e
	----------------------------
	dump_exp(LUNARY(op, e))

  rule	relop_symbol(op) => sym &
	dump_exp(e1) & print sym & dump_exp(e2)
	---------------------------------------
	dump_exp(RELATION(e1, op, e2))

  rule	print "IF " & dump_exp(c) &
	print " THEN " & dump_exp(t) &
	print " ELSE " & dump_exp(f)
	----------------------------
	dump_exp(IFEXP(c,t,f))

  rule	path_string(fcn) => fs &
	print fs & print "(" & dump_list(args,dump_exp,",") & print ")"
	---------------------------------------------
	dump_exp(CALL(fcn, args))

	(*
	 rule	print "EQUATION " & 
	 dump_exp lhs &
	 print " = " &
	 dump_exp rhs
	 ------------------------
	 dump_exp(EQU(lhs, rhs))
	 *)
  rule	print "TIME"
	------------------
	dump_exp(TIME)

  rule	print "real(" & dump_exp(e) & print ")"
	----------------------------------------
	dump_exp CAST_TO_REAL(e)

  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	dump_exp (_)
end


relation print_type : Type => () =

  rule	print "integer"
	---------------
	print_type T_INTEGER

  rule	print "real"
	------------
	print_type T_REAL

  rule	print "string"
	--------------
	print_type T_STRING

  rule	print "bool"
	------------
	print_type T_BOOL

  rule	print "complex"
	------------
	print_type T_OTHER

end
