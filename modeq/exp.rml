(**
 ** file:  exp.rml
 **
 ** This file contains the module `Exp', which contains data types for
 ** describing Modelica expressions.  It is used throughout the
 ** semantic description, in the abstract syntax tree and elsewhere.
 ** All the other modules use this module.
 ** 
 **)

module Exp:

  with "absyn.rml"

  (** - Identifiers *)
  type Ident = string
  (** Define `Ident' as an alias for `string' and use it for all *)
  (** identifiers in Modelica. *)

  datatype BinOp = INT_ADD | REAL_ADD | STRING_ADD
		 | INT_SUB | REAL_SUB
		 | INT_MUL | REAL_MUL
		 | REAL_DIV
		 | REAL_POW
  datatype UnaryOp = UMINUS | UPLUS
  datatype LBinOp = AND | OR
  datatype LUnaryOp = NOT
  datatype RelOp = INT_LESS      | REAL_LESS
		 | INT_LESSEQ    | REAL_LESSEQ
		 | INT_GREATER   | REAL_GREATER
		 | INT_GREATEREQ | REAL_GREATEREQ
		 | INT_EQUAL     | REAL_EQUAL  | BOOL_EQUAL  | STRING_EQUAL
		 | INT_NEQUAL    | REAL_NEQUAL | BOOL_NEQUAL | STRING_NEQUAL
  
  (** - Expressions *)
  datatype Exp = ICONST of int
	       | RCONST of real
	       | SCONST of string
	       | BCONST of bool
	       | CREF of ComponentRef
	       | BINARY of Exp * BinOp * Exp
	       | UNARY of UnaryOp * Exp
	       | LBINARY of Exp * LBinOp * Exp
	       | LUNARY of LUnaryOp * Exp
	       | RELATION of Exp * RelOp * Exp
	       | IFEXP of Exp * Exp * Exp
	       | CALL of Absyn.Path * Exp list		(* Function call *)
	       | ARRAY of Exp list
	       | MATRIX of Exp list list
	       | RANGE of Exp * Exp option * Exp
                 (* New constructors *)
	       | CAST_TO_REAL of Exp
  (** The `Exp' datatype closely corresponds to the `Absyn.Exp' *)
  (** datatype, but is used for statically analyzed expressions.  It *)
  (** includes explicit type promotions and typed (non-overloaded) *)
  (** operators. *)

  (** - Component references *)
  datatype Subscript = NOSUB
		     | SUB1 of Exp
		     | SUB2 of Exp * Exp
		     | SUB3 of Exp * Exp * Exp

  datatype ComponentRef = CREF_QUAL of Ident * (Subscript list) * ComponentRef
		    	| CREF_IDENT of Ident * (Subscript list)
  (** the `Subscript' and `ComponentRef' datatypes are simple *)
  (** translations of the corresponding types in the `Exp' module. *)

  relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef
  relation eq_cref : (ComponentRef, ComponentRef) => ()
  relation print_exp : Exp => ()
  relation print_component_ref : ComponentRef => ()
  relation print_list : ('a list, 'a => (), string) => ()

end

(** relation: extend_cref
 **
 ** The `extend_cref' relation extends a `ComponentRef' by appending
 ** an identifier and a (possibly empty) list of subscripts.  Adding
 ** the identifier `a' to the component reference `x.y[10]' would
 ** produce the component reference `x.y[10].a', for instance.
 **)

relation extend_cref : (ComponentRef, Ident, Subscript list) => ComponentRef =

  axiom	extend_cref (CREF_IDENT(i1,s1),i,s) => CREF_QUAL(i1,s1,CREF_IDENT(i,s))

  rule	extend_cref (c,i,s) => c'
	-------------------------
	extend_cref (CREF_QUAL(i1,s1,c), i, s) => CREF_QUAL(i1,s1,c')

end

(** - Equality relations *)

(** relation: eq_cref
 **
 ** This relation checks if two component references can be considered
 ** equal and fails if not.  Two component references are equal if all
 ** corresponding identifiers are the same, and if the subscripts are
 ** equal, according to the relation `eq_subscripts'.
 **)

relation eq_cref : (ComponentRef, ComponentRef) => () =

  rule	n1 = n2 &
	eq_subscripts (s1,s2)
	---------------------
	eq_cref (CREF_IDENT(n1,s1), CREF_IDENT(n2,s2))

  rule	n1 = n2 &
	eq_subscripts (s1,s2) &
	eq_cref (c1,c2)
	---------------
	eq_cref (CREF_QUAL(n1,s1,c1), CREF_QUAL(n2,s2,c2))

end

(** relation: eq_subscripts
 **
 ** Two list of subscripts are equal if they are of equal length and
 ** all their elements are pairwise equal according to the relation
 ** `eq_subscript'.
 **)

relation eq_subscripts : (Subscript list, Subscript list) => () =

  axiom	eq_subscripts([],[])

  rule	eq_subscript(s1,s2) &
	eq_subscripts(ss1,ss2)
	----------------------
	eq_subscripts(s1::ss1, s2::ss2)

end

(** relation: eq_subscript
 **
 ** This relation test whether two subscripts are equal.  Two
 ** subscripts are equal if they have the same constructor, and if all
 ** corresponding expressions are either syntactically equal, or if
 ** they have the same constant value.
 **)

relation eq_subscript : (Subscript, Subscript) => () =

  axiom	eq_subscript(NOSUB,NOSUB)
 	
 	(* FIXME: this is not complete at all *)
  rule	s1 = s2
	-------------------------------
	eq_subscript(SUB1(s1),SUB1(s2))
	
  rule	print "- eq_subscript failed\n"
	-------------------------------
	eq_subscript(_,_)

end

(**
 ** - Printing expressions
 **
 ** This module provides some relations to print data to the standard
 ** output.  This is used for error messages, and for debugging the
 ** semantic description.
 **)
 
(** relation: print_component_ref
 **
 ** Print a `ComponentRef'.
 **)

relation print_component_ref : ComponentRef => () =

  rule	print_component_ref2 (s,subs)
	----------------------------
	print_component_ref CREF_IDENT(s,subs)

  rule	print_component_ref2 (s,subs) &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref CREF_QUAL(s,subs,cr)
end

relation print_component_ref2 =

  rule	print s
	-------
	print_component_ref2 (s,[])

  rule	print s &
	print "[" & print_list(l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_component_ref2 (s,l)

end

(** relation: print_subscript *)

relation print_subscript: Subscript => () =

	rule	print ":"
		---------
		print_subscript(NOSUB)

	rule	print_exp(e1)
		----------
		print_subscript(SUB1(e1))

	rule	print_exp(e1) & print ":" & print_exp(e2)
		-------------
		print_subscript(SUB2(e1,e2))

	rule	print_exp(e1) & print ":" &
		print_exp(e2) & print ":" & print_exp(e3)
		----------------------------------------------
		print_subscript(SUB3(e1,e2,e3))

end

(** relation: print_exp
 **
 ** This relation prints a complete expression.
 **)

relation print_exp: Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp(ICONST(x))

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp(RCONST(x))

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp(SCONST(s))

  rule	print "FALSE"
	-------------
	print_exp(BCONST(false))

  rule	print "TRUE"
	-------------
	print_exp(BCONST(true))

  rule	print_component_ref(c)
	---------------------
	print_exp(CREF(c))

  rule	binop_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	---------------------------------------------------------------
	print_exp(BINARY(e1, op, e2))

  rule	unaryop_symbol(op) => sym &
	print sym & print_exp e
	----------------------------
	print_exp(UNARY(op, e))

  rule	lbinop_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	----------------------------------------------------------------
	print_exp(LBINARY(e1, op, e2))

  rule	lunaryop_symbol(op) => sym & print sym & print_exp e
	---------------------------------------------------
	print_exp(LUNARY(op, e))

  rule	relop_symbol(op) => sym & print_exp(e1) & print sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(RELATION(e1, op, e2))

  rule	print "IF " & print_exp(c) &
	print " THEN " & print_exp(t) &
	print " ELSE " & print_exp(f)
	----------------------------
	print_exp(IFEXP(c,t,f))

  rule	Absyn.path_string(fcn) => fs &
	print fs & print "(" & print_list(args,print_exp,",") & print ")"
	---------------------------------------------
	print_exp(CALL(fcn, args))

  rule	print "[" &
	print_list(es, print_exp, ",") &
	print "]"
	---------
	print_exp ARRAY(es)
	
  rule	print "[MATRIX]"
	---------
	print_exp MATRIX(es)

  rule	print "(" & print_exp start & print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp RANGE(start,NONE,stop)

  rule	print "(" & print_exp start & print ":" & print_exp step &
 	print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp RANGE(start,SOME(step),stop)

  rule	print "real(" & print_exp e & print ")"
	---------------------------------------
	print_exp CAST_TO_REAL(e)
	
  rule	print "#UNKNOWN EXPRESSION#"
        ----------------------------------
	print_exp (_)
end

(** relation: *_symbol
 **
 ** Make a string describing different operators.
 **)

relation binop_symbol : BinOp => string =
  axiom	binop_symbol(INT_ADD) => " + "
  axiom	binop_symbol(REAL_ADD) => " + "
  axiom	binop_symbol(STRING_ADD) => " + "
  axiom	binop_symbol(INT_SUB) => " - "
  axiom	binop_symbol(REAL_SUB) => " - "
  axiom	binop_symbol(INT_MUL) => "*"
  axiom	binop_symbol(REAL_MUL) => "*"
  axiom	binop_symbol(REAL_DIV) => "/"
  axiom	binop_symbol(REAL_POW) => "^"
end

relation unaryop_symbol : UnaryOp => string =
  axiom	unaryop_symbol(UMINUS) => "-"
  axiom	unaryop_symbol(UPLUS) => "+"
end

relation lbinop_symbol : LBinOp => string =
  axiom	lbinop_symbol(AND) => " AND "
  axiom	lbinop_symbol(OR) => " OR "
end

relation lunaryop_symbol : LUnaryOp => string =
  axiom	lunaryop_symbol(NOT) => "NOT "
end

relation relop_symbol : RelOp => string =
  axiom	relop_symbol(INT_LESS)       => " < "
  axiom	relop_symbol(REAL_LESS)      => " < "
  axiom	relop_symbol(INT_LESSEQ)     => " <= "
  axiom	relop_symbol(REAL_LESSEQ)    => " <= "
  axiom	relop_symbol(INT_GREATER)    => " > "
  axiom	relop_symbol(REAL_GREATER)   => " > "
  axiom	relop_symbol(INT_GREATEREQ)  => " >= "
  axiom	relop_symbol(REAL_GREATEREQ) => " >= "
  axiom	relop_symbol(INT_EQUAL)      => " = "
  axiom	relop_symbol(REAL_EQUAL)     => " = "
  axiom	relop_symbol(STRING_EQUAL)   => " = "
  axiom	relop_symbol(BOOL_EQUAL)     => " = "
  axiom	relop_symbol(INT_NEQUAL)     => " <> "
  axiom	relop_symbol(REAL_NEQUAL)    => " <> "
  axiom	relop_symbol(STRING_NEQUAL)  => " <> "
  axiom	relop_symbol(BOOL_NEQUAL)    => " <> "
end

(** - Utility relations
 **
 ** These are utility relations used in some of the other
 ** relations. *)

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep & print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end
