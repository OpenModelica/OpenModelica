(*
    Copyright (c) PELAB, Dept. Computer and Information Science, Linkoping University,
    Sweden, in the following denoted PELAB/LIU.

   
    This file is part of OpenModelica, in the following denoted OSM.


    The OSM License, Version 1.1, March 4, 2005.


    1 Preface

    The aim of this license is to lay down the conditions enabling you to use, 
    modify and circulate OSM. However, PELAB/LIU remain the authors of 
    OSM and so retain property rights and the use of all ancillary rights.

    2 Definitions

    OSM is defined as all successive versions of the OSM software and their 
    documentation that have been developed by PELAB/LIU and including
    accepted contributions from other contributors according to this license.

    OSM DERIVED SOFTWARE is defined as all or part of OSM that you have 
    modified and/or translated and/or adapted.


    3 Dual License

    OSM is made available under the OSM licensing scheme, which is a dual
    licensing scheme with two options, a) and b):

    a) OSM OPEN SOURCE LICENSE:

    If you wish to write Open Source software you can use the Open Source version 
    of OSM, released under the OSM license which include GPL as its open source 
    licensing option. If you use the OSM Open Source version you must release your 
    Application using OSM including this Application's source code under the GPL as well.

    This OSM license text, and Copyright (c) PELAB/Linkoping University, must
    be present in your copy of OSM and in OSM DERIVED SOFTWARE.

    You should have received a copy of the GPL - GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.


    b) OSM COMMERCIAL LICENSE

    If you are using OSM commercially - that is, for commercial usage or
    for creating proprietary software for sale or use in a commercial setting
    - you must purchase a commercial license of OSM from PELAB/LIU, which allows
    you to use OSM without releasing your Application under the GPL.

    Comment: Payments for OSM are intended for OSM development and
    integration of accepted contributions into OSM.


    4 Priority

    If there is any conflict between this OSM License text and the GNU GPL
    license, this text has priority.


    5 Contributions 

    PELAB/LIU reserves the right to accept or turn down source code contributions
    to OSM.


    6 Limitation of the warranty

    Except when mentioned otherwise in writing, OSM is supplied as is, with 
    no explicit or implicit warranty, including warranties of commercialization or 
    adaptation. You assume all risks concerning the quality or the effects of
    OSM and its use. If OSM is defective, you will bear the costs of 
    all required services, corrections or repairs.


    7 Consent

    When you access and use OSM, you are presumed to be aware of and to 
    have accepted all the rights and obligations of the present OSM license.
    This includes accepting that your open source code contributions to OSM, 
    if accepted into OSM by PELAB/IDA, follow the OSM licensing rules including
    copyright and ownership by PELAB/IDA.


    8 Binding effect

    This license has the binding value of a contract.
    You are not responsible for respect of the license by a third party.


    9 Applicable law

    The present license and its effects are subject to Swedish law and  
    Swedish courts.


    10 Contact information

    See http://www.ida.liu.se/~pelab/modelica/OpenModelica.html
*)
(**
 ** file:	 Lookup.rml
 ** module:      Lookup
 ** description: Scoping rules
 **
 ** RCS: $Id$
 **
 **)

(* This module is responsible for the lookup mechanism in Modelica.
 ** It is responsible for looking up classes, variables, etc. in the
 ** environment 'Env' by following the lookup rules.
 ** The most important relations are:
 ** lookup_class - to find a class 
 ** lookup_type - to find types (e.g. functions, types, etc.)
 ** lookup_var - to find a variable in the instance hierarchy.
 **)

module Lookup:

  with "ClassInf.rml"
  with "Types.rml"
  with "Absyn.rml"
  with "Exp.rml"
  with "Env.rml"
  with "SCode.rml"

  relation lookup_type       : (Env.Env, Absyn.Path, bool (* msg flag *)) 
	  => (Types.Type,Env.Env)
  relation lookup_class      : (Env.Env, Absyn.Path,bool) 
	  => (SCode.Class, Env.Env)
  relation complete_path     : (Env.Env, Absyn.Path) => Absyn.Path
  relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) 
  relation lookup_var        : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding)
  relation lookup_var_local  : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding)
  relation lookup_ident_local : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool)
  relation lookup_ident : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool)
  relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list)
  relation is_in_builtin_env: Absyn.Path => bool

end

with "Parser.rml"
with "Debug.rml"
with "Dump.rml"
with "Inst.rml"
with "Mod.rml"
with "Prefix.rml"
with "Print.rml"
with "Builtin.rml"
with "Util.rml"
with "ModUtil.rml"
with "Static.rml"

(**
 ** - Lookup relations
 **
 ** These relations look up class and variable names in the environment.
 ** The names are supplied as a path, and if the path is qualified, a
 ** variable named as the first part of the path is searched for, and the
 ** name is looked for in it.
 **)

(** relation: lookup_type
 ** 
 ** This relation finds a specified type in the environment. 
 ** If it finds a function instead, this will be implicitly instantiated 
 ** and lookup will start over. 
 **
 ** Arg1: Env.Env is the environment which to perform the lookup in
 ** Arg2: Absyn.Path is the type to look for
 **)
relation lookup_type: (Env.Env,Absyn.Path,bool (* msg flag *)) 
	  => (Types.Type, Env.Env) =

	(* Lookup of simple names *)
  rule	
	(*Debug.fprint ("lotype","lookup_type(") &
	Debug.fcall ("lotype",Env.print_env, env) &
	Debug.fprint ("lotype",", ") & 
	Debug.fcall ("lotype",Dump.print_path,path) &
	Debug.fprint ("lottype",")\n") &*)
	lookup_type_in_env(env,path) => (t,env') 
	(*Debug.fprint ("lotype", "found type:") &
	Debug.fcall ("lotype",Types.print_type, t) *)
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env')

  rule	 (* If we didn't find the type, but found a class definition 
	  * that is a function with the same name then we implicitly instantiate that
	  function, and try again. *)
	lookup_class(env, path, false) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)


  rule	 (* If we didn't find the type, but found a class definition 
	  * that is an external function with the same name then we implicitly 
	  * instantiate that function, and try again. *)
	lookup_class(env, path, msg) 
	  => (c as SCode.CLASS(id, _, encflag, SCode.R_EXT_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',path) => (t,env3) 
	--------------------------------------
	lookup_type(env, path as Absyn.IDENT(_),msg) => (t,env3)

	(* Lookup of qualified name *)
  rule	lookup_class(env, Absyn.IDENT(pack), false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false (*true*)) 
	  => (_,env'',_,cistate1,_) &
        not ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has to do additional check for encapsulated classes, see rule below *)
	lookup_type_in_class(env'', c, path, true) => (t, env''') 
	--------------------------------------
	lookup_type(env, Absyn.QUALIFIED(pack, path),msg) => (t, env''')


  rule	lookup_class(env, Absyn.IDENT(pack), msg) 
	  => (c as SCode.CLASS(id, _, encflag, restr, _), env') &	
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false(*true*))
	  => (_, env'', _, cistate1, _) &
        ClassInf.valid(cistate1, SCode.R_PACKAGE)  &  
	(* Has NOT to do additional check for encapsulated classes, see rule above *)
	lookup_type_in_class(env'', c, path, false) => (c', env''') 
	--------------------------------------
	lookup_type(env, p as Absyn.QUALIFIED(pack, path), msg) => (c', env''')

  rule	Absyn.path_string path => s1 & 
	Util.string_append_list(["# Error, type ", s1, " not found.\n"]) => s2 &
	Print.print_error_buf s2
	---------------------
	lookup_type(_,path,true) => fail
end

(** relation: lookup_class
 ** 
 ** Tries to find a specified class in an environment
 ** 
 ** Arg1: The enviroment where to look
 ** Arg2: The path for the class
 ** Arg3: A Bool to control the output of error-messages. If it is true
 **       then it outputs a error message if the class is not found.
 **)
relation lookup_class: (Env.Env, Absyn.Path, bool) => (SCode.Class, Env.Env) =
  
  rule	(*print "searching for " & print name & print "\n" & *)
	(*Env.print_env env & Print.get_string => str & print str & *)
	lookup_class_in_env(env,path,msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_), env') 
(*	  ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env',Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env'',cistate1) *)
	(*& print "found " & print name & print "\n" *)
	--------------------------------------
	lookup_class(env, path as Absyn.IDENT(name),msgflag) 
	  => (c, env')


  rule	(* If we search for A1.A2....An.x while in scope A1.A2...An
	 , just search for x. Must do like this to ensure finite recursion *)
	Env.get_env_path(env) => SOME(ep) &
	Absyn.strip_last(p) => packp & 
	ModUtil.path_equal(ep,packp) => true &
	Absyn.path_last_ident(p) => id &
	lookup_class(env,Absyn.IDENT(id),msgflag) => (c,env')
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(_,_),msgflag) 
	  => (c, env')

  rule	lookup_class(env,Absyn.IDENT(pack),msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env') &
	Env.open_scope(env',encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env'',cistate1) &
        not ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has to do additional check for encapsulated classes, see rule below *)

	lookup_class(env'',path,msgflag) => (c',env''')
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path),msgflag) 
	  => (c', env''')

  rule	lookup_class(env,Absyn.IDENT(pack),msgflag) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_),env1) &
	Env.open_scope(env1,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &

	Inst.partial_inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[]) 
	  => (env4,cistate1) &
        ClassInf.valid(cistate1,SCode.R_PACKAGE)  &  (* Has NOT to do additional check for encapsulated classes, see rule above *)
	  lookup_class(env4,path,msgflag) => (c',env5)
	--------------------------------------
	lookup_class(env, p as Absyn.QUALIFIED(pack,path), msgflag) 
	  => (c', env5)

  rule	(*print "-lookup_class failed\n" &
 	Absyn.path_string path => s & 
	Env.print_env env &
	Print.get_string => str & print "Env: " & print str & print "\n" 
	Print.print_buf "#Error, class " & Print.print_buf s & 
	Print.print_buf " not found.\n" &
	Debug.fprint("failtrace", "- lookup_class failed\n  - looked for ") &
 	Debug.fprint("failtrace",  s) &
	Debug.fprint("failtrace", "\n env:") &
	Debug.fcall("failtrace", Env.print_env, env) &
	Debug.fprint("failtrace", "\n") *)
	--------------
	lookup_class(env,path,true)=> fail 
end

(** relation: lookup_qualified_imported_class_in_env
 ** 
 ** This relation looks up imported names on the qualified form: import A.B;
 **)
relation lookup_qualified_imported_class_in_env:(Env.Env, Env.Env,
						 Absyn.Path) 
	  => (SCode.Class, Env.Env) =
	
  rule	lookup_qualified_imported_class_in_frame(items,totenv,name) 
	  => (c,env') 
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,items,_)::fs),totenv,Absyn.IDENT(name)) 
	  => (c, env')

  rule	lookup_qualified_imported_class_in_frame(imps, totenv, pack) 
	  => (c as SCode.CLASS(id,_,encflag,restr,_), env') &
       	Env.open_scope(env',encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state,
			   c, false, []) 
	  => (env4,_) &  
	  lookup_class(env4,path,false) => (c',env'')
	-----------------------------------------------------------------
	lookup_qualified_imported_class_in_env(env as (Env.FRAME(sid,_,_,imps,_)::fs),totenv, Absyn.QUALIFIED(pack,path)) 
	  => (c', env'')

  rule	lookup_qualified_imported_class_in_env(fs, env, id) => (c, env')
	---------------------------------------------
	lookup_qualified_imported_class_in_env(f::fs, env, id) => (c, env')
end

(** relation: lookup_qualified_imported_class_in_frame
 ** 
 ** 
 **
 **)
relation lookup_qualified_imported_class_in_frame: ( Env.Item list,Env.Env,
    SCode.Ident)
	    => (SCode.Class, Env.Env) =

  rule	(* For imported paths A, not possible to assert sub-path package*)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],Absyn.IDENT(id),true) => (c, env') 
	------------------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(Absyn.IDENT(id)))::fs,env,ident)
	    => (c, env')
	    
  rule	(* For imported path A.B.C, assert A.B is package*)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr],strippath,true) =>  (c2, _) &
	assert_package(c2) 
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => (c, env')

  rule	(* If not package, error *)
	Absyn.path_last_ident(path) => id &
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2,_) &
	not assert_package(c2) &
	Print.print_error_buf "# Error, " & 
	Absyn.path_string strippath => str & 
	Print.print_error_buf str &
	Print.print_error_buf " is not a package\n"  
	----------------------------------
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.QUAL_IMPORT(path))::fs,env,ident)
	    => fail

  rule	(* Named imports*)
	id = ident &
	Env.top_frame(env) => fr & 
(*	Print.print_buf "NAMED IMPORT, top frame:" & 
	Env.print_env [fr] &*)
	lookup_class([fr], path, true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	assert_package(c2) 
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => (c, env')

  rule	(* Assert package for Named imports *)
	id = ident &
	Env.top_frame(env) => fr & 
	lookup_class([fr],path,true) => (c, env') &
	Absyn.strip_last(path) => strippath &
	lookup_class([fr], strippath, true) =>  (c2, _) &
	not assert_package(c2) &
	Print.print_error_buf "# Error, " & 
	Absyn.path_string strippath => str & 
	Print.print_error_buf str &
	Print.print_error_buf " is not a package\n"  
	---------------------------------- 
	lookup_qualified_imported_class_in_frame(Env.IMPORT(Absyn.NAMED_IMPORT(id,path))::fs,env,ident)
	    => fail
	    
  rule	lookup_qualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env')
	-----------------------
	lookup_qualified_imported_class_in_frame(_::fs,env,ident) 
	  => (c, env')
end


(** relation: more_lookup_unqualified_imported_class_in_frame
 ** 
 ** Helper relation for lookup_unqualified_imported_class_in_frame
 ** 
 **)
relation more_lookup_unqualified_imported_class_in_frame: (Env.Item list, Env.Env, SCode.Ident)
	    => bool =

  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, []) 
	  => (env'',_) &
	lookup_class(env'',Absyn.IDENT(ident),false) => (_,_)
	-----------------------------------------------------
	more_lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident) => true

  rule	more_lookup_unqualified_imported_class_in_frame(fs, env, ident) => res
	----------------------------------------------------------------------
	more_lookup_unqualified_imported_class_in_frame(_::fs, env, ident) => res

  axiom  more_lookup_unqualified_imported_class_in_frame([],_,_) => false
end

(** relation: lookup_unqualified_imported_class_in_frame
 ** 
 ** Finds a class from an unqualified import locally in a frame
 **
 **)
relation lookup_unqualified_imported_class_in_frame: (Env.Item list, Env.Env, SCode.Ident)
	    => (SCode.Class, Env.Env, bool (*unique*) ) =
	    
  rule	Env.top_frame(env) => fr & 
	lookup_class([fr],path,false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.partial_inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, []) 
	  => (env'',cistate1) &
	lookup_class(env'',Absyn.IDENT(ident),false) => (c',env''')  & 
	more_lookup_unqualified_imported_class_in_frame(fs, env, ident) => more &
	bool_not more => unique
	-------------------------------------------
	lookup_unqualified_imported_class_in_frame(Env.IMPORT(Absyn.UNQUAL_IMPORT(path))::fs,env,ident)
	    => (c', env''', unique)


  rule	lookup_unqualified_imported_class_in_frame(fs, env, ident) 
	  => (c, env', unique)
	-----------------------
	lookup_unqualified_imported_class_in_frame(_::fs, env, ident) 
	  => (c, env', unique)
end

(** relation: lookup_record_constructor_class
 ** 
 ** 
 ** 
 **)
relation lookup_record_constructor_class: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_env(env,path) => (c, env') 
	--------------------------------------
	lookup_record_constructor_class(env, path) => (c, env')

end

(** relation: complete_path
 **
 ** This relation takes a type name and an env and looks up the class.
 ** Then it determines the full path for the type, such that it can be looked up
 ** from any environment.
 **)
relation complete_path: (Env.Env, Absyn.Path) => Absyn.Path =

  rule	(* Class found on top level. Nothing to complete. *)
	lookup_class(env,path,true) => (_,Env.FRAME(NONE,_,_,_,_)::_)
	----------------------------------------------
	complete_path(env,path) => path

  rule	lookup_class(env, path, true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,path) => path' 
(*	& Print.print_buf "completed to " &
	Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)
	------------------
	complete_path(env,path as Absyn.IDENT(_)) => path'

  rule	lookup_class(env, Absyn.IDENT(pack), true) 
	  => (_,Env.FRAME(NONE,_,_,_,_)::_)
	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path 

  rule	lookup_class(env,(*Absyn.IDENT(pack)*)path,true) 
	  => (SCode.CLASS(id,_,_,_,_),env') &	
	Env.get_env_path(env') => SOME(path1) &
	Absyn.join_paths(path1,Absyn.IDENT(id)) => path' 
	
(*	& Print.print_buf "Qualified completed to " 
	& Absyn.path_string path' => s1 & Print.print_buf s1 &
	Print.print_buf " class = " & Print.print_buf id & 
	Print.print_buf "\n" &
	Print.print_buf "\nenv =" &
	Env.print_env env'  *)

	------------------
	complete_path(env,path as Absyn.QUALIFIED(pack,_)) => path'

  rule	(*Debug.fprint("failtrace", "-complete_path failed\n env=") &
	Debug.fcall("failtrace", Env.print_env, env) & 
	Debug.fprint("failtrace", "\ntype: ")  &
	Absyn.path_string path => str & 
	Debug.fprint("failtrace", str )&
	Debug.fprint("failtrace", "\n" )*)
	--------------------
	complete_path(env,path) => fail

end

(* LS: when looking up qualified component reference, lookup_var only
checks variables when looking for the prefix, i.e. for Constants.PI
where Constants is a package and is implicitly instantiated, PI is not
found since Constants is not a variable (it is a type and/or class).

1) One option is to make it a variable and put it in the global frame.
2) Another option is to add a lookup rule that also looks in types.

Now implicitly instantiated packages exists both as a class and as a
type (see implicit_instantiation in Inst.rml). Is this correct?

lookup_var is modified to implement 2. Is this correct?

old lookup_var is changed to lookup_var_internal and a new lookup_var
is written, that first tests the old lookup_var, and if not found
looks in the types
 *)

(** relation: lookup_var
 **
 ** This relation tries to finds a variable in the environment
 ** 
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)
relation lookup_var : (Env.Env, Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

	  (* try the old lookup_var *)
  rule	lookup_var_internal (env,cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr, ty, binding)

	(* then look in classes (implicitly instantiated packages)
	 *)
  rule	lookup_var_in_packages (env, cref) => (attr, ty, binding)
	------------------------------------------------------
	lookup_var (env, cref) => (attr,ty,binding)

  rule	(*Debug.fprint("failtrace",  "- lookup_var failed\n")*)
	--------------------
	lookup_var(_,_) => fail
end

(** relation: lookup_var_internal
 **
 ** 
 ** 
 ** 
 ** 
 **)
relation lookup_var_internal : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(ht,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_internal (Env.FRAME(sid,ht,_,imps,_)::fs,ref) => (attr,ty,binding)

  rule	lookup_var_internal (fs,ref) => (attr,ty,binding)
	---------------------------------------
	lookup_var_internal (_::fs,ref) => (attr,ty,binding)

end

(** relation: lookup_var_in_packages
 **
 ** This relation is called when a lookup of a variable with qualified names does 
 ** not have the first element as a component, e.g. A.B.C is looked up where A is 
 ** not a component. This implies that A is a class, and this class should be 
 ** temporary instantiated, and the lookup should 
 ** be performed within that class.
 **
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)
relation lookup_var_in_packages : (Env.Env, Exp.ComponentRef) 
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	(* Special case for looking up enumerations *)
	lookup_class(env, Absyn.IDENT(id1),false) 
	  => (c as SCode.CLASS(n,_,encflag,r as SCode.R_ENUMERATION,_), env2) &
	Env.open_scope(env2,encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env3,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],
			    false,false) 
	  => (_,env5,_,_,types) &
	lookup_var_in_packages(env5,id2) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id1, [], id2 as Exp.CREF_IDENT(_,_))) => (attr,ty,bind)

  rule	lookup_class(env, Absyn.IDENT(id),false) => (c as SCode.CLASS(n,_,encflag,r,_), env2) &
	Env.open_scope(env2,encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in (env3,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],
			    true,false(*true*)) 
	  => (_,env5,_,_,types) &
	lookup_var_in_packages(env5,cref) => (attr,ty,bind) 
	--------------------------------------------------
	lookup_var_in_packages (env, Exp.CREF_QUAL(id, [], cref)) => (attr,ty,bind)

  rule	lookup_var_local(env,cr) => (attr,ty,bind)
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => (attr,ty,bind)

  rule	not lookup_var_local(env,cr) => (attr,ty,bind) 
	(* &Debug.fprint("failtrace",  "- lookup_var_in_packages failed\n" )*)
	--------------------------------------------------
	lookup_var_in_packages (env, cr as Exp.CREF_IDENT(id, sb)) => fail

  rule	(*Debug.fprint("failtrace",  "lookup_var_in_packages failed\n exp:" ) &
	Debug.fcall("failtrace", Exp.print_component_ref, cr) &
	Debug.fprint("failtrace", "\n")*)
	--------------------------------------------------
	lookup_var_in_packages (env, cr) => fail

end


(** relation: lookup_var_local
 ** 
 ** This relation is very similar to `lookup_var', but it only looks
 ** in the topmost environment frame, which means that it only finds
 ** names defined in the local scope.
 **
 ** ----EXCEPTION---: When the topmost scope is the scope of a for loop, the lookup
 ** continues on the next scope. This to allow variables in the local scope to 
 ** also be found even if inside a for scope.
 **
 ** Arg1: The environment to search in
 ** Arg2: The variable to search for
 **)
relation lookup_var_local : (Env.Env,Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var_f(ht,ref) => (attr,ty,binding)
	--------------------------------------------
	lookup_var_local(Env.FRAME(sid,ht,_,_,_)::fs,ref) => (attr,ty,binding)

  rule	(* Exception, when in for loop scope allow search of next scope *)
	lookup_var_local(env,ref) => (attr,ty,binding)
	------------------------------
	lookup_var_local(Env.FRAME(SOME("$for loop scope$"),_,_,_,_)::env,ref) 
	  => (attr,ty,binding)
end


(** relation: lookup_ident_local
 **
 **
 **
 **)
relation lookup_ident_local : (Env.Env, SCode.Ident) => (Types.Var,(SCode.Element*Types.Mod) option,bool) =

  rule  lookup_var2(ht, id) => (fv,c,i)
	----------------------------
	lookup_ident_local(Env.FRAME(sid,ht,_,_,_)::_, id) => (fv,c,i)

end

(** relation: lookup_ident
 **
 ** Same as lookup_ident_local, except check all frames 
 **
 **)
relation lookup_ident : (Env.Env, SCode.Ident) 
	  => (Types.Var,(SCode.Element*Types.Mod) option,bool) =

  rule	lookup_var2(ht, id) => (fv,c,i) 
	----------------------------
	lookup_ident(Env.FRAME(sid,ht,_,_,_)::_, id) => (fv,c,i)

  rule	lookup_ident(rest,id) => (fv,c,i)
	---------------------------------
	lookup_ident(_::rest,id) => (fv,c,i)

  rule	Print.print_error_buf "# Error lookup_ident: " &
	Print.print_error_buf id &
	Print.print_error_buf " failed\n"
	--------------
	lookup_ident(env,id) => fail	
end


(**  Function lookup *)

(** relation: lookup_functions_in_env
 **
 ** Returns a list of types that the function has. 
 **
 **)
relation lookup_functions_in_env: (Env.Env,Absyn.Path) => (Types.Type list) =

        (* PR. Do nothing, could have used a axiom. But this led to an
	 bug unexpected error before. I do not take my chances at the moment.
	 *)
  axiom	lookup_functions_in_env([],id) => []

  rule	(* Check for builtin operators*)
	Static.elab_builtin_handler id => _ &
	Env.top_frame(env) => Env.FRAME(sid,ht,httypes,_,_) &
	lookup_functions_in_frame(ht,httypes,env,id) => reslist
	----------------------------------
	lookup_functions_in_env(env, iid as Absyn.IDENT(id)) => reslist


  rule	lookup_functions_in_frame(ht,httypes,env,id) => c1 &
	lookup_functions_in_env(fs,iid) => c2 &
	list_append (c1,c2) => reslist
	---------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,ht,httypes,_,_)::fs), iid as Absyn.IDENT(id)) => reslist

  rule	(* For qualified function names, e.g. Modelica.Math.sin *)
	lookup_class(env, Absyn.IDENT(pack), false) 
	  => (c as SCode.CLASS(id, _, encflag, restr,_), env') &
	Env.open_scope(env', encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	(* Instantiate implicit (last argument = true) *)
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,env'',_,cistate1,_) &
	  lookup_functions_in_env(env'',path) => reslist
	-------------------------------
	lookup_functions_in_env(env as (Env.FRAME(sid,ht,httypes,_,_)::fs), iid as Absyn.QUALIFIED(pack,path)) 
	  => reslist

  rule	(* If we find class that is function. *)
	lookup_class([f], path, false) 
	  => (c as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),env') &
	Inst.implicit_function_type_instantiation(env',c) 
	  => (env as (Env.FRAME(sid,ht,httypes,_,_)::_)) &
	lookup_functions_in_frame(ht,httypes,env,id) => res
	---------------------------
	lookup_functions_in_env(f::_,path as Absyn.IDENT(id)) => res
	  
	(* Did not match. Continue*)
  rule	lookup_functions_in_env(fs,id) => c
	---------------------
	lookup_functions_in_env(f::fs,id) => c

  rule	Debug.fprintln("failtrace", "lookup_functions_in_env failed")
	-------------------------------------------------------------
	lookup_functions_in_env (_,_) => fail
end


(** - Internal relations *)

(** Type lookup *)

(** relation: lookup_type_in_env
 ** 
 **
 **)
relation lookup_type_in_env: (Env.Env,Absyn.Path) => (Types.Type,Env.Env) =

  rule	lookup_type_in_frame(ht,httypes,env,id) => (c,env')
	---------------------
	lookup_type_in_env(env as (Env.FRAME(sid,ht,httypes,_,_)::fs),Absyn.IDENT(id)) => (c,env')

  rule	lookup_type_in_env(fs,id) => (c,env')
	-------------------------------------
	lookup_type_in_env(f::fs,id) => (c,f::env')

end

(** relation: lookup_type_in_frame
 ** 
 ** 
 ** 
 **)
relation lookup_type_in_frame: (Env.BinTree, (* Classes and vars*)
				Env.BinTree, (* types *)
				 Env.Env,
				 SCode.Ident)
	  => (Types.Type, Env.Env) =

  rule	Env.tree_get(httypes,id,Env.myhash) => Env.TYPE(t::_)
	---------------------------------------------------------
	lookup_type_in_frame(ht,httypes,env, id) => (t,env)

  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_error_buf "# Error while looking up type " &
	Print.print_error_buf id & Print.print_error_buf ": found a component\n"
	------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => fail

  rule	(* Each time a record constructor function is looked up, this rule will create the function.*)
	(* An improvement (perhaps needing lot of code) is to add the function to the environment, which is *)
	(* returned from this relation.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),_) &
	Inst.make_fully_qualified(env,Absyn.IDENT(n)) => fpath &
	build_record_constructor_varlst (cdef,env) => varlst &
	Types.make_function_type(fpath,varlst) => ftype 
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) 
	    => (ftype,env)

  rule	(* If we found class that is function *)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_instantiation(cenv,Types.NOMOD,Prefix.NOPRE,[],cdef,[],false) 
	  => (env',_) &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')

  rule	(* If we found class that is external function *)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef) => env' &
	lookup_type_in_env(env',Absyn.IDENT(id)) => (ty,env'')
	----------------------------------------
	lookup_type_in_frame(ht,httypes,env,id) => (ty,env'')
end
(**)


(** relation: lookup_functions_in_frame
 ** 
 ** This actually only looks up the function name and find all
 ** corresponding types that have this function name.
 ** 
 **)
relation lookup_functions_in_frame: (Env.BinTree, (*Classes and vars*)
				     Env.BinTree, (*Types *)
				     Env.Env,
				     SCode.Ident)
	  => Types.Type list =

  rule	Env.tree_get(httypes, id, Env.myhash) => Env.TYPE(tps)
	---------------------------------------------------------
	lookup_functions_in_frame(ht,httypes, env, id) => tps

  rule	Env.tree_get(ht, id, Env.myhash) => Env.VAR(_,_,_) &
	Print.print_error_buf "# Error while looking up type " &
	Print.print_error_buf id & Print.print_error_buf ": found a component\n"
	------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => fail

  rule	Env.tree_get(ht, id, Env.myhash) => Env.CLASS(cdef as SCode.CLASS(n,_,_,SCode.R_RECORD,_),cenv) &
	build_record_constructor_varlst (cdef,env) => varlst &
	Inst.make_fully_qualified(cenv,Absyn.IDENT(n)) => fpath &
	Types.make_function_type(fpath,varlst) => ftype
	----------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => [ftype]

  rule	(* If found class that is function.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef)  => env' &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps

  rule	(* If found class that is external function.*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_EXT_FUNCTION,_),cenv) &
	Inst.implicit_function_type_instantiation(cenv,cdef) => env' &
	lookup_functions_in_env(env',Absyn.IDENT(id)) => tps
	----------------------------------------------------
	lookup_functions_in_frame(ht,httypes,env,id) => tps
end

(** relation: lookup_recconst_in_env
 ** 
 ** 
 ** 
 **)
relation lookup_recconst_in_env: (Env.Env,Absyn.Path) => (SCode.Class, Env.Env) =

  rule	lookup_recconst_in_frame(ht,env,id) => (c, _) 
	---------------------
	lookup_recconst_in_env(env as (Env.FRAME(sid,ht,_,imps,_)::fs),Absyn.IDENT(id))
	    => (c,env)

  rule	lookup_recconst_in_env(fs,id) => (c, _)
	---------------------
	lookup_recconst_in_env(f::fs,id) => (c, f::fs)
end

(** relation: lookup_recconst_in_frame
 **
 ** This relation lookups the implicit record constructor class (function) of a record in a frame
 **)
relation lookup_recconst_in_frame: (Env.BinTree, Env.Env, SCode.Ident)
	  => (SCode.Class, Env.Env) =

	  
	  
  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_error_buf "# Error while looking up record constructor class " &
	Print.print_error_buf id & Print.print_error_buf ": found a component\n"
	------------------------------------
	lookup_recconst_in_frame(ht,env,id) => fail

  rule	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(cdef as SCode.CLASS(_,_,_,SCode.R_RECORD,_),_) &
	build_record_constructor_class (cdef,env) => cdef 
	----------------------------------------
	lookup_recconst_in_frame(ht,env,id) => (cdef,env)
end

(** relation: build_record_constructor_class
 ** 
 ** 
 ** 
 **)
relation build_record_constructor_class :(SCode.Class, Env.Env) => SCode.Class =

  rule	build_record_constructor_elts(elts,env) => funcelts &
	build_record_constructor_result_elt(elts,id,env) => reselt
	---------------------------------------------------
	build_record_constructor_class (cl as SCode.CLASS(id,_,_,restr,SCode.PARTS(elts,_,_,_,_,_)),env) 
	    => SCode.CLASS(id,false,false,SCode.R_FUNCTION,SCode.PARTS(reselt::funcelts,[],[],[],[],NONE))
end
	
(** relation: build_record_constructor_elts
 ** 
 ** 
 ** 
 **)
relation build_record_constructor_elts: (SCode.Element list, Env.Env) => SCode.Element list =
  rule	build_record_constructor_elts (rest,env) => res
	-------------------------------------------
	build_record_constructor_elts((comp as SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,dir),tp,mod,bc,comment))::rest,env)
	    => SCode.COMPONENT(id,fl,repl,prot,SCode.ATTR(d,f,ac,var,Absyn.INPUT),tp,mod,bc,comment)::res
  axiom	build_record_constructor_elts([],_) => []
end
	
(** relation: build_record_constructor_result_elt
 ** 
 ** This relation builds the result element of a record constructor function, 
 ** i.e. the returned variable
 ** 
 **)
relation build_record_constructor_result_elt: (SCode.Element list, SCode.Ident, Env.Env) => SCode.Element =
	
  rule	build_record_constructor_result_mod(elts) => submodlst
	-------------------------------------------------
	build_record_constructor_result_elt (elts,id,env) 
	    => SCode.COMPONENT("result",false,false,false,SCode.ATTR([],false,SCode.RW,SCode.VAR,Absyn.OUTPUT),Absyn.IDENT(id),SCode.MOD(false,submodlst,NONE),NONE,NONE)
end
	
(** relation: build_record_constructor_result_mod
 **
 ** This relation builds up the modification list for the output element of a record constructor.
 ** Example: 
 **   record foo
 **      Real x;
 **      String y;
 **      end foo;
 **  => modifier list become 'result.x=x, result.y=y'
 **)
relation build_record_constructor_result_mod: (SCode.Element list) => SCode.SubMod list =
	
  rule	build_record_constructor_result_mod(rest) => restmod
	---------------------------------------------------
	build_record_constructor_result_mod (SCode.COMPONENT(id,_,_,_,_,_,_,_,_)::rest) 
	    => SCode.NAMEMOD("result",SCode.MOD(false,[SCode.NAMEMOD(id,SCode.MOD(false,[],SOME(Absyn.CREF(Absyn.CREF_IDENT(id,[])))))],NONE))::restmod

  axiom	build_record_constructor_result_mod([]) => []
end

(** relation: build_record_constructor_varlst
 **
 ** This relation takes a class  (`SCode.Class') which holds a definition of a record
 ** and builds a list of variables of the record used for constructing a record constructor function.
 **)
relation build_record_constructor_varlst : (SCode.Class,Env.Env) => Types.Var list =

  rule	build_varlst_from_elts(elts,env) => inputvarlst &
	Inst.inst_class(env, Types.NOMOD, Prefix.NOPRE, [], cl, [], true (* FIXME: impl*),Inst.TOP_CALL) 
	  => (_,_,_,ty,_) 
	--------------------------------------
	build_record_constructor_varlst (cl as SCode.CLASS(_,_,_,_,SCode.PARTS(elts,_,_,_,_,_)),env) 
	(* Add the return type of the record constructor *)
	    => Types.VAR("result",Types.ATTR(false,SCode.RW,SCode.VAR,Absyn.OUTPUT),false,ty,Types.UNBOUND)::inputvarlst

  rule	Debug.fprint("failtrace","build_record_constructor_varlst failed\n")
	-----------------------
	build_record_constructor_varlst(_,_) => fail
end

(** relation: build_varlst_from_elts
 ** 
 ** 
 ** 
 **)
relation build_varlst_from_elts: (SCode.Element list,Env.Env ) => Types.Var list =

  rule	build_varlst_from_elts(rest,env) => vars &
  (*P.A Here we need to do a lookup of the type. Therefore we need the env passed along from lookup_xxxx function. *)
	Inst.inst_record_constructor_elt(env,comp, true (* FIXME: impl*) ) => var
	-------------------------------------
	build_varlst_from_elts ((comp as SCode.COMPONENT(_,_,_,_ ,_,_,_,_,_))::rest,env) 
	    => var::vars

  axiom	build_varlst_from_elts ([],_) => []

  rule	(*Debug.fprint("failtrace", "- build_varlst_from_elts failed!\n")*)
	----------------------------------------------
	build_varlst_from_elts(_,_) => fail
end

(**  Class lookup *)

relation is_in_builtin_env: Absyn.Path => bool =

  rule	Builtin.initial_env() => i_env &
	lookup_functions_in_env(i_env, path) => []
	-----------------------------------------------
	is_in_builtin_env(path) => false

  rule	Builtin.initial_env() => i_env &
	lookup_functions_in_env(i_env, path) => _
	------------------------------------------------
	is_in_builtin_env(path) => true

  rule	Debug.fprintln("failtrace", "is_in_builtin_env failed")
	-------------------------------------------------------
	is_in_builtin_env(path) => fail
end

(** relation: lookup_class_in_env
 ** 
 ** 
 ** 
 **)
relation lookup_class_in_env: (Env.Env,Absyn.Path,bool) => (SCode.Class, Env.Env) =

  rule	(*print "looking in env for " & print id &*)
	lookup_class_in_frame(frame,frame::fs,id,msg) => (c,env')  
	---------------------
	lookup_class_in_env(env as (frame::fs),Absyn.IDENT(id),msg)
	    => (c,env')
	
  rule	(* Special case if looking up the class that -is- encapsulated. That must be allowed. *)
        id = sid &
	lookup_class_in_env(fs,aid,true) => (c,env)
	---------------------
	lookup_class_in_env(env as Env.FRAME(SOME(sid),_,_,_,true)::fs, aid as Absyn.IDENT(id),_) 
	  => (c,env)

  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_) &
        Print.print_error_buf "# Class " &
        Print.print_error_buf id       &
        Print.print_error_buf " not found and the lookup reached an encapsulated class\n"
	---------------------
	lookup_class_in_env(env as Env.FRAME(sid,_,_,_,true)::fs, aid as Absyn.IDENT(id),true) => fail

  rule	Builtin.initial_env() => i_env & 
        not lookup_class_in_env(  i_env, aid,false)=>(_,_)
	---------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),false) => fail

 rule	Builtin.initial_env() => i_env & 
        lookup_class_in_env(  i_env, aid,msgflag)=> (c,env')
       	---------------------------------------------------
	lookup_class_in_env(Env.FRAME(sid,_,_,_,true)::fs, 
			    aid as Absyn.IDENT(id),msgflag ) => (c,env')

  rule	lookup_class_in_env(fs,id,msgflag) => (c, env')
	-----------------------------------------------
	lookup_class_in_env((f as Env.FRAME(sid,_,_,_,false))::fs,
			    id ,msgflag ) 
	  => (c, env')
end


(** relation: lookup_type_in_class
 ** This relation looks up an type inside a class (The outer class can be a package)
 ** Environment is passed along in case it needs to be modified...
 ** bool determines whether we restrict lookup for encapsulated class (true).
 **  
 **)
relation lookup_type_in_class: (Env.Env, SCode.Class, Absyn.Path, bool) => (Types.Type, Env.Env) =

  rule	lookup_type_in_env(env, classname(*, true*)) => (tp, env')
        (* encapsulated does not matter, _ *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (tp, env')

  rule	(* If not found, look for classdef that is function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_FUNCTION, _), env') &
	Inst.implicit_function_type_instantiation(env', c)  => env'' &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* If not found, look for classdef that is external function and instantiate. *)
	lookup_class_in_env(env, classname, false) 
	  => (c as SCode.CLASS(_, _, _, SCode.R_EXT_FUNCTION, _), env') &
	Inst.implicit_function_type_instantiation(env', c) => env'' &
	lookup_type_in_env(env'',classname) => (t,env3) 
        (* true means here encapsulated *)
      	----------------------------------------------------
	lookup_type_in_class (env, cdef,classname as Absyn.IDENT(_),_) => (t, env3)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as true,restr,_) ,env) &
       	Env.open_scope(env, encflag,SOME(id)) => env2 &
	ClassInf.start(restr, id) => ci_state &
	Inst.inst_class_in(env2, Types.NOMOD, Prefix.NOPRE, [], ci_state, c, false, [], true,false) 
	  => (_,env4,_,_,_) &
  	lookup_type_in_class (env4, c, p1, false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => (t, env5)

  rule	(* Restrict lookup to encapsulated elements only *)
	lookup_class_in_env (env, Absyn.IDENT(c1),false) => (c as SCode.CLASS(id,_,encflag as false,restr,_) ,env) &
        Print.print_error_buf("# Error: attempt to search qualified class name went into non-encapsulated class (when it is still qualified)\n")
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),true) => fail

  rule	(* Lookup not restricted to encapsulated elts. only *)
	lookup_class_in_env (env, Absyn.IDENT(c1), false) => (c as SCode.CLASS(id,_,encflag,restr,_) ,env1) &
       	Env.open_scope(env1,encflag,SOME(id)) => env2 &
	ClassInf.start(restr,id) => ci_state &
(*	Print.print_buf "instanitating class " &
	Print.print_buf id &
	Print.print_buf " in envpath:\n" &
	Env.print_env_path(env2') &
	Print.print_buf "\n" &*)

	Inst.inst_class_in(env2,Types.NOMOD,Prefix.NOPRE,[],ci_state,c,false,[],true,false) 
	  => (_,env4,_,_,_) &
  	lookup_type_in_class (env4,c,p1,false) => (t, env5)
	-------------------------------------------
	lookup_type_in_class (env, cdef, Absyn.QUALIFIED(c1,p1),false) => (t, env5)

  rule	(*Debug.fprint("failtrace",cname) &
	Debug.fprint("failtrace", "\n  - looked for: ") & Absyn.path_string path => s & 
	Debug.fprint("failtrace", s) & 
	Debug.fprint("failtrace", "\n")*)
	-------------------------------
	lookup_type_in_class(_, SCode.CLASS(cname,_,_,_,_), path, _) => fail
end
	
(** relation: lookup_class_in_parts
 ** This relation takes an `Env' and an `Ident' and an `Element' list, and returns the `Class' 
 ** having the name specified by the `Ident'. If not found, the relation fails.
 **)
relation lookup_class_in_parts: (Env.Env, SCode.Ident, SCode.Element list) => (SCode.Class, Env.Env) =
	
  rule	name = name2
	------------
	lookup_class_in_parts(env, name,  SCode.CLASSDEF(name2,_,_,c,_)::xs) => (c, env)


  rule	lookup_class_in_parts(env, name, xs) => (c,env)
	-----------------------------------------------
	lookup_class_in_parts(env, name, _::xs) => (c,env)

  axiom	lookup_class_in_parts(env, name, []) => fail
end

(** relation: lookup_class_in_frame
 ** 
 ** 
 ** 
 **)
relation lookup_class_in_frame: (Env.Frame,Env.Env,
				 SCode.Ident,bool)
	  => (SCode.Class, Env.Env) =


  rule	(*print "looking for class " & print id & print " in frame\n" &*)
	Env.tree_get(ht,id,Env.myhash) => Env.CLASS(c,env) 
	(*& print "found " & print id & print "\n" *)
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,ht,_,_,_),totenv,id,_) 
	  => (c, totenv)


  rule	Env.tree_get(ht,id,Env.myhash) => Env.VAR(_,_,_) &
	Print.print_error_buf "# Error while looking up class " &
	Print.print_error_buf id & Print.print_error_buf ": found a component\n"
	------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,ht,_,_,_),_,id,true) => fail

  rule	lookup_qualified_imported_class_in_frame(items,totenv,name) 
	  => (c,env') 
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_),totenv, name,_) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_frame(items, totenv, name) 
	  => (c, env', true (*unique*) )
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_),totenv, name,_) 
	  => (c, env')

  rule	lookup_unqualified_imported_class_in_frame(items, totenv, name) 
	  => (c, env', false (*unique*) ) &
	Print.print_error_buf "# Error, class found in several unqualified import statements\n"  
	---------------------------------------------------------
	lookup_class_in_frame(Env.FRAME(sid,_,_,items,_),totenv, name,_) 
	  => fail
end

(** relation: lookup_var2
 ** 
 ** 
 ** 
 **)
relation lookup_var2 : (Env.BinTree, SCode.Ident)
	  => (Types.Var, (SCode.Element*Types.Mod) option, bool) =

  rule	Env.tree_get(ht, id, Env.myhash) => Env.VAR(fv,c,i)
	--------------------------------------------
	lookup_var2(ht,id) => (fv,c,i)
end

(** relation: check_subscripts
 **
 ** This relation checks a list of subscripts agains type, and removes
 ** dimensions from the type according to the subscripting.
 **)
relation check_subscripts : (Types.Type, Exp.Subscript list)
	  => Types.Type =

  axiom check_subscripts(t, []) => t

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(dim,t),p),
			 Exp.WHOLEDIM::ys)
	  => ((Types.T_ARRAY(dim,t'),p))

  rule	check_subscripts(t, ys) => t' & 
	list_length(se) => dim
	(* FIXME: Check range *)
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),p),
			 Exp.SLICE(Exp.ARRAY(_,_,se))::ys)
	  => ((Types.T_ARRAY(Types.DIM(SOME(dim)),t'),p))

  rule	int_gt(ind, 0) => true  &  int_le(ind, sz) => true &
	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(Exp.ICONST(ind))::ys) => t'

	(* HJ: Subscrits needn't be constant. No range-checking can
	       be done *)

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.INDEX(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.WHOLEDIM::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(SOME(sz)),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	check_subscripts(t, ys) => t'
	------------------------------
	check_subscripts((Types.T_ARRAY(Types.DIM(NONE),t),_),
			 Exp.SLICE(_)::ys) => t'

  rule	(*Debug.fprint("failtrace", "- check_subscripts failed ( ") &
	Debug.fcall("failtrace", Types.print_type, t) & 
	Debug.fprint("failtrace", ")\n")*)
	-----------------------------------
	check_subscripts(t,s) => fail

end

(** relation: lookup_in_var
 ** 
 ** 
 ** 
 **)
relation lookup_in_var: (Types.Type, Exp.ComponentRef)
	  => (Types.Attributes,Types.Type,Types.Binding) =

	(* Public components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),false,ty',binding)) &
	check_subscripts(ty', ss) => ty''
	--------------------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(fl,acc,vt,di),ty'',binding)

	(* Protected components *)
  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,_,true,_,_)) &
	Print.print_error_buf "# Error, referencing protected elements not allowed.\n" 
	------------------------------
	lookup_in_var(ty, Exp.CREF_IDENT(id,ss))
	  => fail

  rule  Types.lookup_component(ty, id)
	  => (Types.VAR(_,Types.ATTR(fl,acc,vt,di),_,ty',_)) &
	check_subscripts(ty', ss) => ty'' &
	lookup_in_var(ty'', vs) => (attr, ty''',binding)
	--------------------------------------
	lookup_in_var(ty, Exp.CREF_QUAL(id,ss,vs)) => (attr,ty''',binding)

  rule	(*Debug.fprint("failtrace", "- lookup_in_var failed\n")*)
	--------------------------------
	lookup_in_var(_,_) => fail

end	

(** relation: lookup_var_f
 **
 ** This relation looks in a frame to find a declared variable.  If
 ** the name being looked up is qualified, the first part of the name
 ** is looked up, and `lookup_in_var' is used to for further lookup in
 ** the result of that lookup.
 **)
relation lookup_var_f : (Env.BinTree,
			 Exp.ComponentRef)
	  => (Types.Attributes, Types.Type, Types.Binding) =

  rule	lookup_var2(ht, id)
	  => (Types.VAR(n, Types.ATTR(f,acc,vt,di),_,ty,bind),_,_) &
	check_subscripts(ty,ss) => ty'
	----------------------------------
	lookup_var_f(ht,Exp.CREF_IDENT(id,ss))
	  => (Types.ATTR(f,acc,vt,di),ty',bind)

  rule	lookup_var2(ht, id) 
	  => (Types.VAR(n,Types.ATTR(f,acc,vt,di),_,ty,_),_,_) &
	check_subscripts(ty,ss) => ty' & (* FIXME: Check for non-array *)
	lookup_in_var(ty', ids) => (attr,ty'',binding)
	----------------------------------
	lookup_var_f(ht,Exp.CREF_QUAL(id,ss,ids)) => (attr,ty'',binding)

end

(** relation: assert_package
 ** 
 ** This relation checks that a class definition is a package.  This
 ** breaks the everything-can-be-generalized-to-class principle, since
 ** it requires that the keyword `package' is used in the package file.
 **)
relation assert_package : SCode.Class => () =

	(* Break the generalize-to-class rule *)
  axiom	assert_package SCode.CLASS(_,_,_,SCode.R_PACKAGE,_)

end

(** relation: lookup_class_in_package
 ** 
 ** This relation searches a class definition for a named class
 ** definition.
 **
 ** The class is returned together with an empty environment, which
 ** might cause problems.  This should be solved using implicit
 ** instantiation, but that is future work.
 **)
relation lookup_class_in_package : (SCode.Class, Absyn.Path)
	  => (SCode.Class, Env.Env) =

  rule	lookup_class_in_elements (els, path) => c
	-----------------------------------------
	lookup_class_in_package (SCode.CLASS(_,_,_,_,
					       SCode.PARTS(els,_,_,_,_,_)),
				 path) => (c, Env.empty_env)

end

(** relation: lookup_class_in_elements
 ** 
 ** This relation helps `lookup_class_in_package' to do its thing.
 **)
relation lookup_class_in_elements : (SCode.Element list, Absyn.Path)
	  => SCode.Class =

  rule	n1 = n2
        -------
        lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c,_)::_,
				  Absyn.IDENT(n2))
	  => c
				   
  rule	n1 = n2 &
	assert_package c &
	lookup_class_in_package (c, path) => (c', env)
	----------------------------
	lookup_class_in_elements (SCode.CLASSDEF(n1,_,_,c,_)::_,
				  Absyn.QUALIFIED(n2, path))
	  => c'

  rule	lookup_class_in_elements (es, path) => c
	-------------------------------------
	lookup_class_in_elements (_::es, path) => c

end	


