\documentclass[a4paper]{report}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{verbatim}
%\usepackage{boxedminipage}

\author{David Kågedal}
\title{Blahonga Blahonga}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\filename}[1]{\texttt{#1}}
\newcommand{\firstref}[1]{\textit{#1}}
\newcommand{\note}[1]{[\textsc{#1}]}

\newtheorem{Def}{Definition}[chapter]

\newcommand{\codefont}{\normalfont\ttfamily\fontsize{8}{9}\selectfont}

\makeatletter

% See the verbatim package
\def\boxedverbatim{\begingroup%
  \parskip=0pt\topsep=0pt\partopsep=0pt%
  \def\verbatim@processline{%
    \setbox1=\hbox{\the\verbatim@line}%
    \setbox0=\vbox{{\box0}{\box1}}%
    }%
  \def\verbatim@font{%
    \codefont
    \let\do\do@noligs
    \verbatim@nolig@list}
   \verbatim}
\def\endboxedverbatim{\endverbatim\framebox[\linewidth][l]{\box0}%
  \endgroup\vspace{2ex}}

\makeatother
  

\begin{document}

\titlepage
\maketitle{}
\endtitlepage

\begin{abstract}
\label{abs}

Formal descriptions of the syntax of programming languages has long
been accepted as a natural way of describing the syntacical form of
the language. Today everobody expects a BNF-like grammar for a new
language. But that is not the case when it comes to describing the
semantics of languages. Formalisms for the specifications of semantics
hase been avaiable for many years, but are not often used by others
than researchers.

One advantage of using a formal description of the semantics is of
course that the specification becomes more strict and unambiguous. But
there is also the possibility of using the semantic specification to
generate a language translator, or compiler, in an automatic way.

This paper describes a formal semantics for Modelica, an
equation-based language used for modeling. The notation used enables
it to be passed to a compiler generator that generates a Modelica
translator.

\end{abstract}

\tableofcontents

\chapter{Background}
\label{cha:bg}


\section{Introduction}
\label{sec:intro}


\section{Overview of formal semantics}
\label{sec:semoverview}


\section{RML}
\label{sec:rml}


\section{Modelica}
\label{sec:modelicabg}


\chapter{Goals, motivation and stuff}
\label{cha:goals}


\chapter{Development environment}
\label{cha:devenv}


\section{Compiling RML}
\label{sec:rmlc}


\section{Parser}
\label{sec:parser}

The Modelica parser was generated by the PCCTS\note{ref} compiler
generation system.  It generates a parser in C, which is linked with
the RML object files.

\section{The report}
\label{sec:report}

This report was writting using the \LaTeX{} text formatting system.

To produce the annotated semantics in chapter \ref{cha:formsem} a
small program was written to convert the RML source files with
comments to \LaTeX{} source with the comments converted to ordinary
text. This program is a quick'n'dirty Pike\note{ref} hack, and is
provided in appendix\note{ref}.

\chapter{Informal semantics}
\label{cha:semantics}


\section{Introduction}
\label{sec:semintro}

The Modelica specification contains an informal description of the
intended semantics of the language. Unfortunately, the description
lacks considerably in detail, which means that this work needs to
formalize things not covered by the specification. In some cases, the
semantics was easy to guess, but in other cases, discussions with the
authors and reading of design meeting minutes was the needed to find
out what was really intended.

This chapter complements the Modelica specification by providing a
more comprehensive informal description of the language semantics.  It
is indended to help the understanding of the formal semantics in
chapter \ref{cha:formsem}.

\section{Types}
\label{sec:types}


\subsection{Overview of the type system in Modelica}
\label{sec:typeoverview}

The type system is based on \firstref{classes}. A class is the basic
unit of modelling. It is used to modularize the model description and
to \ldots{}


\subsection{Type equality and subtypes}
\label{sec:typeq}


\subsection{Class restrictions}
\label{sec:clrestr}

A class can either be declared with the \code{class} keyword, or with
one of its restricted forms, listed below.  The restricted forms are
used to indicate the intended use of the class, and to impose certain
restrictions on what the class definition can contain, and how it can
be used.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{record} & No equations are allowed in the definition or in any
      of its components. A \code{record} instance may not be used in
      connections. \\
      \hline
      \code{type}   & May only be declared as derived from one of the
      predefined types, or as a matrix of a \code{type}. \\
      \hline
      \code{connector} & No equations are allowed in the definition or
      in any of its components. \\
      \hline
      \code{model} & A \code{model} instance may not be used in
      connections. \\
      \hline
      \code{block} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. \\
      \hline
      \code{package} & May only contain declarations of classes and
      constants. \\
      \hline
      \code{function} & Each public component must be declared with one
      of the modifiers \code{input} or \code{output}. No equations are
      allowed and only one algorithm secion is allowed. \\
      \hline
    \end{tabular}
    \caption{Class restrictions}
    \label{tab:clrestr}
  \end{center}
\end{table}

A valid program can always be transformed into another valid program
by replacing all occurences of the restricted class keywords with the
keyword \code{class}.  For a class declared with the keyword
\code{class} to be able to be used as if it was declared with a
restricted keyword \note{Fel men nästan rätt}, it has to adher to the
restrictions for that keyword.

As an example, this means that if a variable is used in a connection,
its type has to be either a class declared with \code{connector}, or a
class declared with \code{class} which contains no equations.  Another
implication is that an invalid program can be transformed into a valid
program by replacing all restricted keywords with \code{class}, e.g.
when incorrectly trying to use a \code{record} in a connection,
because the keyword \code{record} has the same restrictions as the
\code{connector} keyword, except that \code{record} is explicitly not
allowed in connections, but \code{class} is, as long as it fulfills
the restrictions.

\subsection{Arrays and matrices}
\label{sec:arrays}


\section{Connections}
\label{sec:connections}

Connections between objects are introduced by the \code{connect}
construct in the equation part of a class declaration.  The
\code{connect} construct takes two references to connectors, each of
which is either an element of the same class as the \code{connect}
construct or an element of one of its components. The connectors are
connected to produce equation according to the rules below.  Each
connector reference has either the syntactic form \code{c}, where
\code{c} is a connector instance in the class containing the
\code{connect} construct, or \code{m.c}, where \code{m} is the name of
a component or an array of components \note{Stämmer det?} of the class
containing the \code{connect} construct, and \code{c} is the name of a
connector variable in the component \code{m}.


\subsection{Connection sets}
\label{sec:connectsets}

To create equations from the \code{connect} constructs, the connected
variables are collected in \firstref{connection sets}.

\begin{Def}[Connection sets]
  A connection set is a set $C$ of variables connected by means of
  \code{connect} constructs. A connection set contains either flow or
  non-flow variables, but never both.
\end{Def}

\begin{Def}[Inner and outer connectors]
  In an object $M$, each connector element of that class is called an
  \emph{outer connector} with respect to $M$. Each connector element of
  elements of $M$ is called an \emph{inner connector} with respect to
  $M$.
\end{Def}

When a \code{connect(a,b)} construct is encountered while
instantiating a class \code{C}, the component names \code{a} and
\code{b} are checked to be of the same type (see section
\ref{sec:typeq}). Then \code{a} and \code{b} are decomposed into their
public primitive components. Each subcomponent of \code{a} forms a
connection set with its corresponding subcomponent of \code{b}.

If several \code{connect(a,b)} constructs are encountered during
instantiation of a class, the resulting connection sets are merged to
a collection of connection sets $C$ so that if a component $x$ is
in two different connection sets $S_1$ and $S_2$, they the union $S_1
\cup S_2$ is a subset of one of the sets in $C$. Each component is in
exactly one of the sets in $C$.

\subsection{Equations}
\label{sec:coneq}

Each connection set is used to generate one or more equations. In the
case of variables declared with the \code{flow} type modifier, the
equation generated is a sum-to-zero equation, as in equation
\ref{eq:flow}.  The coefficient $d_v$ is $1$ if the component $v$ was
added to the connection set from an inner connector, and $-1$ if it
was added from an outer connector. \note{Clear?}

\begin{equation}
  \label{eq:flow}
  \sum_{v \in C} d_v v = 0
\end{equation}

In the case of non-flow components a number of simple equations is
generated. If the connection set contains $n$ components $c_1 \ldots
c_n$, equations to the effect of $c_1=c_2=\cdots=c_n$ are generated,
as in \ref{eqn:nonflow}.

\begin{eqnarray}
  \label{eqn:nonflow}
  c_1     & =      & c_2 \notag\\
  c_2     & =      & c_3 \notag\\
          & \vdots & \notag\\
  c_{n-1} & =      & c_n  
\end{eqnarray}


\subsection{Example}
\label{sec:csetex}

This section contains a short example of the use of connections in
Modelica, and shows the corresponding connection sets and generated
equations.  The Modelica source is shown in figure \ref{fig:csetex1}
and declares a connector \code{C} and models \code{A} and \code{M}.
The model that is instantiated at the top level is \code{M}, as it is
the last model in the file.

\begin{figure}[htbp]
\begin{boxedverbatim}
connector C
  Real x;
  flow Real y;
end C;

model A
  C con1, con2;
end A;

model M
  C con;
  A a1, a2;
  Real y;
equation
  connect(con,a1.con1);
  connect(a1.con1,a2.con1);
  connect(a1.con2,a2.con2);
  y = con.y;
end M;
\end{boxedverbatim}
  \caption{\code{connect} example}
  \label{fig:csetex1}
\end{figure}

Connection sets are generated at two different levels in this example.
While instantiating the model \code{M}, the three \code{connect}
statements creates the connection sets described in figure
\ref{fig:csetex2}, and the two instances of the model \code{A}
(components \code{a1} and \code{a2} in model \code{M}) create the
connectsion sets in figure \ref{fig:csetex3}.  Each component in the
sets are marked with a label indicating whether they were added from
an inner or an outer connector.

\newcommand{\Outer}[1]{\code{#1}^{\text{outer}}}
\newcommand{\inner}[1]{\code{#1}^{\text{inner}}}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \Outer{con.x}, \inner{a1.con1.x}, \inner{a2.con1.x} \right\}$
    $\left\{ \inner{con.y}, \inner{a1.con1.y}, \inner{a2.con1.y} \right\}$
    $\left\{ \inner{a1.con2.x}, \inner{a2.con2.x} \right\}$
    $\left\{ \inner{a1.con2.y}, \inner{a2.con2.y} \right\}$
    \caption{Connection sets from \code{M}}
    \label{fig:csetex2}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
    $\left\{ \Outer{a1.con1.x}, \Outer{a1.con2.x} \right\}$
    $\left\{ \Outer{a1.con1.y}, \Outer{a1.con2.y} \right\}$
    $\left\{ \Outer{a2.con1.x}, \Outer{a2.con2.x} \right\}$
    $\left\{ \Outer{a2.con1.y}, \Outer{a2.con2.y} \right\}$
    \caption{Connection sets from \code{A}}
    \label{fig:csetex3}
  \end{center}
\end{figure}

The equations generated from these connection sets, together with the
last equation in the model \code{M} is shown in figure
\ref{fig:csetex4}.

\begin{figure}[htbp]
  \begin{center}
    \begin{eqnarray*}
      \code{con.x}     &=& \code{a1.con1.x} \\
      \code{a1.con1.x} &=& \code{a2.con1.x} \\
      -\code{con.y} + \code{a1.con1.y} + \code{a2.con1.y} &=& 0 \\
      \code{a1.con2.x} &=& \code{a2.con2.x} \\
      \code{a1.con2.y} + \code{a2.con2.y} &=& 0 \\
      \code{a1.con1.x} &=& \code{a1.con2.x} \\
      -\code{a1.con1.y} - \code{a1.con2.x} &=& 0 \\
      \code{a2.con1.x} &=& \code{a2.con2.x} \\
      -\code{a2.con1.y} - \code{a2.con2.x} &=& 0
    \end{eqnarray*}
    \caption{Equations}
    \label{fig:csetex4}
  \end{center}
\end{figure}

\chapter{Design}
\label{cha:design}


\section{Abstract syntax}
\label{sec:absyndesign}

The abstract syntax is closely modelled after the syntactic
structure.  Unfortunately, this form is not very convenient for
the semantic description of the instantiation process.  To address
this problem, a second internal form, called the \firstref{exploded
  form} \note{Hmmm} is introduced. The main difference are that each
variable declaration is a separate entity with type, attributes and
modifications, instead of declaring several variables at once. Another
difference is that the class parts (\code{public}, \code{protected},
\code{equation} and \code{algorithm}) are sorted and collected in a
more structured fashion.


\section{Class restriction inference}
\label{sec:classinf}

To be able to determine if a class definition or a variable can be
used under certain circumstances it is necessary to check whether it
adhers the restrictions currently imposed on it. If the class is
declared with one of the restricted keywords listen in table
\ref{tab:clrestr}, it is immediately known, but when the class is
declared using the \code{class} keyword, the definition has to be
scanned to see what restrictions it breaks.

This is done for each variable as it is instantiated, using the state
machine in the file \filename{classinf.rml} (see section
\ref{src:classinf}).  While instantiating a class the current state is
kept in a variable of type \code{ClassInf.State}.  It is initialized
with the keyword used to declare the class using the relation
\code{ClassInf.start}.  If the keyword was one of the restricted
forms, the state will be initialized to a state that directly
corresponds to that form, and it will never change to another state.
If the keyword was \code{class}, the state is initialized to
\code{ClassInf.UNKNOWN}.

Transitions in the state machine are triggered by events signalled
during instantiation indicating that some piece of information has been
encountered which affects the class restriction. The defined events
are listed in table \ref{tab:classinfevents}.

\begin{table}[htbp]
  \begin{center}
    \begin{tabular}{lp{8cm}}
      \hline
      \code{FOUND\_EQUATION} & The class is now known to contain at
      least one equation. \\
      \hline
      \note{Fyll på} & \ldots
    \end{tabular}
    \caption{Class restriction inference events}
    \label{tab:classinfevents}
  \end{center}
\end{table}

\note{Skriv nåt om \code{ClassInf.valid}}

\chapter{Annotated formal semantics}
\label{cha:formsem}

This chapter contains the complete formal semantics of Modelica.  This
includes the RML source files, but the comments in the files are
converted to more readable text.

\section{Overview}


\input{exp.tex}
\input{classinf.tex}
\input{dae.tex}
\input{types.tex}
\input{absyn.tex}
\input{explode.tex}
\input{dump.tex}
\input{prefix.tex}
\input{mod.tex}
\input{env.tex}
\input{lookup.tex}
\input{builtin.tex}
\input{connect.tex}
\input{staticexp.tex}
\input{inst.tex}
\input{main.tex}


\chapter{rmldoc \note{appendix}}

{\codefont\verbatiminput{../tools/rmldoc}}

\begin{thebibliography}{99}
\bibitem[FOO]{Hm}
\end{thebibliography}

\end{document}
