(*
   modelica.rml - Definition of Modelica AST in RML
*)

module Modelica:

with "exp.rml"
with "dae.rml"
with "class.rml"
with "dump.rml"

type Ident = string

(* Dump routines for debugging of AST *)

relation dump_class: Class => ()
relation dump_element: Element => ()
relation DumpElementList: Element list => ()

(* Test cases *)

relation test1: () => ()
relation test2: () => ()
relation test3: () => ()

end (* module Modelica *)

(*************************************************************************)
(* Instantiation of model *)
(* Note: we should have a separate relation for checking the model *)

val ErrorInstance = DAE.VAR("Error", DAE.LOCAL)

(* Create a variable on DAE form, handling an optional initial value *)

relation make_variable: (Ident, Element list) => DAE.DAEcomp =

	axiom	make_variable(id, []) => DAE.VAR(id, DAE.LOCAL)

	axiom	make_variable(id, [EQUATION(ex)]) => DAE.VARVAL(id, DAE.LOCAL, ex)

	rule	print "Error: modifier too complicated for " &
		print id & print "\n"
		-----------------------------------------------
		make_variable(id, _) => DAE.VAR(id, DAE.LOCAL)

end

relation inst_element: (Env, Env, Element) => DAE.DAEcomp =

	(* Instantiate an equation *)

	axiom	inst_element(g, m, EQUATION(e)) => DAE.EQUATION(e)

	(* Instantiate base class *)

	rule	lookup(g, id) => base &
		inst_def(g, [DEF("?", elist)], base) => inst
		-------------------------------------
		inst_element(g, m, BASE(DEF(id, elist))) => DAE.COMP(id, inst)

	rule	not lookup(g, id) => base &
		print "Error: base class " & print id & print " not found\n"
		-------------------------------------
		inst_element(g, m, BASE(DEF(id, elist))) => ErrorInstance

	(* Instantiate real variable - special case of component *)

	rule	make_variable(id, mod) => var
		-----------------------------------------------
		inst_element(g, m, COMP(DEF("Real", _), DEF(id, mod))) => var

	(* Instantiate other components *)

	rule	lookup(g, typeid) => comp_type&
		list_append(comp_mod, type_mod) => mod &
		inst_def(g, [DEF("?", mod)], comp_type) => comp'
		-------------------------------------------------
		inst_element(g, m, COMP(DEF(typeid, type_mod),
			DEF(compid, comp_mod))) => DAE.COMP(compid, comp')

	rule	not lookup(g, typeid) => _ &
		print "Error: type specifier " & print typeid &
		print " for component " & print compid & print " not found\n"
		-------------------------------------------------
		inst_element(g, m, COMP(DEF(typeid, _),
			DEF(compid, _))) => ErrorInstance

	(* Nothing else has been implemented *)

	axiom	inst_element(g, m, x) => ErrorInstance
end

(* If there is a modifier correspongding to an element, use it
   instead of the element's modifier. *)

and (* relation *) inst_element2: (Env, Env, Element) => DAE.DAEcomp =

	rule	lookup_mod(m, id) => m' &
		inst_element(g, mod, COMP(ty, DEF(id, m'))) => e'
		----------------------------
		inst_element2(g, mod as [DEF(_, m)], e as COMP(ty, DEF(id, compmod))) => e'

	(* Note: should handle base classes and local classes the same way *)

	(* The default rule is to instantiate without changing the modifier *)

	rule	inst_element(g, m (* [] instead? *), e) => e'
		----------------------------
		inst_element2(g, m, e) => e'
end

(* Instantiate a list of elements by recursive traversal *)

and (* relation *) inst_element_list: (Env, Env, Element list) => DAE.DAEcomp list =
	
	axiom	inst_element_list(g, m, []) => []

	rule	inst_element2(g, m, e) => e' &
		inst_element_list(g, m, rest) => rest'
		---------------------------------
		inst_element_list(g, m, e::rest) => e'::rest'
end

(* Instatiation of definition and class just go thrgough its elements *)

and (* relation *) inst_def: (Env, Env, Definition) => DAE.DAEform =

	rule	inst_element_list (g, m, elist) => daelist
		---------------------------------
		inst_def(g, m, DEF(name, elist)) => DAE.DAE(daelist)
end

relation instantiate_class: (Env, Env, Class) => DAE.DAEform =
	
	rule	inst_def(g, m, def) => def'
		------------------------
		instantiate_class(g, m, CLASS(def)) => def'
end

(*************************************************************************)
(* Dump routines for debugging of AST *)

relation dump: Definition => () =
	rule	print id
		----------------------------------
		dump (DEF(id, []))

	rule	print id & print " (\n" &
		DumpElementList elist &
		print ")\n"
		----------------------------------
		dump (DEF(id, elist))
end

and (* relation *) dump_class: Class => () =

	rule	print "CLASS " &
		dump def &
		print "\n"
		----------------------------
		dump_class(CLASS(def)) => ()
end


and (* relation *) dump_element: Element => () =
	rule	print "INHERIT " & dump(b) & print "\n"
		--------------
		dump_element(BASE(b))

	rule	dump_class(d) & print "\n"
		--------------
		dump_element(CL(d))

	rule	dump(typ) & print ": " & dump(comp) & print "\n"
		--------------
		dump_element(COMP(typ, comp))

	rule	Dump.dump_exp(eq) & print "\n"
		--------------
		dump_element(EQUATION(eq))

end

and (* relation *) DumpElementList: Element list => () =
	axiom	DumpElementList([]) => ()

	rule	dump_element first &
		DumpElementList rest
		-----------------------
		DumpElementList(first :: rest) => ()
end

(*************************************************************************)
(* Test cases *)

val Real = CLASS(DEF("Real", []))

val m1 = CLASS(DEF("m1", []))

val m2 = CLASS(DEF("m2", [
	COMP(DEF("Real", []), DEF("x", [])),
	COMP(DEF("Real", []), DEF("y", [EQUATION(Exp.NUMBER(2.0))])),
	EQUATION(Exp.EQU(Exp.IDENT("x"), Exp.IDENT("y")))
	]))

val m3 = CLASS(DEF("m3", [
	COMP(DEF("m2", []), DEF("a", [])),
	COMP(DEF("m2", []), DEF("b", [EQUATION(
		Exp.EQU(Exp.IDENT("x"), Exp.NUMBER(3.0)))]))
	]))

val global_env = [Real, m1, m2, m3]

relation test1 =
	rule	print "\nTest case 1\n\n" &
		dump_class m1 &
		print "\n"
		------------------------
		test1 () => ()
end

relation test2 =
	rule	print "\nTest case 2\n\n" &
		dump_class m2
		------------------------
		test2
end

relation class_list_to_def_list =

	axiom	class_list_to_def_list [] => []

	rule	class_list_to_def_list tail => tail'
		--------------------------------------
		class_list_to_def_list CLASS(head)::tail => head::tail'
end

relation test3 =
	rule	print "\nTest case 3\n\n" &
		dump_class m3 &
		class_list_to_def_list global_env => global_env' &
		instantiate_class(global_env', [], m3) => m3' &
		DAE.dump m3'
		------------------------
		test3
end
