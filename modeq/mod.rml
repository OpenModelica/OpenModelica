(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:        mod.rml
 ** module:      Mod
 ** description: Modification handling
 **
 ** RCS: $Id$
 **
 ** Modifications are simply the same kind of modifications used in
 ** the `Absyn' module.
 **
 ** This type is very similar to `SCode.Mod'.  The main difference is
 ** that it uses `Exp.Exp' for the expressions.  Expressions stored
 ** here are prefixed and typechecked.
 **
 ** The datatype itself is moved to the Types module, in types.rml, to prevent
 ** circular dependencies.
 **
 **)

module Mod:

  with "absyn.rml"
  with "env.rml"
  with "exp.rml"
  with "prefix.rml"
  with "explode.rml"
  with "types.rml"


  type Ident = string


  relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Types.Mod
  relation unelab_mod : (Types.Mod) => SCode.Mod
  relation update_mod: (Env.Env, Prefix.Prefix, Types.Mod) => Types.Mod 
  relation elab_untyped_mod : (SCode.Mod,Env.Env, Prefix.Prefix) => Types.Mod

  relation lookup_comp_modification: (Types.Mod, Absyn.Ident) => Types.Mod
  relation lookup_idx_modification: (Types.Mod, int) => Types.Mod
  relation lookup_modification_p: (Types.Mod,Absyn.Path) => Types.Mod
  relation merge : (Types.Mod, Types.Mod,Env.Env, Prefix.Prefix) => Types.Mod
  relation mod_equation : Types.Mod => Types.EqMod option

  relation print_mod : Types.Mod => ()

end

with "dump.rml"
with "debug.rml"
with "print.rml"
with "inst.rml"
with "staticexp.rml"
with "values.rml"
with "util.rml"

(** relation: elab_mod
 **
 ** This relation elaborates on the expressions in a modification and
 ** turns them into global expressions.  This is done because the
 ** expressions in modifications must be elaborated on in the context
 ** they are provided in, and not the context they are used in.
 **)
 
relation elab_mod : (Env.Env, Prefix.Prefix, SCode.Mod) => Types.Mod =

  axiom	elab_mod (_,_,SCode.NOMOD) => Types.NOMOD

  rule	elab_submods (env,pre,subs) => subs'
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,subs,NONE))
	  => Types.MOD(final,subs',NONE)
	
  rule	elab_submods (env,pre,subs) => subs' &
	Static.elab_exp(env,e,false,NONE) => (e',prop,_) &
	(* Bug: will cause elaboration of parameters without value to fail,
	 But this can be ok, since a modifier is present, giving it a value 
	 from outer modifications.. *)
	Prefix.prefix_exp(env,e',pre) => e''
	------------------------------------
	elab_mod (env,pre,m as SCode.MOD(final,subs,SOME(e)))
	  => Types.MOD(final,subs',SOME(Types.TYPED(e'',prop)))

  rule	Inst.add_nomod(elist) => elist' 
	-------------------------------
	elab_mod (env, pre, m as SCode.REDECL(final, elist)) 
	  =>  Types.REDECL(final, elist')

  rule	(*Debug.fprint("failtrace", "#-- elab_mod failed\n")*)
	-------------------------------------------------
	elab_mod (_,pre,mod) => fail 
end



relation unelab_mod: Types.Mod => SCode.Mod =
	
  axiom	unelab_mod (Types.NOMOD) => SCode.NOMOD
	
  rule	unelab_submods (subs) => subs'
	------------------------------------
	unelab_mod (m as Types.MOD(final,subs,NONE))
	  =>  SCode.MOD(final,subs',NONE)
	  
  rule	unelab_submods (subs) => subs' 
	------------------------------------
	unelab_mod (m as Types.MOD(final,subs,SOME(Types.UNTYPED(e))))
	  => SCode.MOD(final,subs',SOME(e))
	  
  rule	unelab_submods (subs) => subs' &
	Exp.unelab_exp(e) => e'
	------------------------------------
	unelab_mod (m as Types.MOD(final,subs,SOME(Types.TYPED(e,p))))
	  => SCode.MOD(final,subs',SOME(e'))
	  
  rule	Util.list_map(elist,Util.tuple2_1) => elist'
	--------------------------------------------
	unelab_mod (m as Types.REDECL(final, elist)) 
	  =>  SCode.REDECL(final, elist')
	  
  rule	Print.print_buf "#-- elab_untyped_mod failed:\n" &
	print "- unelab_mod failed\n" 
	----------
	unelab_mod (mod) => fail
end


relation unelab_submods : ( Types.SubMod list)
	  => SCode.SubMod list =
	  
  axiom	unelab_submods ([]) => []
	
  rule	unelab_submod (x) => x' &
	unelab_submods (xs) => xs' &
	list_append(x',xs') => res	    
	-----------------------------
	unelab_submods (x::xs) => res
end

(** relation: unelab_submod
 **
 ** This relation unelaborates on a submodification.
 **)
		 
relation unelab_submod : (Types.SubMod) => SCode.SubMod list =
	
  rule	unelab_mod (m) => m'
	--------------------------
	unelab_submod (Types.NAMEMOD(i,m)) => [SCode.NAMEMOD(i,m')]
	
  rule	unelab_subscript(ss) => ss' &
	unelab_mod(m) => m'
	---------------------------
	unelab_submod (Types.IDXMOD(ss,m)) => [SCode.IDXMOD(ss',m')]
end

relation unelab_subscript: (int list) => SCode.Subscript list =
		    
   axiom unelab_subscript ([]) => []

   rule	unelab_subscript(is) => xs 
	--------------------------
	unelab_subscript (i::is) => Absyn.SUBSCRIPT(Absyn.INTEGER(i))::xs	    
end
(** relation: update_mod
 **
 ** This relation updates and untyped modification to a typed one, by looking
 ** up the type of the modifier in the environment and update it.
 **)
relation update_mod: (Env.Env,Prefix.Prefix, Types.Mod) => Types.Mod =

  axiom	update_mod(_,_,Types.NOMOD) => Types.NOMOD
  axiom	update_mod(_,_,m as Types.REDECL(_,_)) => m

  rule	update_submods (env,pre,subs) => subs' &
	Static.elab_exp(env,e,false,NONE) => (e',prop,_)  &
	Prefix.prefix_exp(env,e',pre) => e'' &
	Debug.fprint("updmod","Updated mod: ") &
	Debug.fcall("updmod",print_mod ,Types.MOD(f, subs', SOME(Types.TYPED(e'', prop)))) 
	-----------------
	update_mod(env, pre, m as Types.MOD(f, subs, SOME(Types.UNTYPED(e))))
	  => Types.MOD(f, subs', SOME(Types.TYPED(e'', prop)))

  rule	update_submods (env, pre, subs) => subs' 
	---------------------------------------
	update_mod(env, pre, Types.MOD(f, subs, SOME(Types.TYPED(e, p)))) 
	  => Types.MOD(f, subs', SOME(Types.TYPED(e, p)))

  rule	update_submods (env,pre,subs) => subs' 	
	-------------------------
	update_mod(env, pre, Types.MOD(f, subs, NONE)) => Types.MOD(f,subs',NONE)

  rule	Print.print_buf "- update_mod failed\n mod:" &
	print_mod m & Print.print_buf "\n" 
	--------------
	update_mod(env,pre,m) => fail
end

relation update_submods: (Env.Env, Prefix.Prefix, Types.SubMod list)
	=> Types.SubMod list =
  axiom	update_submods (_,_,[]) => []

  rule	update_submod (env,pre,x) => x' &
	update_submods (env,pre,xs) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	update_submods (env,pre,x::xs) => res
end


relation update_submod : (Env.Env, Prefix.Prefix, Types.SubMod) 
	  => Types.SubMod list =

  rule	update_mod (env,pre,m) => m'
	--------------------------
	update_submod (env,pre,Types.NAMEMOD(i,m)) => [Types.NAMEMOD(i,m')]

  rule	(*Static.elab_subscripts (env,ss) => (ss',true) &*)
	update_mod (env,pre,m) => m' &
	make_idxmods ([],m') => smods &
	Print.print_buf "#Error, not implemented updating of IDXMOD yet\n"
	(* Need to store untyped IDXMOD list in mods such that we can elab *)
	(* the index here *)
	---------------------------
	update_submod (env,pre,Types.IDXMOD(_,m)) => smods
end

(** relation elab_untyped_mod
 ** This relation is used to convert SCode.Mod into Mod, without 
 ** adding correct type information. Instead, a undefined type will be 
 ** given to the modification. This is used when modifications of e.g. 
 ** elements in base classes used. For instance,
 ** model test extends A(x=y); end test; // both x and y are defined in A
 ** The modifier x=y must be merged with outer modifiers, thus it needs 
 ** to be converted to Mod.
 ** Notice that the correct type information must be updated later on.
 **)

relation elab_untyped_mod: (SCode.Mod,Env.Env,Prefix.Prefix) => Types.Mod =

  axiom	elab_untyped_mod (SCode.NOMOD,_,_) => Types.NOMOD

  rule	elab_untyped_submods (subs,env,pre) => subs'
	------------------------------------
	elab_untyped_mod (m as SCode.MOD(final,subs,NONE),env,pre)
	  => Types.MOD(final,subs',NONE)
	
  rule	elab_untyped_submods (subs,env,pre) => subs' 
	------------------------------------
	elab_untyped_mod (m as SCode.MOD(final,subs,SOME(e)),env,pre)
	  => Types.MOD(final,subs',SOME(Types.UNTYPED(e)))

  rule	Inst.add_nomod(elist) => elist'
	-----------------
	elab_untyped_mod (m as SCode.REDECL(final, elist),env,pre) 
	  =>  Types.REDECL(final, elist')

  rule	Print.print_buf "#-- elab_untyped_mod failed:\n" &
	SCode.print_mod mod &
	Print.print_buf "\n"
	----------
	elab_untyped_mod (mod,env,pre) => fail
end

(** relation: elab_submods
 **
 ** This relation helps `elab_mod' by recusively elaborating on a list
 ** of submodifications.
 **)

relation elab_submods : (Env.Env, Prefix.Prefix, SCode.SubMod list)
	  => Types.SubMod list =

  axiom	elab_submods (_,_,[]) => []

  rule	elab_submod (env,pre,x) => x' &
	elab_submods (env,pre,xs) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	elab_submods (env,pre,x::xs) => res

end

(** relation: elab_submod
 **
 ** This relation elaborates on a submodification, turning an
 ** `SCode.SubMod' into one or more `Types.SubMod's.
 **)

relation elab_submod : (Env.Env, Prefix.Prefix, SCode.SubMod) => Types.SubMod list =

  rule	elab_mod (env,pre,m) => m'
	--------------------------
	elab_submod (env,pre,SCode.NAMEMOD(i,m)) => [Types.NAMEMOD(i,m')]

  rule	Static.elab_subscripts (env,ss) => (ss',true) &
	elab_mod (env,pre,m) => m' &
	make_idxmods (ss',m') => smods
	---------------------------
	elab_submod (env,pre,SCode.IDXMOD(ss,m)) => smods

end

(** relation: elab_untyped_submods
 **
 ** This relation helps `elab_untyped_mod' by recusively elaborating on a list
 ** of submodifications.
 **)

relation elab_untyped_submods : (SCode.SubMod list,Env.Env,Prefix.Prefix)
	  => Types.SubMod list =

  axiom	elab_untyped_submods ([],_,_) => []

  rule	elab_untyped_submod (x,env,pre) => x' &
	elab_untyped_submods (xs,env,pre) => xs' &
	insert_submods (x',xs',env,pre) => res
	-----------------------------
	elab_untyped_submods (x::xs,env,pre) => res
end

(** relation: elab_untyped_submod
 **
 ** This relation elaborates on a submodification, turning an
 ** `SCode.SubMod' into one or more `Types.SubMod's, wihtout type information.
 **)

relation elab_untyped_submod : (SCode.SubMod,Env.Env,Prefix.Prefix) 
	  => Types.SubMod list =

  rule	elab_untyped_mod (m,env,pre) => m'
	--------------------------
	elab_untyped_submod (SCode.NAMEMOD(i,m),env,pre) 
	  => [Types.NAMEMOD(i,m')]

  rule	elab_untyped_mod (m,env,pre) => m'
	---------------------------
	elab_untyped_submod (SCode.IDXMOD(subcr,m),env,pre)
	  => [Types.IDXMOD([-1],m')]
end

(** relation: make_idxmods
 **
 ** From a list of list of integers, this relation creates a list of
 ** sub-modifications of the `IDXMOD' variety.
 **)

relation make_idxmods : (Exp.Subscript list, Types.Mod) => Types.SubMod list =

  axiom	make_idxmods([Exp.INDEX(Exp.ICONST(x))],m) => [Types.IDXMOD([x],m)]

  rule	make_idxmods(xs, m) => mods &
	prefix_idxmods(mods, x) => mods'
	--------------------------------
	make_idxmods(Exp.INDEX(Exp.ICONST(x))::xs, m) => mods'

  rule	Print.print_buf "= expand_slice\n" &
	expand_slice(x, xs, 1, m) => mods
	---------------------------
	make_idxmods(Exp.SLICE(Exp.ARRAY(_,_,x))::xs, m) => mods

  rule	Print.print_buf "# Sorry, [:] slices are not handled in modifications\n"
	--------------------------------------------------------------
	make_idxmods(Exp.WHOLEDIM::xs, m) => fail
	
end

(** relation: prefix_idxmods
 **
 ** This relation adds a subscript to each `Types.IDXMOD' in a list of
 ** submodifications.
 **)

relation prefix_idxmods : (Types.SubMod list, int) => Types.SubMod list =

  axiom	prefix_idxmods([],_) => []

  rule	prefix_idxmods(mods, i) => mods'
	--------------------------------
	prefix_idxmods(Types.IDXMOD(l,m)::mods, i) => Types.IDXMOD(i::l,m)::mods'

end

(** relation: expand_slice
 **
 ** This relation goes through an array slice modification and creates
 ** an singly indexed modification for each index in the slice.  For
 ** example, `x[2:3] = y' is changed into `x[2] = y[1]' and
 ** `x[3] = y[2]'.
 **)

relation expand_slice : (Exp.Exp list, Exp.Subscript list, int, Types.Mod)
	  => Types.SubMod list =

  axiom	expand_slice([], _, _, _) => []

  axiom	expand_slice([], _, _, _) => []

  rule	Exp.simplify(Exp.ASUB(e,n)) => e' &
	Types.unlift_array(t) => t' &
	make_idxmods(Exp.INDEX(x)::ss,
		     Types.MOD(final, [],
			 SOME(Types.TYPED(e',Types.PROP(t',const))))) => mods1 &
	int_add(n, 1) => n' &
	expand_slice(xs, ss, n', m) => mods2 &
	list_append(mods1, mods2) => mods
	---------------------------------
	expand_slice(x::xs, ss, n,
		     m as Types.MOD(final, [],
			      SOME(Types.TYPED(e,Types.PROP(t,const))))) => mods

  rule	Print.print_buf "# Illegal modification (" & print_mod mod & Print.print_buf ")\n"
	--------------------------------
	expand_slice(_,_,_,mod) => fail

end

(** relation: expand_list
 **
 ** This utility relation takes a list of integer values and a list of
 ** list of integers, and for each integer in the first and each list
 ** in the second list creates a
 ** list with that integer as head and the second list as tail. All
 ** resulting lists are collected in a list and returned.
 **)

relation expand_list : (Values.Value list, int list list) => int list list =

  axiom	expand_list([],_) => []

  axiom	expand_list(_,[]) => []

  rule	expand_list(xx,ys) => l1 &
	expand_list(xs,yy) => l2 &
	list_append(l1,l2) => l
	-----------------------
	expand_list(xx as (Values.INTEGER(x)::xs),yy as (y::ys))
		    => ((x::y)::l)

end

(** relation: insert_submods
 **
 ** This relation repeatedly calls `insert_submod' to incrementally
 ** insert several sub-modifications.
 **)

relation insert_submods : (Types.SubMod list, Types.SubMod list, 
			   Env.Env, Prefix.Prefix) 
	  => Types.SubMod list =

  axiom	insert_submods ([],_,_,_) => []

  rule	insert_submod (x,y,env,pre) => x' &
	insert_submods (xs,y,env,pre) => xs' &
	list_append(x', xs') => l
	-------------------------
	insert_submods (x::xs,y,env,pre) => l

end

(** relation: insert_submod
 **
 ** This relation inserts a `SubMod' into a list of unique `SubMod's,
 ** while keeping the uniqueness, merging the submod if necessary.
 **)

relation insert_submod : (Types.SubMod, Types.SubMod list,
			  Env.Env, Prefix.Prefix) 
	  => Types.SubMod list =

  axiom	insert_submod (sub,[],_,_) => [sub]

  rule	n1 = n2 &
	merge (m1,m2,env,pre) => m
	----------------------
	insert_submod (Types.NAMEMOD(n1,m1),Types.NAMEMOD(n2,m2)::tail,env,pre)
	  => (Types.NAMEMOD(n1,m)::tail)

  rule	i1 = i2 &
	merge (m1,m2,env,pre) => m
	----------------------
	insert_submod (Types.IDXMOD(i1,m1),Types.IDXMOD(i2,m2)::tail,env,pre)
	  => (Types.IDXMOD(i1,m)::tail)

  axiom	insert_submod (sub1, sub2,_,_) => sub1::sub2

end

(**
 ** - Lookup
 **)

(** relation: lookup_modification_p
 ** 
 ** This relation extracts a modification from inside another
 ** modification, using a name to look up submodifications.
 **)

relation lookup_modification_p: (Types.Mod,Absyn.Path) => Types.Mod =

  rule	lookup_comp_modification (m,n) => mod
	--------------------------------
	lookup_modification_p (m,Absyn.IDENT(n)) => mod

  rule	lookup_comp_modification (m,n) => mod &
	lookup_modification_p (mod,p) => mod'
	-------------------------------------
	lookup_modification_p (m,Absyn.QUALIFIED(n,p)) => mod'

  rule	Print.print_buf "- lookup_modification_p failed\n" 
	-----------------------
	lookup_modification_p(_,_) => fail
end

(** relation: lookup_comp_modification
 **
 ** This relation is used to look up an identifier in a modification.
 **)

relation lookup_comp_modification: (Types.Mod, Absyn.Ident) => Types.Mod =

  axiom lookup_comp_modification(Types.NOMOD,_) => Types.NOMOD

  axiom	lookup_comp_modification(Types.REDECL(_,_),_) => Types.NOMOD

  rule  lookup_comp_modification2(subs,n) => mod
	-----------------------------------
	lookup_comp_modification(Types.MOD(_,subs,_),n) => mod
	
  rule	Print.print_buf "# Mod.lookup_comp_modification(" &
	print_mod mod & Print.print_buf "," & Print.print_buf i &
	Print.print_buf ") failed\n" &
	print "- lookup_comp_modification failed\n" 
	--------------------
	lookup_comp_modification(mod,i) => fail

end	

(** relation: lookup_comp_modification2
 ** 
 ** This relation is just a helper to `lookup_comp_modification'.
 **)

relation lookup_comp_modification2 : (Types.SubMod list,Absyn.Ident) => Types.Mod =

  axiom lookup_comp_modification2([],_) => Types.NOMOD

  rule  n = m
	--------------------------------------
	lookup_comp_modification2(Types.NAMEMOD(n,mod)::_,m) => mod
	
  rule  lookup_comp_modification2(xs,n) => mod
	---------------------------------
	lookup_comp_modification2(x::xs,n) => mod

  rule	Print.print_buf "- lookup_comp_modification2 failed\n"
	---------------------------------------
	lookup_comp_modification2 (_,_) => fail

end

(** relation: lookup_idx_modification
 **
 ** This relation extracts modifications to an array element, using an
 ** integer to index the modification.
 **)

relation lookup_idx_modification: (Types.Mod, int) => Types.Mod =

  axiom lookup_idx_modification(Types.NOMOD,_) => Types.NOMOD

  axiom	lookup_idx_modification(Types.REDECL(_,_),_) => Types.NOMOD

  rule  lookup_idx_modification2(subs,NONE,idx) => (mod',subs') &
	merge (Types.MOD(f,subs',NONE),mod',[],Prefix.NOPRE) => mod'' &

	index_eqmod (eq,[idx]) => eq' &
	merge (mod'',Types.MOD(false,[],eq'),[],Prefix.NOPRE) => mod'''
	-----------------------------------
	lookup_idx_modification(Types.MOD(f,subs,eq),idx) => mod'''
	
  rule	Print.print_buf "# Mod.lookup_idx_modification(" &
	print_mod mod & Print.print_buf "," & int_string idx => s & Print.print_buf s &
	Print.print_buf ") failed\n"
	--------------------
	lookup_idx_modification(mod,idx) => fail

end	

(** relation: lookup_idx_modification2
 **
 ** This relation does part of the job for `lookup_idx_modification'.
 **)

relation lookup_idx_modification2 : (Types.SubMod list, Types.EqMod option, int)
	  => (Types.Mod, Types.SubMod list) =

  axiom lookup_idx_modification2([],_,_) => (Types.NOMOD, [])

	(* FIXME: Redeclaration *)

  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (Types.NOMOD,subs')
	--------------------------------------
	lookup_idx_modification2(Types.IDXMOD([x],mod)::subs,eq,y)
	  => (mod,subs')
	
  rule  x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(Types.IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',Types.IDXMOD(xs,mod)::subs')

  rule  not x = y &
	lookup_idx_modification2(subs,eq,y) => (mod',subs')
	---------------------------------
	lookup_idx_modification2(Types.IDXMOD(x::xs,mod)::subs,eq,y)
	  => (mod',subs')

  rule  lookup_idx_modification2(xs,eq,idx) => (mod,xs')
	---------------------------------
	lookup_idx_modification2(x::xs,eq,idx) => (mod,x::xs')

  rule	Print.print_buf "- lookup_idx_modification2 failed\n"
	---------------------------------------
	lookup_idx_modification2 (_,_,_) => fail

end

(** relation: index_eqmod
 **
 ** If there is an equation modification, this relation can subscript
 ** it using the provided indexing expressions.  This is used when a
 ** modification equates an array variable with an array expression.
 ** This expression will be expanded to produce one equation
 ** expression per array component.
 **)

relation index_eqmod : (Types.EqMod option, int list) => Types.EqMod option =

  axiom	index_eqmod (NONE,_) => NONE

  axiom	index_eqmod (e,[]) => e

  rule	Types.unlift_array t => t' &
	Exp.simplify Exp.ASUB(e,x) => exp &
	index_eqmod (SOME(Types.TYPED(exp,Types.PROP(t',c))),xs) => e
	------------------------------------------
	index_eqmod (SOME(Types.TYPED(e,Types.PROP(t,c))),x::xs) => e

end

(**
 **
 ** - Merging
 **
 ** The merge relation merges to modifications to one. The first
 ** argument is the "outer" modification that should take precedence over
 ** the "inner" modifications.
 **
 **)

(** relation: merge
 ** 
 ** This relation merges to modificiations into one.  The first
 ** modifications takes precedence over the second.
 **)

relation merge : (Types.Mod, Types.Mod,Env.Env,Prefix.Prefix) => Types.Mod =

  axiom merge(Types.NOMOD,Types.NOMOD,_,_) => Types.NOMOD

  axiom merge(Types.NOMOD,m,_,_) => m

  axiom merge(m,Types.NOMOD,_,_) => m

(*  rule	(* If redeclaring same component*)
	id1 = id2 &
	elab_mod(env,pre,m1) => m1' &
	elab_mod(env,pre,m2) => m2' &
	merge(m1',m2',env,pre) => m'' 
	--------------------------------------
	merge(Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,m1,bc),_)]),
	      Types.REDECL(f2,[(SCode.COMPONENT(id2,_,_,_,_,_,m2,bc2),_)])
			       ,env,pre) 
	  => Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,SCode.NOMOD,bc),m'')])
*)

  rule	(* If didn't work, try with untyped modifications*)
	id1 = id2 &
	elab_untyped_mod(m2,env,pre) => m1' &
	elab_untyped_mod(m2,env,pre) => m2' &
	merge(m1',m2',env,pre) => m'' 
	--------------------------------------
	merge(Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,m1,bc),_)]),
	      Types.REDECL(f2,[(SCode.COMPONENT(id2,_,_,_,_,_,m2,bc2),_)])
			       ,env,pre) 
	  => Types.REDECL(f1,[(SCode.COMPONENT(id1,f,r,p,attr,tp,SCode.NOMOD,bc),m'')])
	  
  axiom	merge(Types.REDECL(f1,els as [(SCode.COMPONENT(id1,_,_,_,_,_,_,_),_)]),
	      Types.MOD(_,subs,_),env,pre) 
	  => Types.MOD(false,Types.NAMEMOD(id1,Types.REDECL(f1,els))::subs,
		       NONE)
	  
  axiom	merge(Types.MOD(_,subs,_),
	      Types.REDECL(f1,els as [(SCode.COMPONENT(id1,_,_,_,_,_,_,_),_)]),
	      env,pre)
	  => Types.MOD(false,Types.NAMEMOD(id1,Types.REDECL(f1,els))::subs,
		       NONE)

  rule  Print.print_buf "# trying to modify final element\n"
	------------------------------------------
	merge(_,m as Types.MOD(true,_,_),_,_) => fail

  rule  merge_subs(subs1, subs2, env, pre) => subs &
	merge_eq(ass1, ass2) => ass
	----------------------------
	merge(Types.MOD(final,subs1,ass1), Types.MOD(false,subs2,ass2),env,pre)
	  => Types.MOD(final,subs,ass)

  rule	Print.print_buf "# incomplete handling of modification merging. Outer:" &
	print_mod outer & Print.print_buf " inner:" &
	print_mod inner 
	-----------------------------------------------------
	merge(outer,inner,_,_) => outer

end

(** relation: merge_subs
 ** 
 ** This relation merges to list of `Types.SubMod's.
 **)

relation merge_subs : (Types.SubMod list, Types.SubMod list, Env.Env, Prefix.Prefix)
	  => Types.SubMod list =

  axiom merge_subs(s1,[],_,_) => s1

  rule  merge_subs2(s1,s,env,pre) => (s1',s') &
	merge_subs(s1',s2,env,pre) => ss
	------------------------
	merge_subs(s1,s::s2,env,pre) => s'::ss

end

(** relation: merge_subs2
 ** 
 ** This relation helps in the merging of two lists of `Types.SubMod's.  It
 ** compares one `Types.SubMod' against a list of other `Types.SubMod's, and if
 ** there is one with the same name,  it is kept and the one `Types.SubMod'
 ** given in the second argument is discarded.
 **)

relation merge_subs2 : (Types.SubMod list, Types.SubMod, Env.Env, Prefix.Prefix)
	  => (Types.SubMod list, Types.SubMod) =

  axiom merge_subs2([],m,_,_) => ([],m)

	(* Modifications in the list take precedence *)

  rule  n1 = n2 & merge(m1,m2,env,pre) => m
	---------------------------
	merge_subs2(Types.NAMEMOD(n1,m1)::ss, Types.NAMEMOD(n2,m2),env,pre)
	  => (ss, Types.NAMEMOD(n1,m))

  rule  i1 = i2 & merge(m1,m2,env,pre) => m
	---------------------------
	merge_subs2(Types.IDXMOD(i1,m1)::ss, Types.IDXMOD(i2,m2),env,pre) 
	  => (ss, Types.IDXMOD(i1,m))

  rule  merge_subs2(ss, s2,env,pre) => (ss',s)
	------------------------------
	merge_subs2(s1::ss, s2,env,pre) => (s1::ss',s)

end

(** relation: merge_eq
 ** 
 ** The outer modification, given in the first argument, takes
 ** precedence over the inner modifications.
 **)

relation merge_eq : (Types.EqMod option, Types.EqMod option) => Types.EqMod option =

	(* Outer assignments take precedence *)

  axiom merge_eq(e as SOME(Types.TYPED(_,_)), _) => e
  axiom merge_eq(e as SOME(Types.UNTYPED(_)), _) => e
  axiom merge_eq(NONE,e) => e

end

(** relation: mod_equation
 ** 
 ** This relation simply extracts the equation part of a modification.
 **)

relation mod_equation : Types.Mod => Types.EqMod option =

  axiom mod_equation Types.NOMOD => NONE
  axiom mod_equation Types.REDECL(_,_) => NONE
  axiom mod_equation Types.MOD(_,_,e) => e

end

(** - Printing *)
(*!ignorecode*)

(** relation: print_mod
 **
 ** This relation prints a modification. It uses a few other relation
 ** to do its stuff.
 **
 ** The relations are excluded from the report for brevity.
 **)

relation print_mod : Types.Mod => () =

  rule	Print.print_buf "()"
	----------
	print_mod(Types.NOMOD)

  rule  Print.print_buf "(redeclare(" &
	Util.list_map(elist,Util.tuple2_1)=> elist' &
	Dump.print_list(elist', SCode.print_element, ", ") &
	Print.print_buf "))"
	------------------------------
	print_mod Types.REDECL(final,elist)
	
  rule	print_final final &
	print_subs1 subs &
	print_eqmod eq
	--------------
	print_mod Types.MOD(final, subs, eq)

end

(**)

relation print_final : bool => () =

  axiom print_final false

  rule Print.print_buf " final "
       --------------
       print_final true

end

(**)

relation print_subs1 : Types.SubMod list => () =

  axiom print_subs1 [] => ()

  rule	Print.print_buf "(" & print_sub x & print_subs2 xs & Print.print_buf ")"
	------------------------------------
	print_subs1 x::xs

end

(**)

relation print_subs2 : Types.SubMod list => () =

  axiom print_subs2 []

  rule  Print.print_buf "," & print_sub sub & print_subs2 subs
	----------------------------------------------
	print_subs2 sub::subs

end

(**)

relation print_sub : Types.SubMod => () =

  rule  Print.print_buf n & print_mod mod
	------------------
	print_sub Types.NAMEMOD(n,mod)

  rule  print_subscripts ss & print_mod mod
	------------------
	print_sub Types.IDXMOD(ss,mod)

end

(**)

relation print_subscripts : int list => () =

  rule	Print.print_buf "[]"
  	---------------
	print_subscripts []

  rule	Print.print_buf "[" &
	int_string x => s & Print.print_buf s &
	print_subscripts2 xs &
	Print.print_buf "]"
	-----------------------------------------------------
	print_subscripts x::xs

end

(**)

relation print_subscripts2 : int list => () =

  axiom	print_subscripts2 []

  rule	Print.print_buf "," & int_string x => s & Print.print_buf s &
	print_subscripts2 xs
	--------------------
	print_subscripts2 x::xs

end

(**)

relation print_eqmod : Types.EqMod option => () =

  axiom print_eqmod NONE

  rule  Print.print_buf " =(typed) " & Exp.print_exp e &
	Types.print_prop prop
	-----------------------------
	print_eqmod SOME(Types.TYPED(e,prop))

  rule  Print.print_buf " =(untyped) " & Dump.print_exp e
	-----------------------------
	print_eqmod SOME(Types.UNTYPED(e))

end
	
