(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 dae.rml
 ** module:      DAE
 ** description: DAE management and output
 **
 ** RCS: $Id$
 ** 
 ** This module defines types for collecting DAE equations together
 ** with declarations of variables.
 **)

(** - Module header *)

module DAE:
  
  with "absyn.rml"
  with "exp.rml"
  with "algorithm.rml"
  with "types.rml"

  type Ident = string
  type InstDims = Exp.Subscript list

  datatype VarKind = VARIABLE | DISCRETE | PARAM | CONST

  datatype Type = REAL | INT | BOOL | STRING | ENUM | ENUMERATION of string list

(* LS: Added for variables in functions *)
  datatype VarDirection = INPUT | OUTPUT | BIDIR

(* LS: Removed VARVAL completely, and added Exp.Exp as an option to VAR *)
  datatype Element = VAR of Exp.ComponentRef * VarKind * VarDirection * Type * Exp.Exp option * InstDims
		   | DEFINE of Exp.ComponentRef * Exp.Exp
		   | INITIALDEFINE of Exp.ComponentRef * Exp.Exp
		   | EQUATION of Exp.Exp * Exp.Exp
		   | INITIALEQUATION of Exp.Exp * Exp.Exp
		   | ALGORITHM of Algorithm.Algorithm
		   | INITIALALGORITHM of Algorithm.Algorithm
		   | COMP of Ident * DAElist
		   | FUNCTION of Absyn.Path * DAElist * Types.Type
		   | EXTFUNCTION of Absyn.Path * DAElist * Types.Type * ExternalDecl

  datatype ExtArg = EXTARG of Exp.ComponentRef * Types.Attributes * Types.Type
		  | EXTARGEXP of Exp.Exp * Types.Type
                  | EXTARGSIZE of Exp.ComponentRef * Types.Attributes * Types.Type * Exp.Exp
                  | NOEXTARG

  datatype ExternalDecl = EXTERNALDECL of Ident * (* external function name *)
					  ExtArg list * (* parameters *)
					  ExtArg * (* return type *)
					  string (* language *)
	  

(* 
 LS: Could have extended DAElist to have two lists, one with 
 functions and one with elements, but that would mean a lot of
 change in places where two daes are built and appended, in 
 inst.rml 
 FUNCTION could also consist of SCode.Class instead.
 *)

  datatype DAElist = DAE of Element list


  relation dump: DAElist => ()
  relation dump2: DAElist => ()
  relation dump_elements : Element list => () 
  relation dump_str: DAElist => string
  relation dump_debug: DAElist => ()
  relation dump_debug_element : Element => ()
  relation dump_graphviz: DAElist => ()
  relation dump_type: Type => ()
  relation dump_type_str: Type => string
  relation dump_ext_arg_str : ExtArg => string 
  relation dump_algorithm: Element => ()
  relation get_matching_elements: (Element list, Element => () )  => Element list
  relation get_matching: ('a list, 'a => () )  => 'a list
  relation get_output_vars: Element list  => Element list
  relation get_bidir_vars: Element list  => Element list
  relation get_input_vars: Element list  => Element list
  relation is_algorithm : Element => ()
  relation is_function : Element => ()
  relation is_var: Element => ()
  relation is_output_var: Element => ()
  relation is_input_var: Element => ()
  relation is_bidir_var: Element => ()
  relation is_parameter: Element => ()
  relation is_comp: Element => ()
  relation find_element: (Element list, Element => ()) => Element option
  relation build_gr_strlist : ('a list, 'a => string, int) => (string list, 'a list)
  relation get_variable_bindings_str: Element list => string
end


(** - Relations
 **
 ** The only relations in this module are for printing, and are not
 ** included in the report.
 **)

(*!ignorecode*)

with "rtopts.rml"
with "graphviz.rml"
with "dump.rml"
with "print.rml"
with "util.rml"

(** relation: dump
 **
 ** This relation prints the DAE in the standard output format.
 **)

relation dump : DAElist => () =
	
  rule	dump_list (daelist, dump_function) &
	dump_list (daelist, dump_comp_element) 
	-------------
	dump DAE(daelist)
end

relation dump2: DAElist => () =
  rule	Print.print_buf "VAR(" &
	Exp.print_component_ref cr &
	Print.print_buf "=" &
	Exp.print_exp e &
	Print.print_buf ")\n" &
	dump2 (DAE(xs))
	-------------------
	dump2 DAE(VAR(cr,_,_,_,SOME(e),_)::xs)

  rule	Print.print_buf "VAR(" &
	Exp.print_component_ref cr &
	Print.print_buf ")\n" &
	dump2 (DAE(xs))
	-------------------
	dump2 DAE(VAR(cr,_,_,_,NONE,_)::xs)

  rule	Print.print_buf "DEFINE(" &
	Exp.print_component_ref cr &
	Print.print_buf ")\n" &
	dump2 (DAE(xs))
	---------
	dump2 DAE(DEFINE(cr,_)::xs)

  rule	Print.print_buf "INITIALDEFINE(" &
	Exp.print_component_ref cr &
	Print.print_buf ")\n" &
	dump2 (DAE(xs))
	---------
	dump2 DAE(INITIALDEFINE(cr,_)::xs)

  rule	Print.print_buf "EQUATION(" &
	Exp.print_exp e1 &
	Print.print_buf " = " &
	Exp.print_exp e2 &
	Print.print_buf ")\n" &
	dump2( DAE(xs))
	---------
	dump2 DAE(EQUATION(e1,e2)::xs)
	
  rule	Print.print_buf "INITIALEQUATION(" &
	Exp.print_exp e1 &
	Print.print_buf " = " &
	Exp.print_exp e2 &
	Print.print_buf ")\n" &
	dump2( DAE(xs))
	---------
	dump2 DAE(INITIALEQUATION(e1,e2)::xs)

  rule	Print.print_buf "ALGORITHM(...)" &
	dump2 (DAE(xs))
	------------
	dump2 (DAE(ALGORITHM(_)::xs))

  rule	Print.print_buf "INITIALALGORITHM(...)" &
	dump2 (DAE(xs))
	------------
	dump2 (DAE(INITIALALGORITHM(_)::xs))

  rule	Print.print_buf "COMP(" &
	Print.print_buf ident &
	dump2 (lst) &
	Print.print_buf ")\n" &
	dump2 (DAE(xs))
	----------
	dump2 (DAE(COMP(ident,lst)::xs))

  rule	Print.print_buf "FUNCTION(...)\n" &
	dump2 (DAE(xs))
	--------------
	dump2 (DAE(FUNCTION(_,_,_)::xs))

  rule	Print.print_buf "EXTFUNCTION(\n" &
	Absyn.path_string path => str & Print.print_buf str &
	Print.print_buf ", " &
	dump2 dae &
	Print.print_buf ", " &
	Types.print_type tp &
	Print.print_buf ", " &
	dump_ext_decl_str extdecl => extdeclstr &
	Print.print_buf extdeclstr &
	Print.print_buf ")\n" &	
	dump2 (DAE(xs))
	--------------
	dump2 (DAE(EXTFUNCTION(path,dae,tp,extdecl)::xs))

  axiom dump2 (DAE([]))

  rule	Print.print_buf "dump2 failed\n"
	---------------------
	dump2 (_)
end

relation dump_ext_decl_str : ExternalDecl => string = 

  rule	Dump.get_string_list (extargs, dump_ext_arg_str, ",") => extargsstr &
	dump_ext_arg_str retty => rettystr &
	Util.string_append_list(["EXTERNALDECL(",id,", (",extargsstr,"), ",
				 rettystr,", \"",lang,"\")"]) => str
	-----------------------------------------------------------------------
	dump_ext_decl_str EXTERNALDECL(id,extargs,retty,lang) => str
end

relation dump_ext_arg_str : ExtArg => string = 

  axiom	dump_ext_arg_str NOEXTARG => "void"

  rule	Exp.print_component_ref_str cr => crstr &
	Dump.direction_symbol dir => dirstr &
	Types.get_type_name ty => tystr &
	Util.string_append_list([dirstr," ",tystr," ",crstr]) => str
	------------------------------------------------------------
	dump_ext_arg_str EXTARG(cr,Types.ATTR(fl,acc,var,dir),ty) => str

  rule	Exp.print_exp_str exp => crstr &
	Types.get_type_name ty => tystr &
	Util.string_append_list(["(",tystr,") ",crstr]) => str
	------------------------------------------------------------
	dump_ext_arg_str EXTARGEXP(exp,ty) => str

  rule	Exp.print_component_ref_str cr => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size(",crstr,",",dimstr,")"]) => str
	------------------------------------------------------------
	dump_ext_arg_str EXTARGSIZE(cr,attr,ty,dim) => str
end

(** relation: dump_str
 ** 
 ** This relation prints the DAE to a string.
**)
relation dump_str : DAElist => string =
	
  rule	dump_comp_element_str d => str &
	dump_str(DAE(dl)) => str2 &
	string_append(str,str2) => str3
	-------------------------------
	dump_str DAE((d as COMP(_,_))::dl) => str3

	axiom dump_str DAE([]) => ""
end
	
	
relation dump_list : ('a list, 'a => ()) => () =
	
  axiom	dump_list ([],_)
	
  rule	r(first) &
	dump_list (rest, r)
	-------------------
	dump_list (first::rest, r)
	
end

relation dump_comp_element : Element => () =
	
  rule	RTOpts.modelica_output => false &
	Print.print_buf "fclass " & Print.print_buf n & Print.print_buf "\n" &
	dump_elements(l) &
	Print.print_buf "end " & Print.print_buf n & Print.print_buf ";\n"
	-----------------------------------
	dump_comp_element COMP(n,DAE(l))

  rule	RTOpts.modelica_output => true &
	Print.print_buf "class " & Print.print_buf n & Print.print_buf "\n" &
	dump_elements(l) &
	Print.print_buf "end " & Print.print_buf n & Print.print_buf ";\n"
	-----------------------------------
	dump_comp_element COMP(n,DAE(l))

(* LS: for non-COMPS, which are only FUNCTIONS at the moment *)
axiom	dump_comp_element _

end

relation dump_comp_element_str : Element => string =
	
  rule	RTOpts.modelica_output => false &
	string_append("fclass ",n) => s1 &
	string_append(s1,"\n") => s2 &
	dump_elements_str(l) => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4,"end ") => s5 &
        string_append(s5,n) => s6 &
        string_append(s6,";\n") => str
	-----------------------------------
	dump_comp_element_str COMP(n,DAE(l)) => str

  rule	RTOpts.modelica_output => true &
	string_append("class ",n) => s1 &
	string_append(s1,"\n") => s2 &
	dump_elements_str(l) => s3 &
	string_append(s2,s3)  => s4 &
	string_append(s4,"end ") => s5 &
	string_append(s5,n) => s6 &
	string_append(s6,";\n") => str
  	-----------------------------------
	dump_comp_element_str COMP(n,DAE(l)) => str

(* LS: for non-COMPS, which are only FUNCTIONS at the moment *)

  axiom	dump_comp_element_str _ => ""

end


relation dump_elements : Element list => () =

  rule	dump_vars l &
	Print.print_buf "initial equation\n" &
	dump_list (l, dump_initialequation) &
	Print.print_buf "equation\n" &
	dump_list (l, dump_equation) &
	dump_list (l, dump_initialalgorithm) & 
	dump_list (l, dump_algorithm) & 
	dump_list (l, dump_comp_element)
	-----------------
	dump_elements l

end

relation dump_elements_str : Element list => string =

  rule	dump_vars_str l => s1 &
	dump_initialequations_str(l) => s2 &
	dump_equations_str(l) => s3 &
	dump_initialalgorithms_str(l) => s4 &
	dump_algorithms_str(l) => s5 &
	Util.string_append_list([s1,"initial equation\n",s2,"initial algorithm\n",s4,"equation\n",s3,"algorithm\n",s5]) => str
	---------------------------
	dump_elements_str l => str

end

relation dump_algorithms_str: Element list => string = 
	
  rule	Dump.get_string_list(stmts,pp_statement_str,"") => s1 &
	string_append("algorithm\n",s1) => s2 &
	dump_algorithms_str(xs) => s3 &
	string_append(s1,s3) => str
	--------------------------------------
	dump_algorithms_str (ALGORITHM(Algorithm.ALGORITHM(stmts))::xs) => str

  rule	dump_algorithms_str(xs) => str
	------------------------------
	dump_algorithms_str(_::xs) => str
	
  axiom dump_algorithms_str([])  => ""

end

relation dump_initialalgorithms_str: Element list => string = 
	
  rule	Dump.get_string_list(stmts,pp_statement_str,"") => s1 &
	string_append("algorithm\n",s1) => s2 &
	dump_initialalgorithms_str(xs) => s3 &
	string_append(s1,s3) => str
	--------------------------------------
	dump_initialalgorithms_str (INITIALALGORITHM(Algorithm.ALGORITHM(stmts))::xs) => str

  rule	dump_initialalgorithms_str(xs) => str
	------------------------------
	dump_initialalgorithms_str(_::xs) => str
	
  axiom dump_initialalgorithms_str([])  => ""

end

relation dump_equations_str: Element list => string =

  rule	Exp.print_exp_str e1 => s1 &
	string_append("  ",s1) => s2 &
	string_append(s2," = ") => s3 &
	Exp.print_exp_str e2  => s4 &
	string_append(s3,s4) => s4' &
	string_append(s4',";\n") => s5 &
	dump_equations_str(xs) => s6 &
	string_append(s5,s6) => str
	-------------------------------
	dump_equations_str( EQUATION(e1,e2)::xs) => str
	
  rule	Exp.print_component_ref_str c => s1 &
	string_append("  ",s1) => s2 &
	string_append(s2," := ") => s3 &
	Exp.print_exp_str e  => s4 &
	string_append(s3,s4) => s4' &
	string_append(s4',";\n") => s5 &
	dump_equations_str(xs) => s6 &
	string_append(s5,s6) => str
	-------------------------------
	dump_equations_str( DEFINE(c,e)::xs) => str

  rule	dump_equations_str(xs) => str
	-----------------------------
	dump_equations_str(_::xs) => str
	
  axiom dump_equations_str([]) => ""

end

relation dump_initialequations_str: Element list => string =

  rule	Exp.print_exp_str e1 => s1 &
	string_append("  ",s1) => s2 &
	string_append(s2," = ") => s3 &
	Exp.print_exp_str e2  => s4 &
	string_append(s3,s4) => s4' &
	string_append(s4',";\n") => s5 &
	dump_equations_str(xs) => s6 &
	string_append(s5,s6) => str
	-------------------------------
	dump_initialequations_str( INITIALEQUATION(e1,e2)::xs) => str
	
  rule	Exp.print_component_ref_str c => s1 &
	string_append("  ",s1) => s2 &
	string_append(s2," := ") => s3 &
	Exp.print_exp_str e  => s4 &
	string_append(s3,s4) => s4' &
	string_append(s4',";\n") => s5 &
	dump_initialequations_str(xs) => s6 &
	string_append(s5,s6) => str
	-------------------------------
	dump_initialequations_str( INITIALDEFINE(c,e)::xs) => str

  rule	dump_initialequations_str(xs) => str
	-----------------------------
	dump_initialequations_str(_::xs) => str
	
  axiom dump_initialequations_str([]) => ""

end


(* replace this with dump_list when everything works after the VARVAL removal *)
 (* project *)
relation dump_vars: Element list => () =
	
  axiom	dump_vars []
	
  rule	dump_var first &
	dump_vars rest
	-------------------
	dump_vars first :: rest

end

relation dump_vars_str: Element list => string =
	
  axiom	dump_vars_str [] => ""
	
  rule	dump_var_str first => s1 &
	dump_vars_str rest => s2 &
	string_append(s1,s2) => str
	-------------------
	dump_vars_str first :: rest => str

end


relation dump_kind =

  rule	Print.print_buf " constant  "
	--------------------
	dump_kind CONST
	
  rule	Print.print_buf " parameter "
	--------------------
	dump_kind PARAM
	
  rule	Print.print_buf " discrete  "
	--------------------
	dump_kind DISCRETE

  rule	Print.print_buf "           "
	--------------------
	dump_kind VARIABLE

end

relation dump_kind_str: VarKind => string =

  axiom	dump_kind_str CONST => "constant"
  axiom	dump_kind_str PARAM => "parameter"
  axiom	dump_kind_str DISCRETE => "discrete"
  axiom	dump_kind_str VARIABLE => ""

end


relation dump_direction =

  rule	Print.print_buf " input  "
	--------------------
	dump_direction INPUT

  rule	Print.print_buf " output "
	--------------------
	dump_direction OUTPUT
	
  rule	Print.print_buf "        "
	--------------------
	dump_direction BIDIR

end

relation dump_direction_str: VarDirection => string =

  axiom	dump_direction_str INPUT => " input  "
	
  axiom dump_direction_str OUTPUT => " output "
	
  axiom	dump_direction_str BIDIR => "        "

end

relation dump_type =

  rule	Print.print_buf "Integer "
	----------------
	dump_type INT

  rule	Print.print_buf "Real    "
	----------------
	dump_type REAL

  rule	Print.print_buf "Boolean "
	----------------
	dump_type BOOL

  rule	Print.print_buf "String  "
	----------------
	dump_type STRING

  rule	Print.print_buf "Enum "
	-------------
	dump_type ENUM

  rule	Print.print_buf "Enumeration(" &
	Dump.print_list(l,print,",") &
	Print.print_buf ") "
	------------------
	dump_type ENUMERATION(l)
end

relation dump_type_str =

  axiom	dump_type_str INT => "Integer " 
	
  axiom	dump_type_str REAL => "Real    "

  axiom	dump_type_str BOOL => "Boolean "

  axiom	dump_type_str STRING => "String  "

  axiom	dump_type_str ENUM => "Enum  "
	
  rule	Util.string_delimit_list(l,", ") => s1 &
	string_append("enumeration(",s1) => s2 &
	string_append(s2,") ") => str
	----------------------------
	dump_type_str ENUMERATION(l) => str
end

relation dump_var : Element => () =
	
  rule	dump_kind kind & dump_direction dir & dump_type typ &
 	Exp.print_component_ref id & Print.print_buf ";\n"
	--------------------------------------
	dump_var VAR(id, kind, dir, typ, NONE,_)
	
  rule	dump_kind kind & dump_direction dir & dump_type typ &
 	Exp.print_component_ref id & Print.print_buf " = " &
	Exp.print_exp e & Print.print_buf ";\n"
	--------------------------------------
	dump_var VAR(id, kind, dir, typ, SOME(e),_)
	
  axiom	dump_var (_)

end

relation dump_var_str : Element => string =
	
  rule	dump_kind_str kind => s1 & 
	dump_direction_str dir => s2 &
	string_append(s1,s2)=>s3 &
	dump_type_str typ => s4 &	
	string_append(s3,s4) => s5 &
	Exp.print_component_ref_str id => s6 & 
	string_append(s5,s6) => s7 &
	string_append(s7,";\n") => str
	--------------------------------------
	dump_var_str VAR(id, kind, dir, typ, NONE,_) => str
	
  rule	dump_kind_str kind => s1 & 
	dump_direction_str dir => s2 &
	string_append(s1,s2)=>s3 &
	dump_type_str typ => s4 &	
	string_append(s3,s4) => s5 &
	Exp.print_component_ref_str id => s6 & 
	string_append(s6," = ") => s7 &
	Exp.print_exp_str e => s8 & 
	string_append(s7,s8) => s9 &
	string_append(s9,";\n") => str
	--------------------------------------
	dump_var_str VAR(id, kind, dir, typ, SOME(e),_) => str
	
  axiom	dump_var_str (_) => ""

end

relation dump_equation : Element => () =
	
  rule	Print.print_buf "  " & Exp.print_exp e1 &
	Print.print_buf " = " & Exp.print_exp e2 & Print.print_buf ";\n"
	--------------------------------------
	dump_equation(EQUATION(e1, e2))
	
  rule	Print.print_buf "  " & Exp.print_component_ref c &
	Print.print_buf " ::= " & Exp.print_exp e & Print.print_buf ";\n"
	--------------------------------------
	dump_equation(DEFINE(c, e))
	
  axiom	dump_equation _

end

relation dump_initialequation : Element => () =
	
  rule	Print.print_buf "  " & Exp.print_exp e1 &
	Print.print_buf " = " & Exp.print_exp e2 & Print.print_buf ";\n"
	--------------------------------------
	dump_initialequation(INITIALEQUATION(e1, e2))
	
  rule	Print.print_buf "  " & Exp.print_component_ref c &
	Print.print_buf " ::= " & Exp.print_exp e & Print.print_buf ";\n"
	--------------------------------------
	dump_initialequation(INITIALDEFINE(c, e))
	
  axiom	dump_initialequation _

end

relation dump_equation_str : Element => string =
	
  rule	
	Exp.print_exp_str e1 => s1 &
	string_append("  ",s1) => s2 &
	string_append(s2, " = ") => s3 &
	Exp.print_exp_str e2  => s4 & 
	string_append(s3,s4)=> s5 &
	string_append(s5,";\n") => str
	--------------------------------------
	dump_equation_str(EQUATION(e1, e2)) => str
	
  rule	Exp.print_component_ref_str c => s1 &
	string_append("  ",s1) => s2 &
	string_append(" ::= ",s2) => s3 &
	Exp.print_exp_str e => s4 & 
	string_append(s3,s4) => s5 &
	string_append(s5,";\n") => str
	--------------------------------------
	dump_equation_str(DEFINE(c, e)) => str
	
  axiom	dump_equation_str _ => ""

end

relation dump_algorithm : Element => () =

  rule	Print.print_buf "algorithm\n" &
	Dump.print_list(stmts, pp_statement, "")
	----------------------------------------------
	dump_algorithm ALGORITHM(Algorithm.ALGORITHM(stmts))

  axiom	dump_algorithm _

end

relation dump_initialalgorithm : Element => () =

  rule	Print.print_buf "initial algorithm\n" &
	Dump.print_list(stmts, pp_statement, "")
	----------------------------------------------
	dump_initialalgorithm INITIALALGORITHM(Algorithm.ALGORITHM(stmts))

  axiom	dump_initialalgorithm _

end

relation dump_algorithm_str : Element => string =

  rule	Dump.get_string_list(stmts,pp_statement_str,"") => s1 &
	string_append("algorithm\n",s1) => str
	----------------------------------------------
	dump_algorithm_str ALGORITHM(Algorithm.ALGORITHM(stmts)) => str

  axiom	dump_algorithm_str _ => ""

end


relation dump_initialalgorithm_str : Element => string =

  rule	Dump.get_string_list(stmts,pp_statement_str,"") => s1 &
	string_append("initial algorithm\n",s1) => str
	----------------------------------------------
	dump_initialalgorithm_str INITIALALGORITHM(Algorithm.ALGORITHM(stmts)) => str

  axiom	dump_initialalgorithm_str _ => ""

end

(* LS *)
relation dump_function: Element => () =


  rule	Print.print_buf "function " &
	Absyn.path_string fpath => fstr &
	Print.print_buf fstr & Print.print_buf "\n" &
	dump_elements(dae) &
	Print.print_buf "end " & Print.print_buf fstr & Print.print_buf ";\n\n\n"
	------------------------------------
	dump_function FUNCTION(fpath,DAE(dae),t)
	
  axiom	dump_function _


end


(** relation: pp_statement
 **
 ** Prettyprint an algorithm statement
 **)

relation pp_statement : Algorithm.Statement => () =

  rule	pp_stmt (alg,2)
	--------------
	pp_statement alg

end

relation pp_statement_str : Algorithm.Statement => string =

  rule	pp_stmt_str (alg,2) => str
	--------------
	pp_statement_str alg => str

end

relation pp_stmt : (Algorithm.Statement, int) => () =

  rule	indent i &
	Exp.print_component_ref c &
	Print.print_buf " := " &
	Exp.print_exp e &
	Print.print_buf ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN(_,c,e), i)

  rule	indent i &
	Exp.print_component_ref c &
	Print.print_buf " := " &
	Exp.print_exp e &
	Print.print_buf ";\n"
	----------
	pp_stmt (Algorithm.ASSIGN_ARR(_,c,e), i)

  rule	indent i &
 	Print.print_buf "if " & Exp.print_exp e & Print.print_buf " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i) &
	indent i & Print.print_buf "end if;\n"
        -------------------
	pp_stmt (Algorithm.IF(e,then,else), i)
	
  rule	indent i &
	Print.print_buf "for " & Print.print_buf id & Print.print_buf " in " &
 	Exp.print_exp e & Print.print_buf " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	Print.print_buf "end for;\n"
        -------------------
	pp_stmt (Algorithm.FOR(_,_,id,e,stmts), i)
	
  rule	indent i &
	Print.print_buf "while " & Exp.print_exp e & Print.print_buf " loop\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	Print.print_buf "end while;\n"
        -------------------
	pp_stmt (Algorithm.WHILE(e,stmts), i)
	
  rule	indent i &
	Print.print_buf "when " & Exp.print_exp e & Print.print_buf " do\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i') &
	indent i &
	Print.print_buf "end when;\n"
        -------------------
	pp_stmt (Algorithm.WHEN(e,stmts), i)
	
  rule	indent i & Print.print_buf "**ALGORITHM**;\n"
	----------------------------------
	pp_stmt (_,i)

end

relation pp_stmt_str : (Algorithm.Statement, int) => string =

  rule	indent_str i => s1 &
	Exp.print_component_ref_str c => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," := ") => s4 &
	Exp.print_exp_str e => s5 &
	string_append(s4,s5) => s6 &
	string_append(s6,";\n") => str
	----------
	pp_stmt_str (Algorithm.ASSIGN(_,c,e), i) => str

  rule	indent_str i => s1 &
	Exp.print_component_ref_str c => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," := ") => s4 &
	Exp.print_exp_str e => s5 &
	string_append(s4,s5) => s6 &
	string_append(s6,";\n") => str
	----------
	pp_stmt_str (Algorithm.ASSIGN_ARR(_,c,e), i) => str

  rule	indent_str i => s1 &
	string_append(s1,"if ") => s2 &
	Exp.print_exp_str e => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," then\n") => s5 &
	int_add(i,2) => i' &
	pp_stmt_list_str (then, i') => s6 &
	string_append(s5,s6) => s7 &
	pp_else_str (else, i) => s8 &
	string_append(s7,s8) => s9 &
	indent_str i => s10 & 
	string_append(s9,s10) => s11 &
	string_append(s11,"end if;\n") => str
        -------------------
	pp_stmt_str (Algorithm.IF(e,then,else), i) => str
	
  rule	indent_str i => s1 &
	string_append(s1,"for ") => s2 &
	string_append(s2,id) => s3 &
	string_append(s3," in ") => s4 &
 	Exp.print_exp_str e => s5 &
	string_append(s4,s5) => s6 &
	string_append(s6," loop\n") => s7 &
	int_add(i,2) => i' &
	pp_stmt_list_str (stmts, i') => s8 &
	string_append(s7,s8) => s9 &				   
	indent_str i => s10 &
	string_append(s9,s10) => s11 &
	string_append(s11,"end for;\n") => str
        -------------------
	pp_stmt_str (Algorithm.FOR(_,_,id,e,stmts), i) => str
	
  rule	indent_str i => s1 &
	string_append(s1,"while ") => s2 &
	Exp.print_exp_str e => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," loop\n") => s5 &
	int_add(i,2) => i' &
	pp_stmt_list_str (stmts, i') => s6 &
	string_append(s5,s6) => s7 &
	indent_str i => s8 &
	string_append(s7,s8) => s9 &
	string_append(s9,"end while;\n") => str
        -------------------
	pp_stmt_str (Algorithm.WHILE(e,stmts), i) => str
	
  rule	indent_str i => s1 &
	string_append(s1,"when ") => s2 &
	Exp.print_exp_str e => s3 & 
	string_append(s2,s3) => s4 &
	string_append(s4," do\n") => s5 &
	int_add(i,2) => i' &
	pp_stmt_list_str (stmts, i') => s6 &
	string_append(s5,s6) => s7 &				  
	indent_str i => s8 &
	string_append(s7,s8) => s9 &
	string_append(s9,"end when;\n") => str
        -------------------
	pp_stmt_str (Algorithm.WHEN(e,stmts), i) => str
	
  rule	indent_str i => s1 & string_append(s1,"**ALGORITHM**;\n") => str
	----------------------------------
	pp_stmt_str (_,i) => str

end

relation pp_stmt_list : (Algorithm.Statement list, int) => () =

  axiom	pp_stmt_list ([],_)

  rule	pp_stmt (stmt,i) & pp_stmt_list(stmts,i)
	--------------------------------
	pp_stmt_list (stmt::stmts,i)

end

relation pp_stmt_list_str : (Algorithm.Statement list, int) => string =

  axiom	pp_stmt_list_str ([],_) => ""

  rule	pp_stmt_str (stmt,i) =>s1 & pp_stmt_list_str(stmts,i) => s2 &
	string_append(s1,s2) => str
	--------------------------------
	pp_stmt_list_str (stmt::stmts,i) => str

end

relation pp_else : (Algorithm.Else, int) => () =

  axiom	pp_else (Algorithm.NOELSE, _)

  rule	indent i &
 	Print.print_buf "elseif " & Exp.print_exp e & Print.print_buf " then\n" &
	int_add(i,2) => i' &
	pp_stmt_list (then, i') &
	pp_else (else, i)
        -----------------
	pp_else (Algorithm.ELSEIF(e,then,else), i)

  rule	indent i &
 	Print.print_buf "else\n" &
	int_add(i,2) => i' &
	pp_stmt_list (stmts, i')
        ------------------------
	pp_else (Algorithm.ELSE(stmts), i)

end

relation pp_else_str : (Algorithm.Else, int) => string =

  axiom	pp_else_str (Algorithm.NOELSE, _) => ""

  rule	indent_str i => s1 &
	string_append(s1,"elseif ") => s2 &
	Exp.print_exp_str e => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," then\n") => s5 &
	int_add(i,2) => i' &
	pp_stmt_list_str (then, i') => s6 &
	string_append(s5,s6) => s7 &
	pp_else_str (else, i) => s8 &
	string_append(s7,s8) => str
        -----------------
	pp_else_str (Algorithm.ELSEIF(e,then,else), i) => str

  rule	indent_str i => s1 &
 	string_append(s1,"else\n") => s2 &
	int_add(i,2) => i' &
	pp_stmt_list_str (stmts, i') => s3 &
	string_append(s2,s3) => str
        ------------------------
	pp_else_str (Algorithm.ELSE(stmts), i) => str

end

relation indent : int => () =

  axiom indent 0

  rule	Print.print_buf " " & int_sub(i,1) => i' & indent i'
	------------------------------------------
	indent i

end

relation indent_str : int => string =

  axiom indent_str 0 => ""

  rule	int_sub(i,1) => i' & indent_str i' => s1 &
	string_append(" ",s1) => str
	------------------------------------------
	indent_str i => str

end

(* LS *)
relation get_matching_elements: (Element list, Element => () )  => Element list =

  rule	get_matching (elist, cond ) => elist
	------------------------------------
	get_matching_elements (elist, cond) => elist
end	

(* LS *)
relation get_matching: ('a list, 'a => () )  => 'a list =

  axiom	get_matching ([],_) => []

  rule	cond(v) &
	get_matching (vl, cond) => vl'
	-------------------
	get_matching (v::vl, cond) => v::vl'

  rule	not cond(v) &
	get_matching (vl, cond) => vl'
	--------------------------
	get_matching (v::vl, cond) => vl'
end	


(* LS *)
relation is_parameter: Element => () =

  (* LS: false means not protected, hence we ignore protected variables *)
  axiom	is_parameter VAR(_, PARAM, _, _, _, _)

end

(* LS *)
relation is_comp: Element => () =

  axiom	is_comp COMP(_,_) 

end



(* LS *)
relation get_output_vars: Element list  => Element list =
	
  rule	get_matching_elements(vl, is_output_var) => vl'
	---------------------------------
	get_output_vars vl => vl'
end

(* LS *)
relation get_bidir_vars: Element list  => Element list =
	
  rule	get_matching_elements(vl, is_bidir_var) => vl'
	---------------------------------
	get_bidir_vars vl => vl'
end

(* HJ *)
relation get_input_vars: Element list  => Element list =
	
  rule	get_matching_elements(vl, is_input_var) => vl'
	---------------------------------
	get_input_vars vl => vl'
end

(* LS *)
relation is_output_var: Element => () =

  axiom	is_output_var VAR(n, VARIABLE, OUTPUT, ty, _, _)

end

(* LS *)
relation is_bidir_var: Element => () =

  axiom	is_bidir_var VAR(n, VARIABLE, BIDIR, ty, _, _)

end

(* HJ *)
relation is_input_var: Element => () =

  axiom	is_input_var VAR(n, VARIABLE, INPUT, ty, _, _)

end


(* LS *)
relation is_not_var: Element => () =

  rule	not is_var e
	------------
	is_not_var e
end

(* LS *)
relation is_var: Element => () =

  axiom	is_var VAR(_,_,_,_,_,_)

end

relation is_algorithm : Element => () =

  axiom is_algorithm ALGORITHM(_)

end

relation is_function : Element => () =

  axiom is_function FUNCTION(_,_,_)
  axiom	is_function EXTFUNCTION(_,_,_,_)

end

(*******************************

 Dump the data structures in a 
 paranthesised way

********************************)


relation dump_debug : DAElist => () =

  rule	Print.print_buf "DAE(" & dump_debug_elist elist & Print.print_buf ")"
	-------------------------------------------------
	dump_debug DAE(elist)

end

relation dump_debug_elist : Element list => () =

  axiom dump_debug_elist []

  rule	dump_debug_element first & Print.print_buf "\n" &
	dump_debug_elist rest
	---------------------
	dump_debug_elist first :: rest

end

relation dump_debug_element : Element => () =

  rule	Print.print_buf "VAR(" &
	Exp.print_component_ref cr & Print.print_buf ", " &
	dump_kind vk &
	Print.print_buf ")"
	-------------
	dump_debug_element VAR(cr,vk,vd,ty,NONE,_)

  rule	Print.print_buf "VAR(" &
	Exp.print_component_ref cr & Print.print_buf ", " &
	dump_kind vk & Print.print_buf ", " &
	Exp.print_exp e &
	Print.print_buf ")"
	-------------
	dump_debug_element VAR(cr,vk,vd,ty,SOME(e),_)

  rule	Print.print_buf "DEFINE(" &
	Exp.print_component_ref cr &
	Print.print_buf ", " &
	Exp.print_exp exp &
	Print.print_buf ")"
	----------------
	dump_debug_element DEFINE(cr,exp)

  rule	Print.print_buf "INITIALDEFINE(" &
	Exp.print_component_ref cr &
	Print.print_buf ", " &
	Exp.print_exp exp &
	Print.print_buf ")"
	----------------
	dump_debug_element INITIALDEFINE(cr,exp)

  rule	Print.print_buf "EQUATION(" &
	Exp.print_exp e1 &
	Print.print_buf "," &
	Exp.print_exp e2 &
	Print.print_buf ")"
	------------------
	dump_debug_element EQUATION(e1,e2)

  rule	Print.print_buf "INITIALEQUATION(" &
	Exp.print_exp e1 &
	Print.print_buf "," &
	Exp.print_exp e2 &
	Print.print_buf ")"
	------------------
	dump_debug_element INITIALEQUATION(e1,e2)

  rule	Print.print_buf "ALGORITHM()"
	-------------------
	dump_debug_element ALGORITHM(_)

  rule	Print.print_buf "INITIALALGORITHM()"
	-------------------
	dump_debug_element INITIALALGORITHM(_)

  rule	Print.print_buf "COMP(" & Print.print_buf n & Print.print_buf "," &
	dump_debug (l) &
	Print.print_buf ")"
	--------------------------------------
	dump_debug_element COMP(n,l)

  rule	Print.print_buf "FUNCTION(" &
	Absyn.path_string fpath => fstr &
	Print.print_buf fstr & Print.print_buf "," &
	Types.print_type t & Print.print_buf "," &
	dump_debug (l) &
	Print.print_buf ")"
	--------------------------------------
	dump_debug_element FUNCTION(fpath,l,t)

  rule	Print.print_buf "UNKNOWN "
	---------------------------
	dump_debug_element _

end


relation find_element : (Element list, Element => ()) => Element option =

  axiom	find_element ([],_) => NONE

  rule	f(e)
	------------
	find_element (e::rest, f) => SOME(e)

  rule	not f(e) &
	find_element (rest, f) => e'
	-----------------
	find_element (e::rest, f) => e'

end


(***************************
 Graphviz relations to visualize 
 the dae
***************************)

relation dump_graphviz : DAElist => () =

  rule	build_graphviz dae => r &
	Graphviz.dump(r)
	----------------
	dump_graphviz dae

end


relation build_graphviz : DAElist => Graphviz.Node =

  rule	get_matching_elements (els, is_var) => vars &
	get_matching_elements (els, is_not_var) => nonvars &
	build_gr_list nonvars => nonvarnodes &
	build_gr_vars vars => varnodes &
	list_append (nonvarnodes,varnodes) => nodelist
	-----------------------------
	build_graphviz DAE(els) => Graphviz.NODE("DAE",[],nodelist)

end

relation build_gr_list : Element list => Graphviz.Node list =

  axiom build_gr_list [] => []

  rule	build_gr_element el => node &
	build_gr_list rest => nodelist
	---------------------------
	build_gr_list el::rest => node::nodelist

end

relation build_gr_vars : Element list => Graphviz.Node list =

  axiom build_gr_vars [] => []

  rule	build_gr_strlist (vars, build_gr_var_str, 10) => (strlist,_)
	---------------------------
	build_gr_vars vars => [Graphviz.LNODE("VARS",strlist,[Graphviz.box],[])]

end

relation build_gr_strlist : ('a list, 'a => string, int) => (string list, 'a list) =

  axiom	build_gr_strlist ([], _, _) => ([],[])

  rule	int_le (count, 0) => true	
	-------------------------------------
	build_gr_strlist (ignored, printer, count) => (["..."], ignored)

  rule	int_gt (count, 0) => true &
	int_sub (count, 1) => count' &
	build_gr_strlist (rest, printer, count') => (strlist, ignored) &
	printer (var) => str
	-------------------------------------
	build_gr_strlist (var::rest, printer, count) => (str::strlist, ignored)

end

relation build_gr_var_str : Element => string =

  rule	Exp.print_component_ref_str cr => str
	-------------------------------------
	build_gr_var_str VAR(cr,_,_,_,NONE,_) => str

  rule	Exp.print_component_ref_str cr => str &
	print_exp_str_special exp => expstr &
	string_append (str, " = ") => str' &
	string_append (str', expstr) => str''
	-------------------------------------
	build_gr_var_str VAR(cr,_,_,_,SOME(exp),_) => str''

end

relation print_exp_str_special : (Exp.Exp) => string =

  rule	string_append ("\\\"", s) => s' &
	string_append (s', "\\\"") => s''
	---------------------------------
	print_exp_str_special Exp.SCONST(s) => s''

  rule	Exp.print_exp_str exp => str
	----------------------------
	print_exp_str_special exp => str

end



relation build_gr_element : Element => Graphviz.Node =


  rule	Exp.print_component_ref_str cr => crstr &
	dump_kind_str vk => vkstr
	--------------------------
	build_gr_element VAR(cr,vk,vd,ty,NONE,_) => Graphviz.LNODE("VAR",[crstr,vkstr],[],[])

  rule	Exp.print_component_ref_str cr => crstr &
	dump_kind_str vk => vkstr &
	print_exp_str_special exp => expstr &
	string_append ("= ", expstr) => expstr'
	-------------------------------
	build_gr_element VAR(cr,vk,vd,ty,SOME(exp),_) => Graphviz.LNODE("VAR",[crstr,vkstr,expstr'],[],[])


  rule	Exp.print_component_ref_str cr => crstr &
	print_exp_str_special exp => expstr &
	string_append ("= ", expstr) => expstr'
	---------------------------------------
	build_gr_element DEFINE(cr,exp) => Graphviz.LNODE("DEFINE",[crstr,expstr'],[],[])

  rule	print_exp_str_special e1 => e1str &
	print_exp_str_special e2 => e2str
	---------------------------------------
	build_gr_element EQUATION(e1,e2) => Graphviz.LNODE("EQUATION",[e1str,"=",e2str],[],[])

  axiom	build_gr_element ALGORITHM(_) => Graphviz.NODE("ALGORITHM",[],[])

  rule	Exp.print_component_ref_str cr => crstr &
	print_exp_str_special exp => expstr &
	string_append ("= ", expstr) => expstr'
	---------------------------------------
	build_gr_element INITIALDEFINE(cr,exp) => Graphviz.LNODE("INITIALDEFINE",[crstr,expstr'],[],[])

  rule	print_exp_str_special e1 => e1str &
	print_exp_str_special e2 => e2str
	---------------------------------------
	build_gr_element INITIALEQUATION(e1,e2) => Graphviz.LNODE("INITIALEQUATION",[e1str,"=",e2str],[],[])

  axiom	build_gr_element INITIALALGORITHM(_) => Graphviz.NODE("INITIALALGORITHM",[],[])

  rule	build_graphviz dae => node
	---------------------------------------
	build_gr_element COMP(n,dae) => Graphviz.LNODE("COMP",[n],[],[node])

  rule	build_graphviz dae => node &
	Absyn.path_string fpath => fstr
	---------------------------------------
	build_gr_element FUNCTION(fpath,dae,ty) => Graphviz.LNODE("FUNCTION",[fstr],[],[node])


end

(** relation: get_variable_bindings_str
 ** This relation takes a `DAE.Element' list and returns a comma separated string of variable bindings.
 ** E.g. model A Real x=1; Real y=2; end A; => "1,2"
 **)
relation get_variable_bindings_str: Element list => string =
	
  rule	get_variable_list elts => varlst &
	get_bindings_str varlst => str
	------------------------------
	get_variable_bindings_str elts => str
end

relation get_variable_list: Element list  => Element list =

  rule	get_variable_list lst => res
	-------------------------------------
	get_variable_list  VAR(a,b,c,d,e,f)::lst => (VAR(a,b,c,d,e,f)::res)

  rule	get_variable_list lst => res
	----------------------------
	get_variable_list _::lst => res

  axiom	get_variable_list [] => []
end

relation get_bindings_str: Element list  => string =
	
  rule	Exp.print_exp_str e => expstr &
	string_append(expstr,",") => s3 &
	get_bindings_str(lst) => s4 &
	string_append(s3,s4) => str
	-----------------
	get_bindings_str((v as VAR(cr,_,_,_,SOME(e),_))::(lst as _::_)) => str

  rule	let s1 = "-," &
	get_bindings_str(lst) => s2 &
	string_append(s1,s2) => str
	-----------------
	get_bindings_str((v as VAR(cr,_,_,_,NONE,_))::(lst as _::_)) => str	

  rule	Exp.print_exp_str e => str 
	-----------------
	get_bindings_str([v as VAR(cr,_,_,_,SOME(e),_)]) => str

  axiom	get_bindings_str([v as VAR(cr,_,_,_,NONE,_)]) => ""	
end