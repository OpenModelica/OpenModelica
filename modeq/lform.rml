(* lform.rml
 *
 * Lform is very similar to the AST, with the difference that classes
 * are referred to with a reference to the Lform representation,
 * rather than with its name.
 *)

module Lform:

  with "exp.rml"
  with "absyn.rml"

  type Ident = Absyn.Ident

  type Path = Absyn.Path
  
  type Subscript = Absyn.Subscript

  type ComponentRef = Absyn.ComponentRef

  type ArrayDim = Absyn.ArrayDim

  datatype ElementArg = MODIFICATION of bool * Path * Modification
		      | REDECLARATION of bool * ElementSpec

  and	   Modification = CLASSMOD of ElementArg list
			| EQUALMOD of Exp.Exp

  and	   ElementSpec = CLASSDEF of bool		(* replaceable *)
				   * Class
		       | EXTENDS of Class * ElementArg list
		       | COMPONENT of bool	(* flow *)
				    * bool	(* parameter *)
				    * bool	(* constant *)
				    * bool	(* input *)
				    * bool	(* output *)
				    * Type	(* type name *)
				    * Ident (* component name *)
				    * ArrayDim option
				    * Modification option

  and	   Element = ELEMENT of bool		(* final *)
			      * string
			      * ElementSpec

  and	   ClassRestriction = CL_CLASS
			    | CL_MODEL
			    | CL_RECORD
			    | CL_BLOCK
			    | CL_CONNECTOR
			    | CL_TYPE
			    | CL_PACKAGE
			    | CL_FUNCTION

  and	   Type = REAL | INTEGER | BOOLEAN | STRING | CLASSTYPE of Class

  and	   Class = CLASS of Exp.Ident             (* Name *)
			  * bool			(* Partial *)
			  * ClassRestriction      (* Restricion *)
			  * ClassDef		(* Parts *)

  and	   ClassDef = PARTS of ClassPart list
		    | DERIVED of Class
			       * ArrayDim option
			       * ElementArg list

  and	   ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list

  and	   Equation = EQ_EXPR of Exp.Exp (* more later *)
		    | EQ_EQUALS of Exp.Exp * Exp.Exp

  and	   Algorithm = ALGORITHM (* Fill in later *)

  type Program = Class list

  relation convert_element : Absyn.Element => Element

end

(**********************************************************************
 *  Conversions
 **********************************************************************)

relation convert_list =
	
  axiom	convert_list(_,_,[]) => []
	
  rule	r(env,x) => x' &
	convert_list(r,env,xs) => xs'
	--------------------------------
	convert_list(r,env,x::xs) => x'::xs'
	
end

relation convert_option =
	
  axiom	convert_option(_,_,NONE) => NONE
	
  rule	r(env,x) => x'
	--------------
	convert_option(r,env,SOME(x)) => SOME(x')

end


relation convert_array_dim: Absyn.ArrayDim option => ArrayDim option =
	
  axiom	convert_array_dim(NONE) => NONE
  axiom	convert_array_dim(SOME(x)) => SOME(x)
	
end
	
relation convert_class_restr: Absyn.ClassRestriction => ClassRestriction =
	
  axiom	convert_class_restr(Absyn.CL_CLASS) => CL_CLASS
  axiom	convert_class_restr(Absyn.CL_MODEL) => CL_MODEL
  axiom	convert_class_restr(Absyn.CL_RECORD) => CL_RECORD
  axiom	convert_class_restr(Absyn.CL_BLOCK) => CL_BLOCK
  axiom	convert_class_restr(Absyn.CL_CONNECTOR) => CL_CONNECTOR
  axiom	convert_class_restr(Absyn.CL_TYPE) => CL_TYPE
  axiom	convert_class_restr(Absyn.CL_PACKAGE) => CL_PACKAGE
  axiom	convert_class_restr(Absyn.CL_FUNCTION) => CL_FUNCTION
	
end
	
relation convert_modification: (Env,Absyn.Modification) => Modification =
	
  rule	convert_list(convert_element_arg,env,l) => l'
	---------------------------------------------
	convert_modification(env,Absyn.CLASSMOD(l)) => CLASSMOD(l')
	
  axiom	convert_modification(env,Absyn.EQUALMOD(e)) => EQUALMOD(e)
	
end
and convert_element_arg: (Env,Absyn.ElementArg) => ElementArg =
	
  rule	convert_modification(env,m) => m'
	-----------------------------
	convert_element_arg(env,Absyn.MODIFICATION(f,c,m))
	  => MODIFICATION(f,c,m')
	
end
and convert_element_spec: (Env.Env,Absyn.ElementSpec) => ElementSpec =
	
  rule	convert_class(env,c) => c'
	-----------------------------------------------
	convert_element_spec(env,Absyn.CLASSDEF(r,c)) => CLASSDEF(r,c')

  rule	lookup_class(env,c) => c' &
	convert_list(convert_element_arg,env,a) => a'
	---------------------------------
	convert_element_spec(env,Absyn.EXTENDS(c,a)) => (env,EXTENDS(c',a'))

  rule	lookup_type(env,n) => t &
	convert_option(convert_modification,env,cm) => cm'
	------------------------------------------------------------------
	convert_element_spec(env,
		Absyn.COMPONENTS(f,p,c,i,o,n,[Absyn.COMPONENT(ci,cd,cm)]))
	  => (env,COMPONENT(f,p,c,i,o,t,ci,cd,cm'))

	(* FIXME *)

end
and convert_element : Absyn.Element => Element =
	
  rule	convert_element_spec s => s'
	------------------------------------------
	convert_element Absyn.ELEMENT(f,n,s)
	  => ELEMENT(f,n,s')
	
end
and convert_equation: (Env,Absyn.Equation) => Equation =
	
  axiom	convert_equation(env,Absyn.EQ_EXPR(e)) => EQ_EXPR(e)
  axiom	convert_equation(env,Absyn.EQ_EQUALS(e1,e2)) => EQ_EQUALS(e1,e2)

end
and convert_class_part: (Env,Absyn.ClassPart) => (Env, ClassPart) =
	
  axiom	convert_class_part(env,Absyn.PUBLIC([])) => (env,PUBLIC([]))
	
  rule	convert_element(env,e) => (env',e') &
	convert_class_part(env',Absyn.PUBLIC(es)) => (env'',PUBLIC(es'))
	---------------------
	convert_class_part(env,Absyn.PUBLIC(e::es)) => (env'',PUBLIC(e'::es'))
	
  axiom	convert_class_part(env,Absyn.PROTECTED([])) => (env,PROTECTED([]))
	
  rule	convert_element(env,e) => (env',e') &
	convert_class_part(env',Absyn.PROTECTED(es)) => (env'',PROTECTED(es'))
	---------------------
	convert_class_part(env,Absyn.PROTECTED(e::es))
	  => (env'',PROTECTED(e'::es'))
	
  axiom	convert_class_part(env,Absyn.EQUATIONS([])) => (env,EQUATIONS([]))
	
  rule	convert_equation(env,e) => e' &
	convert_class_part(env,Absyn.EQUATIONS(es)) => (env'',EQUATIONS(es'))
	--------------------------------------------------
	convert_class_part(env,Absyn.EQUATIONS(e::es))
	  => (env'',EQUATIONS(e'::es'))

end
and convert_class_def: (Env,Absyn.ClassDef) => ClassDef =
	
  axiom	convert_class_def(env,Absyn.PARTS([])) => PARTS([])
	
  rule	convert_class_part(env,p) => (env',p') &
	convert_class_def(env',Absyn.PARTS(ps)) => PARTS(ps')
	------------------------------------------
	convert_class_def(env,Absyn.PARTS(p::ps)) => PARTS(p'::ps')
	
  rule	lookup_class(env,i) => c &
	convert_array_dim(d) => d' &
	convert_list(convert_element_arg,env,a) => a'
	-----------------------------------------------
	convert_class_def(env, Absyn.DERIVED(i,d,a))
	  => DERIVED(c,d',a')
	
end
and convert_class: (Env,Absyn.Class) => (Env, Class) =
	
  rule	print "converting " & print i & print "\n" &
	convert_class_restr(r) => r' &
	convert_class_def(env,d) => d' &
	(* let *) c = CLASS(i,p,r',d') &
	extend_env(env,c) => env'
	------------------------------------------------------
	convert_class(env, Absyn.CLASS(i,p,r,d)) => (env',c)
	
end
	
and convert_e: (Env,Absyn.Class list) => (Env, Class) =
	
  rule	convert_class(env,c) => c'
	--------------------------
	convert_e(env,[c]) => c'
	
  rule	convert_class(env,c) => c' &
	Env.extend_frame_c(env,c') => env' &
	convert_e(env',cs) => cc
	--------------------------------
	convert_e(env,c::cs) => (env'',cc)
	
end
and elaborate : Absyn.Program => Class =
	
  rule	Builtin.initial_env => env &
	convert_e(env,cs) => (env',c)
	--------------------------
	elaborate cs => c
	
end
