(* lform.rml
 *
 * Lform is very similar to the AST, with the difference that classes
 * are referred to with a reference to the Lform representation,
 * rather than with its name.
 *)

module Lform:

  with "exp.rml"
  with "absyn.rml"

  type Ident = Absyn.Ident

  type Subscript = Absyn.Subscript

  type ComponentRef = Absyn.ComponentRef

  type ArrayDim = Absyn.ArrayDim

  datatype ElementArg = MODIFICATION of bool * Path * Modification
		      | REDECLARATION of bool * ElementSpec

  and	   Modification = CLASSMOD of ElementArg list
			| EQUALMOD of Exp.Exp

  and	   ElementSpec = CLASSDEF of bool		(* replaceable *)
				   * Class
		       | EXTENDS of Class * ElementArg list
		       | COMPONENTS of bool	(* flow *)
				     * bool	(* parameter *)
				     * bool	(* constant *)
				     * bool	(* input *)
				     * bool	(* output *)
				     * Type	(* type name *)
				     * Ident (* component name *)
				     * ArrayDim option
				     * Modification option

  and	   Element = ELEMENT of bool		(* final *)
			      * ElementSpec

  and	   ClassRestriction = CL_CLASS
			    | CL_MODEL
			    | CL_RECORD
			    | CL_BLOCK
			    | CL_CONNECTOR
			    | CL_TYPE
			    | CL_PACKAGE
			    | CL_FUNCTION

  and	   Type = REAL | INTEGER | CLASSTYPE of Class

  and	   Class = CLASS of Exp.Ident             (* Name *)
			  * bool			(* Partial *)
			  * ClassRestriction      (* Restricion *)
			  * ClassDef		(* Parts *)

  and	   ClassDef = PARTS of ClassPart list

  and	   ClassPart = PUBLIC of Element list
		     | PROTECTED of Element list
		     | EQUATIONS of Equation list
		     | ALGORITHMS of Algorithm list

  and	   Equation = EQ_EXPR of Exp.Exp (* more later *)
		    | EQ_EQUALS of Exp.Exp * Exp.Exp

  and	   Algorithm = ALGORITHM (* Fill in later *)

  type Program = Class list

  relation convert: Absyn.Program => Program

end

(**********************************************************************
 *  Environment handling
 **********************************************************************)

type Binding = Exp.Ident * Class

type Env = Binding list

val empty_env = []

relation mk_binding : (Exp.Ident,Class) => Binding =

	axiom mk_binding(n,c) => ((n,c))

end

relation extend_env : (Env,Class) => Env =

	rule	mk_binding(n,c) => b
		------------------------------------
		extend_env(e,c as CLASS(n,p,r,d)) => b::e

end

relation lookup_class: (Env,Absyn.Path) => Class =

(*	axiom	lookup_class([],_) *)

	rule	n = i
		-------------------------------
		lookup_class((n,c)::env,Exp.IDENT(i)) => c

	rule	lookup_class(env,Exp.IDENT(i)) => c
		(* find_in_class(c,p) FIXME *)
		------------------------
		lookup_class(env,Exp.QUALIFIED(i,p)) => c

end

relation lookup_type: (Env,Absyn.Path) => Type =

	axiom	lookup_type(_,Exp.IDENT("RealType")) => REAL
	axiom	lookup_type(_,Exp.IDENT("IntType")) => INTEGER

	rule	lookup_class(env,p) => c
		------------------------
		lookup_type(env,p) => CLASSTYPE(c)

end		

(**********************************************************************
 *  Conversions
 **********************************************************************)

relation convert_list =

  axiom	convert_list(_,_,[]) => []

  rule	r(env,x) => x' &
	convert_list(r,env,xs) => xs'
	--------------------------------
	convert_list(r,env,x::xs) => x'::xs'

end

relation convert_list_env =

  axiom	convert_list_env(_,env,[]) => ((env,[]))

  rule	r(env,x) => ((env',x')) &
	convert_list_env(r,env',xs) => ((env'',xs'))
	----------------------------------------
	convert_list_env(r,env,x::xs) => ((env'',x'::xs'))

end

relation convert_option =

  axiom	convert_option(_,_,NONE) => NONE

  rule	r(env,x) => x'
	--------------
	convert_option(r,env,SOME(x)) => SOME(x')

end


relation convert_array_dim: Absyn.ArrayDim option => ArrayDim option =

	axiom	convert_array_dim(NONE) => NONE
	axiom	convert_array_dim(SOME(x)) => SOME(x)

end

relation convert_class_restr: Absyn.ClassRestriction => ClassRestriction =

	axiom	convert_class_restr(Absyn.CL_CLASS) => CL_CLASS
	axiom	convert_class_restr(Absyn.CL_MODEL) => CL_MODEL
	axiom	convert_class_restr(Absyn.CL_RECORD) => CL_RECORD
	axiom	convert_class_restr(Absyn.CL_BLOCK) => CL_BLOCK
	axiom	convert_class_restr(Absyn.CL_CONNECTOR) => CL_CONNECTOR
	axiom	convert_class_restr(Absyn.CL_TYPE) => CL_TYPE
	axiom	convert_class_restr(Absyn.CL_PACKAGE) => CL_PACKAGE
	axiom	convert_class_restr(Absyn.CL_FUNCTION) => CL_FUNCTION

end

relation convert_modification: (Env,Absyn.Modification) => Modification =

  rule	convert_list(convert_element_arg,env,l) => l'
	---------------------------------------------
	convert_modification(env,Absyn.CLASSMOD(l)) => CLASSMOD(l')

  axiom	convert_modification(env,Absyn.EQUALMOD(e)) => EQUALMOD(e)

end
and convert_element_arg: (Env,Absyn.ElementArg) => ElementArg =

  rule	convert_modification(env,m) => m'
	-----------------------------
	convert_element_arg(env,Absyn.MODIFICATION(f,c,m)) =>
		MODIFICATION(f,c,m')

end
and convert_element_spec: (Env,Absyn.ElementSpec) => Env*ElementSpec =

  rule	convert_class(env,c) => ((env',c'))
	-----------------------------------------------
	convert_element_spec(env,Absyn.CLASSDEF(r,c)) =>
		((env',CLASSDEF(r,c')))

  rule	lookup_class(env,c) => c' &
	convert_list(convert_element_arg,env,a) => a'
	---------------------------------
	convert_element_spec(env,Absyn.EXTENDS(c,a)) =>
		((env,EXTENDS(c',a')))

  rule	lookup_type(env,n) => t &
	convert_option(convert_modification,env,cm) => cm'
	------------------------------------------------------------------
	convert_element_spec(env,
		Absyn.COMPONENTS(f,p,c,i,o,n,[Absyn.COMPONENT(ci,cd,cm)])) =>
		((env,COMPONENTS(f,p,c,i,o,t,ci,cd,cm')))

	(* FIXME *)

end
and convert_element: (Env,Absyn.Element) => Env*Element =

	rule	convert_element_spec(env,s) => ((env',s'))
		------------------------------------------
		convert_element(env,Absyn.ELEMENT(f,s)) =>
			((env',ELEMENT(f,s')))

end
and convert_equation: (Env,Absyn.Equation) => Equation =

	axiom	convert_equation(env,Absyn.EQ_EXPR(e)) => EQ_EXPR(e)
	axiom	convert_equation(env,Absyn.EQ_EQUALS(e1,e2)) =>
			EQ_EQUALS(e1,e2)

end
and convert_class_part: (Env,Absyn.ClassPart) => Env*ClassPart =

	axiom	convert_class_part(env,Absyn.PUBLIC([])) => ((env,PUBLIC([])))

	rule	convert_element(env,e) => ((env',e')) &
		convert_class_part(env',Absyn.PUBLIC(es)) =>
			((env'',PUBLIC(es')))
		---------------------
		convert_class_part(env,Absyn.PUBLIC(e::es)) =>
			((env'',PUBLIC(e'::es')))

	axiom	convert_class_part(env,Absyn.PROTECTED([])) =>
			((env,PROTECTED([])))

	rule	convert_element(env,e) => ((env',e')) &
		convert_class_part(env',Absyn.PROTECTED(es)) =>
			((env'',PROTECTED(es')))
		---------------------
		convert_class_part(env,Absyn.PROTECTED(e::es)) =>
			((env'',PROTECTED(e'::es')))

	axiom	convert_class_part(env,Absyn.EQUATIONS([])) =>
			((env,EQUATIONS([])))

	rule	convert_equation(env,e) => e' &
		convert_class_part(env,Absyn.EQUATIONS(es)) =>
			((env'',EQUATIONS(es')))
		--------------------------------------------------
		convert_class_part(env,Absyn.EQUATIONS(e::es)) =>
			((env'',EQUATIONS(e'::es')))

end
and convert_class_def: (Env,Absyn.ClassDef) => ClassDef =

	axiom	convert_class_def(env,Absyn.PARTS([])) => PARTS([])

	rule	convert_class_part(env,p) => ((env',p')) &
		convert_class_def(env',Absyn.PARTS(ps)) => PARTS(ps')
		------------------------------------------
		convert_class_def(env,Absyn.PARTS(p::ps)) => PARTS(p'::ps')

(* FIXME
	rule	lookup_class(env,i) => c &
		convert_array_dim(d) => d' &
		convert_element_arg(env,a) => a'
		-----------------------------------------------
		convert_class_def(env, Absyn.DERIVED(i,d,a)) =>
			PARTS([PUBLIC(ELEMENT(false,a'))])
*)

end
and	 convert_class: (Env,Absyn.Class) => Env * Class =

	rule	print "converting " & print i & print "\n" &
		convert_class_restr(r) => r' &
		convert_class_def(env,d) => d' &
		(* let *) c = CLASS(i,p,r',d') &
		extend_env(env,c) => env'
		------------------------------------------------------
		convert_class(env, Absyn.CLASS(i,p,r,d)) => ((env',c))

end
and      convert_e: (Env,Absyn.Class list) => Env * Program =

	axiom	convert_e(env,[]) => ((env,[]))

	rule	convert_class(env,c) => ((env',cc)) &
		convert_e(env',cs) => ((env'',ccs))
		--------------------------------
		convert_e(env,c::cs) => ((env'',cc::ccs))

end
and      convert: Absyn.Program => Program =

	rule	convert_e(empty_env,cs) => ((env,cs'))
		--------------------------
		convert cs => cs'

end
