(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id$
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The implementation of the relations are excluded from the report,
 ** as they occupy a lot of space and do not convey any useful
 ** semantic information.
 **)


 module Dump:
  
  with "absyn.rml"
with "interactive.rml"							  
with "debug.rml"

  type Ident = string

(* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation unparse_str: Absyn.Program => string
  relation dump_istmt: Interactive.InteractiveStmts => ()
  relation direction_symbol: Absyn.Direction => string
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_arraydim_str: Absyn.ArrayDim => string 
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation print_named_arg: Absyn.NamedArg => () 
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_select: (bool,string,string) => ()
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
  relation get_option_str: ('a option, 'a => string) => string 
  relation unparse_annotation_option: Absyn.Annotation option => string 
  relation unparse_within: Absyn.Within => string 	
  end




(*!ignorecode*)

with "classinf.rml"
with "rtopts.rml"
with "print.rml"
with "util.rml"

(* Relations *)

relation dump : Absyn.Program => () =
	
  axiom	dump Absyn.PROGRAM([],_) => ()
	
  rule	print_class c & Print.print_buf "\n" &
	dump Absyn.PROGRAM(cs,w)
	------------------------
	dump Absyn.PROGRAM(c::cs,w) => ()

end

relation unparse_str : Absyn.Program => string =
	
  axiom	unparse_str Absyn.PROGRAM([],_) => ""
	
  rule	unparse_within(w) => s1 &
	get_string_list(c,unparse_class_str,"\n") => s2 &
	string_append(s1,s2) => str
	------------------------
	unparse_str Absyn.PROGRAM(c,w) => str
end

relation unparse_within: Absyn.Within => string =
  axiom unparse_within Absyn.TOP => ""
	
  rule	Absyn.path_string p => s1 &
	Util.string_append_list(["within ",s1,";\n"]) => str
	------------------------------
	unparse_within Absyn.WITHIN(p) => str
end

relation unparse_class_str: Absyn.Class => string =
  rule	select_string(p, "partial ","") => s1 &
	select_string(f, "final ","") => s2 &
	unparse_restriction_str (r) => s3 &
	get_string_list (parts,unparse_class_part_str,"") => s4 &
	unparse_string_comment_option(optcmt) => s5 &
	Util.string_append_list([s1, s2, s3, " ", n, s5, "\n", s4, "\nend ", n, ";\n"]) => str
	-----------------------------
	unparse_class_str(Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,optcmt))) => str

  rule	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	unparse_restriction_str (r)  => s3 &
	string_append(s1,s2) => s4 &
	Absyn.path_string i => s5 &
	get_option_str(dim,print_arraydim_str) => s6 &
	unparse_mod1_str m => s7 &
	unparse_comment_option(optcmt) => s8 &
	Util.string_append_list([s1,s2,s3," ",n,"= ",s4,s5,s6,s7,s8,";\n"]) => str
	------------------------------
	unparse_class_str(Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,dim,m,optcmt))) => str
	
  rule	select_string(p, "partial ", "") => s1 &
	select_string(f, "final ", "") => s2 &
	unparse_restriction_str (r)  => s3 &
	unparse_enumliterals(l) => s4 &
	unparse_comment_option(cmt) => s5 &
	Util.string_append_list([s1,s2,s3," ",n,"= enumeration(",s4,")",s5,";\n"]) => str
	-------------------------------
	unparse_class_str(Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(l,cmt))) => str    
end 

relation unparse_comment_option: (Absyn.Comment option) => string =

	axiom unparse_comment_option(NONE) => ""
	
  rule	unparse_annotation_option(annopt) => s1 &
	Util.string_append_list([s1," ", cmt]) => str
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,SOME(cmt)))) => str
	
  rule	unparse_annotation_option(annopt) => str 
	---------------------------------------------
	unparse_comment_option(SOME(Absyn.COMMENT(annopt,NONE))) => str
	
end

relation unparse_enumliterals : Absyn.EnumLiteral list => string =
	
  axiom	unparse_enumliterals([]) => ""
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_enumliterals(a::b)=> s2 &
	Util.string_append_list([str,s1,", ",s2]) => res
	---------------------------
	unparse_enumliterals(Absyn.ENUMLITERAL(str,optcmt)::a::b) => res
	
  rule	unparse_comment_option(optcmt) => s1 &
	unparse_comment_option(optcmt2) => s2 &
	Util.string_append_list([str,s1,", ",str2,s2]) => res
	---------------------------
	unparse_enumliterals([Absyn.ENUMLITERAL(str,optcmt),Absyn.ENUMLITERAL(str2,optcmt2)]) => res
end

relation unparse_restriction_str : Absyn.Restriction => string =
	
  axiom	unparse_restriction_str Absyn.R_CLASS			=> "class"
  axiom	unparse_restriction_str Absyn.R_MODEL			=> "model"
  axiom	unparse_restriction_str Absyn.R_RECORD			=> "record"
  axiom	unparse_restriction_str Absyn.R_BLOCK			=> "block"
  axiom	unparse_restriction_str Absyn.R_CONNECTOR		=> "connector"
  axiom	unparse_restriction_str Absyn.R_TYPE			=> "type"
  axiom	unparse_restriction_str Absyn.R_PACKAGE			=> "package"
  axiom	unparse_restriction_str Absyn.R_FUNCTION			=> "function"
  axiom	unparse_restriction_str  Absyn.R_PREDEFINED_INT		=> "Integer"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_REAL		=> "Real"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_STRING	=> "String"
  axiom	unparse_restriction_str Absyn.R_PREDEFINED_BOOL		=> "Boolean"
	
end

relation dump_istmt : Interactive.InteractiveStmts => () =
  rule	Print.print_buf ("IALG(") &
	print_algorithmitem(alg) => () &
	Print.print_buf ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)])) => ()
	
  rule	Print.print_buf ("IEXP(") &
	print_exp(expr) &
	Print.print_buf ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)])) => ()
	
  rule Print.print_buf "IALG(" &
	print_algorithmitem(alg) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l)) => ()
	
  rule Print.print_buf "IEXP(" &
	print_exp(expr) => () &
	Print.print_buf "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l)) => ()
	
  axiom	dump_istmt(_) => ()
end
(**)

relation print_class: Absyn.Class => () =
	
  rule	print_class_restriction(r) & Print.print_buf "(" &
	Print.print_buf n & Print.print_buf "," & print_select(p,"PARTIAL,","") &
	print_list_debug("print_class1",parts,print_class_part,",") & Print.print_buf ")"
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.PARTS(parts,_))) => ()
	
  rule	print_class_restriction(r) & Print.print_buf "(" &
	Print.print_buf n & Print.print_buf "," & print_select(p,"PARTIAL,","") &
	Print.print_buf ") = " & print_path(i) &
	print_class_modification(m)
	----------------------------------------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.DERIVED(i,_,m,_))) => ()
	
  rule	print_class_restriction(r) & Print.print_buf "(" &
	Print.print_buf n & Print.print_buf "," &
	print_select(p,"PARTIAL,","") &
	Print.print_buf "ENUMERATION(...)\n"
	----------
	print_class(Absyn.CLASS(n,p,f,e,r,Absyn.ENUMERATION(l,_))) => ()
end

(**)

relation print_class_restriction: Absyn.Restriction => () =

  rule	Absyn.print_restr re
	-----------------------
	print_class_restriction re
	
end


(**)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	Print.print_buf "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & Print.print_buf ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

relation unparse_class_modification_str: Absyn.Modification => string =

  axiom	unparse_class_modification_str(Absyn.CLASSMOD([],_)) => ""
	
  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str 
	---------------------------------------------------------
	unparse_class_modification_str(Absyn.CLASSMOD(l,_)) => str
	
end
(**)

relation print_element_arg =
	
  rule	Print.print_buf "ARG(" &
	print_select(f,"FINAL,",",") &
	print_component_ref(r) &
	print_modification(m) &
	Print.print_buf ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,each,r,m,optcmt))

  rule	Print.print_buf "REDECLARATION(" &
	print_select(f,"FINAL,",",") &
	print_elementspec spec &
	Print.print_buf ",_)"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,each,spec,_))

end

relation unparse_element_arg_str: (Absyn.ElementArg) => string =
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","") => s2 &
	print_component_ref_str(r) => s3 &
	unparse_modification_str(m) => s4 &
	unparse_string_comment_option(optstr) => s5 &
	Util.string_append_list([s1, s2, s3, s4, s5]) => str
	-------------------------------------------
	unparse_element_arg_str(Absyn.MODIFICATION(f,each,r,m,optstr)) => str
	
  rule	unparse_each_str ( each ) => s1 &
	select_string(f,"final ","")  => s2 &
	unparse_elementspec_str spec => s3 &
	get_option_str(constropt,unparse_elementspec_str) => s4 &
	Util.string_append_list([s1,s2,"redeclare ",s3," ",s4]) => str
	-----------------------------------------------------------
	unparse_element_arg_str(Absyn.REDECLARATION(f,each, spec,constropt)) => str
end

(**)

relation unparse_each_str: (Absyn.Each) => string =

  axiom	unparse_each_str(Absyn.EACH) => "each "

  axiom	unparse_each_str(Absyn.NON_EACH) => ""
end
				
relation print_class_part: Absyn.ClassPart => () =

  rule	Print.print_buf "PUBLIC(" & print_elementitems(el) & Print.print_buf ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	Print.print_buf "PROTECTED(" & print_elementitems(el) & Print.print_buf ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	Print.print_buf "EQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	Print.print_buf ")"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))

  rule	Print.print_buf "INITIALEQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	Print.print_buf ")"
	--------------------------------------
	print_class_part(Absyn.INITIALEQUATIONS(eqs))
	
  rule	Print.print_buf "ALGORITHMS(" &
	print_list_debug("print_class_part",eqs,print_algorithmitem,",") &
	Print.print_buf ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(eqs))

  rule	Print.print_buf "INITIALALGORITHMS(" &
	print_list_debug("print_class_part",eqs,print_algorithmitem,",") &
	Print.print_buf ")"
	--------------------------------------
	print_class_part(Absyn.INITIALALGORITHMS(eqs))

  rule	Print.print_buf "EXTERNAL(" &
	print_external_decl (edecl) &
	Print.print_buf ")"
	-------------------
	print_class_part(Absyn.EXTERNAL(edecl))

end

relation print_external_decl : Absyn.ExternalDecl => () =

  rule	get_option_str (id, identity) => idstr &
	get_option_str (lang, identity) => langstr &
	get_option_str (cref, print_component_ref_str) => crefstr &
	print_list_str(exps,print_exp_str,",") => expstr &
	Util.string_append_list([idstr, ", ", langstr, ", ", crefstr, ", (",
				 expstr, ")"]) => str &
	Print.print_buf str
	-------------------
	print_external_decl Absyn.EXTERNALDECL(id, lang, cref, exps)
end


relation unparse_class_part_str: Absyn.ClassPart => string =

  rule	get_string_list(el,unparse_elementitem_str,"\n") => s1 & 
	string_append("public \n",s1) => str 
	-----------------------------------------------
	unparse_class_part_str(Absyn.PUBLIC(el)) => str
	
  rule	get_string_list(el,unparse_elementitem_str,"\n") => s1 & 
	string_append("protected \n",s1) => str 
	---------------------------------------
	unparse_class_part_str(Absyn.PROTECTED(el)) => str
	
  rule	get_string_list(eqs,unparse_equationitem_str,"\n") => s1 & 
	string_append("\nequation \n",s1) => str 
	--------------------------------------
	unparse_class_part_str(Absyn.EQUATIONS(eqs)) => str
				
  rule	get_string_list(eqs,unparse_equationitem_str,"\n") => s1 & 
	string_append("\ninitial equation \n",s1) => str 
	--------------------------------------
	unparse_class_part_str(Absyn.INITIALEQUATIONS(eqs)) => str

  rule	get_string_list(eqs,unparse_algorithm_str,"\n") => s1 & 
	string_append("algorithm \n",s1) => str 
	--------------------------------------
	unparse_class_part_str(Absyn.ALGORITHMS(eqs)) => str

  rule	get_string_list(eqs,unparse_algorithm_str,"\n") => s1 & 
	string_append("initial algorithm \n",s1) => str 
	-----------------------------------------------
	unparse_class_part_str(Absyn.INITIALALGORITHMS(eqs)) => str

  rule	get_option_str(lang,identity) => langstr &
	print_component_ref_str output => outputstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	Util.string_append_list(["\nexternal ",langstr," ", outputstr, "=",ident,"(",expstr,");\n"]) => str
	--------------------------------------
	unparse_class_part_str(Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,SOME(output),expl)))
	    => str

  rule	get_option_str(lang,identity) => langstr &
	print_list_str(expl,print_exp_str,",") => expstr &
	string_append(langstr," ") => s1 &
	Util.string_append_list(["\nexternal ", langstr," ",ident,"(",expstr,");\n"]) => str
	--------------------------------------
	unparse_class_part_str(Absyn.EXTERNAL(Absyn.EXTERNALDECL(SOME(ident),lang,NONE,expl))) 
	    => str

  axiom	unparse_class_part_str(Absyn.EXTERNAL(Absyn.EXTERNALDECL(NONE,_,NONE,_))) 
	    => "\n  external;\n"
end

(**)

relation print_elementitems: Absyn.ElementItem list => () =
  axiom print_elementitems [] => ()

  rule  print_element e
	---------------
	print_elementitems[ Absyn.ELEMENTITEM(e)]

  rule	print_annotation a
	------------------
	print_elementitems([Absyn.ANNOTATIONITEM(a)])
	
  rule	print_element e &
	print_elementitems els
	---------------
	print_elementitems Absyn.ELEMENTITEM(e)::els 

  rule	print_annotation a &
	print_elementitems els
	------------------
	print_elementitems Absyn.ANNOTATIONITEM(a)::els

  rule	Print.print_buf "Error print_elementitems\n"
	--------------
	print_elementitems _ 
end

relation print_annotation: Absyn.Annotation => () =	
  rule	Print.print_buf "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	Print.print_buf ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end
	
relation unparse_elementitem_str: Absyn.ElementItem => string =

  rule	unparse_element_str e => str
	----------------------------
	unparse_elementitem_str Absyn.ELEMENTITEM(e) => str

  rule	unparse_annotation_option SOME(a) => str
	-------------------------------
	unparse_elementitem_str Absyn.ANNOTATIONITEM(a) => str
	
end

relation unparse_annotation_option: Absyn.Annotation option => string =	
	
  rule	unparse_class_modification_str Absyn.CLASSMOD(mod,NONE) => s1 &
	string_append(" annotation(",s1) => s2 &
	string_append(s2,")") => str
	----------------------------
	unparse_annotation_option(SOME(Absyn.ANNOTATION(mod))) => str

  axiom	unparse_annotation_option(NONE) => ""
end


(**)

relation print_element: Absyn.Element => () =
	
  rule	Print.print_buf "ELEMENT(" & print_select(final,"FINAL,","") &
	print_innerouter inout &
	Print.print_buf ", " &
	print_elementspec spec & Print.print_buf ")"
	----------------
	print_element (Absyn.ELEMENT(final,repl,inout,_,spec,constr))

end

relation unparse_element_str: Absyn.Element => string = 

  rule	select_string(final, "final ", "") => s1 &
	select_string(repl, "replaceable ", "") => s2 &
	unparse_innerouter_str inout => s3 &
	unparse_elementspec_str spec => s4 &
	Util.string_append_list([s1, s2, s3, s4, ";"]) => str
	----------------------------
	unparse_element_str Absyn.ELEMENT(final,repl,inout,_,spec,constr) => str
end


relation print_innerouter: Absyn.InnerOuter => () =
   rule Print.print_buf "INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule Print.print_buf "OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule Print.print_buf " "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end

relation unparse_innerouter_str: Absyn.InnerOuter => string =
	
  axiom	unparse_innerouter_str(Absyn.INNER) => "innner"

  axiom	unparse_innerouter_str(Absyn.OUTER) => "outer"

  axiom	unparse_innerouter_str(Absyn.UNSPECIFIED) => ""
end
(**)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	Print.print_buf "CLASSDEF(" & print_select(repl,"REPLACEABLE,","") &
	print_class cl & Print.print_buf ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	Print.print_buf "EXTENDS(" & print_path p & Print.print_buf "," &
	print_list_debug("print_elementspec",l,print_element_arg,",") & Print.print_buf ")"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	Print.print_buf "COMPONENTS(" &
	print_elementattr(attr) & Print.print_buf "," &
	print_path(t) & Print.print_buf "," &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	Print.print_buf ")"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	Print.print_buf "IMPORT(" &
	print_import i &
	Print.print_buf ")"
	--------
	print_elementspec(Absyn.IMPORT(i,_))

  rule	Print.print_buf " ##ERROR## "
	-------------------
	print_elementspec(_)

end

relation unparse_elementspec_str: Absyn.ElementSpec => string =
	
  rule	select_string(repl,"replaceable,","") => s1 &
	unparse_class_str cl => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_elementspec_str(Absyn.CLASSDEF(repl,cl)) => str
	
  rule	Absyn.path_string p => s1 &
	string_append("extends ",s1) => s2 &
	get_string_list(l,unparse_element_arg_str,",") => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_elementspec_str(Absyn.EXTENDS(p,l)) => str

  rule	Absyn.path_string(t) => s1 &
	unparse_elementattr_str(attr) => s2 &
	string_append(s1,s2) => s3 &
	string_append(s3," ") => s4 &
	get_string_list(cs, unparse_componentitem_str, ",") => s5 &
	string_append(s4,s5) => str
	------------------------------------------
	unparse_elementspec_str(Absyn.COMPONENTS(attr,t,cs)) => str
	
  rule	unparse_import_str i => s1 &
	string_append("import ",s1) => s2 &
	string_append(s2,";") => str
	----------------------------
	unparse_elementspec_str(Absyn.IMPORT(i,_)) => str

  rule	Print.print_buf " ##ERROR## "
	-------------------
	unparse_elementspec_str(_) => ""

end

relation print_import : Absyn.Import => () =

  rule	Print.print_buf i & Print.print_buf " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & Print.print_buf ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end
relation unparse_import_str : Absyn.Import => string =

  rule	string_append(i," = ") => s1 &
	Absyn.path_string p => s2 &
	string_append(s1,s2) => str
	-----------------------
	unparse_import_str(Absyn.NAMED_IMPORT(i,p)) => str

  rule	Absyn.path_string p => str
	-------------
	unparse_import_str(Absyn.QUAL_IMPORT(p)) => str

  rule	Absyn.path_string p => s1 &
	string_append(s1, ".*") => str
	--------------------------
	unparse_import_str(Absyn.UNQUAL_IMPORT(p)) => str
end

relation print_elementattr: Absyn.ElementAttributes => () =

  rule	Print.print_buf "ATTR(" &
	select_string(fl,"FLOW,","") => fs &
	variability_symbol(var) => vs &
	direction_symbol(dir) => ds &
	let sl = [fs,vs,ds] &
	print_list_debug("print_elementattr",sl, print, ",") &
	Print.print_buf ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	Print.print_buf " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

relation unparse_elementattr_str: Absyn.ElementAttributes => string =

  rule	
	select_string(fl,"flow ","") => fs &
	unparse_variability_symbol_str(var) => vs &
	unparse_direction_symbol_str(dir) => ds &
	string_append(fs,vs) => s1 &
	string_append(s1," ") => s2 &
	string_append(s2,ds) => s3 &
	string_append(s3," ") => str
	-----------------------------------
	unparse_elementattr_str(Absyn.ATTR(fl,var,dir,adim)) => str

  rule	Print.print_buf " ##ERROR## print_elementattr"
	-------------------
	unparse_elementattr_str(_) => ""

end

relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => ""
  axiom	variability_symbol(Absyn.DISCRETE) => "DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "PARAM"
  axiom	variability_symbol(Absyn.CONST) => "CONST"

end

relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => ""
  axiom	direction_symbol(Absyn.INPUT) => "INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "OUTPUT"

end

relation unparse_variability_symbol_str: Absyn.Variability => string =

  axiom unparse_variability_symbol_str(Absyn.VAR) => ""
  axiom	unparse_variability_symbol_str(Absyn.DISCRETE) => "discrete"
  axiom	unparse_variability_symbol_str(Absyn.PARAM) => "parameter"
  axiom	unparse_variability_symbol_str(Absyn.CONST) => "const"

end

relation unparse_direction_symbol_str: Absyn.Direction => string =

  axiom unparse_direction_symbol_str(Absyn.BIDIR) => ""
  axiom	unparse_direction_symbol_str(Absyn.INPUT) => "input"
  axiom	unparse_direction_symbol_str(Absyn.OUTPUT) => "output"

end

(**)

relation print_component: Absyn.Component => () =

  rule	Print.print_buf n &
	print_arraydim a &
	print_option(m,print_modification) 
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

relation print_componentitem: Absyn.ComponentItem => () =

  rule	Print.print_buf "COMPONENTITEM(" &
	print_component c &
	Print.print_buf ",..)"
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,optcmt))
end

relation unparse_component_str: Absyn.Component => string =

  rule	print_arraydim_str a => s1 &
	string_append(n,s1) => s2 &
	get_option_str(m,unparse_modification_str) => s3 &
	string_append(s2,s3) => str
	------------------------------------------
	unparse_component_str(Absyn.COMPONENT(n,a,m)) => str
end

relation unparse_componentitem_str: Absyn.ComponentItem => string =

  rule	
	unparse_component_str c => s1 &
	unparse_comment_option cmtopt => s2 &
	string_append(s1,s2) => str
	------------------------------------------
	unparse_componentitem_str(Absyn.COMPONENTITEM(c,cmtopt)) => str
end

(**)

relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

relation print_subscript: Absyn.Subscript => () =

  rule	Print.print_buf ":"
	---------
	print_subscript(Absyn.NOSUB)

  rule	print_exp(e1)
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(* Modifications *)

relation print_modification: Absyn.Modification => () =
	
  rule	print_mod1 l & print_mod2 e
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	Print.print_buf "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	Print.print_buf "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	Print.print_buf ")"
	------------------------------------
	print_mod1 l

end

relation print_mod2 : Absyn.Exp option => () =

  axiom	print_mod2 NONE

  rule	Print.print_buf " = " & print_exp(e)
	-------------------------
	print_mod2 SOME(e)

end


relation unparse_modification_str: Absyn.Modification => string =
	
  rule	unparse_mod1_str l => s1 & 
	unparse_mod2_str e => s2 &
	string_append(s1,s2) => str
	-------------------------
	unparse_modification_str(Absyn.CLASSMOD(l, e)) => str
	
  rule	Print.print_buf " Failure MODIFICATION \n"
	-------------
	unparse_modification_str(_) => ""
	
end

relation unparse_mod1_str: Absyn.ElementArg list => string =

  axiom	unparse_mod1_str [] => ""

  rule	get_string_list(l,unparse_element_arg_str,",") => s1 &
	string_append("(",s1) => s2 &
	string_append(s2,")") => str
	------------------------------------
	unparse_mod1_str l => str
end

relation unparse_mod2_str : Absyn.Exp option => string =

  axiom	unparse_mod2_str NONE => ""

  rule	print_exp_str(e) => s1 &
	string_append("=",s1) => str
	-------------------------
	unparse_mod2_str SOME(e) => str
end

(* Equations *)

relation print_equation: Absyn.Equation => () =
	
  rule	Print.print_buf "EQ_EXPR(" & print_exp(e) & Print.print_buf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EXPR(e))
	
  rule	Print.print_buf "IF (" & print_exp(e) & Print.print_buf ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	Print.print_buf " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	Print.print_buf "EQ_EQUALS(" & print_exp(e1) & Print.print_buf "," &
	print_exp(e2) & Print.print_buf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	Print.print_buf "EQ_CONNECT(" & print_component_ref(e1) & Print.print_buf "," &
	print_component_ref(e2) & Print.print_buf ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	Print.print_buf "FOR " & Print.print_buf i & Print.print_buf " in " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_equation",el, print_equationitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	Print.print_buf " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

relation print_equationitem: Absyn.EquationItem => () =
  rule	Print.print_buf "EQUATIONITEM(" &
	print_equation eq &
	Print.print_buf ",... " &
	Print.print_buf ")\n"
	--------------
	print_equationitem Absyn.EQUATIONITEM(eq,_)
	
  rule	Print.print_buf "EQUATIONITEMANN(...)\n" 
	--------------
	print_equationitem Absyn.EQUATIONITEMANN(_)
end

relation unparse_equation_str: Absyn.Equation => string =
	
  rule	print_exp_str(e) => str 
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_EXPR(e)) => str
	
  rule	print_exp_str(e) => s1 &
	get_string_list(tb,unparse_equationitem_str, ";") => s2 &
	get_string_list(eb,unparse_eq_elseif_str, " ") => s3 &
	get_string_list(fb,unparse_equationitem_str,"") => s4 &
	Util.string_append_list(["if ", s1, " then\n", s2, s3, "\nelse", s4]) => str
	----------------------------------------------------
	unparse_equation_str(Absyn.EQ_IF(e,tb,eb,fb)) => str
	
  rule	print_exp_str(e1) => s1 &
	print_exp_str(e2) => s2 &
	Util.string_append_list([s1, "=", s2]) => str
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_EQUALS(e1,e2)) => str
	
  rule	print_component_ref_str(e1) => s1  &
	print_component_ref_str(e2) => s2 &
	Util.string_append_list(["connect(", s1, ",", s2, ")"]) => str
	-------------------------------------------
	unparse_equation_str(Absyn.EQ_CONNECT(e1,e2)) => str
	
  rule	print_exp_str(e) => s1 &
	get_string_list(el,unparse_equationitem_str,";\n") => s2 &
	Util.string_append_list(["for ", i, " in ", s1, "loop\n", s2, "\nend loop"]) => str
	----------------------------------------------------------
	unparse_equation_str (Absyn.EQ_FOR(i,e,el)) => str
	
  rule	Print.print_buf " ** Failure! UNKNOWN EQUATION ** "
	--------------------------------
	unparse_equation_str(_) => ""
	
end
	
relation unparse_equationitem_str: Absyn.EquationItem => string =
  rule	
	unparse_equation_str eq => s1 &
	unparse_comment_option(optcmt) => s2 &
	string_append(s1,s2) => str
	---------------------------
	unparse_equationitem_str Absyn.EQUATIONITEM(eq,optcmt) => str 
	
  rule	unparse_annotation_option(SOME(ann)) => str
	-------------------------------------------
	unparse_equationitem_str Absyn.EQUATIONITEMANN(ann) => str
end
	
(**)
	
relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =
	
  rule	Print.print_buf " ELSEIF " & print_exp e & Print.print_buf " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))
end
	
relation unparse_eq_elseif_str : (Absyn.Exp * Absyn.EquationItem list) => string =
	    
  rule	print_exp_str e => s1 &
	string_append ("\n elseif ",s1) => s2 &
	string_append(s2," then \n") => s3 &
	get_string_list(el,unparse_equationitem_str, ";") => s4 &
 	string_append(s3,s4) => str 
	-----------------------------------
	unparse_eq_elseif_str((e,el)) => str
end

(* Algorithm clauses *)

relation print_algorithmitem: Absyn.AlgorithmItem => () =

  rule	Print.print_buf "ALGORITHMITEM(" &
	print_algorithm(alg)&
	Print.print_buf ")\n"
	-------------------
	print_algorithmitem (Absyn.ALGORITHMITEM(alg,_))

  rule	Print.print_buf "ALGORITHMITEMANN(..)\n"
	----------------------------------------
	print_algorithmitem(Absyn.ALGORITHMITEMANN(ann))
end

relation print_algorithm: Absyn.Algorithm => () =
	
  rule	Print.print_buf "ALG_ASSIGN(" & print_component_ref cr &
	Print.print_buf " := " & print_exp(exp) & Print.print_buf ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	Print.print_buf "IF (" & print_exp(e) & Print.print_buf ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithmitem, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	Print.print_buf " ELSE " & print_list_debug("print_algorithm",fb, print_algorithmitem, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	Print.print_buf "FOR " & Print.print_buf i & Print.print_buf " in " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",el, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	Print.print_buf "WHILE " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	Print.print_buf "WHEN_E " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	Print.print_buf "WHEN_A " & print_exp(e) &
	Print.print_buf " {" & print_list_debug("print_algorithm",al, print_algorithmitem, ";") & Print.print_buf "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al,el)
	
  rule	Print.print_buf " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

relation unparse_algorithm_str: Absyn.AlgorithmItem => string =
				
  rule	print_component_ref_str cr => s1 &
	print_exp_str(exp) => s2 & 
	unparse_comment_option(optcmt) => s3 &
	Util.string_append_list([s1,":=",s2,s3]) => str
	-------------------------------------------
	unparse_algorithm_str(Absyn.ALGORITHMITEM(Absyn.ALG_ASSIGN(cr,exp),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	get_string_list(tb,unparse_algorithm_str,";\n") => s2 &
	get_string_list(eb,unparse_alg_elseif_str, " ") => s3 &
	get_string_list(fb,unparse_algorithm_str,";\n") => s4 &
	unparse_comment_option(optcmt) => s5 &
	Util.string_append_list(["if ",s1," then \n", s2, s3, "\n else", s4, "end if" ,s5, ";\n"]) => str
	----------------------------------------------------
	unparse_algorithm_str(Absyn.ALGORITHMITEM(Absyn.ALG_IF(e,tb,eb,fb),optcmt)) => str

  rule	print_exp_str(e)=> s1 &
	get_string_list(el,unparse_algorithm_str," ;\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	Util.string_append_list(["for ", i, " in ", s1, " loop\n", s2, "\nend for", s3, ";\n"]) => str
	----------------------------------------------------------
        unparse_algorithm_str (Absyn.ALGORITHMITEM(Absyn.ALG_FOR(i,e,el),optcmt)) => str
				     
  rule	print_exp_str(e) => s1 &
	get_string_list(al,unparse_algorithm_str,";\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	Util.string_append_list(["while (", s1, ") loop\n", s2, "\nend while", s3, ";\n"]) => str
	----------------------------------------------------------
	unparse_algorithm_str (Absyn.ALGORITHMITEM(Absyn.ALG_WHILE(e,al),optcmt)) => str
	
  rule	print_exp_str(e) => s1 &
	get_string_list(al,unparse_algorithm_str,";\n") => s2 &
	unparse_comment_option(optcmt) => s3 &
	Util.string_append_list(["when ", s1, " then\n", s2, "\nend when", s3, ";\n"]) => str
	(* TODO elsewhen *)
        ----------------------------------------------------------
	unparse_algorithm_str (Absyn.ALGORITHMITEM(Absyn.ALG_WHEN_A(e,al,al2),optcmt)) => str
	
  rule	unparse_annotation_option SOME(ann) => str
	------------------------------------------
	unparse_algorithm_str (Absyn.ALGORITHMITEMANN(ann)) => str			       
  rule	Print.print_buf " *Failure! UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	unparse_algorithm_str(_) => ""
	
end
(**)

relation print_alg_elseif : (Absyn.Exp * Absyn.AlgorithmItem list) => () =

  rule	Print.print_buf " ELSEIF " & print_exp e & Print.print_buf " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithmitem, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end

relation unparse_alg_elseif_str : (Absyn.Exp * Absyn.AlgorithmItem list) => string =

  rule  print_exp_str e => s1 &
	string_append(" elseif ",s1) => s2 &
	string_append(s2, " then \n") => s3 &
	get_string_list(el,unparse_algorithm_str,";\n")=> s4 &
	string_append(s3,s4) => str
	-----------------------------------
	unparse_alg_elseif_str((e,el)) => str
end

(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef'.
 *)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	Print.print_buf s &
	print_subscripts subs
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	Print.print_buf s &
	print_subscripts subs &
	Print.print_buf "." &
	print_component_ref cr
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

relation print_subscripts : Absyn.Subscript list => () =

  axiom	print_subscripts []

  rule	Print.print_buf "[" & print_list_debug("print_subscripts",l,print_subscript,",") & Print.print_buf "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)

relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''

end


relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path : Absyn.Path => () =

  rule	Absyn.path_string p => s & Print.print_buf s
	----------------------------------
	print_path p

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path_str : Absyn.Path => string =

  rule	Absyn.path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & Print.print_buf s
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & Print.print_buf s
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	print_component_ref(c)
	---------------------
	print_exp(Absyn.CREF(c))

  rule	Print.print_buf "\"" & Print.print_buf s & Print.print_buf "\""
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	Print.print_buf "FALSE"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	Print.print_buf "TRUE"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	op_symbol(op) => sym & print_exp e1 & Print.print_buf sym & print_exp e2
	---------------------------------------------------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	op_symbol(op) => sym &
	Print.print_buf sym & print_exp e
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	op_symbol(op) => sym & print_exp e1 & Print.print_buf sym & print_exp e2
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	op_symbol(op) => sym & Print.print_buf sym & print_exp e
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	op_symbol(op) => sym & print_exp(e1) & Print.print_buf sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	Print.print_buf "if " & print_exp(c) &
	Print.print_buf " then " & print_exp(t) &
	Print.print_buf " else " & print_exp(f)
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f,lst))

  rule	print_component_ref(fcn) &
 	Print.print_buf "(" & 
	print_function_args(args) & Print.print_buf ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	Print.print_buf "[" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.print_buf "]"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	Print.print_buf "TUPLE" &
	Print.print_buf "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	Print.print_buf ")"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	Print.print_buf "[" &
	print_list_debug("print_exp",es, print_row, ";") &
	Print.print_buf "]"
	---------
	print_exp Absyn.MATRIX(es)

  rule	Print.print_buf "(" & print_exp start & Print.print_buf ":" & print_exp stop & Print.print_buf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	Print.print_buf "(" & print_exp start & Print.print_buf ":" & print_exp step &
 	Print.print_buf ":" & print_exp stop & Print.print_buf ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule	Print.print_buf "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  Print.print_buf "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	Print.print_buf ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	Print.print_buf ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)
end

relation print_function_args_str: Absyn.FunctionArgs => string =
	
  rule	print_list_str(expargs,print_exp_str,", ") => s1 &
	string_append(s1,", ") => s2 &
	print_list_str(nargs,print_named_arg_str,", ") => s3 &
	string_append(s2,s3) => str 
	---------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs,nargs as _::_) => str

  rule	print_list_str(expargs,print_exp_str,", ") => str 
	---------------------------------------------
	print_function_args_str Absyn.FUNCTIONARGS(expargs,[]) => str

end

relation print_named_arg: Absyn.NamedArg => () =
  rule	Print.print_buf ident &
	Print.print_buf "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

relation print_named_arg_str: Absyn.NamedArg => string =
  rule	string_append(ident,"=") => s1 &
	print_exp_str(e) => s2 &
	string_append(s1,s2) => str
	---------------------------
	print_named_arg_str Absyn.NAMEDARG(ident,e) => str
end	

(**)

relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end



(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.BINARY(e1, op, e2)) => s1

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.UNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str (Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.LUNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	print_elseif_str elseif => el &		       
	Util.string_append_list(["if ", cs, " then ", ts, el, " else ", fs]) => str
	---------------------------------
	print_exp_str(Absyn.IFEXP(c,t,f,elseif)) => str

  rule	print_component_ref_str(fcn) => fs &
	print_function_args_str(args) => argsstr &
	string_append(fs, "(") => s &
	string_append(s, argsstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

	(* PR. *)
  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ")") => s'''
	--------------------------------
	print_exp_str Absyn.RANGE(start,NONE,stop) => s'''

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s2) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s3) => s'''' &
	string_append (s'''', ")") => s'''''
	------------------------------------
	print_exp_str Absyn.RANGE(start,SOME(step),stop) => s'''''

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end
			       
relation print_elseif_str: (Absyn.Exp * Absyn.Exp) list => string =
  axiom print_elseif_str ([]) => ""

  rule	print_exp_str(ec) => s1 &
	print_exp_str(ee) => s2 &
	print_elseif_str(rest) => s3 &
	Util.string_append_list([" elseif ", s1, " then ", s2, s3]) => str
	-------------------------------------------------------------
	print_elseif_str((ec,ee)::rest) => str
end

relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)

relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " AND "
  axiom	op_symbol(Absyn.OR) => " OR "

  axiom	op_symbol(Absyn.NOT) => "NOT "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " = "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)

relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	Print.print_buf res
	-------------------------
	print_select(f,yes,no)

end

relation print_option = (* : ('a option)*('a => 'b) = *)

  axiom	print_option(NONE,_)
	
  rule	r( x )
	------
	print_option(SOME(x),r)
	
end

relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	Debug.fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	Debug.fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	Debug.fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	Debug.fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	Print.print_buf sep & 
	Debug.fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & Print.print_buf sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end


relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b
end


relation get_option_str: ('a option, 'a => string) => string =
  rule  r (a) => str
	------------
	get_option_str (SOME(a),r) => str

  axiom	get_option_str(NONE,_) => ""
end

relation unparse_string_comment_option: string option => string =
	
  axiom unparse_string_comment_option(NONE) => ""
	
  rule	string_append(" ",s)=> str 
	--------------------------
	unparse_string_comment_option(SOME(s)) => str
end

relation identity: ('a) => 'a =
  axiom identity(x) => x
end

relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end

relation stringlist_append : string list => string =

	axiom stringlist_append([]) => ""

  rule	stringlist_append(xs) => s2 &
	string_append(s1,s2) => str
	-----------------------------
        stringlist_append(s1::xs) => str
end