(* dump.rml *)

module Dump:

  with "exp.rml"
  with "absyn.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation dump_exp: Exp.Exp => ()

end

(*************************************************************************)
(* Dump routines for debugging of AST *)

relation dump_select: (bool,string,string) => () =

	rule	print no
		-------------------------
		dump_select(false,yes,no)

	rule	print yes
		-------------------------
		dump_select(true,yes,no)

end

relation dump_option = (* : ('a option)*('a => 'b) = *)

	axiom	dump_option(NONE,_)

	rule	r( x )
		---------------------
		dump_option(SOME(x),r)

end

relation dump_list =

	axiom	dump_list([],_,_)

	rule	r(h)
		------------------
		dump_list([h],r,_)

	rule	r(h) & print sep & dump_list(t,r,sep)
		-------------------------------------
		dump_list(h::t,r,sep)
end

(* Exp *)

relation binop_symbol: Exp.BinOp => string =
	axiom	binop_symbol(Exp.ADD) => " + "
	axiom	binop_symbol(Exp.SUB) => " - "
	axiom	binop_symbol(Exp.MUL) => "*"
	axiom	binop_symbol(Exp.DIV) => "/"
	axiom	binop_symbol(Exp.POW) => "^"
end

relation unaryop_symbol: Exp.UnaryOp => string =
	axiom	unaryop_symbol(Exp.UMINUS) => "-"
	axiom	unaryop_symbol(Exp.UPLUS) => "+"
end

relation lbinop_symbol: Exp.LBinOp => string =
	axiom	lbinop_symbol(Exp.AND) => " AND "
	axiom	lbinop_symbol(Exp.OR) => " OR "
end

relation lunaryop_symbol: Exp.LUnaryOp => string =
	axiom	lunaryop_symbol(Exp.NOT) => "NOT "
end

relation relop_symbol: Exp.RelOp => string =
	axiom	relop_symbol(Exp.LESS)      => " < "
	axiom	relop_symbol(Exp.LESSEQ)    => " <= "
	axiom	relop_symbol(Exp.GREATER)   => " > "
	axiom	relop_symbol(Exp.GREATEREQ) => " >= "
	axiom	relop_symbol(Exp.EQUAL)     => " == "
	axiom	relop_symbol(Exp.NEQUAL)    => " <> "
end

relation dump_exp: Exp.Exp => () =
	rule	real_string(x) => s &
		print s
		--------------
		dump_exp(Exp.NUMBER(x))

	rule	Exp.path_string(p) => s &
		print s
		---------------
		dump_exp(Exp.PATH(p))

	rule	print "\"" & print s & print "\""
		---------------------------------
		dump_exp(Exp.STRING(s))

	rule	print "FALSE"
		-------------
		dump_exp(Exp.BOOL(false))

	rule	print "TRUE"
		-------------
		dump_exp(Exp.BOOL(true))

	rule	binop_symbol(op) => sym &
		dump_exp e1 & print sym & dump_exp e2
		----------------------------
		dump_exp(Exp.BINARY(e1, op, e2))

	rule	unaryop_symbol(op) => sym &
		print sym & dump_exp e
		----------------------------
		dump_exp(Exp.UNARY(op, e))

	rule	lbinop_symbol(op) => sym &
		dump_exp e1 & print sym & dump_exp e2
		----------------------------
		dump_exp(Exp.LBINARY(e1, op, e2))

	rule	lunaryop_symbol(op) => sym &
		print sym & dump_exp e
		----------------------------
		dump_exp(Exp.LUNARY(op, e))

	rule	relop_symbol(op) => sym &
		dump_exp(e1) & print sym & dump_exp(e2)
		---------------------------------------
		dump_exp(Exp.RELATION(e1, op, e2))

	rule	print "IF " & dump_exp(c) &
		print " THEN " & dump_exp(t) &
		print " ELSE " & dump_exp(f)
		----------------------------
		dump_exp(Exp.IFEXP(c,t,f))

	rule	Exp.path_string(fcn) => fs &
		print fs & print "(" & dump_list(args,dump_exp,",") & print ")"
		---------------------------------------------
		dump_exp(Exp.CALL(fcn, args))

(*
	rule	print "EQUATION " & 
		dump_exp lhs &
		print " = " &
		dump_exp rhs
		------------------------
		dump_exp(Exp.EQU(lhs, rhs))
*)
	rule	print "TIME"
		------------------
		dump_exp(Exp.TIME)

  	rule	print "#UNKNOWN EXPRESSION#"
        	----------------------------------
	        dump_exp (_)
end

(* Class *)

relation dump_class_restriction: Absyn.ClassRestriction => () =

	rule	print "CLASS"
		--------------------------------------------
		dump_class_restriction(Absyn.CL_CLASS) => ()

	rule	print "TYPE"
		----------------------------
		dump_class_restriction(Absyn.CL_TYPE) => ()

	rule	print "CONNECTOR"
		----------------------------
		dump_class_restriction(Absyn.CL_CONNECTOR) => ()

	rule	print "MODEL"
		----------------------------
		dump_class_restriction(Absyn.CL_MODEL) => ()

	rule	print "MODEL"
		------------------------------------------------
		dump_class_restriction(Absyn.CL_MODEL) => ()

	rule	print "BLOCK"
		------------------------------------------------
		dump_class_restriction(Absyn.CL_BLOCK) => ()

	rule	print "PACKAGE"
		--------------------------------------------------
		dump_class_restriction(Absyn.CL_PACKAGE) => ()

	rule	print "FUNCTION"
		---------------------------------------------------
		dump_class_restriction(Absyn.CL_FUNCTION) => ()

end

relation dump: Absyn.Program => () =

	axiom	dump [] => ()

	rule	dump_class c & print "\n" &
		dump cs
		----------------
		dump c::cs => ()

end
and dump_class: Absyn.Class => () =

	rule	dump_class_restriction(r) & print "(" &
		print n & print "," & dump_select(p,"PARTIAL,","") &
		dump_list(parts,dump_class_part,",") & print ")"
		----------------------------------------
		dump_class(Absyn.CLASS(n,p,r,Absyn.PARTS(parts))) => ()

	rule	dump_class_restriction(r) & print "(" &
		print n & print "," & dump_select(p,"PARTIAL,","") &
		print ") = " & Exp.path_string(i) => is & print is &
		dump_class_modification(m)
		----------------------------------------
		dump_class(Absyn.CLASS(n,p,r,Absyn.DERIVED(i,_,m))) => ()

end
and dump_class_modification =

	axiom	dump_class_modification([])

	rule	print "(" & dump_list(l,dump_element_arg,",") & print ")"
		---------------------------------------------------------
		dump_class_modification(l)

end
and dump_element_arg =

	rule	print "ARG(" &
		dump_select(f,"FINAL,",",") &
		Exp.path_string(r) => s & print s &
		dump_modification(m) &
		print ")"
		-------------------------------------------
		dump_element_arg(Absyn.MODIFICATION(f,r,m))

end
and dump_class_part: Absyn.ClassPart => () =

	rule 	print "PUBLIC(" & dump_elements(el) & print ")"
		-----------------------------------------------
		dump_class_part(Absyn.PUBLIC(el))

	rule 	print "PROTECTED(" & dump_elements(el) & print ")"
		---------------------------------------
		dump_class_part(Absyn.PROTECTED(el))

	rule 	print "EQUATIONS(" &
		dump_list(eqs,dump_equation,",") &
		print ")"
		--------------------------------------
		dump_class_part(Absyn.EQUATIONS(eqs))

	rule 	print "ALGORITHMS(...)"
		---------------------------------------
		dump_class_part(Absyn.ALGORITHMS(_))

end
and dump_elements: Absyn.Element list => () =

	axiom	dump_elements [] => ()

	rule    dump_element e
		--------------------------
		dump_elements [e]

	rule    dump_element e & print "," &
		dump_elements els
		--------------------------
		dump_elements e::els

end
and dump_element: Absyn.Element => () =

	rule	print "ELEMENT(" & dump_select(final,"FINAL,","") &
		dump_elementspec spec & print ")"
		----------------
		dump_element (Absyn.ELEMENT(final,_,spec))

end
and dump_elementspec: Absyn.ElementSpec => () =

	rule	print "CLASSDEF(" & dump_select(repl,"REPLACEABLE,","") &
		dump_class cl & print ")"
		-------------------------
		dump_elementspec(Absyn.CLASSDEF(repl,cl))


	rule	Exp.path_string(p) => s &
		print "EXTENDS(" & print s & print "," &
		dump_list(l,dump_element_arg,",") & print ")"
		------------------------------------------
		dump_elementspec(Absyn.EXTENDS(p,l))

	rule	print "COMPONENTS(" &
		dump_select(f,"FLOW,","") &
		dump_select(p,"PARAMETER,","") &
		dump_select(c,"CONSTANT,","") &
		dump_select(i,"INPUT,","") &
		dump_select(o,"OUTPUT,","") &
		Exp.path_string(t) => ts & print ts & print "," &
		dump_list(cs, dump_component, ",") &
		print ")"
		------------------------------------------
		dump_elementspec(Absyn.COMPONENTS(f,p,c,i,o,t,cs))

	rule	print " ##ERROR## "
		-------------------
		dump_elementspec(_)

end
and dump_component: Absyn.Component => () =

	rule	print n &
		dump_option(a,dump_arraydim) &
		dump_option(m,dump_modification)
		------------------------------------------
		dump_component(Absyn.COMPONENT(n,a,m))


end
and dump_arraydim: Absyn.ArrayDim => () =

	rule	print "[" & dump_subscript(s) & print "]"
		-----------------------------------------
		dump_arraydim(Absyn.ONEDIM(s))

	rule	print "[" & dump_subscript(s1) &
		print "," & dump_subscript(s2) & print "]"
		-----------------------------------------
		dump_arraydim(Absyn.TWODIM(s1,s2))

end
and dump_subscript: Absyn.Subscript => () =

	rule	print ":"
		---------
		dump_subscript(NONE)

	rule	dump_exp(e1)
		----------
		dump_subscript(SOME((e1,NONE)))

	rule	dump_exp(e1) & print ":" & dump_exp(e2)
		-------------
		dump_subscript(SOME((e1,SOME((e2,NONE)))))

	rule	dump_exp(e1) & print ":" &
		dump_exp(e2) & print ":" & dump_exp(e3)
		----------------------------------------------
		dump_subscript(SOME((e1,SOME((e2,SOME(e3))))))

end
and dump_modification: Absyn.Modification => () =

	rule	print "(" &
		dump_list(l,dump_element_arg,",") &
		print ")"
		------------------------------------
		dump_modification(Absyn.CLASSMOD(l))

	rule	print " = " & dump_exp(e)
		------------------------------------
		dump_modification(Absyn.EQUALMOD(e))

	rule	print "( ** MODIFICATION ** )"
		-------------
		dump_modification(_)

end
and dump_equation: Absyn.Equation => () =

	rule	print "EQ_EXPR(" & dump_exp(e) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_EXPR(e))

	rule	print "EQ_EQUALS(" & dump_exp(e1) & print "," &
		dump_exp(e2) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_EQUALS(e1,e2))

	rule	print "EQ_CONNECT(" & dump_component_ref(e1) & print "," &
		dump_component_ref(e2) & print ")"
		-------------------------------------------
		dump_equation(Absyn.EQ_CONNECT(e1,e2))

	rule	print " ** UNKNOWN EQUATION ** "
		--------------------------------
		dump_equation(_)

end
and dump_component_ref =

	rule	dump_list(cr,dump_component_ref2,".")
		---------------------------------------------------------
		dump_component_ref(cr)

end
and dump_component_ref2 =

	rule	print s
		-------------------------
		dump_component_ref2((s,[]))

	rule	print s &
		print "[" & dump_list(l,dump_subscript,",") & print "]"
		-------------------------------------------------------------
		dump_component_ref2((s,l))

end
