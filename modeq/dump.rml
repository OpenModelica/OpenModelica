(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 dump.rml
 ** module:      Dump
 ** description: debug printing
 **
 ** RCS: $Id$
 **
 ** Printing routines for debugging of the AST.  These relations do
 ** nothing but print the data structures to the standard output.
 **
 ** The implementation of the relations are excluded from the report,
 ** as they occupy a lot of space and do not convey any useful
 ** semantic information.
 **)


module Dump:

  with "absyn.rml"
  with "interactive.rml"							  
  with "debug.rml"

  type Ident = string

  (* Dump routines for debugging of AST *)

  relation dump: Absyn.Program => ()
  relation dump_istmt: Interactive.InteractiveStmts => ()
  relation print_exp: Absyn.Exp => ()
  relation print_exp_str: Absyn.Exp => string
  relation print_component_ref: Absyn.ComponentRef => ()
  relation print_component_ref_str : Absyn.ComponentRef => string
  relation print_path : Absyn.Path => ()
  relation print_subscripts : Absyn.Subscript list => ()
  relation print_arraydim: Absyn.ArrayDim => ()
  relation print_equation: Absyn.Equation => ()
  relation print_algorithm: Absyn.Algorithm => ()
  relation print_list_debug : (string, 'a list, 'a => (), string) => ()
  relation print_list : ('a list, 'a => (), string) => ()
  relation print_elementspec: Absyn.ElementSpec => ()
  relation op_symbol : Absyn.Operator => string
  relation print_bool : bool => ()
  relation print_select: (bool,string,string) => ()
  relation select_string: (bool,string,string) => string
  relation get_string_list : ('a list, 'a => string, string) => string
end




(*!ignorecode*)

with "classinf.rml"
with "rtopts.rml"

(* Relations *)

relation dump : Absyn.Program => () =
	
  axiom	dump Absyn.PROGRAM([],_) => ()
	
  rule	print_class c & print "\n" &
	dump Absyn.PROGRAM(cs,w)
	------------------------
	dump Absyn.PROGRAM(c::cs,w) => ()

end

relation dump_istmt : Interactive.InteractiveStmts => () =
  rule	print ("IALG(") &
	print_algorithm(alg) => () &
	print ")\n" 
	--------------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IALG(alg)])) => ()
	    
  rule  print ("IEXP(") &
	print_exp(expr) &
	print ")\n" 
	----------------------
	dump_istmt(Interactive.ISTMTS([Interactive.IEXP(expr)])) => ()
	
  rule print "IALG(" &
	print_algorithm(alg) => () &
	print "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IALG(alg)::l)) => ()

  rule print "IEXP(" &
	print_exp(expr) => () &
	print "," &
	dump_istmt(Interactive.ISTMTS(l)) => ()
	--------------------------
	dump_istmt(Interactive.ISTMTS(Interactive.IEXP(expr)::l)) => ()

  axiom	dump_istmt(_) => ()
end
	(**)

relation print_class: Absyn.Class => () =

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print_list_debug("print_class1",parts,print_class_part,",") & print ")"
	----------------------------------------
	print_class(Absyn.CLASS(n,p,r,Absyn.PARTS(parts))) => ()

  rule	print_class_restriction(r) & print "(" &
	print n & print "," & print_select(p,"PARTIAL,","") &
	print ") = " & print_path(i) &
	print_class_modification(m)
	----------------------------------------
	print_class(Absyn.CLASS(n,p,r,Absyn.DERIVED(i,_,m))) => ()

  rule	print_class_restriction(r) & print "(" &
	print n & print "," &
	print_select(p,"PARTIAL,","") &
	print "ENUMERATION(" &
	print_list_debug("print_class",l,print, ",") &
	print ")\n"
	----------
	print_class(Absyn.CLASS(n,p,r,Absyn.ENUMERATION(l))) => ()
end

(**)

relation print_class_restriction: Absyn.Restriction => () =

  rule	Absyn.print_restr re
	-----------------------
	print_class_restriction re

end

(**)

relation print_class_modification =

  axiom	print_class_modification([])
	
  rule	print "(" & print_list_debug("print_class_modification",l,print_element_arg,",") & print ")"
	---------------------------------------------------------
	print_class_modification(l)
	
end

(**)

relation print_element_arg =
	
  rule	print "ARG(" &
	print_select(f,"FINAL,",",") &
	print_component_ref(r) &
	print_modification(m) &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.MODIFICATION(f,r,m))
	
  rule	print "REDECLARATION(" &
	print_select(f,"FINAL,",",") &
	print_elementspec spec &
	print ")"
	-------------------------------------------
	print_element_arg(Absyn.REDECLARATION(f,spec))

end

(**)

relation print_class_part: Absyn.ClassPart => () =

  rule	print "PUBLIC(" & print_elementitems(el) & print ")"
	-----------------------------------------------
	print_class_part(Absyn.PUBLIC(el))
	
  rule	print "PROTECTED(" & print_elementitems(el) & print ")"
	---------------------------------------
	print_class_part(Absyn.PROTECTED(el))
	
  rule	print "EQUATIONS(" &
	print_list_debug("print_class_part",eqs,print_equationitem,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.EQUATIONS(eqs))
	
  rule	print "ALGORITHM(" &
	print_list_debug("print_class_part",eqs,print_algorithm,",") &
	print ")"
	--------------------------------------
	print_class_part(Absyn.ALGORITHMS(eqs))

end


(**)

relation print_elementitems: Absyn.ElementItem list => () =
  axiom print_elementitems [] => ()

  rule  print_element e
	---------------
	print_elementitems[ Absyn.ELEMENTITEM(e)]

  rule	print_annotation a
	------------------
	print_elementitems([Absyn.ANNOTATIONITEM(a)])
	
  rule	print_element e &
	print_elementitems els
	---------------
	print_elementitems Absyn.ELEMENTITEM(e)::els 

  rule	print_annotation a &
	print_elementitems els
	------------------
	print_elementitems Absyn.ANNOTATIONITEM(a)::els

  rule	print "Error print_elementitems\n"
	--------------
	print_elementitems _ 
end

relation print_annotation: Absyn.Annotation => () =	
  rule	print "ANNOTATION(" &
	print_modification Absyn.CLASSMOD(mod,NONE) &
	print ")"
	---------
	print_annotation(Absyn.ANNOTATION(mod))
end
	

relation print_elements: Absyn.Element list => () =

  axiom	print_elements [] => ()

  rule	print_element e
	--------------------------
	print_elements [e]
	
  rule	print_element e & print "," &
	print_elements els
	--------------------------
	print_elements e::els
	
end

(**)

relation print_element: Absyn.Element => () =
	
  rule	print "ELEMENT(" & print_select(final,"FINAL,","") &
	print_innerouter inout &
	print ", " &
	print_elementspec spec & print ")"
	----------------
	print_element (Absyn.ELEMENT(final,inout,_,spec))

end

relation print_innerouter: Absyn.InnerOuter => () =
   rule print "INNER"
	----------------------------
	print_innerouter(Absyn.INNER)

   rule print "OUTER"
        ----------------------------
        print_innerouter(Absyn.OUTER)

   rule print " "
        ----------------------------------
        print_innerouter(Absyn.UNSPECIFIED)
end
(**)

relation print_elementspec: Absyn.ElementSpec => () =
	
  rule	print "CLASSDEF(" & print_select(repl,"REPLACEABLE,","") &
	print_class cl & print ")"
	-------------------------
	print_elementspec(Absyn.CLASSDEF(repl,cl))
	
	
  rule	print "EXTENDS(" & print_path p & print "," &
	print_list_debug("print_elementspec",l,print_element_arg,",") & print ")"
	------------------------------------------
	print_elementspec(Absyn.EXTENDS(p,l))

  rule	print "COMPONENTS(" &
	print_elementattr(attr) & print "," &
	print_path(t) & print "," &
	print_list_debug("print_elementspec",cs, print_componentitem, ",") &
	print ")"
	------------------------------------------
	print_elementspec(Absyn.COMPONENTS(attr,t,cs))
	
  rule	print "IMPORT(" &
	print_import i &
	print ")"
	--------
	print_elementspec(Absyn.IMPORT(i))

  rule	print " ##ERROR## "
	-------------------
	print_elementspec(_)

end

relation print_import : Absyn.Import => () =

  rule	print i & print " = " &
	print_path p
	-----------------------
	print_import(Absyn.NAMED_IMPORT(i,p))

  rule	print_path p
	-------------
	print_import(Absyn.QUAL_IMPORT(p))

  rule	print_path p & print ".*"
	--------------------------
	print_import(Absyn.UNQUAL_IMPORT(p))
		     
end

relation print_elementattr: Absyn.ElementAttributes => () =

  rule	print "ATTR(" &
	select_string(fl,"FLOW,","") => fs &
	variability_symbol(var) => vs &
	direction_symbol(dir) => ds &
	let sl = [fs,vs,ds] &
	print_list_debug("print_elementattr",sl, print, ",") &
	print ")"
	-----------------------------------
	print_elementattr(Absyn.ATTR(fl,var,dir,adim))

  rule	print " ##ERROR## print_elementattr"
	-------------------
	print_elementattr(_)

end

relation variability_symbol: Absyn.Variability => string =

  axiom variability_symbol(Absyn.VAR) => ""
  axiom	variability_symbol(Absyn.DISCRETE) => "DISCRETE"
  axiom	variability_symbol(Absyn.PARAM) => "PARAM"
  axiom	variability_symbol(Absyn.CONST) => "CONST"

end

relation direction_symbol: Absyn.Direction => string =

  axiom direction_symbol(Absyn.BIDIR) => ""
  axiom	direction_symbol(Absyn.INPUT) => "INPUT"
  axiom	direction_symbol(Absyn.OUTPUT) => "OUTPUT"

end

(**)

relation print_component: Absyn.Component => () =

  rule	print n &
	print_arraydim a &
	print_option(m,print_modification) 
	------------------------------------------
	print_component(Absyn.COMPONENT(n,a,m))

end

relation print_componentitem: Absyn.ComponentItem => () =

  rule	print "COMPONENTITEM(" &
	print_component c &
	print ", " &
	print_option(a, print_annotation) &
	print ")"
	------------------------------------------
	print_componentitem(Absyn.COMPONENTITEM(c,a))

end

(**)

relation print_arraydim: Absyn.ArrayDim => () =

  rule	print_subscripts(s)
	-------------------
	print_arraydim(s)
	
end

relation print_arraydim_str: Absyn.ArrayDim => string =

  rule	print_subscripts_str (s) => str
	-------------------------------
	print_arraydim_str(s) => str
	
end

relation print_subscript: Absyn.Subscript => () =

  rule	print ":"
	---------
	print_subscript(Absyn.NOSUB)

  rule	print_exp(e1)
	----------
	print_subscript(Absyn.SUBSCRIPT(e1))

end

relation print_subscript_str: Absyn.Subscript => string =

  axiom	print_subscript_str (Absyn.NOSUB) => ":"

  rule	print_exp_str (e1) => s
	-----------------------
	print_subscript_str (Absyn.SUBSCRIPT(e1)) => s

end

(* Modifications *)

relation print_modification: Absyn.Modification => () =
	
  rule	print_mod1 l & print_mod2 e
	-------------------------
	print_modification(Absyn.CLASSMOD(l, e))
	
  rule	print "( ** MODIFICATION ** )"
	-------------
	print_modification(_)
	
end

relation print_mod1: Absyn.ElementArg list => () =

  axiom	print_mod1 []

  rule	print "(" &
	print_list_debug("print_mod1",l,print_element_arg,",") &
	print ")"
	------------------------------------
	print_mod1 l

end

relation print_mod2 : Absyn.Exp option => () =

  axiom	print_mod2 NONE

  rule	print " = " & print_exp(e)
	-------------------------
	print_mod2 SOME(e)

end

(* Equations *)

relation print_equation: Absyn.Equation => () =
	
  rule	print "EQ_EXPR(" & print_exp(e) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EXPR(e))
	
  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_equation",tb, print_equationitem, ";") &
	print_list_debug("print_equation",eb, print_eq_elseif, " ") &
	print " ELSE " & print_list_debug("print_equation",fb, print_equationitem, ";")
	----------------------------------------------------
	print_equation(Absyn.EQ_IF(e,tb,eb,fb))
	
  rule	print "EQ_EQUALS(" & print_exp(e1) & print "," &
	print_exp(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_EQUALS(e1,e2))
	
  rule	print "EQ_CONNECT(" & print_component_ref(e1) & print "," &
	print_component_ref(e2) & print ")"
	-------------------------------------------
	print_equation(Absyn.EQ_CONNECT(e1,e2))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_equation",el, print_equationitem, ";") & print "}"
	----------------------------------------------------------
	print_equation Absyn.EQ_FOR(i,e,el)
	
  rule	print " ** UNKNOWN EQUATION ** "
	--------------------------------
	print_equation(_)
	
end

relation print_equationitem: Absyn.EquationItem => () =
  rule	print "EQUATIONITEM(" &
	print_equation eq &
	print ", " &
	print_annotation ann &
	print ")\n"
	--------------
	print_equationitem Absyn.EQUATIONITEM(eq,SOME(ann))
	
  rule	print "EQUATIONITEM(" &
	print_equation eq &
	print ",NONE)\n"
	--------------
	print_equationitem Absyn.EQUATIONITEM(eq,NONE)
end
(**)

relation print_eq_elseif : (Absyn.Exp * Absyn.EquationItem list) => () =

  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_eq_elseif",el, print_equationitem, ";")
	-----------------------------------
	print_eq_elseif((e,el))

end

(* Algorithm clauses *)

relation print_algorithm: Absyn.Algorithm => () =
	
  rule	print "ALG_ASSIGN(" & print_component_ref cr &
	print " := " & print_exp(exp) & print ")"
	-------------------------------------------
	print_algorithm(Absyn.ALG_ASSIGN(cr,exp))
	
  rule	print "IF (" & print_exp(e) & print ") THEN " &
	print_list_debug("print_algorithm",tb, print_algorithm, ";") &
	print_list_debug("print_algorithm",eb, print_alg_elseif, " ") &
	print " ELSE " & print_list_debug("print_algorithm",fb, print_algorithm, ";")
	----------------------------------------------------
	print_algorithm(Absyn.ALG_IF(e,tb,eb,fb))
	
  rule	print "FOR " & print i & print " in " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",el, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_FOR(i,e,el)
	
  rule	print "WHILE " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHILE(e,al)
	
	(*  rule	print "WHEN_E " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	 ----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_E(e,al)
*)
  rule	print "WHEN_A " & print_exp(e) &
	print " {" & print_list_debug("print_algorithm",al, print_algorithm, ";") & print "}"
	----------------------------------------------------------
	print_algorithm Absyn.ALG_WHEN_A(e,al)
	
  rule	print " ** UNKNOWN ALGORITHM CLAUSE ** "
	--------------------------------
	print_algorithm(_)
	
end

(**)

relation print_alg_elseif : (Absyn.Exp * Absyn.Algorithm list) => () =

  rule	print " ELSEIF " & print_exp e & print " THEN " &
	print_list_debug("print_alg_elseif",el, print_algorithm, ";")
	-----------------------------------
	print_alg_elseif((e,el))

end



(* Component references and paths *)

(* relation: print_component_ref
 *
 * Print a `ComponentRef'.
 *)

relation print_component_ref : Absyn.ComponentRef => () =

  rule	print s &
	print_subscripts subs
	---------------------
	print_component_ref Absyn.CREF_IDENT(s,subs)

  rule	print s &
	print_subscripts subs &
	print "." &
	print_component_ref cr
	---------------------
	print_component_ref Absyn.CREF_QUAL(s,subs,cr)
end

relation print_subscripts : Absyn.Subscript list => () =

  axiom	print_subscripts []

  rule	print "[" & print_list_debug("print_subscripts",l,print_subscript,",") & print "]"
	-------------------------------------------------------
	print_subscripts l

end

(* relation: print_component_ref_str
 *
 * Print a `ComponentRef' and return as a string.
 *)

relation print_component_ref_str : Absyn.ComponentRef => string =

  rule	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s'
	--------------------------------
	print_component_ref_str Absyn.CREF_IDENT(s,subs) => s'

  rule	print_component_ref_str cr => crs &
	print_subscripts_str subs => subsstr &
	string_append (s, subsstr) => s' &
	string_append (s', ".") => s'' &
	string_append (s'', crs) => s'''
	--------------------------------
	print_component_ref_str Absyn.CREF_QUAL(s,subs,cr) => s'''

end


relation print_subscripts_str : Absyn.Subscript list => string =

  axiom	print_subscripts_str [] => ""

  rule	print_list_str(l,print_subscript_str,",") => s &
	string_append ("[", s) => s' & 
	string_append (s', "]") => s''
	-------------------------------------------------------
	print_subscripts_str l => s''

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path : Absyn.Path => () =

  rule	Absyn.path_string p => s & print s
	----------------------------------
	print_path p

end

(* relation: print_path
 *
 * Print a `Path'.
 *)

relation print_path_str : Absyn.Path => string =

  rule	Absyn.path_string p => s
	----------------------------------
	print_path_str p => s

end

(* - Expressions *)

(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp : Absyn.Exp => () =
	
  rule	int_string(x) => s & print s
	----------------------------
	print_exp(Absyn.INTEGER(x))

  rule	real_string(x) => s & print s
	-----------------------------
	print_exp(Absyn.REAL(x))

  rule	print_component_ref(c)
	---------------------
	print_exp(Absyn.CREF(c))

  rule	print "\"" & print s & print "\""
	---------------------------------
	print_exp(Absyn.STRING(s))

  rule	print "FALSE"
	-------------
	print_exp(Absyn.BOOL(false))

  rule	print "TRUE"
	-------------
	print_exp(Absyn.BOOL(true))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	---------------------------------------------------------------
	print_exp(Absyn.BINARY(e1, op, e2))

  rule	op_symbol(op) => sym &
	print sym & print_exp e
	----------------------------
	print_exp(Absyn.UNARY(op, e))

  rule	op_symbol(op) => sym & print_exp e1 & print sym & print_exp e2
	----------------------------------------------------------------
	print_exp(Absyn.LBINARY(e1, op, e2))

  rule	op_symbol(op) => sym & print sym & print_exp e
	---------------------------------------------------
	print_exp(Absyn.LUNARY(op, e))

  rule	op_symbol(op) => sym & print_exp(e1) & print sym & print_exp(e2)
	-----------------------------------------------------------------
	print_exp(Absyn.RELATION(e1, op, e2))

  rule	print "if " & print_exp(c) &
	print " then " & print_exp(t) &
	print " else " & print_exp(f)
	----------------------------
	print_exp(Absyn.IFEXP(c,t,f))

  rule	print_component_ref(fcn) &
 	print "(" & 
	print_function_args(args) & print ")"
	---------------------------------------------
	print_exp(Absyn.CALL(fcn, args))

  rule	print "[" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print "]"
	---------
	print_exp Absyn.ARRAY(es)

	(* PR. *)
  rule	print "TUPLE" &
	print "(" &
	print_list_debug("print_exp",es, print_exp, ",") &
	print ")"
	---------
	print_exp Absyn.TUPLE(es)
	
  rule	print "[" &
	print_list_debug("print_exp",es, print_row, ";") &
	print "]"
	---------
	print_exp Absyn.MATRIX(es)

  rule	print "(" & print_exp start & print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,NONE,stop)

  rule	print "(" & print_exp start & print ":" & print_exp step &
 	print ":" & print_exp stop & print ")"
	-------------------------------------------------------------
	print_exp Absyn.RANGE(start,SOME(step),stop)

  rule	print "#UNKNOWN EXPRESSION#"
	----------------------------------
	print_exp (_)
end

relation print_function_args: Absyn.FunctionArgs => () =
	
  rule  print "FUNCTIONARGS(" &
	print_list_debug("print_exp",expargs,print_exp,", ") &
	print ", " &
	print_list_debug("print_namedarg",nargs,print_named_arg,", ") &
	print ")"
	-------------------
	print_function_args Absyn.FUNCTIONARGS(expargs,nargs)
end

relation print_named_arg: Absyn.NamedArg => () =
  rule	print ident &
	print "=" &
	print_exp(e) 
	------------
	print_named_arg Absyn.NAMEDARG(ident,e)
end

	

(**)

relation print_row : Absyn.Exp list => () =

  rule	print_list_debug("print_row",es, print_exp, ",")
	------------------------------
	print_row es

end



(* relation: print_exp
 *
 * This relation prints a complete expression.
 *)

relation print_exp_str : Absyn.Exp => string =
	
  rule	int_string(x) => s
	----------------------------
	print_exp_str(Absyn.INTEGER(x)) => s

  rule	real_string(x) => s
	-----------------------------
	print_exp_str(Absyn.REAL(x)) => s

  rule	print_component_ref_str (c) => s
	---------------------
	print_exp_str(Absyn.CREF(c)) => s

  rule	string_append("\"", s) => s' &
	string_append(s', "\"") => s''
	---------------------------------
	print_exp_str(Absyn.STRING(s)) => s''

  rule	print_bool_str b => s
	---------------------
	print_exp_str(Absyn.BOOL(b)) => s

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.BINARY(e1, op, e2)) => s1

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.UNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str (Absyn.LBINARY(e1, op, e2)) => s'

  rule	op_symbol(op) => sym &
	print_exp_str e => s &
	string_append (sym, s) => s'
	----------------------------
	print_exp_str(Absyn.LUNARY(op, e)) => s'

  rule	op_symbol(op) => sym & 
	print_exp_str e1 => s1 &
	print_exp_str e2 => s2 &
	string_append (s1, sym) => s &
	string_append (s, s2) => s'
	---------------------------
	print_exp_str(Absyn.RELATION(e1, op, e2)) => s'

  rule	print_exp_str c => cs &
	print_exp_str t => ts &
	print_exp_str f => fs &
	string_append ("if ", cs) => s &
	string_append (s, " then ") => s' &
	string_append (s', ts) => s'' &
	string_append (s'', " else ") => s''' &
	string_append (s''', fs) => s''''
	---------------------------------
	print_exp_str(Absyn.IFEXP(c,t,f)) => s''''

  rule	print_component_ref_str(fcn) => fs &
	let argstr = "not implemented yet" & 
	string_append(fs, "(") => s &
	string_append(s, argstr) => s' &
	string_append(s', ")") => s''
	---------------------------------------------
	print_exp_str(Absyn.CALL(fcn, args)) => s''

  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.ARRAY(es) => s''

	(* PR. *)
  rule	print_list_str(es, print_exp_str, ",") => s &
	string_append ("(",s) => s' &
	string_append (s',")") => s''
	-----------------------------
	print_exp_str Absyn.TUPLE(es) => s''
	
  rule	print_list_str(es, print_row_str, ";") => s &
	string_append ("[",s) => s' &
	string_append (s',"]") => s''
	-----------------------------
	print_exp_str Absyn.MATRIX(es) => s''

  rule	print_exp_str (start) => s1 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s3) => s'' &
	string_append (s'', ")") => s'''
	--------------------------------
	print_exp_str Absyn.RANGE(start,NONE,stop) => s'''

  rule	print_exp_str (start) => s1 &
	print_exp_str (step) => s2 &
	print_exp_str (stop) => s3 &
	string_append ("(", s1) => s &
	string_append (s, ":") => s' &
	string_append (s', s2) => s'' &
	string_append (s'', ":") => s''' &
	string_append (s''', s3) => s'''' &
	string_append (s'''', ")") => s'''''
	------------------------------------
	print_exp_str Absyn.RANGE(start,SOME(step),stop) => s'''''

  axiom	print_exp_str (_) =>  "#UNKNOWN EXPRESSION#"

end


relation print_row_str : Absyn.Exp list => string =

  rule	print_list_str (es, print_exp_str, ",") => s
	----------------------------
	print_row_str es => s

end

(** relation: print_list_str
 **
 ** Same as print_list, except it returns a string
 ** instead of printing
 **)

relation print_list_str : ('a list, 'a => string, string) => string =

  axiom	print_list_str ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	print_list_str ([h],r,_) => s

  rule	r(h) => s & 
	print_list_str (t,r,sep) => srest &
	string_append (s, sep) => s' & 
	string_append (s', srest) => s''
	-------------------------------------
	print_list_str (h::t,r,sep) => s''

end


(* relation: op_symbol
 *
 * Make a string describing different operators.
 *)

relation op_symbol : Absyn.Operator => string =
  axiom	op_symbol(Absyn.ADD) => " + "
  axiom	op_symbol(Absyn.SUB) => " - "
  axiom	op_symbol(Absyn.MUL) => "*"
  axiom	op_symbol(Absyn.DIV) => "/"
  axiom	op_symbol(Absyn.POW) => "^"

  axiom	op_symbol(Absyn.UMINUS) => "-"
  axiom	op_symbol(Absyn.UPLUS) => "+"

  axiom	op_symbol(Absyn.AND) => " AND "
  axiom	op_symbol(Absyn.OR) => " OR "

  axiom	op_symbol(Absyn.NOT) => "NOT "

  axiom	op_symbol(Absyn.LESS)      => " < "
  axiom	op_symbol(Absyn.LESSEQ)    => " <= "
  axiom	op_symbol(Absyn.GREATER)   => " > "
  axiom	op_symbol(Absyn.GREATEREQ) => " >= "
  axiom	op_symbol(Absyn.EQUAL)     => " = "
  axiom	op_symbol(Absyn.NEQUAL)    => " <> "
end

(* - Utility relations
 *
 * These are utility relations used in some of the other
 * relations. *)

relation select_string: (bool,string,string) => string =

  axiom	select_string(true,a,b) => a
  axiom	select_string(false,a,b) => b

end

relation print_select: (bool,string,string) => () =

  rule	select_string(f,yes,no) => res &
	print res
	-------------------------
	print_select(f,yes,no)

end

relation print_option = (* : ('a option)*('a => 'b) = *)

  axiom	print_option(NONE,_)
	
  rule	r( x )
	------
	print_option(SOME(x),r)
	
end

relation print_list_debug : (string, 'a list, 'a => (), string) => () =

  rule	Debug.fprintln ("dumptr", "print_list_debug-1")
	-----------------------------------------------
	print_list_debug(_,[],_,_)
	
  rule	Debug.fprintl ("dumptr", ["print_list_debug-2 from ", caller, "\n"]) &
	r(h) &
	Debug.fprintln ("dumptr", "//print_list_debug-2")
	------------------
	print_list_debug(caller,[h],r,_)

  rule	string_append("print_list_debug-3 from ", caller) => s1 &
	Debug.fprintl ("dumptr", [s1, "\n"]) &
	r(h) & 
	print sep & 
	Debug.fprintln ("dumptr", "//print_list_debug-3") &
	print_list_debug(s1, rest, r, sep)
	-------------------------------------
	print_list_debug(caller, h::rest, r, sep)

end

relation print_list : ('a list, 'a => (), string) => () =

  axiom	print_list([],_,_)
	
  rule	r(h)
	------------------
	print_list([h],r,_)

  rule	r(h) & print sep &
	print_list(t,r,sep)
	-------------------------------------
	print_list(h::t,r,sep)

end


relation get_string_list : ('a list, 'a => string, string) => string =

  axiom	get_string_list ([],_,_) => ""
	
  rule	r(h) => s
	------------------
	get_string_list([h],r,_) => s

  rule	r(h) => s & 
	string_append (s, sep) => s' &
	get_string_list (t,r,sep) => srest &
	string_append (s', srest) => s''
	-------------------------------------
	get_string_list (h::t,r,sep) => s''

end

relation print_bool : bool => () =

  rule	print_select (b, "true", "false")
	---------------------------------
	print_bool b

end

relation print_bool_str : bool => string =

  rule	select_string (b, "true", "false") => s
	---------------------------------
	print_bool_str b => s

end
