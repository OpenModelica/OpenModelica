(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 codegen.rml
 ** module:      Codegen
 ** description: Generate code from DAE (Flat Modelica)
 **
 ** RCS: $Id$
 **
 **)

(* ------------------------------------------------------------------------- *)

module Codegen :
						      
    with "dae.rml"
    with "print.rml"
							  
							  
    type Ident = string
							  
    type ReturnType          = string
    type FunctionName        = string
    type ArgumentDeclaration = string
    type VariableDeclaration = string
    type InitStatement       = string
    type Statement           = string
    type CleanupStatement    = string
    type ReturnTypeStruct    = string list
							  
    datatype CFunction = CFUNCTION of 
							  ReturnType *
							  FunctionName * 
							  ReturnTypeStruct *
							  (ArgumentDeclaration list) *
							  (VariableDeclaration list) *
							  (InitStatement       list) *
							  (Statement           list) *
							  (CleanupStatement    list)
		     | CEXTFUNCTION of
							  ReturnType *
							  FunctionName *
							  ReturnTypeStruct *
							  ArgumentDeclaration list							  
  relation generate_functions : DAE.DAElist => ()
	  
end

(* ------------------------------------------------------------------------- *)

with "dump.rml"
with "debug.rml"

with "absyn.rml"
with "algorithm.rml"
with "classinf.rml"
with "exp.rml"
with "modutil.rml"
with "types.rml"
with "util.rml"

(* ------------------------------------------------------------------------- *)

val c_empty_function = CFUNCTION("","",[],[],[],[],[],[])

relation c_make_function : (ReturnType,
			    FunctionName,
			    ReturnTypeStruct,
			    ArgumentDeclaration list)
	  => CFunction =

  axiom	c_make_function (rt,fn,rts,ads) => CFUNCTION(rt,fn,rts,ads,[],[],[],[])

end

relation c_make_function_decl: (ReturnType, FunctionName, ReturnTypeStruct, ArgumentDeclaration list) => CFunction =

  axiom	c_make_function_decl(rt,fn,rts,ads) => CEXTFUNCTION(rt,fn,rts,ads)

end

relation c_add_variables : (CFunction, VariableDeclaration list) => CFunction =

  rule	list_append(vd,nvd) => vd'
	--------------------------
	c_add_variables (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nvd)
			 => CFUNCTION(rt,fn,rts,ads,vd',is,st,cl)

end


relation c_add_inits : (CFunction, InitStatement list) => CFunction =

  rule	list_append(is,nis) => is'
	--------------------------
	c_add_inits (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nis)
			 => CFUNCTION(rt,fn,rts,ads,vd,is',st,cl)

end

relation c_add_statements : (CFunction, Statement list) => CFunction =

  rule	list_append(st,nst) => st'
	--------------------------
	c_add_statements (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),nst)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st',cl)

end

relation c_add_cleanups : (CFunction, CleanupStatement list) => CFunction =

  rule	list_append(cl,ncl) => cl'
	--------------------------
	c_add_cleanups (CFUNCTION(rt,fn,rts,ads,vd,is,st,cl),ncl)
			 => CFUNCTION(rt,fn,rts,ads,vd,is,st,cl')

end

relation c_merge_fns : CFunction list => CFunction =
	
  axiom	c_merge_fns [] => c_empty_function

  rule	c_merge_fns r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	c_merge_fns cfn1::r => cfn

end

relation c_merge_fn : (CFunction, CFunction) => CFunction =

  rule	list_append(vd1,vd2) => vd &
	list_append(is1,is2) => is &
	list_append(st1,st2) => st &
	list_append(cl1,cl2) => cl 	
	-----------------------------
	c_merge_fn (CFUNCTION(rt,fn,rts,ad,vd1,is1,st1,cl1),
		    CFUNCTION(_ , _, _ , _,vd2,is2,st2,cl2)) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)
			 
end

relation c_move_statements_to_inits : CFunction => CFunction =

  rule	list_append(is,st) => is'
	---------------------------
	c_move_statements_to_inits CFUNCTION(rt,fn,rts,ad,vd,is,st,cl) 
	  => CFUNCTION(rt,fn,rts,ad,vd,is',[],cl)
end

relation c_print_functions : CFunction list => () =

  axiom	c_print_functions []

  rule	c_print_function(f) &
	c_print_functions(r)
	---------------------
	c_print_functions f::r
end

relation c_print_function : CFunction => () =

  rule	Util.string_delimit_list(ad,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,") {"] => stmt_str &
	
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	c_print_indented (stmt_str,i1) => i2 & Print.print_buf "\n" &
	c_print_indented_list (vd,i2)  => i3 & Print.print_buf "\n" &
	c_print_indented_list (is,i3)  => i4 & Print.print_buf "\n" &
	c_print_indented_list (st,i4)  => i5 & Print.print_buf "\n" &
	c_print_indented_list (cl,i5)  => i6 & Print.print_buf "\n" &
	c_print_indented      ("}",i6) => i7 & Print.print_buf "\n"
	-----------
	c_print_function CFUNCTION(rt,fn,rts,ad,vd,is,st,cl)

  rule	Util.string_delimit_list(ads,", ") => args_str &
	Util.string_append_list [rt," ",fn,"(",args_str,");\n"] => stmt_str &
	let i0 = 0 &
	c_print_indented_list (rts,i0) => i1 & Print.print_buf "\n" &
	Print.print_buf "extern " & Print.print_buf stmt_str
	---------------------------------------------------
	c_print_function CEXTFUNCTION(rt,fn,rts,ads)

  rule	Print.print_buf "# c_print_function_failed\n"
	-----------
	c_print_function _
end

relation c_print_indented_list : (string list, int) => int =
	
  axiom c_print_indented_list ([],i) => i

  rule	c_print_indented(f,i) => i' & Print.print_buf "\n" &
	c_print_indented_list(r,i') => i''
	-----------------
	c_print_indented_list(f::r,i) => i''

end

relation c_print_indented : (string, int) => int =

  rule	string_list str => strl &
	c_next_level(strl,i) => i' &
	c_this_level(strl,i) => it &
	c_print_indent it &
	Print.print_buf str 
	-----------
	c_print_indented (str,i) => i'
end

relation c_next_level : (char list, int) => int =

  axiom	c_next_level ([],i) => i

  rule	list_string [f] => "{" &
	int_add(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* { *)

  rule	list_string [f] => "}" &
	int_sub(i,2) => i' &
	c_next_level(r,i') => i''
	-----
	c_next_level (f::r,i) => i'' (* } *)

  rule	c_next_level(r,i) => i'
	-----
	c_next_level (_::r,i) => i'

end

relation c_this_level : (char list, int) => int =


  rule	list_string [f] => "#"
	----
	c_this_level(f::_,_) => 0

rule	list_string [f] => "}" &
	int_sub(i,2) => i'
	----
	c_this_level(f::_,i) => i'

  axiom	c_this_level(_,i) => i

end

relation c_print_indent : int => () =

  axiom c_print_indent 0

  rule	Print.print_buf " " &
	int_sub(i,1) => i' &
	c_print_indent i'
	----------------
	c_print_indent i

end

(* ------------------------------------------------------------------------- *)
(*
 generate_functions
 generate_functions_elist
 generate_functions_elist2
 generate_params_type
 generate_function
 generate_result_struct
 generate_return_defs
 generate_return_decls
 generate_return_decl
 is_array
 is_first_in_array
 subs_is_one
 dae_exp_type
 dae_type_str
 dae_short_type_str
 exp_short_type_str
 exp_type_str
 generate_type
 generate_return_type
 generate_array_type
 generate_array_return_type
 print_int
 print_star
 generate_tuple_type
 generate_simple_type
 array_type_string
 generate_function_name
 generate_function_arg
 generate_function_body_tuple
 generate_alloc_outvars
 generate_alloc_outvar
 prefix_cr
 generate_algorithms
 generate_algorithms2
 generate_algorithm
 generate_algorithm_statements
 generate_algorithm_statement
 generate_range_expressions
 generate_else
 generate_vars
 generate_var
 is_var_q
 generate_var_q
 generate_var_q2
 generate_result_vars
 generate_result_var
 generate_equations
 generate_exp
 get_array_dim
 generate_expressions
 generate_expression
 generate_binary
 generate_temp_decl
 generate_scalar_lhs_cref
 generate_rhs_cref
 subs_to_scalar
 generate_scalar_rhs_cref
 generate_array_rhs_cref
 generate_index_spec
 generate_indices_array
 generate_indices
 generate_index_array
 generate_index
 indent_strings
 ident_cstr
 comp_ref_cstr
 generate_lbinary
 generate_lunary
 generate_relation
 generate_matrix
 generate_read_call_write
 invar_names
 generate_read
 generate_write
 is_rcw_output
 is_rcw_input

*)
(* ------------------------------------------------------------------------- *)

relation generate_functions : DAE.DAElist => () =

  rule	Debug.fprintln ("cgtr", "generate_functions") &
	generate_functions_elist elist => cfns &
	Print.print_buf "#include \"modelica.h\"\n" &
	c_print_functions cfns &
	Print.print_buf "\n"
	------------------------------
	generate_functions DAE.DAE(elist)

  rule	Print.print_buf "# generate_functions failed\n"
	--------------------------------------
	generate_functions _ 

end



relation generate_functions_elist : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist") &
	Debug.fprintln ("cgtrdumpdae", "Dumping DAE:") &
	Debug.fcall ("cgtrdumpdae", DAE.dump2, DAE.DAE(els)) &
	DAE.get_matching(els,DAE.is_function) => fns &
	generate_functions_elist2 fns => cfns
	----------------------------
	generate_functions_elist els => cfns
	
end

relation generate_functions_elist2 : DAE.Element list => CFunction list =

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") 
	----------------------------------------------------
	generate_functions_elist2 [] => []

  rule	Debug.fprintln ("cgtr", "generate_functions_elist2") &
	generate_function f => cfns1 &
	generate_functions_elist2 rest => cfns2 &
	list_append(cfns1,cfns2) => cfns
	----------------------------
	generate_functions_elist2 f :: rest => cfns
	
end

relation generate_params_type : Ident => string =

  rule	string_append (n, "_params") => s
	---------------------------------
	generate_params_type n => s

end


relation generate_function : DAE.Element => CFunction list =

  rule	generate_function_name fpath => fn_name_str &
	Debug.fprintl ("cgtr", ["generating function ", fn_name_str, "\n"]) &


	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath           => retstr &
	Util.list_map(args, generate_function_arg)  => arg_strs &

	c_make_function(retstr, fn_name_str, struct_strs,arg_strs)=> head_cfn &

	generate_function_body_tuple(fpath, dae, restype) => body_cfn &

	c_merge_fn(head_cfn,body_cfn) => cfn &
	
	generate_read_call_write(fn_name_str,outvars,retstr,invars) => rcw_fn
	---------------------------
	generate_function DAE.FUNCTION(fpath, 
				       DAE.DAE(dae), 
				       Types.T_FUNCTION(args,restype)) 
	  => [cfn,rcw_fn]

  rule	generate_function_name fpath => fn_name_str &
	Debug.fprintl ("cgtr", ["generating external function ", fn_name_str, "\n"]) &


	let  DAE.EXTERNALDECL(extfnname,extargs,extretarg,lang) = extdecl &

	DAE.get_output_vars dae => outvars &
	DAE.get_input_vars dae => invars &
	generate_result_struct (outvars,fpath) => struct_strs &
	generate_return_type   fpath => retstructtype &
	generate_ext_return_type (extretarg) => retstr &
	generate_ext_function_name (extfnname, lang) => extfnname' &
	generate_ext_function_args (extargs, lang) => arg_strs &
        c_make_function_decl(retstr,extfnname',struct_strs,arg_strs) => func_decl &
	generate_read_call_write_external(fn_name_str,outvars,retstructtype,invars,extdecl) => rcw_fn
	---------------------------------------------------------------------------------------------
	generate_function DAE.EXTFUNCTION(fpath, 
				       DAE.DAE(dae), 
				       Types.T_FUNCTION(args,restype),
					  extdecl) 
	  => [func_decl,rcw_fn]

  rule	generate_functions_elist daelist => cfns
	----------------------
	generate_function DAE.COMP(n, DAE.DAE(daelist)) => cfns


  rule	Print.print_buf "# generate_function failed\n" &
	DAE.dump2 DAE.DAE([comp]) 
	------------------------------------
	generate_function comp => fail
	
end

relation generate_ext_function_name : (string, string) => string =

  axiom	generate_ext_function_name (name, "C") => name

  rule	string_append (name, "_") => name'
	----------------------------------
	generate_ext_function_name (name, "FORTRAN 77") => name'

  rule	Print.print_buf "#-- generate_ext_function_name failed\n" &
	Print.print_buf "#-- Unknown language in external declaration\n"
	---------------------------------------------------------
	generate_ext_function_name (_,_) => fail

end	

relation generate_result_struct : (DAE.Element list, Absyn.Path) 
	  => string list =

  rule	generate_return_type fpath => ptname &
	generate_return_decls outvars => (var_strs,var_names) &
	generate_return_defs (ptname,var_names,1) => defs &
	indent_strings var_strs => var_strs' &
	Util.string_append_list(["typedef struct ",ptname,"_s"]) => first_row &
	Util.string_append_list(["} ",ptname,";"]) => last_row &
	Util.list_flatten([defs,[first_row,"{"],var_strs',[last_row]]) => strs
	-----------------------------------------
	generate_result_struct (outvars, fpath) => strs

end

relation generate_return_defs : (string, string list, int) => string list =

  axiom generate_return_defs (_,[],_) => []
	
  rule	int_string i => i_str &
	Util.string_append_list(["#define ",tn,"_",i_str," ",f]) => f' &
	int_add(i,1) => i' &
	generate_return_defs (tn,r,i') => r'
	----
	generate_return_defs (tn,f::r,i) => f'::r'

end

relation generate_return_decls : DAE.Element list => (string list, 
						      string list) =

  axiom	generate_return_decls [] => ([],[])

  rule	generate_return_decl first => ("",_) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (rs,rd)

  rule	generate_return_decl first => (fs,fd) &
	generate_return_decls rest => (rs,rd)
	------------------
	generate_return_decls first :: rest => (fs::rs,fd::rd)

end


relation generate_return_decl: DAE.Element => (string, string) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([typ_str," ",id_str,";",
				 " /* [",dims_str,"] */"]) 
	  => decl_str
	---------------------------------------------------
	generate_return_decl (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, NONE,inst_dims))
	  => (decl_str,id_str)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (id_str,_) &
	Util.string_append_list([typ_str," ",id_str,";"]) => decl_str &
	Print.print_buf "# default/init values not implemented yet: " &
	Exp.print_exp_str e => str & Print.print_buf str &
	Print.print_buf "\n"
	-----------
	generate_return_decl (DAE.VAR(id, 
				      DAE.VARIABLE, 
				      DAE.OUTPUT, 
				      typ, 
				      SOME(e),
				      _))
	=> (decl_str,id_str)


  axiom	generate_return_decl (_) => ("","")

end

relation is_array : Exp.ComponentRef => bool =
	
  axiom	is_array Exp.CREF_IDENT(_,[]) => false
  axiom	is_array Exp.CREF_IDENT(_,_::_) => true
  axiom	is_array Exp.CREF_QUAL(_,_::_,_) => true

  rule	is_array cref => b
	------------------
	is_array Exp.CREF_QUAL(_,[],cref) => b

end

relation is_first_in_array : Exp.ComponentRef => bool =

  axiom	is_first_in_array Exp.CREF_IDENT(_,[]) => true

  rule	subs_is_one subs => b
	---------------------
	is_first_in_array Exp.CREF_IDENT(_,subs) => b

  rule	is_first_in_array cref => b
	---------------------------
	is_first_in_array Exp.CREF_QUAL(_,[],cref) => b

  rule	subs_is_one subs => b1 &
	is_first_in_array cref => b2 &
	bool_and(b1,b2) => b
	------------------------------
	is_first_in_array Exp.CREF_QUAL(_,subs,cref) => b
end

relation subs_is_one : Exp.Subscript list => bool =

  axiom subs_is_one [] => true

  rule	subs_is_one r => b
	------------------
	subs_is_one Exp.INDEX(Exp.ICONST(1))::r => b

  axiom	subs_is_one _::_ => false

end


relation dae_exp_type : DAE.Type => Exp.Type =

  axiom	dae_exp_type DAE.INT    => Exp.INT
  axiom	dae_exp_type DAE.REAL   => Exp.REAL
  axiom	dae_exp_type DAE.STRING => Exp.STRING
  axiom	dae_exp_type DAE.BOOL   => Exp.BOOL

end

relation dae_type_str : (DAE.Type, bool) => string =

  rule	dae_exp_type t => t' &
	exp_type_str (t',a) => str
	--------------------------
	dae_type_str (t,a) => str

end

relation dae_short_type_str : DAE.Type => string =

  rule	dae_exp_type t => t' &
	exp_short_type_str t' => str
	--------------------------
	dae_short_type_str t => str

end

relation exp_short_type_str : Exp.Type => string =

  axiom	exp_short_type_str Exp.INT    => "integer"
  axiom	exp_short_type_str Exp.REAL   => "real"
  axiom	exp_short_type_str Exp.STRING => "string"
  axiom	exp_short_type_str Exp.BOOL   => "boolean"
  axiom	exp_short_type_str Exp.OTHER  => "other"

end

relation exp_type_str : (Exp.Type, bool) => string =

  rule	exp_short_type_str t => tstr &
	string_append("modelica_",tstr) => str
	-----------
	exp_type_str (t, false) => str

  rule	exp_short_type_str t => tstr &
	string_append(tstr,"_array") => str
	-----------
	exp_type_str (t, true) => str

end

relation generate_type : Types.Type => string =


  rule	Debug.fprintln ("cgtr", "generate_type") &
	generate_tuple_type tys => ty_str 
	---------------------------
	generate_type Types.T_TUPLE(tys) => ty_str


  rule	Debug.fprintln ("cgtr", "generate_type") &
	Types.flatten_array_type tys => (arrayty, dims) &
	generate_array_type (arrayty, dims) => ty_str
	-----------------------------------
	generate_type (tys as Types.T_ARRAY(_,_)) => ty_str


  axiom	generate_type Types.T_INTEGER => "modelica_integer"
  axiom generate_type Types.T_REAL => "modelica_real"
  axiom	generate_type Types.T_STRING => "modelica_string"
  axiom	generate_type Types.T_BOOL => "modelica_boolean"


  rule	Print.print_buf "#-- generate_type failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type ty => fail

end


relation generate_type_external : Types.Type => string =

  axiom	generate_type_external Types.T_INTEGER  => "int"
  axiom generate_type_external Types.T_REAL => "double"
  axiom	generate_type_external Types.T_STRING => "char*"
  axiom	generate_type_external Types.T_BOOL => "int"

  rule	generate_type_external ty => str
	--------------------------------
	generate_type_external Types.T_ARRAY(dim,ty) => str

  rule	Print.print_buf "#-- generate_type_external failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type_external ty => fail

end

relation generate_type_internal : Types.Type => string =

	(* for the basic types, only those must match *)
  rule	Types.basic_type ty => true &
	generate_type_internal_namepart ty => tystr &
	string_append("modelica_",tystr) => str
	---------------------------------------
	generate_type_internal ty => str

  rule	Types.is_array ty => true &
	Types.array_element_type ty => elty &
	generate_type_internal elty => tystr &
	string_append (tystr,"_array") => str
	--------------------------------
	generate_type_internal ty => str

  rule	Print.print_buf "#-- generate_type_internal failed: " &
	Types.print_type ty & Print.print_buf "\n"
	--------------------------------
	generate_type_internal ty => fail

end

(* for the basic types, only those must match *)
relation generate_type_internal_namepart : Types.Type => string =

  axiom	generate_type_internal_namepart Types.T_INTEGER => "integer"
  axiom generate_type_internal_namepart Types.T_REAL	=> "real"
  axiom	generate_type_internal_namepart Types.T_STRING	=> "string"
  axiom	generate_type_internal_namepart Types.T_BOOL	=> "boolean"
  axiom	generate_type_internal_namepart Types.T_ENUM	=> "NOT_IMPLEMENTED"

end


relation generate_return_type : Absyn.Path => string =

  rule	generate_function_name fpath => fstr &
	string_append (fstr, "_rettype" ) => res
	--------------------------
	generate_return_type fpath => res
end


relation generate_array_type : (Types.Type, int list) => string =

  rule	array_type_string ty => str 
	--------------------------
	generate_array_type (ty, dims) => str
end

relation generate_array_return_type : (Types.Type, int list) => string =

  rule	array_type_string ty => ty_str
	-------------------------------
	generate_array_return_type (ty, dims) => ty_str
end


relation print_int : int => () =

  rule	int_string i => str &
	Print.print_buf str
	---------
	print_int i
end

relation print_star : int => () =

  rule	Print.print_buf "*"
	---------
	print_star i

end



relation generate_tuple_type : Types.Type list => string =


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_1") &
	generate_simple_type ty => str
	--------------------------------
	generate_tuple_type [ty] => str


  rule	Debug.fprintln ("cgtr", "generate_tuple_type_2") &
	generate_simple_type ty => str &
	generate_tuple_type tys => str' &
	string_append (str, str') => str'' &
	string_append ("struct ", str'') => str'''
	----------------------------------
	generate_tuple_type (ty::tys) => str'''

end



relation generate_simple_type : Types.Type => string =

  axiom	generate_simple_type Types.T_INTEGER => "modelica_integer"
  axiom	generate_simple_type Types.T_REAL => "modelica_real"
  axiom	generate_simple_type Types.T_STRING => "modelica_string"
  axiom	generate_simple_type Types.T_BOOL => "modelica_boolean"

  rule	string_append ("const ", n) => n' &
	string_append (n', "&") => n''
	------------------------------
	generate_simple_type Types.T_COMPLEX (ClassInf.RECORD(n),_) => n''

  rule	Types.array_element_type t => t' &
	array_type_string t' => t_str
	-----------------------
	generate_simple_type (t as Types.T_ARRAY(_,_)) => t_str

  rule	Print.print_buf "#--generate_simple_type failed " &
	Types.print_type ty & 
	Print.print_buf "\n"
	--------------------------------------
	generate_simple_type ty => fail
end

relation array_type_string : Types.Type => string =

  axiom	array_type_string Types.T_INTEGER => "integer_array"
  axiom	array_type_string Types.T_REAL => "real_array"
  axiom	array_type_string Types.T_STRING => "string_array"
  axiom	array_type_string Types.T_BOOL => "boolean_array"

end

relation generate_function_name : Absyn.Path => string =

  rule	ModUtil.path_string fpath => fstr 
	----------
	generate_function_name fpath => fstr

end

(* input string is language, e.g. "C" or "FORTRAN 77" *)
relation generate_ext_function_args : (DAE.ExtArg list, string) => string list = 

  rule	Util.list_map(extargs,generate_ext_function_arg) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "C") => arg_strs

  rule	Util.list_map(extargs,generate_ext_function_arg_f77) => arg_strs
	------------------------------------------------------------
	generate_ext_function_args (extargs, "FORTRAN 77") => arg_strs

  rule	Print.print_buf "#-- Unknown external language declaration\n" &
	Print.print_buf lang
	--------------------
	generate_ext_function_args (_,lang) => fail

end	


relation generate_function_arg : Types.FuncArg => string =

  rule	generate_tuple_type [ty] => str &
	string_append (str, " ") => str' &
	string_append (str', name) => str''
	-----------------------------------
	generate_function_arg ((name, ty)) => str''

end

relation generate_ext_arg_type : (Types.Attributes, Types.Type) => string =

  rule	Types.is_array ty => false & 
	generate_type_external ty => str
	--------------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => str

  rule	Types.is_array ty => true & 
	generate_type_external ty => str &
	string_append(str," const *") => resstr
	----------------------------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_type_external ty => tystr &
	string_append("*", tystr) => str
	--------------------------------
	generate_ext_arg_type (Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type failed\n"
	----------------------------------------------------
	generate_ext_arg_type (_,_) => fail

end	

relation generate_ext_function_arg : DAE.ExtArg => string =

(* LS: Why different names, it's only the declaration anyway *)
(* commenting out *)

(*
  rule	Types.is_array ty => false &
	generate_ext_arg_type (attr,ty) => tystr &
	var_name_external cref => name &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARG(cref, attr, ty) => res
*)

  rule	(* Types.is_array ty => true & *)
	generate_ext_arg_type (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg DAE.EXTARG(cref, attr, ty) => res

  axiom	generate_ext_function_arg DAE.EXTARGSIZE(_,_,_,_) => "size_t"

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg (_) => fail

end

relation generate_ext_arg_type_f77 : (Types.Attributes, Types.Type) => string =

  rule	generate_type_external ty => str &
	string_append(str," const *") => resstr
	----------------------------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.INPUT), ty) => resstr

  rule	generate_type_external ty => tystr &
	string_append(tystr, "*") => str
	--------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => str

  rule	generate_type_external ty => tystr &
	string_append("*", tystr) => str
	--------------------------------
	generate_ext_arg_type_f77 (Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str

  rule	Print.print_buf "#-- generate_ext_arg_type_f77 failed\n"
	----------------------------------------------------
	generate_ext_arg_type_f77 (_,_) => fail

end	

relation generate_ext_function_arg_f77 : DAE.ExtArg => string =

  rule	generate_ext_arg_type_f77 (attr,ty) => tystr &
	comp_ref_cstr cref => (name,_) &
	Util.string_append_list([tystr, " ", name]) => res
	-----------------------------------
	generate_ext_function_arg_f77 DAE.EXTARG(cref, attr, ty) => res

  axiom	generate_ext_function_arg_f77 DAE.EXTARGSIZE(_,_,_,_) => "int const *"

  rule	Print.print_buf "#-- generate_ext_function_arg failed\n"
	----------------------------------------------------
	generate_ext_function_arg_f77 (_) => fail

end

(*
relation generate_ext_arg_dims : (Ident, int list) => string =

  rule	generate_ext_arg_dims_2 (name,dims,1) => str	
	-----------------------------------------
       	generate_ext_arg_dims (name,dims) => str

end

relation generate_ext_arg_dims_2 : (Ident, int list, int) => string =

  rule	int_string i => dimno &
	Util.string_append_list (["size_t ", name, "_dim", dimno]) => str
	------------------------------------------
	generate_ext_arg_dims_2 (name, [v], i) => str

  rule	int_add(i,1) => ipp &
	generate_ext_arg_dims_2 (name, rest, ipp) => reststr &
	int_string i => dimno &
	Util.string_append_list(["size_t", name, "_dim", dimno, ", ", reststr]) => str
	--------------------------------------------------------------------
	generate_ext_arg_dims_2 (name, v::rest, i) => str

end
*)

relation generate_ext_return_type : DAE.ExtArg => string =

  rule	generate_type_external ty => res
	--------------------------------------------------
	generate_ext_return_type DAE.EXTARG(cref, attr, ty) => res

  axiom generate_ext_return_type DAE.NOEXTARG => "void"

  rule	Print.print_buf "#-- generate_ext_return_type failed\n" 
	--------------------------------------------------------
	generate_ext_return_type _ => fail
end

relation generate_ext_return_type_f77 : DAE.ExtArg => string =

  rule	generate_ext_return_type arg => str
	-----------------------------------
	generate_ext_return_type_f77 arg => str

end	


relation generate_function_body_tuple : (Absyn.Path, 
					 DAE.Element list, 
					 Types.Type) 
	  => CFunction =
	  
  rule	Debug.fprintln ("cgtr", "generate_function_body_tuple") &
	
	let tnr = 1 &

	generate_return_type fpath => ret_type_str &
	generate_temp_decl(ret_type_str,tnr) => (ret_decl, ret_var, tnr_ret') &
	Util.string_append_list(["return ",ret_var,";"]) => ret_stmt &

	DAE.get_output_vars dae => outvars &
	generate_alloc_outvars(outvars,ret_decl,ret_var,tnr_ret')
	  => (out_fn,tnr_ret) &

	generate_temp_decl("state",tnr_ret) 
	      => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var," = get_memory_state();"]) 
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &

	c_add_variables (out_fn, [mem_decl])  => mem_fn' &
	c_add_inits     (mem_fn',[mem_stmt1]) => mem_fn &

	generate_vars        (dae, is_var_q, tnr_mem)=> (var_fn,tnr_var) &
	generate_algorithms  (dae, tnr_var)          => (alg_fn,tnr_alg) &
	generate_result_vars (dae, ret_var, tnr_alg) => (res_var_fn,tnr_res) &
	
	c_merge_fn(mem_fn, var_fn)     => cfn' &
	c_merge_fn(cfn'  , alg_fn)     => cfn'' &
	c_merge_fn(cfn'' , res_var_fn) => cfn''' &

	c_add_cleanups(cfn''',[mem_stmt2,ret_stmt]) => cfn
	--------------
	generate_function_body_tuple (fpath, dae, restype) => cfn

end

relation generate_alloc_outvars : (DAE.Element list, string, string,int) 
	  => (CFunction,int) =

	  
  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------
	generate_alloc_outvars([],rd,rv,tnr) => (cfn,tnr)

  rule	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars(r,rd,rv,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------
	generate_alloc_outvars ((var as DAE.VAR(cr,vk,vd,t,e,id))::r,
				rd,rv,tnr)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars(r,rd,rv,tnr) => (cfn2,tnr2)
	--------------
	generate_alloc_outvars (_::r,rd,rv,tnr) => (cfn2,tnr2)

end

relation generate_alloc_outvar : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(inst_dims,tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &

	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",prefix,".",cref_str,", ",
			ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	-----------
	generate_alloc_outvar(DAE.VAR(id, vk, vd, typ, e,inst_dims),
			      prefix,
			      tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	-------------
	generate_alloc_outvar (e,_,tnr) => (c_empty_function,tnr)

end

relation generate_alloc_outvars_ext : (DAE.Element list, string, string,int, DAE.ExternalDecl) 
	  => (CFunction,int) =

	  
  rule	c_add_variables(c_empty_function,[rd]) => cfn
	---------
	generate_alloc_outvars_ext([],rd,rv,tnr,extdecl) => (cfn,tnr)

  rule	let DAE.EXTERNALDECL(_,_,_,"C") = extdecl &
	generate_alloc_outvar(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rd,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,id))::r,
				rd,rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	let DAE.EXTERNALDECL(_,_,_,"FORTRAN 77") = extdecl &
	generate_alloc_outvar_f77(var,rv,tnr) => (cfn1,tnr1) &
	generate_alloc_outvars_ext(r,rd,rv,tnr1,extdecl) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------------
	generate_alloc_outvars_ext ((var as DAE.VAR(cr,vk,vd,t,e,id))::r,
				rd,rv,tnr,extdecl)
	  => (cfn,tnr2)

  rule	generate_alloc_outvars_ext(r,rd,rv,tnr,extdecl) => (cfn2,tnr2)
	------------------------------------------------------
	generate_alloc_outvars_ext (_::r,rd,rv,tnr,extdecl) => (cfn2,tnr2)

end

relation generate_alloc_outvar_f77 : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	var_name_external id => cref_str &
	list_reverse inst_dims => inst_dims' &
	generate_size_subscripts(inst_dims',tnr) => (cfn1,dim_strs,tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &

	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",cref_str,", ",
			ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(cfn1',[alloc_str]) => cfn' &
	Util.if (is_a,cfn',cfn1') => cfn
	-----------
	generate_alloc_outvar_f77(DAE.VAR(id, vk, vd, typ, e,inst_dims),
				  prefix,
				  tnr) 
	  => (cfn,tnr1)

  rule	not DAE.is_var e
	-------------
	generate_alloc_outvar_f77 (e,_,tnr) => (c_empty_function,tnr)

end

relation generate_size_subscripts : (Exp.Subscript list,int)
	  => (CFunction,string list,int) =

  axiom	generate_size_subscripts ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (e,tnr) => (cfn1,var1,tnr1) &
	generate_size_subscripts (r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_size_subscripts (Exp.INDEX(e)::r,tnr)
	  => (cfn,var1::vars2,tnr2)

  rule	Print.print_buf "# generate_size_subscripts failed\n" & Print.print_buf " - [" &
	Dump.print_list(subs,Exp.print_subscript,", ") & Print.print_buf "]\n"
	-----------
	generate_size_subscripts(subs,_) => fail

end

relation generate_alloc_array_f77 : (string , Types.Type) => CFunction =

  rule	Types.is_array ty => true &
	Types.flatten_array_type ty => (elty, dims) &
	Exp.int_subscripts dims => dimsubs &
	tick => tnr &
	generate_size_subscripts(dimsubs, tnr) => (cfn1, dim_strs, tnr1) &
	c_move_statements_to_inits cfn1 => cfn1' &
	generate_type ty => typ_str &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list(["alloc_",typ_str,
			"(&",crefstr,", ", ndims_str,", ",dims_str,");"])
	  => alloc_str &
	  
	  c_add_inits(cfn1',[alloc_str]) => cfn
	---------------------------------------
	generate_alloc_array_f77 (crefstr, ty) => cfn


  rule	Print.print_buf "#-- generate_alloc_array_f77 failed\n"
	-------------------------------------------------------
	generate_alloc_array_f77 (_,_) => fail

end

relation prefix_cr : (string, Exp.ComponentRef) => Exp.ComponentRef =

  axiom	prefix_cr (prf,cref) 
	  => Exp.CREF_QUAL(prf,[],cref)
	  
end

relation generate_algorithms: (DAE.Element list, int)
	  => (CFunction, int) =

  rule	DAE.get_matching(els,DAE.is_algorithm) => algs &
	generate_algorithms2(algs,tnr) => (cfn,tnr') 
	------------------------
	generate_algorithms (els, tnr) => (cfn,tnr')

end

relation generate_algorithms2: (DAE.Element list, int)
	  => (CFunction, int) =

  axiom	generate_algorithms2 ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm (first,tnr) => (cfn1,tnr1) &
	generate_algorithms2 (rest,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------
	generate_algorithms2 (first::rest, tnr) => (cfn,tnr2)

end



relation generate_algorithm: (DAE.Element, int)
	  => (CFunction, int) =

  rule	generate_algorithm_statements (stmts,tnr) => (cfn,tnr') 
	----------------------------------------
	generate_algorithm (DAE.ALGORITHM(Algorithm.ALGORITHM(stmts)),tnr)
	  => (cfn,tnr')

  rule	Print.print_buf "# generate_algorithm failed\n"
	------------------------------------
  	generate_algorithm (_,_) => fail

end

relation generate_algorithm_statements : (Algorithm.Statement list, int)
	  => (CFunction, int) =

  axiom	generate_algorithm_statements ([],tnr) => (c_empty_function,tnr)

  rule	generate_algorithm_statement (f,tnr) => (cfn1,tnr1) &
	generate_algorithm_statements(r,tnr1) =>(cfn2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn
	-----------
	generate_algorithm_statements (f::r, tnr) => (cfn,tnr2)
end


(*
 relation : generate_algorithm_statement

 returns:
   CFunction | Code
   string    | expression result: variable name, or 'c' expression
   int       | next temporary number 
 *)

relation generate_algorithm_statement : (Algorithm.Statement, int)
	  => (CFunction, int) =

  rule	Debug.fprintln("cgas","generate_algorithm_statement") &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_scalar_lhs_cref(typ,cref,tnr1)
	  => (cfn2,var2,tnr2) &
	Util.string_append_list([var2," = ",var1,";"]) => stmt &

	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	----------------
	generate_algorithm_statement (Algorithm.ASSIGN(typ,cref,exp),tnr)
	  => (cfn, tnr2)

  rule	comp_ref_cstr cref => (cref_str,[]) &
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["copy_",type_str,"_data(&",
			var1,", &",cref_str,");"]) => stmt &
	  c_add_statements(cfn1,[stmt]) => cfn2
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn2,tnr1)

  rule	comp_ref_cstr cref => (cref_str,subs as _::_) &
	
	generate_expression(exp,tnr) => (cfn1,var1,tnr1) &
	generate_index_spec(subs,tnr1) => (cfn2,var2,tnr2) &
	exp_type_str(typ,true) => type_str &
	Util.string_append_list(["indexed_assign_",type_str,"(&",
			var1,", &",cref_str,", &",var2,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.ASSIGN_ARR(typ,cref,exp),tnr) 
	  => (cfn,tnr2)

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	
	Util.string_append_list(["if (",var1,") {"]) => if_begin &
	c_add_statements(cfn1,[if_begin]) => cfn1' &
	generate_algorithm_statements(then,tnr1) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	generate_else (else,tnr2) => (cfn3,tnr3) &
	c_merge_fns([cfn1',cfn2',cfn3]) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.IF(e,then,else),tnr) 
	  => (cfn,tnr3)

  rule	Exp.is_range e => true &
	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	exp_short_type_str t => short_type &
	generate_temp_decl(ident_type_str,tnr1) => (rdecl1,rvar1,tnr2'') &
	generate_temp_decl(ident_type_str,tnr2'') => (rdecl2,rvar2,tnr2''') &
	generate_temp_decl(ident_type_str,tnr2''') => (rdecl3,rvar3,tnr2) &

	generate_range_expressions(e,tnr2) => (cfn3,e1var,e2var,e3var,tnr3) &
	Util.string_append_list([rvar1," = ",e1var,"; ",
				 rvar2," = ",e2var,"; ",
				 rvar3," = ",e3var,";"]) => r_stmt &
	Util.string_append_list(["for (",i," = ",rvar1,"; ",
			    "in_range_",short_type,"(",i,", ",rvar1,", ",rvar3,"); ",
			    i," += ",rvar2,") {"]) => for_begin &

	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &

	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &

	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &

	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &

	c_add_variables(cfn3,[sdecl,rdecl1,rdecl2,rdecl3]) => cfn3' &
	c_add_statements(cfn3',[r_stmt,
				def_beg1,
				for_begin,
				mem_begin]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	generate_temp_decl("state",tnr) => (sdecl,svar,tnr') &
	generate_temp_decl("",tnr') => (_,dvar,tnr'') &
	generate_temp_decl("int",tnr'') => (tdecl,tvar,tnr1) &
	exp_type_str (t,a) => ident_type_str &
	generate_temp_decl(ident_type_str,tnr1) => (idecl,ivar,tnr2) &
	exp_type_str (t,true) => array_type_str &
	generate_expression(e,tnr2) => (cfn3,evar,tnr3) &
	Util.string_append_list(["for (",tvar," = 0; ",
			    tvar," < size_of_dimension_",array_type_str,"(",evar,", 1); ",
			    "++",tvar,") {"]) => for_begin &
	Util.string_append_list(["{\n  ",ident_type_str," ",i,";\n"]) => def_beg1 &
	Util.string_append_list([svar," = get_memory_state();"]) => mem_begin &
	Util.string_append_list(["simple_index_alloc_",ident_type_str,
			    "1(&",evar,", ",tvar,", &",ivar,"));"]) 
	  => stmt_array &
	Util.string_append_list([i," = *(",array_type_str,"_element_addr1(&",
			    evar,", 1, ",tvar,"));"]) => stmt_scalar & (* Use fast implementation for 1 dim *)

	Util.if(a,stmt_array,stmt_scalar) => stmt &
	generate_algorithm_statements(stmts,tnr3) => (cfn4,tnr4) &
	Util.string_append_list(["restore_memory_state(",svar,");"]) 
	  => mem_end &
	let for_end = "}" &
	let def_end1 = "} /* end for*/\n" &
	c_add_variables(cfn3,[sdecl,tdecl,idecl]) => cfn3' &
	c_add_statements(cfn3',[def_beg1,
				for_begin,
				mem_begin,stmt]) => cfn3'' &
	
	c_add_statements(cfn4,[mem_end,
			       for_end,
			       def_end1]) => cfn4' &

	c_merge_fns([cfn3'',cfn4']) => cfn	
	
	-------------------------
	generate_algorithm_statement (Algorithm.FOR(t,a,i,e,stmts),tnr)
	  => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["while (1) {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (!",var2,") break;"]) => crit_stmt &
	c_add_statements(cfn2,[crit_stmt]) => cfn2' &

	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1,cfn2',cfn3']) => cfn
	-------------------------
	generate_algorithm_statement (Algorithm.WHILE(e,stmts),tnr) 
	  => (cfn,tnr3)

  rule	Print.print_buf "# when statement not implemented\n"
	-------------------------
	generate_algorithm_statement (Algorithm.WHEN(_,_),_) => fail

  rule	Print.print_buf "# generate_algorithm_statement failed\n"
	-------------------------
	generate_algorithm_statement (_,_) => fail

end

relation generate_range_expressions : (Exp.Exp, int)
	  => (CFunction, string, string, string, int) =


  rule	generate_expression (e1,tnr) => (cfn1,var1,tnr1) &
	let var2 = "(1)" &
	generate_expression (e3,tnr1) => (cfn3,var3,tnr3) &
	
	c_merge_fn(cfn1,cfn3) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,NONE,e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	generate_expression (e1,tnr)  => (cfn1,var1,tnr1) &
	generate_expression (e2,tnr1) => (cfn2,var2,tnr2) &
	generate_expression (e3,tnr2) => (cfn3,var3,tnr3) &
	
	c_merge_fns([cfn1,cfn2,cfn3]) => cfn 
	-----------------------
	generate_range_expressions(Exp.RANGE(t,e1,SOME(e2),e3),tnr) 
	  => (cfn,var1,var2,var3,tnr3)

  rule	Print.print_buf "# generate_range_expressions failed\n"
	-----------------------
	generate_range_expressions(_,_) => fail

end

relation generate_else : (Algorithm.Else, int) => (CFunction, int) =

  axiom	generate_else (Algorithm.NOELSE,tnr) => (c_empty_function,tnr)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_expression(e,tnr) => (cfn2,var2,tnr2) &
	Util.string_append_list(["if (",var2,") {"]) => if_begin &
	c_add_statements(cfn2,[if_begin]) => cfn2' &
	generate_algorithm_statements(stmts,tnr2) => (cfn3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &
	generate_else(else,tnr3) => (cfn4,tnr4) &
	c_add_statements(cfn4,["}"]) => cfn4' &
	c_merge_fns([cfn1,cfn2',cfn3',cfn4']) => cfn
	-------
	generate_else (Algorithm.ELSEIF(e,stmts,else),tnr) => (cfn,tnr4)

  rule	c_add_statements(c_empty_function,["else {"]) => cfn1 &
	generate_algorithm_statements(stmts,tnr) => (cfn2,tnr2) &
	c_add_statements(cfn2,["}"]) => cfn2' &
	c_merge_fn(cfn1,cfn2') => cfn
	--------
	generate_else (Algorithm.ELSE(stmts),tnr) => (cfn,tnr)

  rule	Print.print_buf "# generate_else failed\n"
	---------------
	generate_else (_,_) => fail
end

relation generate_vars : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_vars ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var (first,tnr)  => (cfn1,tnr1) & 
	generate_vars (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_vars (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_vars (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_vars failed\n"
	---------------------------------
	generate_vars (_,_,_) => fail
	
end

relation generate_var_decls : (DAE.Element list,DAE.Element => (),int) 
	  => (CFunction,int) =

  axiom	generate_var_decls ([],_,tnr) => (c_empty_function,tnr)
	
  rule	verify first &
	generate_var_decl (first,tnr)  => (cfn1,tnr1) & 
	generate_var_decls (rest,verify,tnr1)  => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	not verify first &
	generate_var_decls (rest,verify,tnr)  => (cfn,tnr2)
	--------------------
	generate_var_decls (first :: rest,verify,tnr)  => (cfn,tnr2) 

  rule	Print.print_buf "# generate_var_decls failed\n"
	---------------------------------
	generate_var_decls (_,_,_) => fail
	
end



relation generate_var : (DAE.Element,int) => (CFunction,int) =
(*
 parameters are put in the params struct

  rule	generate_var_q2 (vd) &
	indent 2 &
	DAE.dump_type typ &
	Exp.print_component_ref id &
	Print.print_buf " = 0;  /* Warning: without value, set to zero */\n"
	-----------
	generate_var(DAE.VAR(id, DAE.PARAM, vd, typ, NONE,_))
*)

  rule	is_first_in_array id => false
	-----------------------------
	generate_var(DAE.VAR(id,_,_,_,_,_),tnr) => (c_empty_function,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn
	----------------------------------------------------
	generate_var(DAE.VAR(id, vk, vd, typ, NONE,inst_dims),tnr) => (cfn,tnr1)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	generate_size_subscripts(inst_dims,tnr) => (cfn1',vars1,tnr1) &
	c_move_statements_to_inits cfn1' => cfn1 &
	Util.string_delimit_list(vars1,", ") => dimvars_str &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])
	  => decl_str &
	Util.string_append_list(["alloc_",typ_str,"(&",cref_str,", ",
			ndims_str,", ",dimvars_str,");"]) => alloc_str &
	c_add_variables(cfn1,[decl_str]) => cfn' &
	c_add_inits(cfn',[alloc_str]) => cfn'' &
	Util.if (is_a,cfn'',cfn') => cfn &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) 
	  => (cfn,tnr1)

  
  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.string_append_list([typ_str," ",cref_str,";"]) => decl_str &
	generate_expression(e,tnr) => (cfn,var,tnr1) &
	c_add_variables(cfn,[decl_str]) => cfn' &
	Util.string_append_list([cref_str," = ",var,";"]) => init_stmt &
	c_add_inits(cfn',[init_stmt]) => cfn'' &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) => (cfn'',tnr1)
	
  rule	Print.print_buf "# generate_var failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var (e,_) => fail
end

relation generate_var_decl : (DAE.Element,int) => (CFunction,int) =

  rule	is_first_in_array id => false
	-----------------------------
	generate_var_decl(DAE.VAR(id,_,_,_,_,_),tnr) => (c_empty_function,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])=> decl_str &
	
	c_add_variables(c_empty_function,[decl_str]) => cfn
	----------------------------------------------------
	generate_var_decl(DAE.VAR(id, vk, vd, typ, NONE,inst_dims),tnr) => (cfn,tnr)

  rule	is_array id => is_a &
	is_first_in_array id => true &
	dae_type_str (typ,is_a) => typ_str &
	comp_ref_cstr id => (cref_str,_) &
	Util.list_map(inst_dims,dim_string) => dim_strs &
	Util.string_delimit_list(dim_strs,", ") => dims_str &
	Util.string_append_list([" /* [",dims_str,"] */"]) => dim_comment &
	Util.if (is_a,dim_comment,"") => dim_comment' &
	list_length dim_strs => ndims &
	int_string ndims => ndims_str &
	Util.string_append_list([typ_str," ",cref_str,";",dim_comment'])
	  => decl_str &
	c_add_variables(c_empty_function,[decl_str]) => cfn &
	Print.print_buf "# default value not implemented yet: " &
	Exp.print_exp e & Print.print_buf "\n"
	-----------
	generate_var_decl(DAE.VAR(id, vk, vd, typ, SOME(e),inst_dims),tnr) 
	  => (cfn,tnr)

	
  rule	Print.print_buf "# generate_var failed\n  " &
	DAE.dump_debug_element e & Print.print_buf "\n"
	-----------------------------------
	generate_var_decl (e,_) => fail
end

relation dim_string : Exp.Subscript => string =

  rule	int_string i => str
	---------------------
	dim_string Exp.INDEX(Exp.ICONST(i)) => str

  axiom	dim_string _ => ":"

end
relation is_var_q : DAE.Element => () =

  rule	generate_var_q(vk) &
	generate_var_q2(vd)
	---------------------
	is_var_q DAE.VAR(id,vk,vd,_,_,_)

end
relation generate_var_q : DAE.VarKind => () =

  axiom	generate_var_q DAE.VARIABLE
(*  axiom	generate_var_q DAE.PARAM *)
  axiom	generate_var_q DAE.CONST 

end

relation generate_var_q2 : DAE.VarDirection => () =

  axiom	generate_var_q2 DAE.OUTPUT
  axiom	generate_var_q2 DAE.BIDIR

end


relation generate_result_vars : (DAE.Element list,string, int) 
	  => (CFunction, int) =

  axiom	generate_result_vars ([],_,tnr) => (c_empty_function,tnr)

  rule	generate_result_var (first,varname,tnr) => (cfn1,tnr1) &
	generate_result_vars (rest,varname,tnr1) => (cfn2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	--------------------------------
	generate_result_vars (first :: rest,varname,tnr) => (cfn,tnr2)

end

relation generate_result_var : (DAE.Element,string,int) => (CFunction,int) =

  rule	is_array id => false &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list([varname,".",cref_str1," = ",cref_str2,";"])
	  =>stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => true &
	dae_type_str (typ, true) => typ_str &
	comp_ref_cstr id => (cref_str1,_) &
	comp_ref_cstr id => (cref_str2,_) &
	Util.string_append_list(["copy_",typ_str,"_data(&",
			cref_str1,", &",varname,".",cref_str2,");"]) 
	  => stmt &
	c_add_cleanups(c_empty_function,[stmt]) => cfn
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (cfn,tnr)

  rule	is_array id => true &
	is_first_in_array id => false
	-----------
	generate_result_var (DAE.VAR(id, DAE.VARIABLE, DAE.OUTPUT, typ, _,_),
			     varname,
			     tnr)
	  => (c_empty_function,tnr)

  axiom	generate_result_var (_,_,tnr) => (c_empty_function,tnr)

end


(* LS: ATT! These can only be assignments for the moment, 
 since no sorting or solving exists *)

relation generate_equations : DAE.Element list => () =

  axiom	generate_equations []

  rule	Exp.print_exp e1 &
	Print.print_buf " = " &
	Exp.print_exp e2 &
	Print.print_buf ";\n" &
	generate_equations rest
	------------------
	generate_equations DAE.EQUATION(e1,e2) :: rest

  rule	generate_equations rest
	-----------------------
	generate_equations _ :: rest

end

relation generate_exp : Exp.Exp => () =

  rule	Print.print_buf "{" &
	Exp.print_list (es, generate_exp, ", ") &
	Print.print_buf "}"
	---------------------------------------
	generate_exp Exp.ARRAY(_,_,es)

  rule	Exp.print_exp e
	---------------
	generate_exp e

end



relation get_array_dim : Types.Type => int =

  axiom	get_array_dim Types.T_ARRAY(Types.DIM(SOME(ad)), ty2) => ad

	(** LS: Fail if not array, or if there is no dim value **)

end




relation generate_expressions : (Exp.Exp list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_expressions ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_expression (f,tnr) => (cfn1,var1,tnr1) &
	generate_expressions(r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn 
	----
	generate_expressions (f::r,tnr) => (cfn,var1::vars2,tnr2)

end




(*
 generate_expression

 returns
   CFunction | the generated code
   string    | expression result variable name, or c expression
   int       | next temporary number 
*)
 
relation generate_expression : (Exp.Exp, int) => (CFunction,string,int) =
	  
  rule	int_string i => istr
	-----------------------------------------------------
	generate_expression(Exp.ICONST(i),tnr) => (c_empty_function,istr,tnr)

  rule	real_string r => rstr
	------------------
	generate_expression(Exp.RCONST(r),tnr) => (c_empty_function,rstr,tnr)
	
  rule	Print.print_buf "# sconst not implemented\n"
	-------------------------
	generate_expression(Exp.SCONST(_),_) => fail

  rule	Util.if(b,"(1)","(0)") => var
	-------------------------
	generate_expression(Exp.BCONST(b),tnr) => (c_empty_function,var,tnr)

  rule	generate_rhs_cref(cref, t, tnr) => (cfn,var,tnr')
	-------------------------------------------------
	generate_expression(Exp.CREF(cref,t),tnr) => (cfn,var,tnr')

  rule	generate_binary(e1,op,e2,tnr) => (cfn, var, tnr')
	-------------------------------------------------
	generate_expression(Exp.BINARY(e1,op,e2),tnr) => (cfn, var, tnr')

  rule	generate_unary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.UNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_lbinary(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LBINARY(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_lunary(op,e,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.LUNARY(op,e),tnr) => (cfn,var,tnr')

  rule	generate_relation(e1,op,e2,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.RELATION(e1,op,e2),tnr) => (cfn,var,tnr')

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	generate_temp_decl("modelica_boolean",tnr1) => (decl,tvar,tnr1') &
	Util.string_append_list([tvar," = ",var1,";"]) => b_stmt &
	Util.string_append_list(["if (",tvar,") {"]) => if_begin &
	c_add_statements(cfn1,[b_stmt,if_begin]) => cfn1'' &
	c_add_variables(cfn1'',[decl]) => cfn1' &	

	generate_expression(then,tnr1') => (cfn2,var2,tnr2) &
	c_add_statements(cfn2,["}","else {"]) => cfn2' &

	generate_expression(else,tnr2) => (cfn3,var3,tnr3) &
	c_add_statements(cfn3,["}"]) => cfn3' &

	c_merge_fns([cfn1',cfn2',cfn3']) => cfn &

	Util.string_append_list(["((",tvar,")?",var2,":",var3,")"]) => var
	-------------------------
	generate_expression(Exp.IFEXP(e,then,else),tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"])
	  => stmt &

	c_add_statements(cfn2,[stmt]) => cfn &

	Util.string_append_list([tvar,".",ret_type,"_1"]) => var_not_bi &
	Util.if(builtin,tvar,var_not_bi) => var
	-------------------------
	generate_expression(Exp.CALL(fn,args,false,builtin),tnr) 
	  => (cfn,var,tnr2)

rule	generate_expressions(args,tnr) => (cfn1,vars1,tnr1) &
	generate_return_type fn => ret_type &
	generate_function_name fn => fn_name &
	generate_temp_decl(ret_type,tnr1) => (tdecl,tvar,tnr2) &
	c_add_variables(cfn1,[tdecl]) => cfn2 &
		
	Util.string_delimit_list(vars1,", ") => args_str &
	Util.string_append_list([tvar," = ",fn_name,"(", args_str,");"]) => stmt &

	c_add_statements(cfn2,[stmt]) => cfn
	-------------------------
	generate_expression(Exp.CALL(fn,args,true,builtin),tnr) 
	  => (cfn,tvar,tnr2)

  rule	generate_expressions(elist,tnr) => (cfn1,vars1,tnr1) &
	list_length vars1 => nvars &
	int_string nvars => nvars_str &
	exp_type_str (t,true) => array_type_str &
	exp_short_type_str t => short_type_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(a,"","scalar_") => scalar &
	Util.if(a,"&","") => scalar_ref &
	string_append(", ",scalar_ref) => scalar_delimit &
	Util.string_delimit_list (vars1, scalar_delimit) => args_str &
	Util.string_append_list ["array_",scalar,array_type_str,"(&",
				 tvar,", ",nvars_str,", ",
				 scalar_ref,args_str,");"
				 ] => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------
	generate_expression(Exp.ARRAY(t,a,elist),tnr) => (cfn,tvar,tnr2)

  rule	generate_matrix(t,maxn,ell,tnr) => (cfn,var,tnr')
	-------------------------
	generate_expression(Exp.MATRIX(t,maxn,ell),tnr) => (cfn,var,tnr')

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var2,", 1, &",tvar,");"]) => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,NONE,e2),tnr) => (cfn,tvar,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	generate_expression(e3,tnr1)=> (cfn3,var3,tnr3) &
	exp_type_str (t,true) => type_string &
	generate_temp_decl(type_string,tnr3) => (tdecl,tvar,tnr4) &
	Util.string_append_list(["range_alloc_",type_string,"(",
				 var1,", ",var3,", ",var2,", &",tvar,");"]) 
	  => stmt &

	c_add_variables(cfn1,[tdecl]) => cfn1' &
	c_add_statements(cfn2,[stmt]) => cfn2' &
	c_merge_fns([cfn1',cfn2']) => cfn
	-------------------------
	generate_expression(Exp.RANGE(t,e1,SOME(e2),e3),tnr) => (cfn,tvar,tnr4)

  rule	Print.print_buf "# tuple not implemented\n"
	-------------------------
	generate_expression(Exp.TUPLE(_),_) => fail

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_int)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.INT,e),tnr) => (cfn,var',tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list(["((modelica_real)",var,")"]) => var'
	-------------------------------------
	generate_expression(Exp.CAST(Exp.REAL,e),tnr) => (cfn,var',tnr')

  rule	Print.print_buf "# asub not implemented\n"
	-------------------------
	generate_expression(Exp.ASUB(_,_),_) => fail

  
  rule	Debug.fprintln("ccode","# generate_expression failed") &
	Debug.fcall("ccode",Exp.print_exp,e) &
	Debug.fprintln("ccode","")
	----------------
	generate_expression(e,_) => fail
end

relation generate_unary : (Exp.Operator, Exp.Exp, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.REAL), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr') &
	Util.string_append_list ["(-",var,")"] => var'
	------------------------
	generate_unary (Exp.UMINUS(Exp.INT), e, tnr) => (cfn, var', tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.REAL), e, tnr) => (cfn, var, tnr')

  rule	generate_expression(e,tnr) => (cfn,var,tnr')
	------------------------
	generate_unary (Exp.UPLUS_ARR(Exp.INT), e, tnr) => (cfn, var, tnr')

  rule	Print.print_buf "# unary minus for arrays not implemented\n"
	------------------------
	generate_unary (Exp.UMINUS_ARR(_), _, _) => fail



end

(*

 generate_binary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_binary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =
	  
  rule	generate_expression(e1,tnr ) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) => (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," + ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.ADD(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," - ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.SUB(_),e2,tnr) => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," * ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.MUL(_),e2,tnr) => (cfn,var,tnr2)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," / ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	------------------------------------
	generate_binary(e1,Exp.DIV(_),e2,tnr) => (cfn,var,tnr2)

  rule	Print.print_buf "# pow not implemented yet"
	-------------------------------
	generate_binary(e1,Exp.POW(_),e2,tnr) => fail

  rule	Print.print_buf "# Unary minus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UMINUS(_),_,_) => fail
	
  rule	Print.print_buf "# Unary plus in binary expression (internal error)"
	-------------------------
	generate_binary(_,Exp.UPLUS(_),_,_) => fail
		
  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_real_array(&",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.REAL),e2, tnr) => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["add_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.ADD_ARR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_real_array(&",var1,", &",
			var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["sub_alloc_integer_array(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.SUB_ARR(Exp.INT),e2, tnr)
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_real_array(",var1,
			", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_scalar_integer_array(",var1,
		       ", &",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_ARRAY(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_array_scalar(&",var1,
			", ",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2, tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_array_scalar(&",var1,
			", ",var2,", &",var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_ARRAY_SCALAR(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_real_scalar_product(&",var1,
			", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.REAL),e2, tnr)
	  => (cfn,var,tnr2)

  rule	generate_expression(e1, tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2, tnr1) =>(cfn2,var2,tnr2) &
	Util.string_append_list(["mul_integer_scalar_product(&",var1,
		       ", &",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	----------------------
	generate_binary(e1,Exp.MUL_SCALAR_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("real_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_real_matrix_product_smart(&",var1,
			", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.REAL),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1) =>(cfn2,var2,tnr2) &
	generate_temp_decl("integer_array",tnr2) => (decl, var, tnr3) &
	Util.string_append_list(["mul_alloc_integer_matrix_product_smart(&",
				 var1,", &",var2,", &", var,");"]) => stmt &
	c_merge_fn(cfn1,cfn2) => cfn' &
	c_add_variables(cfn',[decl]) => cfn'' &
	c_add_statements(cfn'',[stmt]) => cfn
	-----------------------------------
	generate_binary(e1,Exp.MUL_MATRIX_PRODUCT(Exp.INT),e2, tnr) 
	  => (cfn,var,tnr3)

  rule	Print.print_buf "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# pow_array not implemented\n"
	-------------------------
	generate_binary(_,Exp.POW_ARR(_),_,_) => fail

  rule	Print.print_buf "# div_array_scalar not implemented\n"
	-------------------------
	generate_binary(_,Exp.DIV_ARRAY_SCALAR(_),_,_) => fail

  rule	Print.print_buf "# generate_binary failed\n"
	-------------------------
	generate_binary(_,_,_,_) => fail



end

relation generate_temp_decl : (string, int) => (string, string, int) =
	 
  rule	int_string(tnr) => tnr_str &
	int_add(tnr,1) => tnr' &
	string_append("tmp",tnr_str) => tmp_name &
	Util.string_append_list([t," ",tmp_name,";"]) => t' 
	------------------------------	
	generate_temp_decl(t, tnr) => (t', tmp_name, tnr')

end
 
relation generate_scalar_lhs_cref : (Exp.Type, Exp.ComponentRef, int)
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[])
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	generate_scalar_rhs_cref(cref_str,t,subs,tnr) => (cfn,var,tnr')
	--------------------
	generate_scalar_lhs_cref(t,cref,tnr)
	  => (cfn,var,tnr')

	    (* two special cases rules for 1 and 2 dimensions for faster code (no vararg) *)
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 &  (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr1(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
 
  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2 *)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr2(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)


  rule	Debug.fprintln("gcge","generating cref ccode") &
	generate_indices(idx,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str(t,true) => type_str &
	Util.string_append_list(["(*",type_str,"_element_addr(&",id,", ",ndims_str,
			", ",idxs_str,"))"]) => cref1 
	------------------------------------------------
	generate_scalar_lhs_cref(t,Exp.CREF_IDENT(id,idx),tnr)
	  => (cfn1,cref1,tnr1)
  
  rule	Print.print_buf "# generate_scalar_lhs_cref failed\n"
	-----------------------------
	generate_scalar_lhs_cref(_,_,_) => fail

end

relation generate_rhs_cref : (Exp.ComponentRef, Exp.Type, int) 
	  => (CFunction, string, int) =

  rule	comp_ref_cstr cref => (cref_str,[]) 
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (c_empty_function,cref_str,tnr)

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => true &
	generate_scalar_rhs_cref(cref_str,crt, subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

  rule	comp_ref_cstr cref => (cref_str,subs) &
	subs_to_scalar subs => false &
	generate_array_rhs_cref(cref_str,crt,subs,tnr) => (cfn,var,tnr')
	--------------------------------------
	generate_rhs_cref (cref, crt, tnr) => (cfn,var,tnr')

end

relation subs_to_scalar : Exp.Subscript list => bool =

  axiom subs_to_scalar [] => true
  axiom subs_to_scalar Exp.SLICE(_)::_ => false
  axiom	subs_to_scalar Exp.WHOLEDIM::_ => false

  rule	subs_to_scalar r => b
	---------------------
	subs_to_scalar Exp.INDEX(_)::r => b

end

relation generate_scalar_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

	   (* Two special rules for faster code when ndims == 1 or 2 *)
	
  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 1 & (* ndims == 1*)
	int_string 1 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr1(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => 2 & (* ndims == 2*)
	int_string 2 => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr2(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)

  rule	generate_indices(subs,tnr) => (cfn1,idxs1,tnr1) &
	list_length idxs1 => ndims &
	int_string ndims => ndims_str &
	Util.string_delimit_list(idxs1,", ") => idxs_str &
	exp_type_str (crt,true) => array_type_str &
	Util.string_append_list(["(*",array_type_str,"_element_addr(&",
				 cref_str,", ",ndims_str,
				 ", ",idxs_str,"))"]) => cref1
	--------------------
	generate_scalar_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn1,cref1,tnr1)
end

relation generate_array_rhs_cref : (string, Exp.Type,Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_index_spec(subs,tnr) => (cfn1,spec1,tnr1) &
	exp_type_str(crt,true) => array_type_str &
	generate_temp_decl(array_type_str,tnr1) => (decl,temp,tnr2) &
	Util.string_append_list(["index_alloc_",array_type_str,"(&",cref_str,
				 ", &",spec1,", &",temp,");"]) => stmt &
	c_add_variables(cfn1,[decl]) => cfn'&
	c_add_statements(cfn',[stmt]) => cfn
	-------------------------------------------
	generate_array_rhs_cref (cref_str,crt,subs,tnr) 
	  => (cfn,temp,tnr2)
end

relation generate_index_spec : (Exp.Subscript list, int) 
	  => (CFunction, string, int) =

  rule	generate_indices_array(subs,tnr) => (cfn1,idxs1,idxsizes,tnr1) &
	generate_temp_decl("index_spec_t",tnr1) => (decl,spec,tnr2) &
	list_length idxs1 => nridx &
	int_string nridx => nridx_str &
	Util.list_thread(idxsizes,idxs1) => idxs' &
	Util.string_delimit_list(idxs',", ") => idxs_str &
	Util.string_append_list(["create_index_spec(&",
				 spec,", ",nridx_str,", ",idxs_str,");"]) 
	  => stmt &
  
	c_add_variables(cfn1,[decl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	
	---------------------------------------------
	generate_index_spec (subs, tnr) => (cfn,spec,tnr2)

  rule	Print.print_buf "# generate_index_spec failed\n"
	-----------------------------
	generate_index_spec(_,_) => fail

end

relation generate_indices_array : (Exp.Subscript list, int) 
	  => (CFunction, string list, string list, int) =

  axiom	generate_indices_array ([],tnr) => (c_empty_function,[],[],tnr)

  rule	generate_index_array(f,tnr) => (cfn1,idx1,idxsize1, tnr1) &
	generate_indices_array(r,tnr1)=>(cfn2,idxs2,idxsizes2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2 &
	let idxsizes = idxsize1::idxsizes2
	---------
	generate_indices_array (f::r, tnr) => (cfn,idxs,idxsizes,tnr2)

  rule	Print.print_buf "# generate_indices_array failed\n"
	-----------------------------
	generate_indices_array(_,_) => fail

end

relation generate_indices : (Exp.Subscript list, int) 
	  => (CFunction, string list, int) =

  axiom	generate_indices ([],tnr) => (c_empty_function,[],tnr)

  rule	generate_index(f,tnr) => (cfn1, idx1, tnr1) &
	generate_indices(r,tnr1)=>(cfn2,idxs2,tnr2) &
	
	c_merge_fn(cfn1,cfn2) => cfn &
	let idxs = idx1::idxs2
	---------
	generate_indices (f::r, tnr) => (cfn,idxs,tnr2)

  rule	Print.print_buf "# generate_indices failed\n"
	-----------------------------
	generate_indices(_,_) => fail

end

relation generate_index_array : (Exp.Subscript, int)
	  => (CFunction, string, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1) &
	Util.string_append_list(["make_index_array(1, ",var1,")"]) => idx &
	let idxsize = "(0)"
	------------------------------------
	generate_index_array(Exp.INDEX(e), tnr) 
	  => (cfn,idx,idxsize,tnr1)

  rule	let idx = "(0)" &
	let idxsize = "(1)"
	------------------------------------
	generate_index_array(Exp.WHOLEDIM, tnr) 
	  => (c_empty_function,idx,idxsize,tnr)

	  
  rule	Print.print_buf "# generate_index_array failed\n"
	-----------------------------
	generate_index_array(_,_) => fail

end

relation generate_index : (Exp.Subscript, int)
	  => (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn,var1,tnr1)	
	------------------------------------
	generate_index(Exp.INDEX(e), tnr) => (cfn,var1,tnr1)

  rule	Print.print_buf "# generate_index failed\n"
	-----------------------------
	generate_index(_,_) => fail

end

relation indent_strings : string list => string list =

  axiom	indent_strings [] => []

  rule	string_append("  ",f) => f' &
	indent_strings r => r'
	-----------------------------
	indent_strings f::r => f'::r'
	
end

relation ident_cstr : string => string =
  axiom ident_cstr s => s
end

relation comp_ref_cstr : Exp.ComponentRef => (string, Exp.Subscript list) =

  rule	ident_cstr id => id_str
	---------------------
	comp_ref_cstr Exp.CREF_IDENT(id,subs) => (id_str,subs)

  rule	ident_cstr id => id_str &
	comp_ref_cstr cref => (cref_str,cref_subs) &
	Util.string_append_list([id,"__",cref_str]) => cref_str' &
	Util.list_flatten([subs,cref_subs]) => subs'
	------------------------------
	comp_ref_cstr Exp.CREF_QUAL(id,subs,cref) => (cref_str',subs')

end


(*

 generate_lbinary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lbinary : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.AND,e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_lbinary (e1,Exp.OR,e2,tnr) => (cfn, var, tnr2)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lbinary (_,_,_,_) => fail

end

(*

 generate_lunary

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_lunary : (Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	Util.string_append_list(["(!",var1,")"]) => var
	-------
	generate_lunary (Exp.NOT,e,tnr) => (cfn1, var, tnr1)


  rule	Print.print_buf "# generate_lbinary failed\n"
	-----------------------------
	generate_lunary (_,_,_) => fail

end

(*

 generate_relation

 returns:
  CFunction | the generated code
  string    | expression result 
  int       | next temporary number 
*)
relation generate_relation : (Exp.Exp, Exp.Operator, Exp.Exp, int) 
	  => (CFunction, string, int) =


  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," && ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESS(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," < ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESS(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," && !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATER(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," > ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATER(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(!",var1," || ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," <= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.LESSEQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," || !",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," >= ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.GREATEREQ(Exp.REAL),e2,tnr) => (cfn, var, tnr2)

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && !",var2,") || (",
			var1," && ",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," == ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.EQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with ==\n"
	-------
	generate_relation (e1,Exp.EQUAL(Exp.REAL),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["((!",var1," && ",var2,") || (",
			var1," && !",var2,"))"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.BOOL),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# string comparison not supported\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.STRING),e2,tnr) => fail

  rule	generate_expression(e1,tnr) => (cfn1,var1,tnr1) &
	generate_expression(e2,tnr1)=> (cfn2,var2,tnr2) &
	Util.string_append_list(["(",var1," != ",var2,")"]) => var &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.INT),e2,tnr) => (cfn, var, tnr2)

  rule	Print.print_buf "# Reals can't be compared with <>\n"
	-------
	generate_relation (e1,Exp.NEQUAL(Exp.REAL),e2,tnr) => fail


  rule	Print.print_buf "# generate_relation failed\n"
	-----------------------------
	generate_relation (_,_,_,_) => fail

end

relation generate_matrix : (Exp.Type, int, (Exp.Exp*bool) list list, int) 
	  => (CFunction, string, int) =


  rule	generate_matrix_expressions(typ,exps,maxn,tnr) => (cfn1,vars1,tnr1) &
	concatenate_matrix_rows(typ,vars1,tnr1) => (cfn2,vars2,tnr2) &
	
	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars2,", &") => args_str &
	list_length(vars2) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr2) => (tdecl,tvar,tnr3) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(1, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(cfn2,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn'' &
	c_merge_fn(cfn1,cfn'') => cfn
	
	(*

	 Generate code for every expression and
	 promote it to maxn dimensions
	 for every row create cat(2,rowvar1,....)
	 for every column create cat(1,row1,....)

	 *)
	---------------------
	generate_matrix(typ,maxn,exps,tnr) => (cfn,tvar,tnr3)

end

relation concatenate_matrix_rows : (Exp.Type, string list list, int)
	=> (CFunction, string list, int) =

  axiom	concatenate_matrix_rows (_,[],tnr) => (c_empty_function, [], tnr)

  rule	concatenate_matrix_row(typ,f,tnr) => (cfn1,var1,tnr1) &
	concatenate_matrix_rows(typ,r,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	concatenate_matrix_rows (typ,f::r,tnr) => (cfn,var1::vars2,tnr2)

end

relation concatenate_matrix_row : (Exp.Type, string list, int) 
	  => (CFunction, string, int) =

  rule	exp_type_str(typ,true) => array_type_str &
	Util.string_delimit_list(vars,", &") => args_str &
	list_length(vars) => n &
	int_string n => n_str &
	generate_temp_decl(array_type_str,tnr) => (tdecl,tvar,tnr1) &
	Util.string_append_list(["cat_alloc_",array_type_str,"(2, &",
				 tvar,", ",n_str,
				 ", &",args_str,");"]) => stmt &

	c_add_variables(c_empty_function,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------
	concatenate_matrix_row (typ,vars,tnr) => (cfn,tvar, tnr1)
end

relation generate_matrix_expressions : (Exp.Type,(Exp.Exp*bool) list list, int, int) =>
	(CFunction, string list list, int) =

  axiom	generate_matrix_expressions(_,[],_,tnr) => (c_empty_function,[],tnr)


  rule	generate_matrix_expr_row (typ,fr,maxn,tnr) => (cfn1,vars1,tnr1) &
	generate_matrix_expressions(typ,rr,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	-------
	generate_matrix_expressions(typ,fr::rr,maxn,tnr) 
	  => (cfn,vars1::vars2,tnr2)


end

relation generate_matrix_expr_row : (Exp.Type,(Exp.Exp*bool) list, int, int)
	  => (CFunction,string list, int) =

  axiom	generate_matrix_expr_row (_,[],_,tnr) => (c_empty_function,[],tnr)

  rule	generate_matrix_expression(t,f,maxn,tnr) => (cfn1,var1,tnr1) &
	generate_matrix_expr_row(t,r,maxn,tnr1) => (cfn2,vars2,tnr2) &
	c_merge_fn(cfn1,cfn2) => cfn
	------
	generate_matrix_expr_row(t,f::r,maxn,tnr) => (cfn,var1::vars2,tnr2)


end
	
relation generate_matrix_expression : (Exp.Type,(Exp.Exp*bool), int, int) 
	=> (CFunction, string, int) =

  rule	generate_expression(e,tnr) => (cfn1,var1,tnr1) &
	exp_type_str(t,true) => array_type_str &
	int_string maxn => maxn_str &
	generate_temp_decl(array_type_str,tnr1) => (tdecl,tvar,tnr2) &
	Util.if(b,"","scalar_") => scalar &
	Util.if(b,"&","") => sc_ref &
	Util.string_append_list(["promote_",scalar,array_type_str,"(",
				 sc_ref,var1,
				 ", ",maxn_str,", &",tvar,");"]) => stmt &
	c_add_variables(cfn1,[tdecl]) => cfn' &
	c_add_statements(cfn',[stmt]) => cfn
	---------------------------------
	generate_matrix_expression(t,(e,b),maxn,tnr) => (cfn,tvar,tnr2)

end
(* generate_read_call_write(fpath,outvars,retstr,args) => rcw_fn *)
relation generate_read_call_write : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write") &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES",
			       out_decl]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)
	generate_var_decls(invars,is_rcw_input,1) => (cfn3,tnr2) &
	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &
	invar_names invars => in_names &
	Util.string_delimit_list(in_names,", ") => in_args &
	
	generate_read(invars) => cfn4 &
	Util.string_append_list(["out = ",fnname,"(",in_args,");"]) => fn_call &
	c_add_statements(cfn4,["PRE_READ_DONE",
			       fn_call,
			       "PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE",
			       "return 0;"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',cfn4',cfn5']) => cfn 
	------------------------------------------------------
	generate_read_call_write(fnname,outvars,retstr,invars) => cfn

end

relation generate_read_call_write_external : (string,
				     DAE.Element list,
				     string,
				     DAE.Element list,
				     DAE.ExternalDecl)
	=> CFunction =


  rule	Debug.fprintln ("cgtr", "generate_read_call_write_external") &
	let tnr = 1 &
	string_append(fnname,"_read_call_write") => rcw_fnname &
	c_make_function("int",rcw_fnname,[],
			["char const* in_filename",
			 "char const* out_filename"]) => cfn1 &

	Util.string_append_list([retstr," out;"]) => out_decl&
	c_add_inits(cfn1,["PRE_VARIABLES"]) => cfn1' &
	(*generate_vars(outvars,is_rcw_output,1) => (cfn2,tnr1) &*)

	generate_alloc_outvars_ext(outvars, out_decl, "out", tnr, extdecl) 
	  => (allocstmts, tnr_ret) &
	generate_temp_decl("state",tnr_ret) => (mem_decl, mem_var, tnr_mem) &
	Util.string_append_list([mem_var, " = get_memory_state();"])
	  => mem_stmt1 &
	Util.string_append_list(["restore_memory_state(",mem_var,");"]) 
	  => mem_stmt2 &
	
	c_add_variables(allocstmts, [mem_decl]) => mem_fn' &
	c_add_inits(mem_fn', [mem_stmt1]) => mem_fn &

	generate_var_decls(invars,is_rcw_input,tnr_mem) => (cfn3,tnr_invars) &

	c_add_inits(cfn3,["PRE_OPEN_INFILE"]) => cfn3' &

	generate_read(invars) => readinvars & 
	c_add_inits(readinvars, ["PRE_READ_DONE"]) => readdone &

	list_append (invars, outvars) => vars &

	generate_ext_call (vars, extdecl, tnr_invars) => (extcall, tnr_extcall) &

	c_add_statements(extcall,["PRE_OPEN_OUTFILE"]) => cfn4' &

	generate_write(outvars) => cfn5 &
	c_add_statements(cfn5,["PRE_WRITE_DONE"]) => cfn5' &

	c_merge_fns([cfn1',cfn3',readdone,mem_fn,cfn4',cfn5']) => cfn' &

	c_add_cleanups(cfn', [mem_stmt2, "return 0;"]) => cfn
	------------------------------------------------------
	generate_read_call_write_external(fnname,outvars,retstr,invars,extdecl) => cfn

  rule	Print.print_buf "#-- generate_read_call_write_external failed\n"
	----------------------------------------------------------------
	generate_read_call_write_external (_,_,_,_,_) => fail

end

relation generate_ext_call : (DAE.Element list, DAE.ExternalDecl, int) => (CFunction, int) =

  rule	generate_extcall_vardecls (vars, arglist, retarg, lang, tnr) => (argdecls,arglist',tnr') &
	generate_ext_call_fcall (n, arglist', retarg, lang) => fcall &
	Util.list_matching (arglist', is_extarg_output) => outputarglist &
	generate_extcall_varcopy (outputarglist, retarg, lang, tnr') => (argcopies,tnr'') &
	c_merge_fns([argdecls,fcall,argcopies]) => extcall
	-------------------------------------------------------------
	generate_ext_call (vars, DAE.EXTERNALDECL(n,arglist,retarg,lang), tnr) => (extcall,tnr'')

  rule	Print.print_buf "#-- generate_ext_call failed\n"
	------------------------------------------------
	generate_ext_call (_,_,_) => fail
end


relation generate_extcall_vardecls : (DAE.Element list, DAE.ExtArg list,
				      DAE.ExtArg, string, int) 
	  => (CFunction, DAE.ExtArg list, int) =

  rule	generate_extcall_vardecls2 (args, retarg) => (decls)
	----------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "C", tnr) => (decls,args,tnr)

  rule	generate_extcall_copydecls_f77 (vars,tnr) => (copydecls,tnr') &
	generate_extcall_vardecls2_f77 (args, retarg, tnr') => (decls, args', tnr'') &
	c_merge_fn (copydecls, decls) => res
	-----------------------------------------------------------------
	generate_extcall_vardecls (vars, args, retarg, "FORTRAN 77",tnr) => (res, args', tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls (_,_,_,_,_) => fail

end

relation generate_extcall_copydecls_f77 : (DAE.Element list, int) => (CFunction, int) =

  axiom	generate_extcall_copydecls_f77 ([], tnr) => (c_empty_function, tnr)

  rule	let DAE.VAR(cref, vk, vd, ty, value, dims) = var &
	is_array cref => true &
	var_name_external_cref cref => cref' &
	list_reverse dims => dims' &
	let extvar = DAE.VAR(cref', vk, vd, ty, value, dims') &
	generate_var_decl (extvar, tnr) => (fn, tnr') &
	generate_extcall_copydecls_f77 (rest, tnr') => (restfn, tnr''') &
	c_merge_fn (fn, restfn) => resfn
	--------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (resfn,tnr''')

  rule	Debug.fprint("cgtr", "#--Ignoring: ") &
	Debug.fcall("cgtr", DAE.dump2, DAE.DAE([var])) &
	Debug.fprintln("cgtr", "") &
	generate_extcall_copydecls_f77 (rest, tnr) => (fn,tnr')
	-------------------------------------------------------
	generate_extcall_copydecls_f77 (var::rest, tnr) => (fn, tnr')

end

relation generate_extcall_vardecls2 : (DAE.ExtArg list, DAE.ExtArg) => CFunction =

  axiom	generate_extcall_vardecls2 ([],DAE.NOEXTARG) => c_empty_function

  rule	generate_extcall_vardecl retarg => retdecl
	-----------------------------------------
	generate_extcall_vardecls2 ([],retarg) => retdecl

  rule	generate_extcall_vardecl var => decl &
	generate_extcall_vardecls2 (rest, retarg) => decls &
	c_merge_fn(decl, decls) => res
	---------------------------------------------
	generate_extcall_vardecls2 (var::rest, retarg) => res

  rule	Print.print_buf "#-- generate_extcall_vardecls2 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2 (_,_) => fail

end

relation generate_extcall_vardecl : DAE.ExtArg => CFunction =

  rule	Types.is_array ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	Util.string_append_list ([tystr, " ", name, " = (", tystr, ")", orgname, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_vardecl DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) => res

  rule	Types.is_array ty => true
	--------------------------------------------------------
	generate_extcall_vardecl DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) => c_empty_function

  rule	Types.is_array ty => false &
	generate_type_external ty => tystr &
	var_name_external cref => name &
	Util.string_append_list ([tystr, " ", name, ";"]) => str &
	c_add_variables(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_vardecl DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => res

  rule	Types.is_array ty => true
	---------------------------
	generate_extcall_vardecl DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.OUTPUT), ty) => c_empty_function

  axiom	generate_extcall_vardecl DAE.EXTARGSIZE(_,_,_,_) => c_empty_function


  rule	Print.print_buf "#-- generate_extcall_vardecl failed\n"
	-------------------------------------------------------
	generate_extcall_vardecl _ => fail

end

relation generate_extcall_vardecls2_f77 : (DAE.ExtArg list, DAE.ExtArg, int)
	  => (CFunction, DAE.ExtArg list, int) =

  axiom	generate_extcall_vardecls2_f77 ([],DAE.NOEXTARG,tnr) => (c_empty_function,[],tnr)

  rule	generate_extcall_vardecl_f77 (retarg,tnr) => (retdecl,_,tnr')
	-------------------------------------------------
	generate_extcall_vardecls2_f77 ([],retarg,tnr) => (retdecl,[],tnr')

  rule	generate_extcall_vardecl_f77 (var,tnr) => (decl,var',tnr') &
	generate_extcall_vardecls2_f77 (rest, retarg, tnr') => (decls,varr, tnr'') &
	c_merge_fn(decl,decls) => res
	---------------------------------------------
	generate_extcall_vardecls2_f77 (var::rest, retarg, tnr) => (res, var'::varr, tnr'')

  rule	Print.print_buf "#-- generate_extcall_vardecls2_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_vardecls2_f77 (_,_,_) => fail

end

relation generate_c_to_f77_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_to_f77"]) => str
	---------------------------------------------------------------------
	generate_c_to_f77_converter Types.T_ARRAY(_,Types.T_ARRAY(_,ty)) => str

  rule	Print.print_buf "#-- generate_c_to_f77_converter failed\n" &
	Print.print_buf "#-- Not an array?\n"
	---------------------------------------------
	generate_c_to_f77_converter _ => fail

end

relation generate_f77_to_c_converter : Types.Type => string =

  rule	Types.array_element_type ty => elty &
	generate_type_internal_namepart elty => eltystr &
	Util.string_append_list (["convert_alloc_",eltystr,"_array_from_f77"]) => str
	---------------------------------------------------------------------
	generate_f77_to_c_converter (ty as Types.T_ARRAY(_,_)) => str

  rule	Print.print_buf "#-- generate_f77_to_c_converter failed\n" &
	Print.print_buf "#-- Not an array?\n"
	---------------------------------------------
	generate_f77_to_c_converter _ => fail

end

relation is_output_or_bidir : Types.Attributes => bool =

  rule	Types.is_output_attr attr => outvar &
	Types.is_bidir_attr attr => bivar &
	bool_or (outvar, bivar) => res
	---------------------------------
	is_output_or_bidir attr => res
end

relation generate_extcall_vardecl_f77 : (DAE.ExtArg,int) => (CFunction, DAE.ExtArg, int) =

  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_1") &
	Types.is_input_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,tnr) => (res, arg, tnr)

  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_2") &
	Types.is_input_attr attr => true&
	Types.is_array ty => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_c_to_f77_converter ty => converter &
	Util.string_append_list ([converter, "(&", orgname, ", &", name, ");"]) => initstr &
	c_add_statements(c_empty_function, [initstr]) => res
	----------------------------------------------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (res, extarg, tnr)

  rule	let DAE.EXTARG(cref, attr, ty) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_3") &
	Types.is_output_attr attr => true &
	Types.is_array ty => false &
	generate_extcall_vardecl arg => res
	--------------------------------------------------------
	generate_extcall_vardecl_f77  (arg, tnr) => (res,arg, tnr)

  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_4") &
	Types.is_array ty => true &
	Types.is_output_attr attr => true
	---------------------------
	generate_extcall_vardecl_f77 (extarg, tnr) => (c_empty_function, extarg, tnr)

  rule	let DAE.EXTARGSIZE(cr, attr, ty, dim) = arg &
	Debug.fprintln ("cgtr", "generate_extcall_vardecl_f77_5") &
	var_name_external cr => tmpname' &
	int_string tnr => tnrstr &
	int_add(tnr,1) => tnr' &
	Util.string_append_list([tmpname',"_size_",tnrstr]) => tmpstr &
	let tmpcref = Exp.CREF_IDENT(tmpstr,[]) &
	generate_ext_array_size_call arg => callstr &
	Util.string_append_list(["int ",tmpstr,";"]) => declstr &
	c_add_variables(c_empty_function, [declstr]) => decl &
	Util.string_append_list([tmpstr," = ",callstr,";"]) => callstr &
	c_add_statements(decl, [callstr]) => res &
	let newarg = DAE.EXTARGSIZE(tmpcref, attr, ty, dim)
	-----------------------------------------------------------------
	generate_extcall_vardecl_f77 (arg, tnr)  => (res, newarg, tnr')


  rule	Print.print_buf "#-- generate_extcall_vardecl_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => argstr &
	Print.print_buf argstr & Print.print_buf "\n"
	-------------------------------------------------------
	generate_extcall_vardecl_f77 (arg,_) => fail

end

(* input string is language *)
relation generate_ext_call_fcall : (Ident, DAE.ExtArg list, DAE.ExtArg, string) => CFunction =

	(* call without return value *)
  rule	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	string_append(fcall2, ";") => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.NOEXTARG, lang) => res

	(* return value assignment, shouldn't happen for arrays *)
  rule	Types.is_array ty => false &
	generate_ext_call_fcall2 (fnname,args,lang) => fcall2 &
	var_name_external cr => crstr &
	Util.string_append_list([crstr," = ", fcall2, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	---------------------------------------------
	generate_ext_call_fcall (fnname, args, DAE.EXTARG(cr,_,ty), lang) => res

  rule	Print.print_buf "#-- generate_ext_call_fcall failed\n"
	------------------------------------------------------
	generate_ext_call_fcall (_,_,_,_) => fail

end	


relation generate_ext_call_fcall2 : (Ident, DAE.ExtArg list, string) => string =

  rule	Util.list_map (args, generate_ext_call_fcall_arg) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "C") => res

  rule	Util.list_map (args, generate_ext_call_fcall_arg_f77) => strlist &
	Util.string_delimit_list (strlist, ", ") => str &
	Util.string_append_list([n,"_(",str,")"]) => res
	-----------------------------------------------
	generate_ext_call_fcall2 (n, args, "FORTRAN 77") => res

  rule	Print.print_buf "#-- generate_ext_call_fcall2 failed\n"
	------------------------------------------------------
	generate_ext_call_fcall2 (_,_,_) => fail

end


relation generate_ext_call_fcall_arg : DAE.ExtArg => string =

  rule	Types.is_array ty => false &
	var_name_external cref => res
	-----------------------------
	generate_ext_call_fcall_arg DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.INPUT), ty) => res

  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg DAE.EXTARG(cref, attr, ty) => res

  rule	Types.is_array ty => true &
	var_name_array (cref,attr) => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg DAE.EXTARG(cref, attr, ty) => res

(*
  rule	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => res
*)

  rule	generate_array_size_call arg => str
	-----------------------------
	generate_ext_call_fcall_arg (arg as DAE.EXTARGSIZE(_,_,_,_)) => str


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg failed\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg _ => fail

end

relation generate_ext_call_fcall_arg_f77 : DAE.ExtArg => string =

  rule	Types.is_array ty => false &
	var_name_external cref => name &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 DAE.EXTARG(cref, attr, ty) => res

  rule	Types.is_array ty => true &
	var_name_external cref => name &
	string_append(name,".data") => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 DAE.EXTARG(cref, attr, ty) => res


  rule	comp_ref_cstr cref => (name,_) &
	string_append("&", name) => res 
	-----------------------------
	generate_ext_call_fcall_arg_f77 DAE.EXTARGSIZE(cref, attr, ty, dim) => res


  rule	Print.print_buf "#-- generate_ext_call_fcall_arg_f77 failed\n#-- " &
	DAE.dump_ext_arg_str arg => str &
	Print.print_buf str &
	Print.print_buf "\n"
	----------------------------------------------------------
	generate_ext_call_fcall_arg_f77 arg => fail

end


relation generate_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => Types.T_INTEGER &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => Types.T_REAL &
	var_name_array (cr,attr) => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_array_size_call _ => fail
	
end

relation generate_ext_array_size_call : DAE.ExtArg => string = 

  rule	Types.array_element_type ty => Types.T_INTEGER &
	var_name_external cr => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_integer_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Types.array_element_type ty => Types.T_REAL &
	var_name_external cr => crstr &
	Exp.print_exp_str dim => dimstr &
	Util.string_append_list(["size_of_dimension_real_array(",crstr,", ",
				 dimstr,")"]) => str
	-----------------------------
	generate_ext_array_size_call DAE.EXTARGSIZE(cr, attr, ty, dim) => str

  rule	Print.print_buf "#-- generate_array_size_call failed\n#-- Not a DAE.EXTARGSIZE?\n"
	----------------------------------------------------------------------------------
	generate_ext_array_size_call _ => fail
	
end


relation is_extarg_output : DAE.ExtArg => () =

  axiom	is_extarg_output DAE.EXTARG(_,Types.ATTR(_,_,_,Absyn.OUTPUT),_)

end

relation generate_extcall_varcopy : (DAE.ExtArg list, DAE.ExtArg, string, int) => (CFunction, int) =

  axiom	generate_extcall_varcopy ([],DAE.NOEXTARG,_,tnr) => (c_empty_function,tnr)

  rule	is_extarg_output retarg & 
	generate_extcall_varcopy_single retarg => retcopy
	--------------------------------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (retcopy,tnr)

  rule	not is_extarg_output retarg
	-----------------------------------------
	generate_extcall_varcopy ([],retarg,lang,tnr) => (c_empty_function,tnr)

	(* extarg list is already filtered and contains only outputs *)
  rule	generate_extcall_varcopy_single var => vc &
	generate_extcall_varcopy (rest, retarg, lang,tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "C", tnr) => (res,tnr')

  rule	generate_extcall_varcopy_single_f77 var => vc &
	generate_extcall_varcopy (rest, retarg, lang, tnr) => (vcr,tnr') &
	c_merge_fn(vc, vcr) => res
	--------------------------------------------------
	generate_extcall_varcopy (var::rest, retarg, lang as "FORTRAN 77", tnr) => (res,tnr')

  rule	Print.print_buf "#-- generate_extcall_varcopy failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy (_,_,_,_) => fail

end

relation generate_extcall_varcopy_single : DAE.ExtArg => CFunction =

  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => res

  rule	Types.is_array ty => true &
	Types.is_output_attr attr => true
	---------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) 
	  => c_empty_function

(*
  rule	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str
	--------------------------------------------------------
	generate_extcall_varcopy_single DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str
*)

  axiom	generate_extcall_varcopy_single DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single _ => fail

end

relation generate_extcall_varcopy_single_f77 : DAE.ExtArg => CFunction =

  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_input_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res 
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

  rule	Types.is_array ty => false &
	Types.is_output_attr attr => true &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	--------------------------------------------------------
	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => res

  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_array ty => true &
	Types.is_output_attr attr => true &
	generate_type ty => tystr &
	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_f77_to_c_converter ty => converter &
	Util.string_append_list ([converter, "(&",name, ", &out.", orgname, ");"]) => str &
	c_add_statements(c_empty_function, [str]) => res
	----------------------------------------------------------------
	generate_extcall_varcopy_single_f77 extarg => res

  rule	let DAE.EXTARG(cref, attr, ty) = extarg &
	Types.is_output_attr attr => true &
	Types.is_array ty => true
	---------------------------
	generate_extcall_varcopy_single_f77 extarg => c_empty_function

(*
  rule	var_name_external cref => name &
	comp_ref_cstr cref => (orgname, _) &
	generate_type ty => typcast &
	Util.string_append_list (["out.", orgname, " = (", typcast, ")", name, ";"]) => str
	--------------------------------------------------------
	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, Types.ATTR(_,_,_,Absyn.BIDIR), ty) => str
*)

  axiom	generate_extcall_varcopy_single_f77 DAE.EXTARG(cref, attr, ty) => c_empty_function

  rule	Print.print_buf "#-- generate_extcall_varcopy_single_f77 failed\n"
	-------------------------------------------------------
	generate_extcall_varcopy_single_f77 _ => fail

end


relation invar_names : DAE.Element list => string list =

  axiom	invar_names [] => []


  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	invar_names r => r'
	----------
	invar_names DAE.VAR(id,vk,DAE.INPUT,t,_,_)::r => cref_str::r'

  rule	invar_names r => cfn
	-------
	invar_names _::r => cfn

end

relation is_input_or_output_var : DAE.Element => () =
	
  axiom	is_input_or_output_var DAE.VAR(_,_,DAE.INPUT,_,_,_)
  axiom	is_input_or_output_var DAE.VAR(_,_,DAE.OUTPUT,_,_,_)

end

relation var_name_external : Exp.ComponentRef => string =

  rule	var_name_external_cref cref => cref' &
	comp_ref_cstr cref' => (str, _)
	---------------------------------------
	var_name_external cref => str

end

relation var_name_external_cref : Exp.ComponentRef => Exp.ComponentRef =

  rule	suffix_cref (cref,"_ext") => cref'
	---------------------------------------
	var_name_external_cref cref => cref'
end

relation suffix_cref : (Exp.ComponentRef, string) => Exp.ComponentRef =

  rule	string_append(id, str) => id'
	--------------------------------
	suffix_cref (Exp.CREF_IDENT(id,subs), str) => Exp.CREF_IDENT(id',subs)

  rule	suffix_cref (cref,str) => cref'
	---------------------------------------
	suffix_cref (Exp.CREF_QUAL(id,subs,cref), str) => Exp.CREF_QUAL(id,subs,cref')
end

relation var_name_array : (Exp.ComponentRef, Types.Attributes) => string =

  rule	comp_ref_cstr cref => (str, _) &
	Types.is_input_attr attr => true
	---------------------------------------
	var_name_array (cref,attr) => str

  rule	comp_ref_cstr cref => (cref_str, _) &
	Types.is_output_attr attr => true &
	string_append ("out.", cref_str) => str
	---------------------------------------
	var_name_array (cref,attr) => str

end

relation var_arg_names_external : DAE.Element list => string list =

  axiom	var_arg_names_external [] => []


  rule	var_name_external id => cref_str &
	is_first_in_array id => true &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.INPUT,t,_,_)::r => cref_str::r'

  rule	var_name_external id => cref_str &
	string_append("&", cref_str) => cref_str2 &
	is_first_in_array id => true &
	var_arg_names_external r => r'
	----------------------------
	var_arg_names_external DAE.VAR(id,vk,DAE.OUTPUT,t,_,_)::r => cref_str2::r'

  rule	var_arg_names_external r => cfn
	-----------------------------
	var_arg_names_external _::r => cfn

end


relation generate_read : DAE.Element list => CFunction =

  axiom	generate_read [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["if(read_",type_string,"(in_file, &",cref_str,")) return 1;"])
	  => stmt &
	  
	c_add_inits(c_empty_function,[stmt]) => cfn1 &
	generate_read r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_read DAE.VAR(id,vk,DAE.INPUT,t,_,_::_)::r => cfn

	
  rule	generate_read r => cfn
	-------
	generate_read _::r => cfn


end


relation generate_write : DAE.Element list => CFunction =

  axiom	generate_write [] => c_empty_function


  rule	comp_ref_cstr id => (cref_str,_) &
	dae_type_str(t, false) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,[])::r => cfn

  rule	comp_ref_cstr id => (cref_str,_) &
	is_first_in_array id => true &
	dae_type_str(t, true) => type_string &
	Util.string_append_list(["write_",type_string,"(out_file, &out.",cref_str,");"])
	  => stmt &
	  
	  c_add_statements(c_empty_function,[stmt]) => cfn1 &
	generate_write r => cfn2 &
	c_merge_fn(cfn1,cfn2) => cfn
	----------
	generate_write DAE.VAR(id,vk,DAE.OUTPUT,t,_,_::_)::r => cfn

	
  rule	generate_write r => cfn
	-------
	generate_write _::r => cfn


end

relation is_rcw_output : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_output_var e
	--------------------
	is_rcw_output e 

end

relation is_rcw_input : DAE.Element => () =

  rule	DAE.is_var e &
	DAE.is_input_var e
	--------------------
	is_rcw_input e 

end


relation new_ident : string => Exp.ComponentRef =

  rule	tick => i & int_string i => is & string_append(str,is) => s
	-----------------------------------------------------------------
	new_ident str => Exp.CREF_IDENT(s,[])

end
