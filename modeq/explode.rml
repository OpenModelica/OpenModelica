(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 scode.rml
 ** module:      SCode
 ** description: SCode intermediate form
 **
 ** RCS: $Id$
 **
 ** This module contains data structures to describe a Modelica model
 ** in a more convenient way than the `Absyn' module does.  The most
 ** important relation in this module is the `elaborate' relation
 ** which turns an abstract syntax tree into an SCode representation.
 **)

module SCode :

  with "absyn.rml"

  (** Some definitions are borrowed from `Absyn' *)
  type Ident = Absyn.Ident
  type Path = Absyn.Path
  type Subscript = Absyn.Subscript
  datatype Restriction =  R_CLASS
		   | R_MODEL
		   | R_RECORD
		   | R_BLOCK
		   | R_CONNECTOR
		   | R_TYPE
		   | R_PACKAGE
		   | R_FUNCTION
		   | R_EXT_FUNCTION   (* Added c.t. Absyn *)
		   | R_ENUMERATION	
		   | R_PREDEFINED_INT
		   | R_PREDEFINED_REAL
		   | R_PREDEFINED_STRING
		   | R_PREDEFINED_BOOL
		   | R_PREDEFINED_ENUM
							  
  (** - Modifications *)
  datatype Mod = MOD of bool * (SubMod list) * (Absyn.Exp option)
  	       | REDECL of bool * Element list
	       | NOMOD
  datatype SubMod = NAMEMOD of Ident * Mod         (* A named component *)
		  | IDXMOD of Subscript list * Mod (* An array element *)
  (** Modifications are represented in an more structured way than in 
   ** the `Absyn' module.  Modifications using qualified names
   ** (such as in `x.y =  z') are normalized (to `x(y = z)').  And a
   ** special case when arrays are subscripted in a modification.
   **)

  (** - Programs *)
  type Program = Class list
  (** As in the AST, a program is simply a list of class definitions. *)

  (** - Classes *)
  datatype Class = CLASS of Ident		(* Name *)
			  * bool		(* Partial *)
			  * bool		(* Encapsulated *)
			  * Restriction	        (* Restricion *)
			  * ClassDef		(* Parts *)

  datatype ClassDef = PARTS of Element list
			     * Equation list
			     * Equation list    (* InitialEquation *)
			     * Algorithm list
			     * Algorithm list   (* InitialAlgorithm *)
                             * Absyn.ExternalDecl option  (* Used by external functions*)
		    | DERIVED of Path
			       * Absyn.ArrayDim option
			       * Mod
		    | ENUMERATION of Ident list

  (** The major difference between these types and their `Absyn' *)
  (** counterparts is that the `PARTS' constructor contains separate *)
  (** lists for elements, equations and algorithms. *)


  (* - Equations *)
  datatype Equation = EQ_EXPR of Absyn.Exp	(* more later? *)
		    | EQ_IF of Absyn.Exp	(* conditional *)
			     * Equation list	(* true branch *)  
			     * Equation list	(* false branch *)
		    | EQ_EQUALS of Absyn.Exp * Absyn.Exp
		    | EQ_CONNECT of Absyn.ComponentRef * Absyn.ComponentRef
		    | EQ_FOR of Ident * Absyn.Exp * Equation list
		    | EQ_WHEN of Absyn.Exp * Equation list
  (** These are almost identical to the `Absyn' versions.  In `EQ_IF', *)
  (** the `elseif' branches are represented as normal `else' branches *)
  (** with a single `if' statement in them. *)

  (** - Algorithms *)
  datatype Algorithm = ALGORITHM of Absyn.Algorithm list
  (** The `Absyn' module uses the terminology from the grammar, where *)
  (** `algorithm' means an algorithmic statement.  But here, *)
  (** `Algorithm' means a whole algorithm section. *)

  (** - Elements *)
  datatype Element = EXTENDS of Path * Mod
		   | CLASSDEF of Ident		(* name *)
			       * bool		(* final *)
			       * bool		(* replaceable *)
			       * Class
		   | IMPORT    of Absyn.Import
		   | COMPONENT of Ident		(* component name *)
				* bool		(* final *)
				* bool		(* replaceable *)
				* bool		(* protected *)
				* Attributes
				* Path		(* type name *)
				* Mod
  (** There are three types of elements in a declaration, represented *)
  (** by the constructors `EXTENDS' (for `extends' clauses), *)
  (** `CLASSDEF' (for local class definitions) and `COMPONENT' (for *)
  (** local variables). *)

  (** - Attributes *)
  datatype Attributes = ATTR of Absyn.ArrayDim
			      * bool	(* flow *)
			      * Accessibility
	  		      * Variability	(* parameter *)
			      * Absyn.Direction

  datatype Variability = VAR | DISCRETE | PARAM | STRUCTPARAM | CONST 

  datatype Accessibility = RW	(* read/write *)
			 | RO	(* read-only *)
			 | WO	(* write-only (not used) *)
  (** These are attributes that apply to a declared component. *)

  relation elaborate : Absyn.Program => Program
  relation elab_class: Absyn.Class => Class	
  relation build_mod : (Absyn.Modification option, bool) => Mod
  relation get_element_named: (Ident, Class) => Element
  relation print_mod : Mod => ()
  relation print_element : Element => ()
  relation print_element_list : Element list => ()	  
  relation print_restr: Restriction => ()
  relation variability_string: Variability => string
	  
end


with "dump.rml"
with "debug.rml"
with "print.rml"

(** relation: elaborate
 **
 ** This relation takes an `Absyn.Program' and constructs a `Program'
 ** from it.
 **)

relation elaborate : Absyn.Program => Program =

  axiom	elaborate(Absyn.PROGRAM([],_)) => []

  rule	elab_class(c) => c' &
	elaborate(Absyn.PROGRAM(cs,w)) => cs'
	-----------------------------
	elaborate(Absyn.PROGRAM(c::cs,w)) => (c'::cs')

end

(** relation: elab_class
 **
 ** This relations converts an `Absyn.Class' to a `Class'.
 **)

relation elab_class: Absyn.Class => Class =

  rule	elab_classdef d => d' &
	elab_restriction(c,r) => r'
	---------------------
	elab_class(c as Absyn.CLASS(n,p,f,e,r,d)) => CLASS(n,p,e,r',d')

end

relation elab_restriction: (Absyn.Class, Absyn.Restriction) => Restriction =

  rule	contain_external_func_decl(d) => true 
	-------------------------------------------------
	elab_restriction(d,Absyn.R_FUNCTION) 
	    => R_EXT_FUNCTION

  rule	contain_external_func_decl(d) => false 
	-------------------------------------------------
	elab_restriction(d,Absyn.R_FUNCTION)
	    => R_FUNCTION

  axiom	elab_restriction(_,Absyn.R_CLASS) => R_CLASS
  axiom	elab_restriction(_,Absyn.R_MODEL) => R_MODEL
  axiom	elab_restriction(_,Absyn.R_RECORD) => R_RECORD
  axiom	elab_restriction(_,Absyn.R_BLOCK) => R_BLOCK
  axiom	elab_restriction(_,Absyn.R_CONNECTOR) => R_CONNECTOR
  axiom	elab_restriction(_,Absyn.R_TYPE) => R_TYPE
  axiom	elab_restriction(_,Absyn.R_PACKAGE) => R_PACKAGE
  axiom	elab_restriction(_,Absyn.R_ENUMERATION) => R_ENUMERATION
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_INT) => R_PREDEFINED_INT
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_REAL) => R_PREDEFINED_REAL
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_STRING) => R_PREDEFINED_STRING
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_BOOL) => R_PREDEFINED_BOOL
  axiom	elab_restriction(_,Absyn.R_PREDEFINED_ENUM) => R_PREDEFINED_ENUM
end
	
relation contain_external_func_decl:(Absyn.Class) => bool =
	
  axiom	contain_external_func_decl(Absyn.CLASS(_,_,_,_,_,Absyn.PARTS(Absyn.EXTERNAL(_)::_,_))) => true
	
  rule	contain_external_func_decl(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(rest,cmt))) => res
	----------------------
	contain_external_func_decl(Absyn.CLASS(a,b,c,d,e,Absyn.PARTS(_::rest,cmt))) => res

  axiom	contain_external_func_decl(_) => false
end

(** relation: elab_classdef
 **
 ** This relation converts an `Absyn.ClassDef' to a `ClassDef'.  For
 ** the `DERIVED' case, the conversion is fairly trivial, but for the
 ** `PARTS' case more work is needed.  The result contains separate
 ** lists for elements, equations and algorithms, which are mixed in
 ** the input.
 **)

(** LS: Divided the elab_classdef into separate relations for
 ** collecting the different parts
 **)

relation elab_classdef: Absyn.ClassDef => ClassDef =

  rule	build_mod(SOME(Absyn.CLASSMOD(a, NONE)), false) => mod
	(* TODO: attributes of derived classes *)
	------------------------------------------------
	elab_classdef(Absyn.DERIVED(p,d,attr,a,cmt)) => DERIVED(p,d,mod)


  rule	elab_classdef_elements parts => els &
	elab_classdef_equations parts => eqs &
	elab_classdef_initialequations parts => initeqs &
	elab_classdef_algorithms parts => als &
	elab_classdef_initialalgorithms parts => initals &
	elab_classdef_externaldecls parts => decl
	-------------------------------------
	elab_classdef (Absyn.PARTS(parts,cmt)) => PARTS(els,eqs,initeqs,als,initals,decl)

  rule	elab_enumlist(lst) => lst'
	--------------------------
	elab_classdef(Absyn.ENUMERATION(lst,_)) => ENUMERATION(lst')

end

relation elab_enumlist:(Absyn.EnumLiteral list) => Ident list =

  axiom	elab_enumlist([]) => []
	
  rule	elab_enumlist(rest) => res
	-----------------------------------------
	elab_enumlist(Absyn.ENUMLITERAL(id,_)::rest) => id::res
end

relation elab_classdef_elements: Absyn.ClassPart list => Element list =

  axiom	elab_classdef_elements [] => []

  rule	elab_classdef_elements rest => els &
	elab_eitemlist (es, false) => es' &
	list_append (es',els) => els'
	------------------------------
	elab_classdef_elements (Absyn.PUBLIC(es)::rest) => els'

  rule	elab_classdef_elements rest => els &
	elab_eitemlist (es, true) => es' &
	list_append (es',els) => els'
	------------------------------
	elab_classdef_elements (Absyn.PROTECTED(es)::rest) => els'


(** ignore all other than PUBLIC and PROTECTED, i.e. elements **)

  rule	elab_classdef_elements rest => els
	----------------------------------
	elab_classdef_elements _::rest => els

end


relation elab_classdef_equations: Absyn.ClassPart list => Equation list = 

  axiom	elab_classdef_equations [] => []

  rule	elab_classdef_equations rest => eqs &
	elab_equations(eql) => eql' &
	list_append (eqs, eql') => eqs'
	------------------------------
	elab_classdef_equations (Absyn.EQUATIONS(eql)::rest) => eqs'

(** ignore everthing other than equations **)
  rule	elab_classdef_equations rest => eqs
	-----------------------------------
	elab_classdef_equations _::rest => eqs

end


relation elab_classdef_initialequations: Absyn.ClassPart list => Equation list = 

  axiom	elab_classdef_initialequations [] => []

  rule	elab_classdef_initialequations rest => eqs &
	elab_equations(eql) => eql' &
	list_append (eqs, eql') => eqs'
	------------------------------
	elab_classdef_initialequations (Absyn.INITIALEQUATIONS(eql)::rest) => eqs'

(** ignore everthing other than equations **)
  rule	elab_classdef_initialequations rest => eqs
	-----------------------------------
	elab_classdef_initialequations _::rest => eqs

end



relation elab_classdef_algorithms: Absyn.ClassPart list => Algorithm list =

  axiom	elab_classdef_algorithms [] => []

  rule	elab_classdef_algorithms rest => als &
	elab_classdef_algorithmitems al => al' &
	let als' = ALGORITHM(al')::als
	-----------------------------
	elab_classdef_algorithms (Absyn.ALGORITHMS(al)::rest) => als'


(** ignore everthing other than algorithms **)

  rule	elab_classdef_algorithms rest => als
	------------------------------------
	elab_classdef_algorithms _::rest => als

end

relation elab_classdef_initialalgorithms: Absyn.ClassPart list => Algorithm list =

  axiom	elab_classdef_initialalgorithms [] => []

  rule	elab_classdef_initialalgorithms rest => als &
	elab_classdef_algorithmitems al => al' &
	let als' = ALGORITHM(al')::als
	-----------------------------
	elab_classdef_initialalgorithms (Absyn.INITIALALGORITHMS(al)::rest) => als'


(** ignore everthing other than algorithms **)

  rule	elab_classdef_initialalgorithms rest => als
	------------------------------------
	elab_classdef_initialalgorithms _::rest => als

end


relation elab_classdef_algorithmitems: Absyn.AlgorithmItem list => Absyn.Algorithm list =

  axiom	elab_classdef_algorithmitems [] => []
	
  rule	elab_classdef_algorithmitems(rest) => res
	-----------------------------------------
	elab_classdef_algorithmitems (Absyn.ALGORITHMITEM(alg,_)::rest) => alg::res

  rule	elab_classdef_algorithmitems(rest) => res
	-----------------------------------------
	elab_classdef_algorithmitems (_::rest) => res
end

relation elab_classdef_externaldecls: (Absyn.ClassPart list) => Absyn.ExternalDecl option =

  axiom	elab_classdef_externaldecls(Absyn.EXTERNAL(decl)::_) => SOME(decl)

  rule	elab_classdef_externaldecls(rest) => res
	---------------------------------------
	elab_classdef_externaldecls(_::rest) => res

  axiom	elab_classdef_externaldecls([]) => NONE
end

(** relation: elab_eitemlist
 **
 ** This relation converts a list of `Absyn.ElementItem' to a list of
 ** `Element'.  The boolean argument flags whether the elements are
 ** pretected. Annotations are not elaborated, i.e. they are removed when converting to SCode.
 **)

relation elab_eitemlist : (Absyn.ElementItem list, bool) => Element list =

  axiom	elab_eitemlist([],_) => []

  rule	elab_eitemlist(es,prot) => l
	----------------------------
	elab_eitemlist(Absyn.ANNOTATIONITEM(_)::es,prot) => l

  rule	elab_element(e, prot) => e' &
	elab_eitemlist(es, prot) => es' &
	list_append(e',es') => l
	---------------------
	elab_eitemlist(Absyn.ELEMENTITEM(e)::es, prot) => l
end

(** relation: elab_element
 **
 ** This relation converts an `Absyn.Element' to a list of
 ** `Element's.  The original element may declare several components
 ** at once, and those are separated to several declarations in the
 ** result.
 **)

relation elab_element : (Absyn.Element, bool) => Element list =

  rule	elab_elementspec(f,repl,prot,s) => es
	--------------------------------
	elab_element(Absyn.ELEMENT(f,repl,_,_,s,_), prot) => es

end

(** relation: elab_elementspec
 **
 ** This relation turns an `Absyn.ElementSpec' to a list of
 ** `Element's.  The boolean arguments say if the element is final and
 ** protected, respectively.
 **)

relation elab_elementspec: (bool,bool,bool,Absyn.ElementSpec) => Element list =

  rule	elab_classdef(de) => de' &
	elab_restriction(cl,re) => re'
	-----------------------
	elab_elementspec(final,repl,prot,Absyn.CLASSDEF(rp,cl as Absyn.CLASS(n,pa,fi,e,re,de)))
	  => [CLASSDEF(n,final,rp,CLASS(n,pa,e,re',de'))]

  rule	build_mod(SOME(Absyn.CLASSMOD(args, NONE)), false) => mod &
	Absyn.path_string(n) => ns
	--------------------------
	elab_elementspec(final,repl,prot,Absyn.EXTENDS(n,args))
	  => [EXTENDS(n,mod)]

  axiom	elab_elementspec(_,_,_,Absyn.COMPONENTS(_,_,[])) => []

  rule	elab_elementspec(final,repl,prot,Absyn.COMPONENTS(attr,t,xs)) => xs' &
	build_mod(m,false) => mod &
	(* PR. This adds the arraydimension that may be specified together with
	 the type of the component.  *)
	elab_variability(pa) => pa' &
	list_append(d,ad) => tot_dim
	--------------------------------------------------
	elab_elementspec(final,repl,prot,
			 Absyn.COMPONENTS(attr as Absyn.ATTR(fl,pa,di,ad),t,
					  Absyn.COMPONENTITEM(Absyn.COMPONENT(n,d,m),_)::xs))
	  => COMPONENT(n,final,repl,prot,ATTR(tot_dim,fl,RW,pa',di),t,mod)::xs'

  axiom	elab_elementspec(final,repl,prot,Absyn.IMPORT(imp,_)) => [IMPORT(imp)]

end
relation elab_variability: Absyn.Variability => Variability =

  axiom elab_variability(Absyn.VAR) => VAR
  axiom elab_variability(Absyn.DISCRETE) => DISCRETE
  axiom elab_variability(Absyn.PARAM) => PARAM
  axiom elab_variability(Absyn.CONST) => CONST

end

(** relation: elab_equations
 **
 ** This relation transforms a list of `Absyn.Equation's to a list of
 ** `Equations's, by applying the `elab_equation' relation to each
 ** equation.
 **)

relation elab_equations : Absyn.EquationItem list => Equation list =

  axiom	elab_equations [] => []

  rule	elab_equation e => e' &
	elab_equations es => es'
	------------------------
	elab_equations Absyn.EQUATIONITEM(e,_)::es => e'::es'

  rule	elab_equations es => es'
	------------------------
	elab_equations Absyn.EQUATIONITEMANN(_)::es => es'

end


(** relation: elab_equation
 **
 ** The translation of equations are straightforward, with one
 ** exception.  `If' clauses are translated so that the SCode only
 ** contains simple `if'-`else' constructs, and no `elseif'.
 **)

(* PR Arrays seem to keep their absyn.rml structure. *)
relation elab_equation : Absyn.Equation => Equation =

  axiom	elab_equation Absyn.EQ_EXPR(e) => EQ_EXPR(e)
	
  rule	elab_equations tb => tb' &
	elab_equations fb => fb'
	------------------------
	elab_equation Absyn.EQ_IF(e,tb,[],fb) => EQ_IF(e,tb',fb')

  rule	elab_equation Absyn.EQ_IF(e,tb,[],[Absyn.EQUATIONITEM(Absyn.EQ_IF(ee,ei,eis,fb),NONE)]) => eq
	------------------------------------------------------------------
	elab_equation Absyn.EQ_IF(e,tb,(ee,ei)::eis,fb) => eq

  axiom	elab_equation Absyn.EQ_EQUALS(e1,e2) => EQ_EQUALS(e1,e2)

  axiom	elab_equation Absyn.EQ_CONNECT(c1,c2) => EQ_CONNECT(c1,c2)

  rule	elab_equations l => l'
	----------------------
	elab_equation Absyn.EQ_FOR(i,e,l) => EQ_FOR(i,e,l')

end


(** - Modification management *)

(** relation: build_mod
 **
 ** Builds an `SCode.Mod' from an `Absyn.Modification'.  The boolean
 ** argument flags whether the modification is `final'.
 **)

relation build_mod : (Absyn.Modification option, bool) => Mod =

  axiom build_mod(NONE, _) => NOMOD

  axiom	build_mod(SOME(Absyn.CLASSMOD([], e as SOME(_))), final)
	  => MOD(final,[],e)

  rule	build_args(l) => subs
	---------------------------------
	build_mod(SOME(Absyn.CLASSMOD(l,e)),final) => MOD(final,subs,e)

end

(** LS: Adding elaborate for the elementspec in the redeclaration
 **)
relation build_args : (Absyn.ElementArg list) => SubMod list =

  axiom build_args [] => []

  rule	build_args xs => subs &
	build_mod(mod,final) => mod' &
	build_sub(cref,mod') => sub
	----------------------
	build_args((Absyn.MODIFICATION(final,each,cref,mod,cmt)::xs)) => (sub::subs)

  rule	build_args xs => subs &
	Absyn.element_spec_name spec => n &
	(** LS:: don't know what to use for "protected", so using false **)
	(** LS:: don't know what to use for "replaceable", so using false **)
	elab_elementspec(final,false,false,spec) => elist
	---------------------------
	build_args((Absyn.REDECLARATION(final,each,spec,constropt)::xs))
	  => (NAMEMOD(n,REDECL(final,elist))::subs)

end

(** relation: build_sub
 **
 ** This relation converts a `ComponentRef' into a number of nested
 ** `SUBMOD's.
 **)

relation build_sub : (Absyn.ComponentRef,Mod) => SubMod =

	(* First some rules to prevent bad modifications *)

  rule	Print.print_buf "# Illegal modification of " & Dump.print_component_ref c &
	Dump.print_component_ref c & Print.print_buf "\n"
	---------------------------------------
	build_sub(c as Absyn.CREF_IDENT(_,_::_),MOD(_,_::_,_)) => fail

  rule	Print.print_buf "# Illegal modification of " &
	Dump.print_component_ref c & Print.print_buf "\n"
	---------------------------------------
	build_sub(c as Absyn.CREF_QUAL(_,_::_,_),MOD(_,_::_,_)) => fail
	
	(* Then the normal rules *)
	
  rule	build_sub_sub (ss,mod) => mod'
	------------------------------
	build_sub(Absyn.CREF_IDENT(i,ss),mod) => NAMEMOD(i,mod')

  rule	build_sub(path,mod) => sub &
	let mod = MOD(false,[sub],NONE) &
	build_sub_sub(ss,mod) => mod'
	--------------------------
	build_sub(Absyn.CREF_QUAL(i,ss,path),mod) => NAMEMOD(i,mod')

end

(** relation: build_sub_sub
 **
 ** This relation is used to handle the case when a array component is
 ** indexed in the modification, so that only one or a limitied number
 ** of array elements should be modified.
 **)

relation build_sub_sub : (Subscript list, Mod) => Mod =

  axiom	build_sub_sub ([], m) => m
  axiom	build_sub_sub (l, m) => MOD(false,[IDXMOD(l,m)],NONE)

end

relation get_element_named: (Ident, Class) => Element =
	
  rule	get_element_named_from_elts(id,elts) => elt
	----------------------------------------
	get_element_named(id,CLASS(_,_,_,_,PARTS(elts,_,_,_,_,_))) => elt
end

relation get_element_named_from_elts: (Ident, Element list) => Element =

  rule	not id1 = id2 &
	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,COMPONENT(id1,_,_,_,_,_,_)::xs) => elt
	
  rule	not id1 = id2 &
	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,CLASSDEF(id1,_,_,_)::xs) => elt

  rule	get_element_named_from_elts(id2,xs) => elt
	---------------------------
	get_element_named_from_elts(id2,EXTENDS(_,_)::xs) => elt

  rule	id1 = id2
	--------------------
	get_element_named_from_elts(id2,(comp as COMPONENT(id1,_,_,_,_,_,_))::_) => comp

  rule	id1 = id2
	--------------------
	get_element_named_from_elts(id2,(cdef as CLASSDEF(id1,_,_,_))::_) => cdef

end
(** relation: print_mod
 **
 ** This relation prints a modification.  The code is excluded from
 ** the report for brevity.
 **)

(*!ignorecode*)

relation print_mod : Mod => () =

  rule	Print.print_buf "NOMOD"
	----------------
	print_mod(NOMOD)

  rule	Print.print_buf "redeclare(" & 
	Dump.print_bool b & Print.print_buf ", " &
	Dump.print_list(elist, print_element, ", ") &
	Print.print_buf ")"
	------------------------------
	print_mod REDECL(b,elist)
	
  rule	print_final final &
	print_subs1 subs &
	print_eqmod ass
	------------
	print_mod MOD(final, subs, ass)

  rule	Print.print_buf "#-- print_mod failed\n"
	------------------------
	print_mod _

end

(**)


relation restr_string : Restriction => string =

  axiom restr_string R_CLASS			=> "CLASS"
  axiom	restr_string R_MODEL			=> "MODEL"
  axiom	restr_string R_RECORD			=> "RECORD"
  axiom restr_string R_BLOCK			=> "BLOCK"
  axiom restr_string R_CONNECTOR		=> "CONNECTOR"
  axiom restr_string R_TYPE			=> "TYPE"
  axiom restr_string R_PACKAGE			=> "PACKAGE"
  axiom restr_string R_FUNCTION			=> "FUNCTION"
  axiom	restr_string R_EXT_FUNCTION		=> "EXTFUNCTION"
  axiom restr_string R_PREDEFINED_INT		=> "PREDEFINED_INT"
  axiom restr_string R_PREDEFINED_REAL		=> "PREDEFINED_REAL"
  axiom restr_string R_PREDEFINED_STRING	=> "PREDEFINED_STRING"
  axiom restr_string R_PREDEFINED_BOOL		=> "PREDEFINED_BOOL"

end

relation print_restr : Restriction => () =

  rule	restr_string restr => str &
	Print.print_buf str
	----------------
	print_restr restr

end

relation print_final : bool => () =

  axiom print_final false

  rule	Print.print_buf " final "
	--------------
       print_final true

end

relation print_subs : SubMod list => () =

  axiom print_subs []

  rule	Print.print_buf n & print_mod mod
	-----------------------
	print_subs [NAMEMOD(n,mod)]

  rule	Print.print_buf n & print_mod mod & Print.print_buf ", " &
	print_subs subs
	---------------
	print_subs NAMEMOD(n,mod)::subs

  rule	Dump.print_subscripts ss & print_mod mod
	------------------
	print_subs [IDXMOD(ss,mod)]

  rule	Dump.print_subscripts ss & print_mod mod & Print.print_buf ", " &
	print_subs subs
	--------------
	print_subs IDXMOD(ss,mod)::subs

end

relation print_subs1 : SubMod list => () =

  axiom print_subs1 [] => ()

  rule	Print.print_buf "(" &
	print_subs l &
	Print.print_buf ")"
	-----------
	print_subs1 l

end

relation print_eqmod : Absyn.Exp option => () =

  axiom print_eqmod NONE

  rule	Print.print_buf " = " & Dump.print_exp e
	-----------------------------
	print_eqmod SOME(e)

end
	
(*!includecode*)

relation print_element_list : Element list => () =

  axiom	print_element_list([]) => ()

  rule	print_element x &
	print_element_list(xs) => ()
	----------------------
	print_element_list(x::xs) => ()
end

relation print_element : Element => () =

  rule	Print.print_buf "EXTENDS(" & Absyn.path_string path => str & Print.print_buf str & Print.print_buf ")"
	----------------------------------------------------
	print_element EXTENDS(path,mod)

  rule	Print.print_buf "CLASSDEF(" & Print.print_buf n & Print.print_buf ")"
	---------------------------------------
	print_element CLASSDEF(n,final,repl,cl)

  rule	Print.print_buf "COMPONENT(" & Print.print_buf n &
	Print.print_buf ",mod:" & print_mod mod & 
	Print.print_buf ",tp:" & Absyn.path_string typath => s &
	Print.print_buf s &
	Print.print_buf ")"
	----------------------------------------
	print_element COMPONENT(n,final,repl,prot,attr,typath,mod)

  rule	Print.print_buf "IMPORT(_)\n" 
	-------------------------
	print_element(IMPORT(_))
end	

relation variability_string: Variability => string =
  axiom	variability_string(VAR) => "VAR"
  axiom	variability_string(DISCRETE) => "DISCRETE"
  axiom	variability_string(PARAM) => "PARAM" 
  axiom	variability_string(STRUCTPARAM) => "STRUCTPARAM"
  axiom	variability_string(CONST) => "CONST" 
end