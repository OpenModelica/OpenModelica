(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 ceval.rml
 ** module:      Ceval
 ** description: Constant propagation of expressions
 **
 ** RCS: $Id$
 ** 
 ** This module handles constant propagation (or evaluation)
 ** When elaborating expressions, in the Static module, expressions are checked to 
 ** find out its type. It also checks whether the expressions are constant and the relation 
 ** ceval in this module will then evaluate the expression to a constant value, defined
 ** in the Values module.
 **
 ** Input: 
 **	Env: Environment with bindings
 **	Exp: Expression to check for constant evaluation
 **	Bool flag determines whether the current instantiation is implicit
 **	InteractiveSymbolTable is optional, and used in interactive mode,
 **	e.g. from mosh
 **	
 ** Output:
 **	Value: The evaluated value
 **     InteractiveSymbolTable: Modified symbol table
 **     Subscript list : Evaluates subscripts and generates constant expressions. 
 **)


module Ceval :
  with "env.rml"
  with "exp.rml"
  with "interactive.rml"
  with "values.rml"

  (** Constant evaluation of expressions *)
  relation ceval : (Env.Env, Exp.Exp, bool (*implicit*) ,
		    Interactive.InteractiveSymbolTable option, int option (* dimensions *) )
	    => (Values.Value, Interactive.InteractiveSymbolTable option)

  relation ceval_list : (Env.Env, Exp.Exp list, bool,
			 Interactive.InteractiveSymbolTable option) 
	  => Values.Value list

  relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list)
	  => Exp.Subscript list

end

with "staticexp.rml"
with "print.rml" 
with "types.rml"
with "modutil.rml"
with "system.rml"
with "absyn.rml"
with "explode.rml"
with "inst.rml"
with "lookup.rml"
with "dump.rml"
with "dae.rml"
with "debug.rml"
with "util.rml"
with "modsim.rml"
with "classinf.rml"
with "rtopts.rml"
with "parse.rml"
with "prefix.rml"
with "codegen.rml"
with "classloader.rml"


(** relation: ceval
 **
 ** This relation is used when the value of a constant expression is
 ** needed.  It takes an environment and an expression and calculates
 ** its value.
 **
 ** The third argument indicates whether the evaluation is performed in the
 ** interactive environment (implicit instantiation), in which case function
 ** calls are evaluated.
 **
 ** The last argument is an optional dimension.
 **)
relation ceval : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option, int option) 
	    => (Values.Value, Interactive.InteractiveSymbolTable option) =

  axiom	ceval (_,Exp.ICONST(x),_,st,_) => (Values.INTEGER(x),st)
  axiom	ceval (_,Exp.RCONST(x),_,st,_) => (Values.REAL(x),st)
  axiom ceval (_,Exp.SCONST(x),_,st,_) => (Values.STRING(x),st)
  axiom ceval (_,Exp.BCONST(x),_,st,_) => (Values.BOOL(x),st)
  axiom ceval (_,Exp.END,_,st,SOME(dim))  => (Values.INTEGER(dim), st)

  rule Print.print_buf "# 'end' cannot be used outside array subscript\n"
    --------------------------------------
    ceval (_,Exp.END,_,st,NONE) => fail
  
  rule	ceval_ast_exp(env,exp,impl,st) => exp'
	--------------------------------------
	ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_exp(env,exp,impl,st) => exp'
	--------------------------------------
	ceval (env,Exp.CODE(Absyn.C_EXPRESSION(exp),_),impl,st,_) 
	  => (Values.CODE(Absyn.C_EXPRESSION(exp')),st)

  rule	ceval_ast_elt(env,elt,impl,st) => elt'
	--------------------------------------
	ceval (env,Exp.CODE(Absyn.C_ELEMENT(elt),_),impl,st,_) 
	  => (Values.CODE(Absyn.C_ELEMENT(elt')),st)

  axiom	ceval(env, Exp.CODE(c,_),_,st,_) => (Values.CODE(c),st)

  rule	ceval_list (env,es,impl,st) => es' &
	list_length es' => l
	------------------------------
	ceval (env,Exp.ARRAY(_,_,es),impl,st,_) => (Values.ARRAY(es'),st)

  rule	ceval_matrixelt(env,expll) => elts
	------------------------------
	ceval (env, Exp.MATRIX(_,_,expll),_,st,_) => (Values.ARRAY(elts),st)

  rule	ceval_cref (env,c) => v
	---------------------------
	ceval (env,Exp.CREF(c,_),_,st,_) => (v,st) 

  rule	ceval_builtin_size(env,cref,dim,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.SIZE(cref,SOME(dim)),impl,st,_) => (v,st) 	

  rule	ceval_builtin_size_matrix(env,cref,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.SIZE(cref,NONE),impl,st,_) => (v,st) 	

	(* Start luc_pop *)
  rule	ceval_builtin_floor(env,exp,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("floor"),[exp],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_ceil(env,exp,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("ceil"),[exp],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_sqrt(env,exp,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("sqrt"),[exp],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_integer(env,exp,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("integer"),[exp],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_div(env,exp1,exp2,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("div"),[exp1, exp2],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_mod(env,exp1,exp2,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("mod"),[exp1, exp2],_,_),impl,st,_) => (v,st) 	

  rule	ceval_builtin_rem(env,exp1,exp2,impl,st) => (v,st)
	-----------------------------------------
	ceval (env,Exp.CALL(Absyn.IDENT("rem"),[exp1, exp2],_,_),impl,st,_) => (v,st) 	

	(* end luc_pop *)

  rule	Print.print_buf "# Can't call functions at compile time\n" &
	Print.print_buf "    expression: " & Exp.print_exp e & Print.print_buf "\n"
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(_,_,_,_),false,NONE,_) => fail

  rule	(* Print.print_buf "implicit evaluation of function calls without symbol table, exp: " &
	   Exp.print_exp e & Print.print_buf "\n" *)
	-------------------------------------------
	ceval(env, e as Exp.CALL(_,_,_,_),true,NONE,_) => fail

  rule	ceval_interactive_functions(env,e,st) => (value,st)
	-------------------------------------
	ceval (env, e as Exp.CALL(_,_,_,_),true, SOME(st),_) => (value,SOME(st))

  rule	(* Call of record constructors, etc., i.e. functions that can be 
	   constant propagated. *)
	ceval_list(env,expl,true,st) => vallst &
	ceval_function(env,func,vallst) => newval
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(func,expl,_,_),true,st as SOME(_),_) 
	  => (newval,st)

  rule	(* Call externally implemented functions. *) 
	Static.is_function_in_cflist(cflist,func) => true &
	ceval_list(env,expl,true,st) => vallst &
	ModUtil.path_string2(func,"_") => funcstr &
	string_append(funcstr,"_in.txt") => infilename &
	string_append(funcstr,"_out.txt") => outfilename &
	Values.write_to_file_as_args(vallst,infilename)  &
	System.execute_function(funcstr) &
	System.read_values_from_file(outfilename) => newval
	-------------------------------------------------------
	ceval (env, e as Exp.CALL(func,expl,_,_),true,st as SOME(Interactive.SYMBOLTABLE(p,_,_,_,cflist)),_) => (newval,st)

	(** Strings **)
	
  rule  ceval (env, lh, impl,st, NONE) => (Values.STRING(lhv),_) &
	ceval (env, rh, impl,st,NONE) => (Values.STRING(rhv),_) &
	string_append(lhv,rhv) => str
	-----------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.STRING), rh),impl,st,_)
	  => (Values.STRING(str),st)

	(**  Numerical *)

  rule	ceval (env, lh, impl,st,dim) => (Values.REAL(lhv),st') &
	ceval (env, rh, impl,st',dim) => (Values.REAL(rhv),st'') &
	real_add(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.REAL), rh),impl,st,dim)
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st',dim) => (Values.ARRAY(vlst2),st'') &
	Values.add_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.ADD_ARR(_),rh),impl,st,dim) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.ARRAY(vlst1),st') &
	ceval (env,rh,impl,st',dim) => (Values.ARRAY(vlst2),st'') &
	Values.sub_elementwise_arrayelt(vlst1, vlst2) => reslst
	-------------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB_ARR(_),rh),impl,st,dim) => (Values.ARRAY(reslst),st'')

  rule	ceval (env,lh,impl,st,dim) => (sval,st') &
	ceval (env,rh,impl,st',dim) => (Values.ARRAY(aval),st'') &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_ARRAY(_), rh),impl,st,dim) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,rh,impl,st,dim) => (sval,st') &
	ceval (env,lh,impl,st',dim) => (Values.ARRAY(aval),st'') &
	Values.mult_scalar_arrayelt(sval,aval) => reslst
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_ARRAY_SCALAR(_), rh),impl,st,dim) 
	  => (Values.ARRAY(reslst),st'')

  rule	ceval (env,rh,impl,st,dim) => (Values.ARRAY(rhvals),st') &
	ceval (env,lh,impl,st',dim) => (Values.ARRAY(lhvals),st'') &
	Values.mult_scalar_product(rhvals,lhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_SCALAR_PRODUCT(_), rh),impl,st,dim) => (res,st'')
	
  rule	(* {{..}..{..}} * {...} *)
	ceval (env,lh,impl,st,dim) => (Values.ARRAY(lhvals as (elt1::_)),st') &
 	ceval (env,rh,impl,st',dim) => (Values.ARRAY(rhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim) => (res,st'')

 rule	(* {...} * {{..}..{..}} *)
	ceval (env,rh,impl,st,dim) => (Values.ARRAY(rhvals as (elt1::_)),st') &
 	ceval (env,lh,impl,st',dim) => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => false &
	Values.mult_scalar_product(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim) => (res,st'')

 rule	(* {{..}..{..}} * {{..}..{..}} *)
	ceval (env,rh,impl,st,dim) => (Values.ARRAY(rhvals as (elt1::_)),st') &
 	ceval (env,lh,impl,st',dim) => (Values.ARRAY(lhvals as (elt2::_)),st'') &
	Values.is_array(elt1) => true &
	Values.is_array(elt2) => true &
	Values.mult_matrix(lhvals,rhvals) => res
	------------------------------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL_MATRIX_PRODUCT(_), rh),impl,st,dim) 
	  => (Values.ARRAY(res),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.INTEGER(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.INTEGER(rhv),st'') &
	int_add(lhv, rhv) => sum
	------------------------
 	ceval (env, Exp.BINARY(lh, Exp.ADD(Exp.INT), rh),impl,st,dim) 
	  => (Values.INTEGER(sum),st'')
	(**)
  rule	ceval (env,lh,impl,st,dim) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.REAL(rhv),st'') &
	real_sub(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.REAL), rh),impl,st,dim) 
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.INTEGER(lhv),st') &
	ceval (env, rh,impl,st',dim) => (Values.INTEGER(rhv),st'') &
	int_sub(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.SUB(Exp.INT), rh),impl,st,dim)
	  => (Values.INTEGER(sum),st'') 
	(**)
  rule	ceval (env,lh,impl,st,dim) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.REAL(rhv),st'') &
	real_mul(lhv, rhv) => sum
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.REAL), rh),impl,st,dim) 
	  => (Values.REAL(sum),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.REAL(rhv),st'') &
	real_div(lhv, rhv) => div
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim) 
	  => (Values.REAL(div),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.REAL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.REAL(rhv),st'') &
	not real_div(lhv,rhv) => _ &
	Print.print_buf "#Error, division by zero.\n" 
	-------------------------
	ceval (env, Exp.BINARY(lh, Exp.DIV(Exp.REAL), rh),impl,st,dim) 
	  => fail

  rule	ceval (env,lh,impl,st,dim) => (Values.INTEGER(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.INTEGER(rhv),st'') &
	int_mul(lhv, rhv) => sum
	------------------------
	ceval (env, Exp.BINARY(lh, Exp.MUL(Exp.INT), rh),impl,st,dim)
	  => (Values.INTEGER(sum),st'')
	(**)
  rule	ceval (env,exp,impl,st,dim) => (Values.REAL(x),st') &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.REAL), exp),impl,st,dim)
	  => (Values.REAL(x'),st')

  rule	ceval (env,exp,impl,st,dim) => (Values.INTEGER(x),st') &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UMINUS(Exp.INT), exp),impl,st,dim)
	  => (Values.INTEGER(x'),st')
	(**)
  rule	ceval (env,exp,impl,st,dim) => (Values.REAL(x),st') &
	real_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.REAL), exp),impl,st,dim)
	  => (Values.REAL(x'),st')

  rule	ceval (env,exp,impl,st,dim) => (Values.INTEGER(x),st') &
	int_neg (x) => x'
	---------------------
	ceval (env, Exp.UNARY(Exp.UPLUS(Exp.INT), exp),impl,st,dim)
	  => (Values.INTEGER(x'),st')

	(**  Logical *)

  rule	ceval (env,lh,impl,st,dim) => (Values.BOOL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.BOOL(rhv),st'') &
	bool_and(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.AND, rh),impl,st,dim)
	  => (Values.BOOL(x),st'')

  rule	ceval (env,lh,impl,st,dim) => (Values.BOOL(lhv),st') &
	ceval (env,rh,impl,st',dim) => (Values.BOOL(rhv),st'') &
	bool_or(lhv, rhv) => x
	------------------------
	ceval (env, Exp.LBINARY(lh, Exp.OR, rh),impl,st,dim)
	  => (Values.BOOL(x),st'')

  rule	ceval (env,e,impl,st,dim) => (Values.BOOL(b),st') &
	bool_not(b) => b'
	-----------------
	ceval (env, Exp.LUNARY(Exp.NOT, e),impl,st,dim) => (Values.BOOL(b'),st')

	(**  Relations *)

  rule	ceval (env,lhs,impl,st,dim) => (lhs',st') &
	ceval (env,rhs,impl,st',dim) => (rhs',st'') &
	ceval_relation (lhs',relop,rhs') => v
	-------------------------------------
	ceval (env, Exp.RELATION(lhs,relop,rhs),impl,st,dim) => (v, st'')

	(**)

  rule	ceval (env,start,impl,st,dim) => (Values.INTEGER(start'),st') &
	ceval (env,stop,impl,st',dim) => (Values.INTEGER(stop'),st'') &
	ceval_range(start', 1, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, NONE, stop),impl,st,dim) 
	  => (Values.ARRAY(arr),st')

  rule	ceval (env,start,impl,st,dim) => (Values.INTEGER(start'),st') &
	ceval (env,step,impl,st',dim) => (Values.INTEGER(step'),st'') &
	ceval (env,stop,impl,st'',dim) => (Values.INTEGER(stop'),st''') &
	ceval_range(start', step', stop') => arr 
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.INT,start, SOME(step), stop),impl,st,dim) 
	  => (Values.ARRAY(arr),st''')

  rule	ceval (env,start,impl,st,dim) => (Values.REAL(start'),st') &
	ceval (env,stop,impl,st',dim) => (Values.REAL(stop'),st'') &
	real_sub(stop',start') => diff &
	int_real 1 => step & (* bug in rml, 1.0 => 0.0 in cygwin  *)
	ceval_range_real(start', step, stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, NONE, stop),impl,st,dim) 
	  => (Values.ARRAY(arr),st'')

  rule	
	ceval (env,start,impl,st,dim) => (Values.REAL(start'),st') &
	ceval (env,step,impl,st',dim) => (Values.REAL(step'),st'') &
	ceval (env,stop,impl,st'',dim) => (Values.REAL(stop'),st''') &
	ceval_range_real(start', step', stop') => arr
	-------------------------------------------
	ceval (env, Exp.RANGE(Exp.REAL,start, SOME(step), stop),impl,st,dim) 
	  => (Values.ARRAY(arr),st''')

  rule	ceval (env,e,impl,st,dim) => (Values.INTEGER(i),st') &
	int_real i => r
	---------------
	ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim) => (Values.REAL(r),st')

  rule	ceval (env,e,impl,st,dim) => (Values.ARRAY(ivals),st') &
	Values.type_convert(Exp.INT,Exp.REAL,ivals) => rvals
	----------------------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e),impl,st,dim) => (Values.ARRAY(rvals),st')

  rule	ceval (env,e,impl,st,dim) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT, Exp.REAL, vallst) => vallst'
	--------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.ARRAY(Exp.INT,_,expl)),impl,st,dim) 
	       => (Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st,dim) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	---------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.RANGE(Exp.INT,_,_,_)),impl,st,dim) => 
		(Values.ARRAY(vallst'),st')

  rule	ceval (env,e,impl,st,dim) => (Values.ARRAY(vallst),st') &
	Values.type_convert(Exp.INT,Exp.REAL,vallst) => vallst'
	---------------------------------------
	ceval (env, Exp.CAST(Exp.REAL,e as Exp.MATRIX(Exp.INT,_,_)),impl,st,dim) => 
		(Values.ARRAY(vallst'),st')

  rule	(* Ifexp, true branch *)
	ceval (env,b,impl,st,dim) => (Values.BOOL(true),st') &
	ceval (env,e1,impl,st',dim) => (v,st'')
	------------------------------------
	ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim) 
	  => (v,st'')
  rule	(* Ifexp, false branch *)
	ceval (env,b,impl,st,dim) => (Values.BOOL(false),st') &
	ceval (env,e2,impl,st',dim) => (v,st'')
	------------------------------------
	ceval (env, Exp.IFEXP(b,e1,e2),impl,st,dim) 
	  => (v,st'')

  rule	Print.print_buf "#-- ceval reduction\n"
	---------------------------------------
	ceval (env, Exp.REDUCTION(p,exp,iter,iterexp),impl,st,dim)
	  => fail (* (v,st) *)

  (*  ceval can apparently fail and that is ok, catched by other rules...
   rule	Debug.fprint("failtrace", "- ceval ") &
	Debug.fcall("failtrace",Exp.print_exp, e) &
	Debug.fprint("failtrace", " failed\n") 
	-----------------------------------------------------
	ceval (_,e,_,_,_) => fail
   *)
end



(** relation: ceval_function 
 ** 
 ** For constant evaluation of functions returning a single value. For now only
 ** record constructors.
 **)
relation ceval_function: (Env.Env, Absyn.Path, Values.Value list) 
	  => Values.Value =

	(* For record constructors *)
  rule	Lookup.lookup_record_constructor_class(env,funcname) => (_,_) &
	Lookup.lookup_class(env,funcname,false) => (c,env') &
	SCode.component_names(c) => compnames &
	Types.values_to_mods(vallst,compnames) => mod &
	Inst.inst_class(env',mod,Prefix.NOPRE,[],c,[],false,Inst.TOP_CALL)
	  => (dae,_,_,_,_) &
	DAE.dump_elements dae &
	Print.get_string => s & print s & print "\n" &
	DAE.dae_to_record_value(dae) => value  
	----------------------
	ceval_function(env,funcname,vallst) => value

end


(** relaton: ceval_ast_exp
 **
 ** Part of meta-programming using CODE.
 **
 ** This relation evaluates a piece of Expression AST, replacing Eval(variable)
 ** with the value of the variable, given that it is of type "Expression".
 ** 
 ** Example: y = Code(1 + x)
 **          2 + 5 * ( x + Eval(y) )  =>   2 + 5 * ( x + 1 + x )
 **)
relation ceval_ast_exp: (Env.Env, Absyn.Exp, 
			 bool, Interactive.InteractiveSymbolTable option)
	=> Absyn.Exp =

  axiom	ceval_ast_exp (_,e as Absyn.INTEGER(_),_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.REAL(_),_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.CREF(_),_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.STRING(_),_,_) => e
  axiom	ceval_ast_exp (_,e as Absyn.BOOL(_),_,_) => e

  rule	ceval_ast_exp (env,e1,impl,st) => e1' &
	ceval_ast_exp (env,e2,impl,st) => e2' 
	---------------------------------
	ceval_ast_exp (env, Absyn.BINARY(e1, op, e2),impl,st) 
	  => Absyn.BINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st) => e'
	---------------------------------
	ceval_ast_exp (env, Absyn.UNARY(op, e),impl,st) 
	  => Absyn.UNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st) => e1' &
	ceval_ast_exp (env,e2,impl,st) => e2' 
	---------------------------------
	ceval_ast_exp (env, Absyn.LBINARY(e1, op, e2),impl,st) 
	  => Absyn.LBINARY(e1',op,e2')

  rule	ceval_ast_exp (env,e,impl,st) => e'
	---------------------------------
	ceval_ast_exp (env, Absyn.LUNARY(op, e),impl,st) 
	  => Absyn.LUNARY(op,e')

  rule	ceval_ast_exp (env,e1,impl,st) => e1' &
	ceval_ast_exp (env,e2,impl,st) => e2' 
	---------------------------------
	ceval_ast_exp (env, Absyn.RELATION(e1, op, e2),impl,st) 
	  => Absyn.RELATION(e1',op,e2')

  rule	ceval_ast_exp(env,cond,impl,st)=> cond' &
	ceval_ast_exp(env,then,impl,st)=> then' &
	ceval_ast_exp(env,else,impl,st)=> else' &
	ceval_ast_expexp_list(env,nest,impl,st) =>  nest'
	-----------------------------------------------
	ceval_ast_exp (env, Absyn.IFEXP(cond,then,else,nest),impl,st)
	  => Absyn.IFEXP(cond',then',else',nest')

  rule	Static.elab_exp(env,e,impl,st) => (e',_,_) &
	ceval(env,e',impl,st,NONE) => (Values.CODE(Absyn.C_EXPRESSION(exp)),_) 
	----------------------------------
	ceval_ast_exp (env, 
		       Absyn.CALL(Absyn.CREF_IDENT("Eval",[]),
				  Absyn.FUNCTIONARGS([e],[])),impl,st)
	  => exp
  axiom	ceval_ast_exp(env,e as Absyn.CALL(cr,fa),_,_) => e

  rule	ceval_ast_exp_list(env,expl,impl,st) => expl'
	---------------------------------------------
	ceval_ast_exp(env,Absyn.ARRAY(expl),impl,st) 
	  => Absyn.ARRAY(expl')

  rule	ceval_ast_exp_list_list(env,expl,impl,st) => expl'
	--------------------------------------------------
	ceval_ast_exp(env,Absyn.MATRIX(expl),impl,st) 
	  => Absyn.MATRIX(expl')
	  
  rule	ceval_ast_exp(env,e1,impl,st) => e1' &
	ceval_ast_exp(env,e2,impl,st) => e2' &
	ceval_ast_exp(env,e3,impl,st) => e3' 
	------------------------------------
	ceval_ast_exp(env,Absyn.RANGE(e1,SOME(e2),e3),impl,st) 
	  => Absyn.RANGE(e1',SOME(e2'),e3')

  rule	ceval_ast_exp(env,e1,impl,st) => e1' &
	ceval_ast_exp(env,e3,impl,st) => e3'
	------------------------------------
	ceval_ast_exp(env,Absyn.RANGE(e1,NONE,e3),impl,st) 
	  => Absyn.RANGE(e1',NONE,e3')
  
  rule	ceval_ast_exp_list(env,expl,impl,st) => expl'
	---------------------------------------------
	ceval_ast_exp(env,Absyn.TUPLE(expl),impl,st) 
	  => Absyn.TUPLE(expl')

  axiom	ceval_ast_exp(env,Absyn.END,_,_) => Absyn.END

  axiom	ceval_ast_exp(env,e as Absyn.CODE(_),_,_) => e
end

(** relation: ceval_ast_exp_list
 ** 
 ** List version of ceval_ast_exp
 **)
relation ceval_ast_exp_list: (Env.Env, Absyn.Exp list, 
			      bool, Interactive.InteractiveSymbolTable option) 
	  => (Absyn.Exp list) =
  axiom	ceval_ast_exp_list (env, [],_,_) => []

  rule	ceval_ast_exp(env,e,impl,st) => e' &
	ceval_ast_exp_list(env,es,impl,st) => res
	-----------------------------------------
	ceval_ast_exp_list(env,e::es,impl,st) 
	  => e::res
end

(** relation: ceval_ast_exp_list
 ** 
 **)
relation ceval_ast_exp_list_list: (Env.Env, Absyn.Exp list list, 
			  bool, Interactive.InteractiveSymbolTable option)
	  => (Absyn.Exp list list) =

  axiom	ceval_ast_exp_list_list(env, [], _,_) => []

  rule	ceval_ast_exp_list(env,e,impl,st) => e' &
	ceval_ast_exp_list_list(env,es,impl,st) => res
	----------------------------------------------
	ceval_ast_exp_list_list(env,e::es,impl,st) 
	  => e::res
end

(** relation: ceval_ast_exp_list_list
 **
 ** For IFEXP
 **)
relation ceval_ast_expexp_list: (Env.Env, (Absyn.Exp*Absyn.Exp) list, 
				 bool, Interactive.InteractiveSymbolTable option) 
	  => (Absyn.Exp*Absyn.Exp) list =

  axiom	ceval_ast_expexp_list(_,[],_,_) => []

  rule	ceval_ast_exp(env,e1,impl,st)=> e1' &
	ceval_ast_exp(env,e2,impl,st)=> e2' &
	ceval_ast_expexp_list(env,xs,impl,st) => res
	-------------------------------------
	ceval_ast_expexp_list(env,(e1,e2)::xs,impl,st) 
	  => ((e1',e2')::res)
end




(** relation: ceval_ast_elt
 **
 **)
relation ceval_ast_elt: (Env.Env, Absyn.Element, 
			 bool, Interactive.InteractiveSymbolTable option)
	  => (Absyn.Element) =

  rule	ceval_ast_citems(env,citems,impl,st) => citems'
	-----------------------------------------------
	ceval_ast_elt (env, Absyn.ELEMENT(f,r,io,id,Absyn.COMPONENTS(attr,tp,citems),file,line,c),
		       impl,st)
	  => (Absyn.ELEMENT(f,r,io,id,Absyn.COMPONENTS(attr,tp,citems'),file,line,c))
end

(** relation: ceval_ast_citems
 **
 **)
relation ceval_ast_citems: (Env.Env, Absyn.ComponentItem list, 
			 bool, Interactive.InteractiveSymbolTable option)
	      => Absyn.ComponentItem list =
  axiom	ceval_ast_citems(_,[],_,_) => []

  rule	ceval_ast_citems(env,xs,impl,st) => res &
	ceval_ast_modopt(env,modopt,impl,st) => modopt' &
	ceval_ast_arraydim(env,ad,impl,st) => ad' 
	------------------------------------------------
	ceval_ast_citems (env,Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad,modopt),cmt)::xs,
			  impl,st)
	  => (Absyn.COMPONENTITEM(Absyn.COMPONENT(id,ad',modopt'),cmt)::res)

  	(* If one component fails, the rest should still succeed *)
  rule	ceval_ast_citems(env,xs,impl,st) => res 
	----------------------------------
	ceval_ast_citems(env,x::xs,impl,st) => x::res
end

(** relation: ceval_ast_modopt
 **
 **)
relation ceval_ast_modopt: (Env.Env, Absyn.Modification option,
			    bool, Interactive.InteractiveSymbolTable option)
	  => Absyn.Modification option	=

  rule	ceval_ast_modification(env,mod,st,impl) => res
	----------------------------------------------
	ceval_ast_modopt(env,SOME(mod),st,impl) => SOME(res)

  axiom	ceval_ast_modopt(env,NONE,_,_) => NONE
	
end

(** relation: ceval_ast_modification
 **
 ** This relation evaluates Eval(variable) inside an AST Modification  and replaces 
 ** the Eval operator with the value of the variable if it has a type "Expression"
 **)
relation ceval_ast_modification: (Env.Env, Absyn.Modification, 
				  bool, Interactive.InteractiveSymbolTable option)
	  => (Absyn.Modification) =

  rule	ceval_ast_exp(env,e,impl,st) => e' &
	ceval_ast_eltargs(env,eltargs,impl,st) => eltargs'
	--------------------------------------------------
	ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,SOME(e)),impl,st)
	  => (Absyn.CLASSMOD(eltargs',SOME(e')))

  rule	ceval_ast_eltargs(env,eltargs,impl,st) => eltargs'
	--------------------------------------------------
	ceval_ast_modification(env,Absyn.CLASSMOD(eltargs,NONE),impl,st)
	  => (Absyn.CLASSMOD(eltargs',NONE))
end

relation ceval_ast_eltargs: (Env.Env, Absyn.ElementArg list,
			     bool, Interactive.InteractiveSymbolTable option)
	  => (Absyn.ElementArg list) =

  axiom	ceval_ast_eltargs(env,[],_,_) => []

  rule	ceval_ast_modification(env,mod,impl,st) => mod' &
	ceval_ast_eltargs(env,args,impl,st) => res 
	-----------------------------------------------
	ceval_ast_eltargs(env,Absyn.MODIFICATION(b,e,cr,SOME(mod),stropt)::args,
			  impl,st) 
	  => Absyn.MODIFICATION(b,e,cr,SOME(mod'),stropt)::res

	  (**TODO: look through redeclarations for Eval(var) as well **)
  rule	ceval_ast_eltargs(env,args,impl,st) => res
	------------------------------------------
	ceval_ast_eltargs(env,m::args,
			  impl,st) 
	  => m::res
end

relation ceval_ast_arraydim: (Env.Env, Absyn.ArrayDim, 
			      bool, Interactive.InteractiveSymbolTable option)
	=> (Absyn.ArrayDim) =
  axiom	ceval_ast_arraydim (env,[],_,_) => []

  rule	ceval_ast_arraydim(env,xs,impl,st) => res
	-----------------------------------------
	ceval_ast_arraydim(env,Absyn.NOSUB::xs,impl,st) 
	  => Absyn.NOSUB::res

  rule	ceval_ast_arraydim(env,xs,impl,st) => res &
	ceval_ast_exp(env,e,impl,st) => e'
	----------------------------------
	ceval_ast_arraydim(env,Absyn.SUBSCRIPT(e)::xs,impl,st) 
	  => Absyn.SUBSCRIPT(e)::res
end

(* relation ceval_interactive_functions
** This relation evaluates the functions defined in the interactive environment.
*)
relation ceval_interactive_functions: (Env.Env, Exp.Exp, Interactive.InteractiveSymbolTable)
	=> (Values.Value, Interactive.InteractiveSymbolTable) =


  rule	Static.component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,path,true) => (c, env) &
	Env.get_env_path(env) => SOME(p1) &
	ModUtil.path_string(p1) => s1 &
	Print.print_buf "Found class " &
	Print.print_buf s1 & Print.print_buf "\n\n" &
	Print.get_string() => str
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("lookupClass"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	Interactive.get_type_of_variable(varid, iv) => tp &
	Types.unparse_type tp => str 
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("typeOf"),[Exp.CREF(Exp.CREF_IDENT(varid,_),_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	let newst = Interactive.SYMBOLTABLE(Absyn.PROGRAM([],Absyn.TOP),[],[],[],[])
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clear"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,ic,[],cf)
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearVariables"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	let newst = Interactive.SYMBOLTABLE(p,fp,[],iv,cf)
	-------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("clearCache"),[],_,_),st as Interactive.SYMBOLTABLE(p,fp,ic,iv,cf)) => (Values.BOOL(true),newst)

  rule	Dump.unparse_str(p) => str
	-------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	Interactive.get_pathed_class_in_program(path,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str
	-------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("list"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	DAE.dump_str (dae) => str &

(* get rid of f in fclass so that old modsimpack works. 
   Get rid of this when modsimpack understands fclass. *)
	string_list(str) => charlist &
	list_delete(charlist, 0) => charlist' &
	list_string(charlist') => str' &

	Debug.fcall ("daedump", DAE.dump, dae) &
	Debug.fcall ("daedump2", DAE.dump2, dae) &
	Debug.fcall ("daedumpdebug", DAE.dump_debug, dae) &
	Debug.fcall ("daedumpgraphv", DAE.dump_graphviz, dae) &

	Print.get_string() => s2 &
	print s2 &
	Print.print_error_buf s2 &
	Exp.cref_modelica_str(cr) => modelname &
	string_append(modelname,".mof") => filename &
	System.pwd => pwd &
	System.path_delimiter => pd &
	Util.string_append_list([pwd,pd,filename]) => filename' &
	System.write_file(filename',str') &
	print "wrote flat file: " & 
	print str & print "\n" &
	ModSim.compile_flat_class(filename',modelname) => exefile &
	
	let record = Values.RECORD([Values.STRING(str),Values.STRING(exefile)],["flatClass","exefile"])
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (record,Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))

  rule	Static.component_ref_to_path(cr) => path & 
	Absyn.path_string path => pathstr &
	Print.print_buf "Failed to instantiate " &
	Print.print_buf pathstr & Print.print_buf " .\n" &
	Print.get_string() => str 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("translateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)
	
  rule	(* Build and simulate model *)
	Static.component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	DAE.dump_str (dae) => str &

(* get rid of f in fclass so that old modsimpack works. 
   Get rid of this when modsimpack understands fclass. *)
	string_list(str) => charlist &
	list_delete(charlist, 0) => charlist' &
	list_string(charlist') => str' &

	Print.get_string() => s2 &
	Print.print_error_buf s2 &
	Exp.cref_modelica_str(cr) => modelname &
	string_append(modelname,".mof") => filename &
	System.pwd => pwd &
	System.path_delimiter => pd &
	Util.string_append_list([pwd,pd,filename]) => filename' &
	System.write_file(filename',str') &
	ModSim.compile_flat_class(filename',modelname) => exefile &
	ceval(env,starttime,true,SOME(st),NONE) => (Values.REAL(start),_) &
	ceval(env,stoptime,true,SOME(st),NONE) => (Values.REAL(stop),_) &
	ceval(env,interval,true,SOME(st),NONE) => (Values.INTEGER(interv),_) &
	Util.string_append_list([pwd,pd,modelname,"_res.plt"]) => resultfile &
	int_sub(interv,1) => interv' &
	ModSim.run_simulation(exefile,start,stop,interv',resultfile) => 0 &
	let simValue = Values.RECORD([Values.STRING(resultfile)],["resultFile"]) &
	let simType = (Types.T_COMPLEX(ClassInf.RECORD("SimulationResult")
			,[Types.VAR("resultFile",
				    Types.ATTR(false, 
					       SCode.RO, 
					       SCode.VAR,
					       Absyn.BIDIR),
				    false, (Types.T_STRING([]),NONE), Types.UNBOUND)
			  ]
			),NONE) &
	Interactive.add_var_to_symboltable("currentSimulationResult",simValue,simType,st) 
	  => newst &
	  
	  System.cd(pwd) => _
	------------------------------------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (simValue,newst)
	  
  rule	let simValue = Values.RECORD([Values.STRING("Simulation Failed.")],["resultFile"])
	------------------------------------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("simulate"),[Exp.CREF(cr,_),starttime,stoptime,interval],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (simValue,st)

  rule	Static.component_ref_to_path(cr) => path &
	SCode.elaborate(p) => p' &
	Inst.instantiate_class(p',path) => (dae as DAE.DAE(dael),env) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(path,dael,env)) => ic' &
	DAE.dump_str (dae) => str 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("instantiateModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.STRING(str),Interactive.SYMBOLTABLE(p,sp,ic',iv,cf))


  rule	Util.list_map(vars,Exp.print_exp_str) => vars' &
	System.pwd() => pwd &
	System.path_delimiter => pd & 
	Util.string_append_list([pwd,pd,filename]) => filename' &
	System.read_ptolemyplot_dataset(filename',vars',size) => value
	------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,vars),Exp.ICONST(size)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (value,st)

  rule	Print.print_buf "#Error reading simulation result. Check that filename and variablenames are correct.\n" 
	------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readSimulationResult"),[Exp.SCONST(filename),Exp.ARRAY(_,_,vars),Exp.ICONST(size)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => fail

  rule	Util.list_map(vars,Exp.print_exp_str) => vars' &
	Util.list_union_elt("time",vars') => vars'' &
	ceval(env,Exp.CREF(Exp.CREF_IDENT("currentSimulationResult",[]),Exp.OTHER),true,SOME(st),NONE) 
	  => (Values.RECORD([Values.STRING(filename)],_),_) &
	System.read_ptolemyplot_dataset(filename,vars'',0) => value &
	System.pwd() => pwd &
    System.read_env("MOSHHOME") => moshhome &
    System.path_delimiter => pd &
    Util.string_append_list([moshhome,pd,"..",pd,"modeq",pd,"scripts",pd,"doPlot"]) => plotCmd &
	Util.string_append_list([pwd,pd,"tmpPlot.plt"]) => tmpPlotFile &
	Values.write_ptolemyplot_dataset(tmpPlotFile,value,vars'',"Plot by OpenModelica") 
	  => res &
	Util.string_append_list([plotCmd, " \"", tmpPlotFile,"\""]) => call &			   
	System.system_call(call) => _
	------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("plot"),[Exp.ARRAY(_,_,vars)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),st)

  rule	System.time => t1 &
	ceval(env,exp,true,SOME(st),NONE) => (value,SOME(st')) &   
	System.time => t2 &
	real_sub(t2,t1) => time 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("timing"),[exp],_,_),st) => (Values.REAL(time),st')

  rule	System.set_c_compiler(str)
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompiler"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	System.set_c_flags(str)
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setCompilerFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	string_append("+d=",str) => str' &
	RTOpts.args [str'] => args 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("setDebugFlags"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),st)

  rule	System.cd(str) => res &
	int_eq (res,0) => true &
	System.pwd => str' 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	System.pwd() => str'
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("cd"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	System.system_call(str) => res 
	-------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("system"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.INTEGER(res),st)


  rule	System.read_file(str) => str'
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("readFile"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str'),st)

  rule	Print.get_error_string() => str &
	Print.clear_error_buf()
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("getErrorString"),[],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.STRING(str),st)

  rule	System.read_file(str) => scriptstr &
	Parser.parsestringexp(scriptstr) => (istmts,msg) &
	msg = "Ok" &
	Interactive.evaluate(istmts,st,true) => (res,newst) &
	Util.string_append_list([res,"\ntrue"]) => res'
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.STRING(res'),newst)

axiom	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("runScript"),[Exp.SCONST(str)],_,_),st) 
	  => (Values.BOOL(false),st)


  rule	SCode.elaborate(p) => p' &
	Static.component_ref_to_path(cr) => path &
	ModUtil.path_string2 (path,"_") => pathstr &
 (*	Inst.instantiate_implicit(p') => d & *)
	Lookup.lookup_class(env, path, false) => (cls, env') &
	Inst.implicit_function_instantiation(env', Types.NOMOD,
					     Prefix.NOPRE, [], cls, [], false)
	  => (env'',d) &

	ModUtil.string_prefix_params DAE.DAE(d) => d' &
	Print.clear_buf &
	Codegen.generate_functions(d') &
	string_append(pathstr,".c") => filename &
	Print.print_buf "#include \"modelica.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n" &
	Print.print_buf "\nint main(int argc, char** argv)\n{\n\n  if (argc != 3)\n    {\n      fprintf(stderr,\"# Incorrrect number of arguments\\n\");\n      return 1;\n    }\n" &
	Print.print_buf pathstr &
	Print.print_buf "_read_call_write(argv[1],argv[2]);\n  return 0;\n}\n" &
	Print.write_buf(filename)&
	System.compile_c_file(filename) 
	--------------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("generateCode"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true), st)
	(* add path to symboltable for compiled functions
	 Interactive.SYMBOLTABLE(p,sp,ic,iv,(path,t)::cf),
	 but where to get t? *)

  rule	System.modelicapath => mp &
	Static.component_ref_to_path(cr) => path &
	ClassLoader.load_class(path, mp) => pnew &
	Interactive.update_program(pnew,p) => p' &
	Print.get_string => str &
	let newst = Interactive.SYMBOLTABLE(p', sp, [], iv, cf)
	------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(true),newst)
	
  rule	Static.component_ref_to_path(cr) => path &
	ModUtil.path_string(path) => pathstr &
	Util.string_append_list(["Class ",pathstr," not found in MODELICAPATH.\n"])=> str &
	Print.print_error_buf str
	------------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadModel"),[Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) => (Values.BOOL(false),st)

  rule	Parser.parse(name) => p1 &
	Interactive.update_program(p1,p) => newp
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),Interactive.SYMBOLTABLE(newp,sp,[],iv,cf))

  rule	not Parser.parse(name) => _
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("loadFile"),[Exp.SCONST(name)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	Static.component_ref_to_path(cr) => classpath &
	Interactive.get_pathed_class_in_program(classpath,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str &
	System.write_file(filename,str) 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(filename),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),st)

  rule	Dump.unparse_str(p) => str &
	System.write_file(filename,str) 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveAll"),[Exp.SCONST(filename)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(true),st)

  rule	(*Error writing to file *)
	Static.component_ref_to_path(cr) => classpath &
	Interactive.get_pathed_class_in_program(classpath,p) => class &
	Dump.unparse_str(Absyn.PROGRAM([class],Absyn.TOP)) => str &
	Print.print_error_buf "Error writing to file.\n" 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	(*Error writing to file *)
	Static.component_ref_to_path(cr) => classpath &
	Print.print_error_buf "Error unknown class.\n" 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("saveModel"),[Exp.SCONST(name),Exp.CREF(cr,_)],_,_),st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.BOOL(false),st)

  rule	System.read_env("MOSHHOME") => moshhome &
    System.path_delimiter => pd &
    Util.string_append_list([moshhome,pd,"..",pd,"modeq",pd,"helptext.txt"]) => filename &
	print filename & 
	System.read_file(filename) => str 
	--------------------------
	ceval_interactive_functions (env, Exp.CALL(Absyn.IDENT("help"),[],_,_),
				     st as Interactive.SYMBOLTABLE(p,sp,ic,iv,cf)) 
	  => (Values.STRING(str),st)

  rule	get_builtin_attribute(classname,cref,"unit",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getUnit"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"quantity",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getQuantity"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"displayUnit",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getDisplayUnit"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"min",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMin"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"max",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getMax"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st )
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"start",st) => (v, st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStart"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"fixed",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getFixed"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"nominal",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getNominal"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')

  rule	get_builtin_attribute(classname,cref,"stateSelect",st) => (v,st')
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("getStateSelect"),
						  [Exp.CREF(cref,_),Exp.CREF(classname,_)], _, _),
				    st)
	  => (v, st')


(* FIXME: test code: remove *)
  rule	Exp.exp_contains (exp1, exp2) => res
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("exp_contains"),
						  [exp1, exp2], _, _),
				    st)
	  => (Values.BOOL(res), st)

  rule	Exp.solve (exp1, exp2, exp3) => res1 &
	Exp.print_exp_str res1 => res
	----------------------------------------------
	ceval_interactive_functions(env, Exp.CALL(Absyn.IDENT("solve"),
						  [exp1, exp2, exp3], _, _),
				    st)
	  => (Values.STRING(res), st)
(* /FIXME: test code: remove *)

end


relation get_builtin_attribute: (Exp.ComponentRef, Exp.ComponentRef, string,
				 Interactive.InteractiveSymbolTable) 
	  => (Values.Value, Interactive.InteractiveSymbolTable) =

  rule	(* Check cached instantiated class *)
	Static.component_ref_to_path(classname) => classname' &
	Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	Lookup.lookup_var(env,cref') => (attr,ty,Types.EQBOUND(exp,_)) &
	Exp.print_exp_str exp => str
	--------------------------------
	get_builtin_attribute(classname,cref,"stateSelect",
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str),st)

  rule	Static.component_ref_to_path(classname) => classname' &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	Env.open_scope(env',encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, [], ci_state, 
			   c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	Exp.join_crefs(cref,Exp.CREF_IDENT("stateSelect",[])) => cref' &
	Lookup.lookup_var(env4,cref') => (attr,ty,Types.EQBOUND(exp,_)) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' &
	Exp.print_exp_str exp => str
	--------------------------------
	get_builtin_attribute(classname,cref,"stateSelect",
			      Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (Values.STRING(str), Interactive.SYMBOLTABLE(p,sp,ic',vars,cf))

  rule	Static.component_ref_to_path(classname) => classname' &
	Interactive.get_instantiated_class(ic,classname') => Interactive.INSTCLASS(_,dae,env) &
	Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	Lookup.lookup_var(env,cref') => (attr,ty,Types.VALBOUND(v)) 
	-----------------------------------------------
	get_builtin_attribute(classname,cref,attribute,
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, st)

  rule	Static.component_ref_to_path(classname) => classname' &
	SCode.elaborate(p) => p' &
	Inst.make_env_from_program(p',Absyn.IDENT("")) => env &
	Lookup.lookup_class(env,classname',true)
	  => (c as SCode.CLASS(n, _, encflag, r, _), env') &
	Env.open_scope(env',encflag,SOME(n)) => env3 &
	ClassInf.start(r,n) => ci_state &
	Inst.inst_class_in(env3, Types.NOMOD, Prefix.NOPRE, [], ci_state, 
			   c, false, [], false, false)
	  => (dae1, env4, csets', ci_state', tys) &
	Exp.join_crefs(cref,Exp.CREF_IDENT(attribute,[])) => cref' &
	Lookup.lookup_var(env4,cref') => (attr,ty,Types.VALBOUND(v)) &
	Interactive.add_instantiated_class(ic,Interactive.INSTCLASS(classname',dae1,env4)) => ic' 
	-----------------------------------------------
	get_builtin_attribute(classname,cref,attribute,
			      st as Interactive.SYMBOLTABLE(p,sp,ic,vars,cf)) 
	  => (v, Interactive.SYMBOLTABLE(p,sp,ic',vars,cf)) 
end 

relation ceval_matrixelt:(Env.Env,(Exp.Exp*bool) list list) => Values.Value list =

  rule	ceval_matrixeltrow(env,expl) => v &
	ceval_matrixelt(env,expll) => vl
	---------------------------
	ceval_matrixelt(env,expl::expll) => v::vl
	
  axiom	ceval_matrixelt(_,[]) => []
end

relation ceval_matrixeltrow:(Env.Env, (Exp.Exp*bool) list ) => Values.Value =
	
  rule	ceval (env,e,false,NONE,NONE) => (res,_) &
	ceval_matrixeltrow(env,rest) => Values.ARRAY(resl)
	-------------------
	ceval_matrixeltrow(env, (e,_)::rest) => Values.ARRAY(res::resl)
	
  axiom	 ceval_matrixeltrow(env,[]) => Values.ARRAY([])

end


(* Builtin operators *)

relation ceval_builtin_size : (Env.Env, Exp.Exp, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule	(* Crefs are looked up to find dimensional size*)
	ceval(env,dim,impl,st,NONE) => (Values.INTEGER(dim),st') &
	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.get_dimension_sizes(tp) => sizelst &
	int_sub(dim,1) => dim' &
	list_nth(sizelst,dim') => v
	------------------------------------
	ceval_builtin_size(env,Exp.CREF(cr,tp),dim,impl,st) => (Values.INTEGER(v),st')

  rule	ceval(env,dim,impl,st,NONE) => (Values.INTEGER(dim),st') &
	ceval(env,cref,impl,st,NONE) => (v,st') &
	ceval_builtin_size_2(v,dim) => v2
	------------------------------------
	ceval_builtin_size(env,cref,dim,impl,st) => (v2,st')
end

relation ceval_builtin_size_2 : (Values.Value, int) => (Values.Value) =

  rule	list_length(lst) => dim
	---------------------------------------
	ceval_builtin_size_2(Values.ARRAY(lst), 1) => Values.INTEGER(dim)

  rule	int_sub (ind, 1) => ind' &
	ceval_builtin_size_2 (l, ind') => dim
	--------------------------------------------------
	ceval_builtin_size_2 (Values.ARRAY(l::lst), ind) => dim

  rule	(*Debug.fprint("failtrace","- ceval_builtin_size_2 failed\n")*)
	-------------------------------------
	ceval_builtin_size_2(_,_) => fail
end

(* Start luc_pop *)
(* floor *)
relation ceval_builtin_floor : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule (*print "# floor function not implemented CEVAL yet\n" &*)
    	ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_floor rv => rv' 
    --------------------------------------
    ceval_builtin_floor(env,exp,impl,st) => (Values.REAL(rv'),st)
end

relation ceval_builtin_ceil : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule  (**print "# ceil function not implemented CEVAL yet\n" &*)
   	    ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        real_int rv' => ri &
        int_real ri => rvt &
        real_eq(rvt,rv) => true 
        --------------------------------------
        ceval_builtin_ceil(env,exp,impl,st) => (Values.REAL(rv'),st)

  rule (**print "# ceil function not implemented CEVAL yet\n" &**)
   	    ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_floor rv => rv' &
        (**print "# ceil function not implemented CEVAL yet\n" &**)
        (** this should be like this but real_add(rv',1.0) does not work!
	     **real_add(rv', 1.0) => rv''
         **)
        real_int rv' => ri &
        int_add(ri,1) => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_ceil(env,exp,impl,st) => (Values.REAL(rv''),st)
end

relation ceval_builtin_sqrt : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_lt (rv,0.0) => true &
        Print.print_buf "# sqrt - the input is negative\n" 
    --------------------------------------
    ceval_builtin_sqrt(env,exp,impl,st) => fail
 
  rule (** print "# sqrt function not implemented CEVAL yet\n" &**)
        ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_sqrt rv => rv' 
    --------------------------------------
    ceval_builtin_sqrt(env,exp,impl,st) => (Values.REAL(rv'),st)
 
end

relation ceval_builtin_div : (Env.Env, Exp.Exp,Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule  ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rv' &
        real_int rv' => ri &
        int_real ri => rv''
        --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => (Values.REAL(rv''),st)
        
  rule  ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => (Values.REAL(rv''),st)
        
  rule  ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	    real_div(rv1,rv2) => rv' &
        real_int rv' => ri' &
        int_real ri' => rv''
        --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => (Values.REAL(rv''),st)
        
  rule  ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
	    int_div(ri1,ri2) => ri' 
         --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => (Values.INTEGER(ri'),st)
        
  rule  ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	    Print.print_buf "#Error, division by zero.\n" 
        --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => fail

  rule  ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	    Print.print_buf "#Error, division by zero.\n" 
        --------------------------------------
        ceval_builtin_div(env,exp1,exp2,impl,st) => fail
        
end

relation ceval_builtin_mod : (Env.Env, Exp.Exp,Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule  (*print "# mod real real" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rva &
	    real_floor(rva) => rvb &
	    real_mul(rvb,rv2) => rvc &
	    real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# mod INTEGER REAL" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rva &
	    real_floor(rva) => rvb &
	    real_mul(rvb,rv2) => rvc &
	    real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# mod REAL INTEGER" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	    real_div(rv1,rv2) => rva &
	    real_floor(rva) => rvb &
	    real_mul(rvb,rv2) => rvc &
	    real_sub(rv1,rvc) => rvd 
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# mod INTEGER INTEGER" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	    int_real ri2 => rv2 &
	    real_div(rv1,rv2) => rva &
	    real_floor(rva) => rvb &
	    real_mul(rvb,rv2) => rvc &
	    real_sub(rv1,rvc) => rvd &
	    real_int rvd => ri'
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => (Values.INTEGER(ri'),st)
        
  rule  ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	    Print.print_buf "#Second argument in mod should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => fail

  rule  ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	    Print.print_buf "#Second argument in mod should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_mod(env,exp1,exp2,impl,st) => fail
        
end

relation ceval_builtin_rem : (Env.Env, Exp.Exp,Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule  (*print "# rem real real" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rva &
	    real_mul(rva,rv2) => rvb &
		real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# rem INTEGER REAL" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv1 &
        ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
	    real_div(rv1,rv2) => rva &
	    real_mul(rva,rv2) => rvb &
		real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# rem REAL INTEGER" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.REAL(rv1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri),_) &
        int_real ri => rv2 &
	    real_div(rv1,rv2) => rva &
	    real_mul(rva,rv2) => rvb &
		real_sub(rv1,rvb) => rvd
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => (Values.REAL(rvd),st)
        
  rule  (*print "# rem INTEGER INTEGER" &*)
		ceval (env,exp1,impl,st,NONE) => (Values.INTEGER(ri1),_) &
        ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
        int_real ri1 => rv1 &
	    int_real ri2 => rv2 &
	    real_div(rv1,rv2) => rva &
	    real_mul(rva,rv2) => rvb &
		real_sub(rv1,rvb) => rvd &
		real_int rvd => ri'
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => (Values.INTEGER(ri'),st)
        
  rule  ceval (env,exp2,impl,st,NONE) => (Values.REAL(rv2),_) &
        real_eq(rv2, 0.0) => true &
 	    Print.print_buf "#Second argument in rem should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => fail

  rule  ceval (env,exp2,impl,st,NONE) => (Values.INTEGER(ri2),_) &
        int_eq(ri2, 0) => true &
 	    Print.print_buf "#Second argument in rem should be non-zero.\n" 
        --------------------------------------
        ceval_builtin_rem(env,exp1,exp2,impl,st) => fail
        
end

relation ceval_builtin_integer : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =
	
  rule (** print "# integer function not implemented CEVAL yet\n" &**)
        ceval (env,exp,impl,st,NONE) => (Values.REAL(rv),_) &
        real_int rv => ri 
    --------------------------------------
    ceval_builtin_integer(env,exp,impl,st) => (Values.INTEGER(ri),st)
 
end
(* end luc_pop*)

(* For size(A) *)
relation ceval_builtin_size_matrix : (Env.Env, Exp.Exp, bool, Interactive.InteractiveSymbolTable option) 
	=> (Values.Value, Interactive.InteractiveSymbolTable option) =

  rule	Lookup.lookup_var(env,cr) => (attr, tp, bind) &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,Exp.CREF(cr,tp),impl,st) 
	  => (v,st)

  rule	ceval(env,exp,impl,st,NONE) => (v,st') &
	Types.type_of_value(v) => tp &
	Types.get_dimension_sizes(tp) => sizelst &
	Values.intlist_to_value(sizelst) => v
	-------------------------------------
	ceval_builtin_size_matrix(env,exp,impl,st) 
	  => (v,st)

end

(** relation: ceval_relation
 **
 ** Performs the relation check and gives a boolean result.
 **)

relation ceval_relation : (Values.Value, Exp.Operator, Values.Value)
 	  => Values.Value =

  rule	ceval_relation (v2, Exp.LESS(t), v1) => v
	-----------------------------------------
	ceval_relation (v1, Exp.GREATER(t), v2) => v

	(**  Integers *)

  rule	int_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.LESS(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.EQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

  rule	int_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.INTEGER(i1),
			Exp.NEQUAL(Exp.INT),
			Values.INTEGER(i2)) => Values.BOOL(b)

	(**  Reals *)

  rule	real_lt (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.LESS(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_eq (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.EQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	real_ne (i1,i2) => b
	-------------------
	ceval_relation (Values.REAL(i1),
			Exp.NEQUAL(Exp.REAL),
			Values.REAL(i2)) => Values.BOOL(b)

  rule	Print.print_buf "- ceval_relation failed\n"
	---------------------------------
	ceval_relation (_,_,_) => fail

end

(** relation: ceval_range
 **
 ** This relation evaluates a range expression.  It only handles integers.
 **)

relation ceval_range : (int, int, int) => Values.Value list =

  rule	int_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	------------------
	ceval_range(start,_,stop) => [Values.INTEGER(start)]

  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	int_gt(j,k) => b1 &
	int_gt(d,0) => b2 &
	bool_and(b1,b2) => c1 &
	int_lt(j,k) => b3 &
	int_lt(d,0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range(j,d,k) => []

rule	ceval_range2(start,step,stop) => res
	-----------------------------------
	ceval_range (start, step, stop) => res

end

relation ceval_range2: (int,int,int) => Values.Value list =

  rule	int_gt(start,stop) => true
	--------------------------
	ceval_range2 (start,_,stop) => []	

  rule	int_gt(start,stop) => false & (* redundant *)
	int_add (start, step) => next &
	ceval_range2 (next, step, stop) => l
	-----------------------------------
	ceval_range2 (start, step, stop) => Values.INTEGER(start)::l
end
	


(** relation: ceval_range_real
 **
 ** This relation evaluates a range expression.  It only handles reals
 **)

relation ceval_range_real : (real, real, real) => Values.Value list =

  rule	real_eq(start,stop) => true (* e.g. 1:1 => {1} *)
	------------------
	ceval_range_real(start,_,stop) => [Values.REAL(start)]

  rule	(*if d > 0 and j>k or if d < 0 and j<k *)
	real_gt(j,k) => b1 &
	real_gt(d,0.0) => b2 &
	bool_and(b1,b2) => c1 &
	real_lt(j,k) => b3 &
	real_lt(d,0.0) => b4 &
	bool_and(b3,b4) => c2 &
	bool_or(c1,c1) => true
	-----------------------------
	ceval_range_real(j,d,k) => []

rule	ceval_range_real2(j,d,k)=> res
	-----------------------------------
	ceval_range_real (j,d,k) => res
end

relation ceval_range_real2 : (real, real, real) => Values.Value list =

  rule	real_gt(start,stop) => true
	--------------------------
	ceval_range_real2 (start,_,stop) => []

  rule	real_gt(start,stop) => false & (* redundant *)
	real_add (start, step) => next &
	ceval_range_real2 (next, step, stop) => l 	
	-----------------------------------
	ceval_range_real2 (start, step, stop) => Values.REAL(start)::l
end

(** relation: ceval_list
 **
 ** This relation does a constant evaluation on a number of expressions.
 **)

relation ceval_list : (Env.Env, Exp.Exp list, bool, Interactive.InteractiveSymbolTable option) 
	    => Values.Value list =
	  
  rule	ceval (env, exp,impl,st,NONE) => (v,_)
	----------------------------
	ceval_list (env, [exp],impl,st) => [v]

  rule	ceval (env,exp,impl,st,NONE) => (v,_) &
	ceval_list (env, exps,impl,st) => vs
	------------------------------
	ceval_list (env, exp::exps,impl,st) => v::vs

end
		      
(**)

relation ceval_cref : (Env.Env, Exp.ComponentRef) => Values.Value =

(* Uncomment this when struct params work *)
(*  rule	(* Parameters should not be evaluated. Exception: structural parameters *)
 Lookup.lookup_var (env, c) => (Types.ATTR(_,_,SCode.PARAM,_),_,binding) 
 -------------------------------------
 ceval_cref (env,c) => fail *)

  rule	Lookup.lookup_var (env, c) => (_,_,binding) &
	ceval_cref_binding (env,c,binding) => v
	-------------------------------------
	ceval_cref (env,c) => v

	(* default *)

  rule	print "# No constant binding for " &
	Exp.print_component_ref_str c => str & print str &  print "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

  rule	Print.print_buf "# No constant binding for " &
	Exp.print_component_ref c & Print.print_buf "\n"
	-------------------------------------
	ceval_cref (_,c) => fail

end

relation ceval_cref_binding : (Env.Env, Exp.ComponentRef,Types.Binding) => Values.Value =

  rule  Lookup.lookup_var(env,Exp.CREF_IDENT(id,[])) => (_, tp, _) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval_subscript_value(env,subsc,v, sizelst) => res
	-----------------------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.VALBOUND(v))
	  => res

  rule	Print.print_buf "- ceval_cref_binding failed (UNBOUND)\n"
	-------------------------------------
	ceval_cref_binding (env,_,Types.UNBOUND) => fail
	

  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	rfn = "array" &
	Print.print_buf "#-- ceval_cref_binding Array evaluation\n"
	---------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,true))
	  => fail

  rule	let Exp.REDUCTION(Absyn.IDENT(rfn),elexp,iter,iterexp) = exp &
	not rfn = "array" &
	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[])) => (_, tp, _) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,false,NONE,NONE) => (v,_) &
	ceval_subscript_value (env,subsc,v,sizelst) => res
	---------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,true))
	  => res

  rule	Lookup.lookup_var(env,Exp.CREF_IDENT(id,[])) => (_, tp, _) &
	Types.get_dimension_sizes(tp) => sizelst &
	ceval (env,exp,false,NONE,NONE) => (v,_) &
	ceval_subscript_value(env,subsc,v,sizelst) => res
	------------------------
	ceval_cref_binding (env,Exp.CREF_IDENT(id,subsc),Types.EQBOUND(exp,true)) 
	  => res

  rule	Print.print_buf "- ceval_cref__binding failed (nonconstant EQBOUND(" &
	Exp.print_exp exp & Print.print_buf ")\n"
	--------------------------------
	ceval_cref_binding (env,_,Types.EQBOUND(exp,false)) => fail
	
end

relation ceval_subscript_value: (Env.Env,Exp.Subscript list ,Values.Value, int list) 
	  => Values.Value =

  rule	ceval(env,exp,false,NONE,SOME(dim)) => (Values.INTEGER(n),_) &
	int_sub(n,1) => n' &
	list_nth(lst,n') => subval &
	ceval_subscript_value(env,subs,subval,dims) => res
	---------------------------------------------
	ceval_subscript_value(env,Exp.INDEX(exp)::subs,Values.ARRAY(lst), dim::dims) 
	  => res
	  
  axiom	ceval_subscript_value(env,[],v,_) => v
			      
end

(** relation: ceval_subscripts
 **
 ** This relation relates a list of subscripts to their canonical
 ** forms, which is when all expressions are evaluated to constant
 ** values.
 **)

relation ceval_subscripts : (Env.Env, Exp.Subscript list, int list)
	  => Exp.Subscript list =

  axiom	ceval_subscripts (_,[],_) => []

  rule	ceval_subscript (env,sub,dim) => sub' &
	ceval_subscripts (env,subs,dims) => subs'
	------------------------------------
	ceval_subscripts (env,sub::subs,dim::dims) => (sub'::subs')

end

(** relation: ceval_subscript
 **
 ** This relation relates a subscript to its canonical forms, which is
 ** when all expressions are evaluated to constant values.
 **)

relation ceval_subscript : (Env.Env, Exp.Subscript, int) => Exp.Subscript =

  axiom	ceval_subscript (env, Exp.WHOLEDIM,_) => Exp.WHOLEDIM

  rule 
    ceval (env, e1,false,NONE,SOME(dim)) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.INDEX(e1),dim) => Exp.INDEX(e1')
	
  rule	ceval (env, e1, false,NONE,SOME(dim)) => (v1,_) &
	Static.value_exp v1 => e1'
	-----------------------------------------
	ceval_subscript (env, Exp.SLICE(e1),dim) => Exp.SLICE(e1')
	
end
