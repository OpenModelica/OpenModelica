(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:        values.rml
 ** module:      Values
 ** description: Evaluated expression values
 **
 ** RCS: $Id$
 ** 
 ** The module `Values' contains data structures for representing
 ** constant Modelica values.  These include integer, real, string and
 ** boolean values, and also arrays of any dimensionality and type.
 ** Multidimensional arrays are represented as arrays of arrays.
 **
 ** The code is excluded from the report, since they convey no
 ** semantic information.
 **)

module Values :
with "exp.rml"
with "absyn.rml"
  datatype Value = INTEGER of int
		 | REAL of real
		 | STRING of string
		 | BOOL of bool
		 | ENUM of string
		 | ARRAY of Value list
		 | TUPLE of Value list 
		 | RECORD of Value list * Exp.Ident list
		 | CODE of Absyn.Code
		(* A record consist of value * Ident pairs *)

  relation val_string : Value => string
  relation print_val : Value => ()
  relation add_elementwise_arrayelt: (Value list, Value list) => Value list
  relation sub_elementwise_arrayelt: (Value list, Value list) => Value list
  relation sum_arrayelt: (Value list) => Value	  
  relation mult_scalar_arrayelt: (Value, Value list) => Value list
  relation mult_scalar_product: (Value list, Value list) => Value
  relation mult_matrix: (Value list,Value list) => Value list
  relation is_array :Value => bool
  relation write_to_file_as_args: (Value list,string) => ()
  relation type_convert: (Exp.Type, Exp.Type,Value list) => Value list
  relation unparse_values: (Value list) => string
end


relation type_convert: (Exp.Type, Exp.Type, Value list) => Value list =
  axiom type_convert(_,_,[]) => []

  rule	type_convert(from,to,vrest) => vallst &
	int_real (i) => rval
	------------------------------------
	type_convert(from as Exp.INT, to as Exp.REAL, INTEGER(i)::vrest) 
	  =>  REAL(rval)::vallst

  rule	type_convert(from,to,vrest) => vallst &
	real_int (r) => ival
	------------------------------------
	type_convert(from as Exp.REAL, to as Exp.INT, REAL(r)::vrest) 
	  =>  INTEGER(ival)::vallst

  rule	type_convert(from,to,vals) => vallst &
        type_convert(from,to,vrest) => vallst2 
	------------------------------------
	type_convert(from, to, ARRAY(vals)::vrest) 
	  =>  ARRAY(vallst)::vallst2
end

relation is_array: Value => bool = 
  axiom	is_array(INTEGER(_)) => false
  axiom	is_array(REAL(_)) => false
  axiom	is_array(STRING(_)) => false
  axiom	is_array(BOOL(_)) => false
  axiom is_array(TUPLE(_)) => false
  axiom	is_array(ARRAY(_)) => true	
end

relation unparse_values: (Value list) => string =

  rule	unparse_description([v]) => s1 &
	unparse_value_numbers([v]) => s2 &
	unparse_values(vallst) => s3 &	
	string_append(s1,s2) => s4 &
	string_append(s4,"\n") => s5 &
	string_append(s5,s3) => str
	-----------------------------
	unparse_values(v::vallst) => str

  axiom	unparse_values([]) => ""
end

relation unparse_value_numbers: (Value list) => string =
	
  rule	unparse_value_numbers(lst) => s1 &
	unparse_value_numbers(xs) => s2 &
	string_append(s1,s2) => res 
	---------------------------
	unparse_value_numbers (ARRAY(lst)::xs)=> res
	
  rule	unparse_value_numbers(xs) => s1 &
	int_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(INTEGER(i)::xs) => res

  rule	unparse_value_numbers(xs) => s1 &
	real_string(i) => istr &
	string_append(istr," ") => s2 &
	string_append(s2,s1) => res
	---------------------------
	unparse_value_numbers(REAL(i)::xs) => res

	axiom unparse_value_numbers([]) => ""
end

relation unparse_description:(Value list) => string =

  rule	unparse_description(xs) => s1 &
	string_append("# i!\n",s1) => str 
	--------------------------------
	unparse_description(INTEGER(_)::xs)=> str

  rule	unparse_description(xs) => s1 &
	string_append("# r!\n",s1) => str
	-------------------------------
	unparse_description(REAL(_)::xs)=> str
	
  rule	unparse_description(xs) => s1 &
	unparse_array_description(vallst) => s2 &
	string_append(s2,s1) => s4 &
	string_append(s4," \n") => str
	-------------------------------
	unparse_description(ARRAY(vallst)::xs)=> str

  axiom unparse_description([]) => ""
end

relation unparse_array_description:(Value list) => string  =

  rule	unparse_prim_type (lst) => pt &
	string_append("# ",pt) => s1 &
	string_append(s1,"[") => s2 &
	unparse_num_dims(lst) => i1 &
	int_string(i1) => s3 &
	string_append(s2,s3) => s4 &
	string_append(s4," ") => s5 &
	unparse_dim_sizes(lst) => s6 &
	string_append(s5,s6) => str
	------------------
	unparse_array_description(lst) => str
end

relation unparse_prim_type: (Value list) => string =

  rule	unparse_prim_type(elts) => res
	------------------------------
	unparse_prim_type(ARRAY(elts)::_) => res
  axiom	unparse_prim_type(INTEGER(_)::_) => "i"
  axiom	unparse_prim_type(REAL(_)::_) => "r"
  axiom	unparse_prim_type(STRING(_)::_) => "s"
  axiom	unparse_prim_type(BOOL(_)::_) => "b"
  axiom	unparse_prim_type(_) => "error"
end

relation unparse_num_dims: (Value list) => int =
	
  rule	unparse_num_dims(vals) => i1 &
	int_add(i1,1) => res
	--------------------
	unparse_num_dims(ARRAY(vals)::_) => res

  axiom	unparse_num_dims(_) => 1
end

relation unparse_dim_sizes: (Value list) => string =

  rule	list_length(lst) => i1 &
	int_string(i1) => s1 &
	string_append(s1, " ") => s2 &
	unparse_dim_sizes(vals) => s3 &
	string_append(s2,s3) => res
	-------------------
	unparse_dim_sizes (lst as (ARRAY(vals)::_)) => res

  rule	list_length(lst) => len &
	int_string(len) => res 
	----------------------
	unparse_dim_sizes(lst) => res
end


relation write_to_file_as_args: (Value list,string) => () =
	
  rule	unparse_values(vallst) => str &
	System.write_file(filename,str) 
	-------------------------------
	write_to_file_as_args(vallst,filename)
end

relation add_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	add_elementwise_arrayelt(v1lst,v2lst) => reslst &
	add_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	add_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_add(v1,v2) => res &
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	add_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  rule	string_append(v1,v2) => res & (* Addition of strings is string concatenation *)
	add_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
 	add_elementwise_arrayelt(STRING(v1)::rest1,STRING(v2)::rest2) 
	    => STRING(res)::res2

  axiom	add_elementwise_arrayelt([],[]) => []

end

relation sub_elementwise_arrayelt: (Value list, Value list) => Value list =
	
  rule	sub_elementwise_arrayelt(v1lst,v2lst) => reslst &
	sub_elementwise_arrayelt(rest1,rest2) => res2 
	----------------------------------------------
	sub_elementwise_arrayelt(ARRAY(v1lst)::rest1, ARRAY(v2lst)::rest2) 
	    => ARRAY(reslst)::res2
	    
  rule	int_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(INTEGER(v1)::rest1,INTEGER(v2)::rest2) 
	    => INTEGER(res)::res2

  rule	real_sub(v1,v2) => res &
	sub_elementwise_arrayelt(rest1,rest2) => res2
	---------------------
	sub_elementwise_arrayelt(REAL(v1)::rest1,REAL(v2)::rest2) 
	    => REAL(res)::res2

  axiom	sub_elementwise_arrayelt([],[]) => []
end

relation sum_arrayelt: (Value list) => Value =

  axiom	sum_arrayelt([INTEGER(v1)]) => INTEGER(v1)

  axiom	sum_arrayelt([REAL(v1)]) => REAL(v1)

  axiom	sum_arrayelt([ARRAY(v1)]) => ARRAY(v1)

  rule	sum_arrayelt(xs) => INTEGER(v1) &
	int_add(v1,v2) => v3
	--------------------
	sum_arrayelt(INTEGER(v2)::xs) => INTEGER(v3) 
	
  rule	sum_arrayelt(xs) => REAL(v1) &
	real_add(v1,v2) => v3
	--------------------
	sum_arrayelt(REAL(v2)::xs) => REAL(v3) 
	
  rule	sum_arrayelt(arr) => ARRAY(v1) &
	add_elementwise_arrayelt(v1,v2) => v3
	------------------------------------
	sum_arrayelt(arr as ARRAY(v2)::_) => ARRAY(v3)

end


relation mult_scalar_arrayelt: (Value, Value list) => Value list =

  rule	mult_scalar_arrayelt(sval,vals) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval,ARRAY(vals)::rest) => ARRAY(r1)::r2
 
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),INTEGER(v2)::rest) => INTEGER(r1)::r2

  rule	int_real(v2) => v2' &
	real_mul(v1,v2') => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),INTEGER(v2)::rest) => REAL(r1)::r2

  rule	int_real(v1) => v1' &
	real_mul(v1',v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as INTEGER(v1),REAL(v2)::rest) => REAL(r1)::r2

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_arrayelt(sval,rest) => r2
	------------------------------------
	mult_scalar_arrayelt (sval as REAL(v1),REAL(v2)::rest) => REAL(r1)::r2

	axiom mult_scalar_arrayelt(_,[]) => []
end

relation mult_scalar_product: (Value list, Value list) => Value =
	
  rule	int_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => INTEGER(r2) & 
	int_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (INTEGER(v1)::(v1lst as (_::_)),INTEGER(v2)::(v2lst as (_::_)))
	    => INTEGER(res)

  rule	int_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([INTEGER(v1)],[INTEGER(v2)]) 
	    => INTEGER(res)

  rule	real_mul(v1,v2) => r1 &
	mult_scalar_product(v1lst,v2lst) => REAL(r2) &
	real_add(r1,r2) => res	
	------------------------------------
	mult_scalar_product (REAL(v1)::(v1lst as (_::_)),REAL(v2)::(v2lst as (_::_)))
	    => REAL(res)

  rule	real_mul(v1,v2) => res 
	------------------------------------
	mult_scalar_product ([REAL(v1)],[REAL(v2)]) 
	    => REAL(res)

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (INTEGER(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],INTEGER(_)::_) => ARRAY([])

  rule	mult_scalar_product (v2lst,vlst) => sres &
	mult_scalar_product (rest,vlst) => ARRAY(vres) 
	---------------------------------------------
	mult_scalar_product (ARRAY(v2lst)::rest, vlst as (REAL(_)::_)) 
	    => ARRAY(sres::vres)

  axiom	mult_scalar_product([],REAL(_)::_) => ARRAY([])


  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => INTEGER(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (INTEGER(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([INTEGER(v)])

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => v &
	mult_scalar_product(vlst,mat') => ARRAY(vals)
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY(_::_::_)::_)) 
	    => ARRAY(v::vals)

  rule	matrix_strip_first_column (mat) => (ARRAY(col),mat') &
	mult_scalar_product(vlst,col) => REAL(v) 
	---------------------------------------------
	mult_scalar_product(vlst  as (REAL(_)::_), mat as (ARRAY([_])::_)) 
	    => ARRAY([REAL(v)])

  rule	Print.print_buf "mult_scalar_product failed\n lst1 len:" &
	list_length(lst1) => len &
	int_string(len) => lenstr &
	Print.print_buf lenstr & Print.print_buf "lst2 len:" &
	list_length(lst2) => len2 &
	int_string(len2) => len2str & 
	Print.print_buf len2str & Print.print_buf "\n" 
	--------------------------
	mult_scalar_product(lst1,lst2) => fail
end

relation mult_matrix: (Value list,Value list) => Value list =
	
  rule	mult_scalar_product(v1lst,m2) => res1 &
	mult_matrix(rest1,m2) => res2
	-----------------------------
	mult_matrix(m1 as (ARRAY(v1lst)::rest1),m2 as (ARRAY(_)::_)) => res1::res2
	
  axiom	 mult_matrix([],_) => []
	
	
end

(** This relation takes a Value list representing a matrix and strips the first column of the matrix, i.e. for each sub list it removes the first element. Returning both the stripped column and the resulting matrix.**)
relation matrix_strip_first_column: Value list => (Value,Value list) =

  rule	matrix_strip_first_column(rest) => (ARRAY(resl),resl2)
	---------------------------------------------------
	matrix_strip_first_column (ARRAY(v1::vrest)::rest) 
	    => (ARRAY(v1::resl),ARRAY(vrest)::resl2)

  axiom	matrix_strip_first_column( []) => (ARRAY([]),[])
end
with "print.rml"
with "system.rml"
with "util.rml"
with "dump.rml"

(*!ignorecode*) 

(** relation: val_string
 **
 ** This relation returns a textual representation of a value.
 **)

relation val_string : Value => string =

  rule	int_string n => s
	-----------------
	val_string INTEGER(n) => s

  rule	real_string x => s
	------------------
	val_string REAL(x) => s

  rule	Util.string_append_list(["\"",s,"\""]) => s'
	--------------------------
	val_string STRING(s) => s'

  axiom	val_string BOOL(false) => "false"
  axiom	val_string BOOL(true) => "true"

  rule	val_list_string vs => s &
	string_append("{",s) => s' &
	string_append(s',"}") => s''
	----------------------------
	val_string ARRAY(vs) => s''

  rule	val_list_string vs => s &
	string_append("(",s) => s' &
	string_append(s',")") => s''
	----------------------------
	val_string TUPLE(vs) => s''

  rule	val_record_string(r) => s &
	Util.string_append_list(["record\n",s,"\n end record"]) => res
	---------------------------
	val_string (r as RECORD(_,_)) => res

  rule	Dump.print_code_str(c) => res &
	Util.string_append_list(["Code(",res,")"]) => res'
	-----------------------
	val_string (CODE(c)) => res'

  rule	Print.print_buf "- val_string failed\n"
	-----------------------------
	val_string _ => fail

end

(** relation: val_record_string
 **
 ** This relation returns a textual representation of a record,
 separating each value with a comma.
 **)
relation val_record_string: Value => string =
  axiom	val_record_string(RECORD([],[])) => ""

  rule	val_string(x) => s1 &
	val_record_string(RECORD(xs,ids))=> s2 &
	Util.string_append_list([id, " = ",s1,",\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(x::(xs as _::_),id::(ids as _::_))) => res

  rule	val_string(x) => s1 &
	val_record_string(RECORD(xs,ids))=> s2 &
	Util.string_append_list(["    ", id, " = ",s1,"\n",s2]) => res
	------------------------------------
	val_record_string(RECORD(x::xs,id::ids)) => res
end

(** relation: val_list_string
 **
 ** This relation returns a textual representation of a list of
 ** values, separating each value with a comman.
 **)

relation val_list_string : Value list => string =

  axiom	val_list_string [] => ""

  rule	val_string v => s
	-----------------
	val_list_string [v] => s

  rule	val_string v => s &
	val_list_string vs => s' &
	string_append (s,",") => s'' &
	string_append (s'',s') =>s'''
	------------------------------
	val_list_string v::vs => s'''

  rule	Print.print_buf "- val_list_string failed\n"
	----------------------------------
	val_list_string _ => fail

end

(** relation: print_val
 **
 ** This relation prints a value.
 **)

relation print_val : Value => () =

  rule	val_string v => s &
	Print.print_buf s
	-------
	print_val v

end

(*!includecode*)
