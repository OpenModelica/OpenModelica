
(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenModelica; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

(**
 ** file:	 algorithm.rml
 ** module:      Algorithm
 ** description: Algorithm datatypes
 **
 ** RCS: $Id$
 **
 ** This file contains data types and relations for managing
 ** algorithm sections. The algorithms in the AST are analyzed by the `Inst'
 ** module (inst.rml) which uses this module to represent the algorithms. No
 ** processing of any kind, except for building the datastructure is 
 ** done in this module.
 ** 
 ** It is used primarily by inst.rml which both provides its input data
 ** and uses its "output" data.
 ** 
 **)

module Algorithm:

  with "exp.rml"
  with "types.rml"
  with "explode.rml"

  type Ident = string

  (** The `Algorithm' type corresponds to a whole algorithm secion. *)
  (** It is simple a list of algorithm statements. *)
  datatype Algorithm = ALGORITHM of Statement list


  (** There are four kinds of statements.  Assignments (`a := b;'),
   ** if statements (`if A then B; elseif C; else D;'), for loops
   ** (`for i in 1:10 loop ...; end for;') and when statements
   ** (`when E do S; end when;'). *)
  datatype Statement = ASSIGN of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | TUPLE_ASSIGN of Exp.Type * Exp.Exp list * Exp.Exp
		     | ASSIGN_ARR of Exp.Type * Exp.ComponentRef * Exp.Exp
		     | IF of Exp.Exp * Statement list * Else
		     | FOR of Exp.Type * bool * Ident * Exp.Exp * Statement list
		     | WHILE of Exp.Exp * Statement list
		     | WHEN of Exp.Exp * Statement list
		     | ASSERT of Exp.Exp * Exp.Exp

  (** An if statements can one or more `elseif' branches and an
   ** optional `else' branch. *)
  datatype Else = NOELSE
		| ELSEIF of Exp.Exp * Statement list * Else
		| ELSE of Statement list

  relation make_assignment : (Exp.Exp, Types.Properties,
			      Exp.Exp, Types.Properties,
			      SCode.Accessibility) => Statement

  relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement 

  relation make_if : (Exp.Exp,
		      Types.Properties,
		      Statement list,
		      (Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Statement

  relation make_for : (Ident, Exp.Exp, Types.Properties,
		       Statement list) => Statement

  relation make_while : (Exp.Exp, Types.Properties,
			 Statement list) => Statement
	
  relation make_when_a : (Exp.Exp, Types.Properties,
			Statement list) => Statement

  relation make_assert: (Exp.Exp, Exp.Exp, Types.Properties, Types.Properties) 
	  => Statement

  relation get_all_exps : Algorithm => Exp.Exp list

end

with "util.rml"
with "print.rml"
with "dump.rml"
with "debug.rml"

(** relation: make_assignment
 **
 ** This relation creates an `ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **
 ** LS: Added call to get_prop_type and is_prop_const instead of
 ** having PROP in the rules. Otherwise rules must be repeated because of
 ** combinations with PROP_TUPLE
 **)
relation make_assignment : (Exp.Exp, Types.Properties,
			    Exp.Exp, Types.Properties,
			    SCode.Accessibility) => Statement =

  rule	Types.is_prop_const (lprop) => true &
	Print.print_error_buf "# Trying to assign to constant component\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & Print.print_buf "\n"
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Print.print_error_buf "# Can't assign to (readonly) " & Exp.print_exp e & Print.print_error_buf "\n"
	---------------------------------------------------------
	make_assignment(e,_,_,_, SCode.RO) => fail

	(* LS: Replaced "as Types.PROP(_,false)" from lhprop", by the first predicate *)
  rule	Types.is_prop_const (lhprop) => false &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => false &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN(t,c,rhs')

  rule	Types.is_prop_const (lhprop) => false &
	Types.match_prop(rhs, rhprop, lhprop) => rhs' &
	Types.is_prop_array lhprop => true &
	get_prop_exp_type lhprop => t
	----------------------------------------------
	make_assignment(Exp.CREF(c,crt), lhprop,
			rhs, rhprop, _) => ASSIGN_ARR(t,c,rhs')

  rule	Types.get_prop_type lprop => lt &
	Types.get_prop_type rprop => rt &
	Types.equivtypes (lt,rt) => false &
	Print.print_error_buf "# Type mismatch in assignment\n" &
	Print.print_error_buf "    " & Exp.print_exp lhs &
 	Print.print_error_buf " := " & Exp.print_exp rhs & Print.print_buf "\n" &
	Print.print_error_buf "    " & Types.print_type lt &
 	Print.print_error_buf " := " & Types.print_type rt & Print.print_buf "\n"
	-------------------------------------------
	make_assignment (lhs,lprop,rhs,rprop,_) => fail

  rule	Print.print_buf "- Algorithm.make_assignment failed\n" &
	Print.print_buf "    " & Exp.print_exp lhs &
 	Print.print_buf " := " & Exp.print_exp rhs & Print.print_buf "\n" 
	---------------------------------------------
	make_assignment (lhs, lprop, rhs, rprop, _) => fail

end

(** relation: make_tuple_assignment
 **
 ** This relation creates an `TUPLE_ASSIGN' construct, and checks that the
 ** assignment is semantically valid, which means that the component
 ** being assigned is not constant, and that the types match.
 **)
relation make_tuple_assignment : (Exp.Exp list, Types.Properties list,
			    Exp.Exp, Types.Properties) => Statement =

  rule	Util.list_map(lprop, Types.is_prop_const) => bvals &
	Util.bool_or_list(bvals) => true &
	Print.print_error_buf "# Trying to assign to constant component in tuple assignment\n" &
	Print.print_error_buf "    " & 
	Dump.print_list(lhs, Exp.print_exp, ", ") &
 	Print.print_error_buf " := " & Exp.print_exp rhs &
	Print.print_error_buf "\n"
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

  rule	Util.list_map(lhprops, Types.is_prop_const) => bvals &
	Util.bool_or_list(bvals) => false &
	Util.list_map(lhprops,Types.get_prop_type) => lhrtypes &
	Types.match_type_list(rhs,tpl,lhrtypes) => (rhs',_)
	(* Don't use the new rhs', since type conversions of several output args
	 are not clearly defined. *)
	----------------------------------------------
	make_tuple_assignment(expl, lhprops,
			rhs, Types.PROP_TUPLE((Types.T_TUPLE(tpl),_),Types.TUPLE_CONST(clist))) 
	  => TUPLE_ASSIGN(Exp.OTHER,expl,rhs)

  rule	(*Debug.fprint("failtrace", "- make_tuple_assignment failed\n")*)
	-------------------------------------------
	make_tuple_assignment (lhs,lprop,rhs,rprop) => fail

end


(** relation: get_prop_exp_type
 **
 ** Returns the expression type for a given Properties by calling
 ** get_type_exp_type. Used by make_assignment.
 **)
relation get_prop_exp_type : Types.Properties => Exp.Type =
	
  rule	Types.get_prop_type p => ty &
	get_type_exp_type ty => t
	--------------------------
	get_prop_exp_type p => t

end

(** relation: get_type_exp_type
 **
 ** Returns the expression type for a given Type module type. Used only by
 ** get_prop_exp_type. 
 **)
relation get_type_exp_type : Types.Type => Exp.Type =

  axiom	get_type_exp_type((Types.T_INTEGER(_),_)) => Exp.INT
  axiom	get_type_exp_type((Types.T_REAL(_),_)) => Exp.REAL
  axiom	get_type_exp_type((Types.T_STRING(_),_)) => Exp.STRING
  axiom	get_type_exp_type((Types.T_BOOL(_),_)) => Exp.BOOL

  rule	get_type_exp_type t => t'
	------------------------
	get_type_exp_type((Types.T_ARRAY(_,t),_)) => t'

  axiom	get_type_exp_type( (_,_) ) => Exp.OTHER (*was fail but records must be handled somehow *)

end

(** relation: make_if
 **
 ** This relation creates an `IF' construct, checking that the types
 ** of the parts are correct. Else part is generated using the make_else
 ** relation.
 **)
relation make_if : (Exp.Exp,
		    Types.Properties,
		    Statement list,
		    (Exp.Exp * Types.Properties * Statement list) list,
		    Statement list) => Statement =

  rule	make_else(eib,fb) => else
	-------------------------
	make_if(e,Types.PROP((Types.T_BOOL(_),_),_),tb,eib,fb) => IF(e,tb,else)

  rule	Print.print_error_buf "# Type error in if conditional (" &
	Exp.print_exp e & Print.print_buf ")\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_if(e,Types.PROP(t,_),_,_,_) => fail

end

(** relation: make_else
 **
 ** 
 **)
relation make_else : ((Exp.Exp * Types.Properties * Statement list) list,
		      Statement list) => Else =

	(** This removes empty else branches *)
  axiom	make_else ([],[]) => NOELSE

  axiom	make_else ([],fb) => ELSE(fb)

  rule	make_else (xs,fb) => else
	-------------------------
	make_else ((e,Types.PROP((Types.T_BOOL(_),_),_),b)::xs,fb)
	  => ELSEIF(e,b,else)
	
  rule	Print.print_error_buf "# Type error in elseif conditional (" &
	Exp.print_exp e & Print.print_error_buf ")\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_else((e,Types.PROP(t,_),_)::_,_) => fail

end

(** relation: make_for 
 **)
relation make_for : (Ident, Exp.Exp, Types.Properties,
		     Statement list) => Statement =

  rule	Types.is_array t => array &
	Types.elab_type t => et
	-----------------------
	make_for(i,e,Types.PROP((Types.T_ARRAY(_,t),_),_),stmts) => FOR(et,array,i,e,stmts)

  rule	Print.print_error_buf "# Type error in for conditional.\n" &
	Print.print_error_buf "    Expected array, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_for(_,_,Types.PROP(t,_),_) => fail

end

(** relation: make_while 
 **)
relation make_while : (Exp.Exp, Types.Properties,
		       Statement list) => Statement =

  axiom	make_while(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHILE(e,stmts)

  rule	Print.print_error_buf "# Type error in while conditional.\n" &
	Print.print_error_buf "    Expected Boolean, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_while(_,Types.PROP(t,_),_) => fail

end

(** relation: make_when_a
 **)
relation make_when_a : (Exp.Exp, Types.Properties,
		      Statement list) => Statement =

  axiom	make_when_a(e,Types.PROP((Types.T_BOOL(_),_),_),stmts) => WHEN(e,stmts)

  axiom	make_when_a(e,Types.PROP((Types.T_ARRAY(_,(Types.T_BOOL(_),_)),_),_),stmts) => WHEN(e,stmts)


  rule	Print.print_error_buf "# Type error in when conditional.\n" &
	Print.print_error_buf "    Expected Boolean scalar or vector, got " &
	Types.print_type t & Print.print_error_buf "\n"
	-------------------------------
	make_when_a(_,Types.PROP(t,_),_) => fail
end

(** relation: make_assert
 **)
relation make_assert: (Exp.Exp, Exp.Exp, Types.Properties, Types.Properties) 
	  => Statement =

  axiom	make_assert(cond, msg, Types.PROP((Types.T_BOOL(_),_),_),Types.PROP((Types.T_STRING(_),_),_)) 
	  => ASSERT(cond,msg)

	  (* RML does not handle the pattern below T_BOOL(_), hence we need to
	     implement this differently. *) 
	(*  rule	not let T_BOOL(_) = condt &  
	 Print.print_buf "# Type error in assert condition.\n" &
	 Print.print_buf " Expected Boolean, got " &
	 Types.print_type condt & Print.print_buf "\n"
	 --------------------------------------------
	 make_assert(_,_,Types.PROP(condt,_),_) => fail 
	 *)
end 

(** relation: get_all_exps
 ** 
 ** This relation goes through the Algorithm structure and finds all the
 ** expressions and returns them in a list
 **)
relation get_all_exps : Algorithm => Exp.Exp list =

  rule	get_all_exps_stmts stmts => exps
	-----------------------------------
	get_all_exps ALGORITHM(stmts) => exps

end

relation get_all_exps_stmts : Statement list => Exp.Exp list=

  rule	Util.list_map(stmts, get_all_exps_stmt) => expslist &
	Util.list_flatten(expslist) => exps
	-----------------------------------
	get_all_exps_stmts stmts => exps
end


relation get_all_exps_stmt : Statement => Exp.Exp list =

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN(expty, cr, exp) => [crexp,exp]

  rule	list_append(explist,[exp]) => exps
	---------------------------------
	get_all_exps_stmt TUPLE_ASSIGN(expty, explist, exp) => exps

  rule	cref_to_exp cr => crexp
	-----------------------
	get_all_exps_stmt ASSIGN_ARR(expty, cr, exp) => [crexp,exp]


  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append(exps1, elseexps) => exps
	------------------------------------
	get_all_exps_stmt IF(exp, stmts, else) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt FOR(expty, flag, id, exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHILE(exp, stmts) => exp::exps

  rule	get_all_exps_stmts stmts => exps
	--------------------------------
	get_all_exps_stmt WHEN(exp, stmts) => exp::exps

  axiom	get_all_exps_stmt ASSERT(e1, e2) => [e1,e2]

  rule	Debug.fprintln("failtrace", "-- get_all_exps_stmt failed")
	----------------------------------------------------------
	get_all_exps_stmt _ => fail

end

relation get_all_exps_else : Else => Exp.Exp list =

  axiom	get_all_exps_else NOELSE => []

  rule	get_all_exps_stmts stmts => exps1 &
	get_all_exps_else else => elseexps &
	list_append (exps1,elseexps) => exps
	------------------------------------
	get_all_exps_else ELSEIF(exp,stmts,else) => exp::exps

  rule	get_all_exps_stmts stmts => exps	
	----------------------------------------
	get_all_exps_else ELSE(stmts) => exps

end


relation cref_to_exp : Exp.ComponentRef => Exp.Exp =

  axiom	cref_to_exp cref => Exp.CREF(cref, Exp.OTHER)

end
