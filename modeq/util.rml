(*
    Copyright PELAB, Linkoping University

    This file is part of Open Source Modelica (OSM).

    OSM is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    OSM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*)

module Util :

  
  relation if : (bool,'a,'a) => 'a
	  
  relation list_fill: ('a ,int) => 'a list
  relation list_first: 'a list => 'a
  relation list_rest: 'a list => 'a list
  relation list_flatten : 'a list list => 'a list
  relation list_map_0 : ('a list, 'a => ()) => ()
  relation list_map : ('a list, 'a => 'b) => 'b list
  relation list_map_1: ('a list, ('a, 'b) => 'c, 'b) => 'c list
  relation list_map_2: ('a list, ('a, 'b,'c) => 'd, 'b,'c) => 'd list 
  relation list_map_2_2: ('a list, ('a, 'b,'c) => ('d,'e), 'b,'c) => ('d * 'e) list
  relation list_list_map : ('a list list, 'a => 'b) => 'b list list 
  relation list_list_reverse: ('a list list) => 'a list list
  relation list_thread : ('a list, 'a list) => 'a list
  relation list_thread_map : ('a list, 'b list, ('a,'b) => 'c) => 'c list
  relation list_thread_tuple : ('a list, 'b list) => ('a * 'b) list
  relation list_list_thread_tuple : ('a list list, 'b list list) 
	  => ('a * 'b) list list
  relation list_position: (''a, ''a list)  => int
  relation list_getmember: (''a, ''a list) => ''a
  relation list_deletemember: (''a list,''a) => ''a list
  relation list_getmember_p: (''a, ''a list,(''a,''a) => bool ) => ''a
  relation list_replaceat: (''a, int, ''a list) => ''a list 
  relation list_union_elt: (''a , ''a list) => ''a list
  relation list_union_elt_p: (''a , ''a list , (''a, ''a) => bool) 
	  => ''a list 
  relation list_union:  (''a list, ''a list) => ''a list
  relation list_union_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list
  relation list_list_union:  (''a list list) => ''a list 
  relation list_list_union_p:  (''a list list, (''a,''a) => bool) => ''a list 
	  
  relation list_reduce: ('a list, ('a,'a) => 'a) => 'a
	      
  relation tuple2_1 : ('a * 'b) => 'a
  relation tuple2_2 : ('a * 'b) => 'b

  relation split_tuple2_list : ('a * 'b) list => ('a list, 'b list)
  relation string_append_list : string list => string
  relation string_delimit_list : (string list, string) => string

  relation bool_and_list: bool list => bool
  relation bool_or_list: bool list => bool
  relation bool_string: bool => string 
  relation string_equal: (string,string) => bool
  relation list_matching : ('a list, 'a => ()) => 'a list

  relation apply_option : ('a option,'a => 'b) => 'b option
end


relation list_fill: ('a ,int) => 'a list =

  axiom	list_fill (a,1) => [a]

  rule	int_sub(n,1) => n' &
	list_fill(a,n') => res
	----------------------
	list_fill (a,n) => a::res
end


relation list_first: 'a list => 'a =	

  axiom	list_first(x::_) => x
end	  

relation list_rest: 'a list => 'a list =
	
  axiom	list_rest (_::x) => x
end

relation list_flatten : 'a list list => 'a list =

  axiom	list_flatten [] => []

  rule	list_flatten r => r' &
	list_append(f,r') => l
	-----------------------
	list_flatten f::r => l

end

relation list_map : ('a list, 'a => 'b) => 'b list =
	
  axiom	list_map ([],_) => []

  rule	fn f => f' &
	list_map(r,fn) => r'
	-------------------
	list_map (f::r,fn) => f'::r'

end

(* Same as list map, but for relations taking one extra argument *)
relation list_map_1: ('a list, ('a, 'b) => 'c, 'b) => 'c list =

  axiom	list_map_1 ([],_,_) => []

  rule	fn (f,extraarg) => f' &
	list_map_1(r,fn,extraarg) => r'
	-------------------
	list_map_1(f::r,fn,extraarg) => f'::r'
end

(*.. and for 2 extra arguments *)
relation list_map_2: ('a list, ('a, 'b,'c) => 'd, 'b,'c) => 'd list =

  axiom	list_map_2 ([],_,_,_) => []

  rule	fn (f,extraarg1,extraarg2) => f' &
	list_map_2(r,fn,extraarg1,extraarg2) => r'
	-------------------
	list_map_2(f::r,fn,extraarg1,extraarg2) => f'::r'
end

relation list_map_2_2: ('a list, ('a, 'b,'c) => ('d,'e), 'b,'c) => ('d * 'e) list =

  axiom	list_map_2_2 ([],_,_,_) => []

  rule	fn (f,extraarg1,extraarg2) => (f1,f2) &
	list_map_2_2(r,fn,extraarg1,extraarg2) => r'
	-------------------
	list_map_2_2(f::r,fn,extraarg1,extraarg2) => ((f1,f2)::r')
end

(* For relation that do not return a value, like print and other sideeffect functions *)
relation list_map_0 : ('a list, 'a => ()) => () =

  axiom	list_map_0 ([],_) => ()

  rule	fn (f) => () &
	list_map_0(r,fn) => ()
	-------------------
	list_map_0(f::r,fn) => ()
end

relation list_list_map : ('a list list, 'a => 'b) => 'b list list =
	
  axiom	list_list_map ([],_) => []

  rule	list_map(f,fn) => f' &
	list_list_map(r,fn) => r'
	-------------------
	list_list_map (f::r,fn) => f'::r'

end

relation list_list_reverse: ('a list list) => 'a list list =

  rule	list_map(lsts, list_reverse) => lsts' &
	list_reverse(lsts') => lsts''
	-----------------------
	list_list_reverse(lsts) => lsts''
end

relation list_thread : ('a list, 'a list) => 'a list =

  axiom	list_thread([],[]) => []

  rule	list_thread(ra,rb) => r' &
	let c = fb::r' &
	let d = fa::c
	------------------------
	list_thread(fa::ra,fb::rb) => d

end

relation list_thread_map : ('a list, 'b list, ('a,'b) => 'c) => 'c list =

  axiom	list_thread_map([],[],_) => []

  rule	fn(fa,fb) => fr &
	list_thread_map(ra,rb,fn) => res
	--------------------------------
	list_thread_map(fa::ra,fb::rb,fn) => fr::res
end 

relation list_thread_tuple : ('a list, 'b list) => ('a * 'b) list =

  axiom	list_thread_tuple ([],[]) => []

  rule	list_thread_tuple(ra,rb) => r
	-----------------------------
	list_thread_tuple (fa::ra, fb::rb) => ((fa,fb)::r)

end

relation list_list_thread_tuple : ('a list list, 'b list list) 
	  => ('a * 'b) list list =

  axiom	list_list_thread_tuple ([],[]) => []

  rule	list_thread_tuple(fa,fb) => f &
	list_list_thread_tuple(ra,rb) => r
	-----------------------------
	list_list_thread_tuple (fa::ra, fb::rb) => f::r

end

relation list_position =
  rule	list_pos(x, ys, 0) => n
	-----------------------
	list_position(x, ys) => n
end

relation list_pos =
  rule	x = y
	-----
	list_pos(x, y::ys, i) => i

  rule	not x = y &
	int_add(i, 1) => i' &
	list_pos(x, ys, i') => n
	------------------------
	list_pos(x, y::ys, i) => n
end

relation list_getmember: (''a, ''a list) => ''a =

  axiom list_getmember(_,[]) => fail

  rule  x = y
	-----
	list_getmember(x,y::ys) => y 
	
  rule	not x = y & 
	list_getmember(x,ys) => res 
	----------------------
	list_getmember(x,y::ys) => res
end 

(* Only deletes first occurence of element in list *)
relation list_deletemember: (''a list,''a) => ''a list =

  rule	list_position(elt,lst) => pos &
	list_delete(lst,pos) => lst'
	----------------------------
	list_deletemember(lst,elt) => lst'

  axiom	list_deletemember(lst,_) => lst

end

relation list_getmember_p: (''a, ''a list,(''a,''a) => bool) => ''a =

  axiom list_getmember_p(_,[],p) => fail

  rule  p(x, y) => true
	-----
	list_getmember_p(x,y::ys,p) => y 
	
  rule	p(x, y) => false & 
	list_getmember_p(x,ys,p) => res 
	----------------------
	list_getmember_p(x,y::ys,p) => res
end 

relation list_union_elt: (''a , ''a list) => ''a list =

  rule	list_getmember(x,lst) => _ 
	--------------------------
	list_union_elt(x,lst) => lst

  rule	not list_getmember(x,lst) => _ 
	--------------------------
	list_union_elt(x,lst) => x::lst	
end

relation list_union:  (''a list, ''a list) => ''a list =
	
  axiom	list_union([],res) => res

  rule	list_union_elt(x,lst2) => r1 &
	list_union(xs,r1) => res
	-----------------------
	list_union(x::xs,lst2) => res
end

relation list_list_union:  (''a list list) => ''a list =
  
  axiom	list_list_union([]) => []

  axiom	list_list_union([x]) => x

  rule	list_union(x1,x2) => r1 &
	list_list_union(r1::rest) => res
	-----------------------
	list_list_union(x1::x2::rest) => res
end

relation list_union_elt_p: (''a , ''a list , (''a, ''a) => bool) => ''a list =

  rule	list_getmember_p(x,lst,p) => _ 
	--------------------------
	list_union_elt_p(x,lst,p) => lst

  rule	not list_getmember_p(x,lst,p) => _ 
	--------------------------
	list_union_elt_p(x,lst,p) => x::lst	
end

relation list_union_p:  (''a list, ''a list, (''a,''a) => bool) => ''a list =
	
  axiom	list_union_p([],res,p) => res

  rule	list_union_elt_p(x,lst2,p) => r1 &
	list_union_p(xs,r1,p) => res
	-----------------------
	list_union_p(x::xs,lst2,p) => res
end

relation list_list_union_p:  (''a list list, (''a,''a) => bool) => ''a list =
  
  axiom	list_list_union_p([],p) => []

  axiom	list_list_union_p([x],p) => x

  rule	list_union_p(x1,x2,p) => r1 &
	list_list_union_p(r1::rest,p) => res
	------------------------------------
	list_list_union_p(x1::x2::rest,p) => res
end

relation list_replaceat: (''a, int, ''a list) => ''a list =

  axiom list_replaceat(x,_,[]) => []

  axiom	 list_replaceat (x,0,y::ys) => x::ys

  rule	int_ge(n,1) => true & int_sub(n,1) => nn &
	list_replaceat(x,nn,ys) => res
	-----------------------------
	list_replaceat(x,n,y::ys) => y::res
end
relation list_reduce: ('a list, ('a,'a) => 'a) => 'a =
  axiom	 list_reduce([e],r) => e

  rule	r(a,b) => res
	-------------
	list_reduce([a,b],r) => res

  rule	r(a,b) => res1 &
	list_reduce(xs,r) => res2 &
	r(res1,res2) => res
	-------------------
	list_reduce(a::b::(xs as _::_),r) => res
end


relation tuple2_1 : ('a * 'b) => 'a =
	
  axiom	tuple2_1 ((a,_)) => a

end

relation tuple2_2 : ('a * 'b) => 'b =
	
  axiom	tuple2_2 ((_,b)) => b

end

relation split_tuple2_list : ('a * 'b) list => ('a list, 'b list) =
  axiom	split_tuple2_list([]) => ([],[])

  rule	split_tuple2_list(rest) => (xs,ys)
	---------------------------------
	split_tuple2_list((x,y)::rest) => (x::xs, y::ys)
end

relation if : (bool,'a,'a) => 'a =
	
  axiom	if (true,r,_) => r
  axiom	if (false,_,r) => r

end


relation string_append_list : string list => string =
	
  axiom string_append_list [] => ""

  axiom	string_append_list [f] => f

  rule	string_append_list r => r' &
	string_append(f,r') => str
	---------------------------
	string_append_list f::r => str

end

relation string_delimit_list : (string list, string) => string =
	
  axiom string_delimit_list([],_) => ""

  axiom	string_delimit_list([f],delim) => f

  rule	string_delimit_list(r,delim) => str1 &
	string_append(f,delim) => str2 &
	string_append(str2,str1) => str
	---------------------------
	string_delimit_list(f::r,delim) => str
end


relation bool_or_list: bool list => bool =

  axiom	bool_or_list([b]) => b

  rule	b = true
	---------------------
  	bool_or_list(b::rest) => true

  rule	b = false &
	bool_or_list(rest) => res
	---------------------
  	bool_or_list(b::rest) => res
end

relation bool_and_list: bool list => bool =

  axiom	bool_and_list([b]) => b

  rule	b = false
	---------------------
  	bool_and_list(b::rest) => false

  rule	b = true &
	bool_and_list(rest) => res
	---------------------
  	bool_and_list(b::rest) => res
end



relation bool_string: bool => string =
  axiom	bool_string true => "true"
  axiom	bool_string false => "false"
end

relation string_equal: (string,string) => bool =
  rule	a = b
	-----
	string_equal(a,b) => true

  axiom	string_equal(_,_) => false

end

relation list_matching: ('a list, 'a => () )  => 'a list =

  axiom	list_matching ([],_) => []

  rule	cond(v) &
	list_matching (vl, cond) => vl'
	-------------------
	list_matching (v::vl, cond) => v::vl'

  rule	not cond(v) &
	list_matching (vl, cond) => vl'
	--------------------------
	list_matching (v::vl, cond) => vl'
end	

relation apply_option : ('a option,'a => 'b) => 'b option =

  axiom	apply_option(NONE,_) => NONE 

  rule	rel(a) => b
	-----------
	apply_option( SOME(a),rel) => SOME(b)
end







