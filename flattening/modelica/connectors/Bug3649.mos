// name:     CGraphBug
// keywords: <insert keywords here>
// status:   correct

loadFile("Bug3649.mo"); getErrorString();
instantiateModel(Transformer.SC1); getErrorString();
checkModel(Transformer.SC1); getErrorString();

// Result:
// true
// ""
// "function Complex \"Automatically generated record constructor for Complex\"
//   input Real re;
//   input Real im;
//   output Complex res;
// end Complex;
//
// function Complex.'*'.multiply \"Inline before index reduction\" \"Multiply two complex numbers\"
//   input Complex c1 \"Complex number 1\";
//   input Complex c2 \"Complex number 2\";
//   output Complex c3 \"= c1*c2\";
// algorithm
//   c3 := Complex(c1.re * c2.re - c1.im * c2.im, c1.re * c2.im + c1.im * c2.re);
// end Complex.'*'.multiply;
//
// function Complex.'*'.scalarProduct \"Inline before index reduction\" \"Scalar product c1*c2 of two complex vectors\"
//   input Complex[:] c1 \"Vector of Complex numbers 1\";
//   input Complex[size(c1, 1)] c2 \"Vector of Complex numbers 2\";
//   output Complex c3 \"= c1*c2\";
// algorithm
//   c3 := Complex(0.0, 0.0);
//   for i in 1:size(c1, 1) loop
//     c3 := Complex.'+'(c3, Complex.'*'.multiply(c1[i], c2[i]));
//   end for;
// end Complex.'*'.scalarProduct;
//
// function Complex.'+' \"Inline before index reduction\" \"Add two complex numbers\"
//   input Complex c1 \"Complex number 1\";
//   input Complex c2 \"Complex number 2\";
//   output Complex c3 \"= c1 + c2\";
// algorithm
//   c3 := Complex(c1.re + c2.re, c1.im + c2.im);
// end Complex.'+';
//
// function Complex.'-'.negate \"Inline before index reduction\" \"Unary minus (multiply complex number by -1)\"
//   input Complex c1 \"Complex number\";
//   output Complex c2 \"= -c1\";
// algorithm
//   c2 := Complex(-c1.re, -c1.im);
// end Complex.'-'.negate;
//
// function Complex.'-'.subtract \"Inline before index reduction\" \"Subtract two complex numbers\"
//   input Complex c1 \"Complex number 1\";
//   input Complex c2 \"Complex number 2\";
//   output Complex c3 \"= c1 - c2\";
// algorithm
//   c3 := Complex(c1.re - c2.re, c1.im - c2.im);
// end Complex.'-'.subtract;
//
// function Complex.'constructor'.fromReal \"Inline before index reduction\" \"Construct Complex from Real\"
//   input Real re \"Real part of complex number\";
//   input Real im = 0.0 \"Imaginary part of complex number\";
//   output Complex result = Complex(re, im) \"Complex number\";
// end Complex.'constructor'.fromReal;
//
// function ComplexOutput \"Automatically generated record constructor for ComplexOutput\"
//   input Real re;
//   input Real im;
//   output ComplexOutput res;
// end ComplexOutput;
//
// function Modelica.ComplexMath.'abs' \"Inline before index reduction\" \"Absolute value of complex number\"
//   input Complex c \"Complex number\";
//   output Real result \"= abs(c)\";
// algorithm
//   result := (c.re ^ 2.0 + c.im ^ 2.0) ^ 0.5;
// end Modelica.ComplexMath.'abs';
//
// function Modelica.ComplexMath.arg \"Inline before index reduction\" \"Phase angle of complex number\"
//   input Complex c \"Complex number\";
//   input Real phi0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"Phase angle phi shall be in the range: -pi < phi-phi0 < pi\";
//   output Real phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") \"= phase angle of c\";
// algorithm
//   phi := Modelica.Math.atan3(c.im, c.re, phi0);
// end Modelica.ComplexMath.arg;
//
// function Modelica.ComplexMath.conj \"Inline before index reduction\" \"Conjugate of complex number\"
//   input Complex c1 \"Complex number\";
//   output Complex c2 \"= c1.re - j*c1.im\";
// algorithm
//   c2 := Complex(c1.re, -c1.im);
// end Modelica.ComplexMath.conj;
//
// function Modelica.ComplexMath.imag \"Inline before index reduction\" \"Imaginary part of complex number\"
//   input Complex c \"Complex number\";
//   output Real r \"= c.im\";
// algorithm
//   r := c.im;
// end Modelica.ComplexMath.imag;
//
// function Modelica.ComplexMath.real \"Inline before index reduction\" \"Real part of complex number\"
//   input Complex c \"Complex number\";
//   output Real r \"= c.re\";
// algorithm
//   r := c.re;
// end Modelica.ComplexMath.real;
//
// function Modelica.Electrical.QuasiStationary.Types.Reference \"Automatically generated record constructor for Modelica.Electrical.QuasiStationary.Types.Reference\"
//   input Real gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   output Reference res;
// end Modelica.Electrical.QuasiStationary.Types.Reference;
//
// function Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint \"Equality constraint for reference angle\"
//   input Modelica.Electrical.QuasiStationary.Types.Reference reference1;
//   input Modelica.Electrical.QuasiStationary.Types.Reference reference2;
//   output Real[0] residue;
// algorithm
//   assert(abs(reference1.gamma - reference2.gamma) < 6.283185307179586e-006, \"Reference angles should be equal!\");
// end Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint;
//
// function Modelica.Math.atan3 \"Four quadrant inverse tangent (select solution that is closest to given angle y0)\"
//   input Real u1;
//   input Real u2;
//   input Real y0(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = 0.0 \"y shall be in the range: -pi < y-y0 <= pi\";
//   output Real y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   protected constant Real pi2 = 6.283185307179586;
//   protected Real w;
// algorithm
//   w := atan2(u1, u2);
//   if y0 == 0.0 then
//     y := w;
//   else
//     y := w + 6.283185307179586 * /*Real*/(integer(0.5 + 0.1591549430918954 * (y0 - w)));
//   end if;
// end Modelica.Math.atan3;
//
// function Modelica.SIunits.ComplexCurrent \"Automatically generated record constructor for Modelica.SIunits.ComplexCurrent\"
//   input Real re(quantity = \"ElectricCurrent\", unit = \"A\");
//   input Real im(quantity = \"ElectricCurrent\", unit = \"A\");
//   output ComplexCurrent res;
// end Modelica.SIunits.ComplexCurrent;
//
// function Modelica.SIunits.ComplexVoltage \"Automatically generated record constructor for Modelica.SIunits.ComplexVoltage\"
//   input Real re(quantity = \"ElectricPotential\", unit = \"V\");
//   input Real im(quantity = \"ElectricPotential\", unit = \"V\");
//   output ComplexVoltage res;
// end Modelica.SIunits.ComplexVoltage;
//
// class Transformer.SC1
//   Real powerSensor2.currentP.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.currentP.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.currentP.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.currentP.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.currentP.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor2.currentN.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.currentN.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.currentN.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.currentN.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.currentN.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor2.voltageP.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.voltageP.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.voltageP.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.voltageP.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.voltageP.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor2.voltageN.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.voltageN.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.voltageN.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.voltageN.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.voltageN.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor2.y.re \"Real part of complex number\";
//   Real powerSensor2.y.im \"Imaginary part of complex number\";
//   Real powerSensor2.abs_y(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(/*.Complex*/(powerSensor2.y)) \"Magnitude of complex apparent power\";
//   Real powerSensor2.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(powerSensor2.y), 0.0) \"Argument of complex apparent power\";
//   Real voltageSensor2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor2.v)) \"Magnitude of complex voltage\";
//   Real voltageSensor2.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor2.v), 0.0) \"Argument of complex voltage\";
//   Real voltageSensor2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor2.i)) \"Magnitude of complex current\";
//   Real voltageSensor2.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor2.i), 0.0) \"Argument of complex current\";
//   Real voltageSensor2.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(voltageSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor2.i)))) \"Active power\";
//   Real voltageSensor2.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(voltageSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor2.i)))) \"Reactive power\";
//   Real voltageSensor2.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(voltageSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor2.i)))) \"Magnitude of complex apparent power\";
//   Real voltageSensor2.pf = cos(Modelica.ComplexMath.arg(Complex(voltageSensor2.P, voltageSensor2.Q), 0.0)) \"Power factor\";
//   Real voltageSensor2.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real voltageSensor2.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSensor2.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor2.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor2.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSensor2.y.re \"Real part of complex number\";
//   Real voltageSensor2.y.im \"Imaginary part of complex number\";
//   Real voltageSensor2.abs_y(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor2.y)) \"Magnitude of complex voltage\";
//   Real voltageSensor2.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor2.y), 0.0) \"Argument of complex voltage\";
//   Real currentSensor1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor1.v)) \"Magnitude of complex voltage\";
//   Real currentSensor1.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor1.v), 0.0) \"Argument of complex voltage\";
//   Real currentSensor1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor1.i)) \"Magnitude of complex current\";
//   Real currentSensor1.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor1.i), 0.0) \"Argument of complex current\";
//   Real currentSensor1.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(currentSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor1.i)))) \"Active power\";
//   Real currentSensor1.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(currentSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor1.i)))) \"Reactive power\";
//   Real currentSensor1.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(currentSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor1.i)))) \"Magnitude of complex apparent power\";
//   Real currentSensor1.pf = cos(Modelica.ComplexMath.arg(Complex(currentSensor1.P, currentSensor1.Q), 0.0)) \"Power factor\";
//   Real currentSensor1.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real currentSensor1.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real currentSensor1.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor1.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor1.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real currentSensor1.y.re \"Real part of complex number\";
//   Real currentSensor1.y.im \"Imaginary part of complex number\";
//   Real currentSensor1.abs_y(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor1.y)) \"Magnitude of complex current\";
//   Real currentSensor1.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor1.y), 0.0) \"Argument of complex current\";
//   Real ground2.pin.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real ground2.pin.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real ground2.pin.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real ground2.pin.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real ground2.pin.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSensor1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor1.v)) \"Magnitude of complex voltage\";
//   Real voltageSensor1.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor1.v), 0.0) \"Argument of complex voltage\";
//   Real voltageSensor1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor1.i)) \"Magnitude of complex current\";
//   Real voltageSensor1.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor1.i), 0.0) \"Argument of complex current\";
//   Real voltageSensor1.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(voltageSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor1.i)))) \"Active power\";
//   Real voltageSensor1.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(voltageSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor1.i)))) \"Reactive power\";
//   Real voltageSensor1.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(voltageSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSensor1.i)))) \"Magnitude of complex apparent power\";
//   Real voltageSensor1.pf = cos(Modelica.ComplexMath.arg(Complex(voltageSensor1.P, voltageSensor1.Q), 0.0)) \"Power factor\";
//   Real voltageSensor1.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real voltageSensor1.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSensor1.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSensor1.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSensor1.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSensor1.y.re \"Real part of complex number\";
//   Real voltageSensor1.y.im \"Imaginary part of complex number\";
//   Real voltageSensor1.abs_y(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSensor1.y)) \"Magnitude of complex voltage\";
//   Real voltageSensor1.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSensor1.y), 0.0) \"Argument of complex voltage\";
//   parameter Real singlePhaseTransformerQS1.N1 = 500.0 \"Number of turns of primary winding\";
//   parameter Real singlePhaseTransformerQS1.R1(quantity = \"Resistance\", unit = \"Ohm\") = 2.5 \"Primary resistance per phase at TRef\";
//   parameter Real singlePhaseTransformerQS1.alpha20_1(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.00392 \"Temperature coefficient of primary resistance at 20 degC\";
//   parameter Real singlePhaseTransformerQS1.L1sigma(quantity = \"Inductance\", unit = \"H\") = 0.0636 \"Primary stray inductance per phase\";
//   parameter Real singlePhaseTransformerQS1.N2 = 250.0 \"Number of turns of secondary winding\";
//   parameter Real singlePhaseTransformerQS1.R2(quantity = \"Resistance\", unit = \"Ohm\") = 0.6 \"Secondary resistance per phase at TRef\";
//   parameter Real singlePhaseTransformerQS1.alpha20_2(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.00392 \"Temperature coefficient of secondary resistance at 20 degC\";
//   parameter Real singlePhaseTransformerQS1.L2sigma(quantity = \"Inductance\", unit = \"H\") = 0.0165 \"Secondary stray inductance per phase\";
//   parameter Real singlePhaseTransformerQS1.TRef(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Reference temperature of primary resistance\";
//   parameter Real singlePhaseTransformerQS1.TOperational(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 293.15 \"Operational temperature of primary resistance\";
//   parameter Boolean singlePhaseTransformerQS1.useHeatPort = false \"Enables or disables thermal heat port\";
//   parameter Real singlePhaseTransformerQS1.Gc(quantity = \"Conductance\", unit = \"S\") = 0.0005149330587023687 \"Total eddy current core loss conductance (w.r.t. primary side)\";
//   parameter Real singlePhaseTransformerQS1.Lm(quantity = \"Inductance\", unit = \"H\") = 1.79 \"Magnetizing inductance\";
//   Real singlePhaseTransformerQS1.inductor1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductor1.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.inductor1.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductor1.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.inductor1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductor1.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.inductor1.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductor1.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.inductor1.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor1.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.inductor1.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor1.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.inductor1.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor1.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.inductor1.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.inductor1.P, singlePhaseTransformerQS1.inductor1.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.inductor1.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.inductor1.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.inductor1.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor1.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor1.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Real singlePhaseTransformerQS1.inductor1.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = singlePhaseTransformerQS1.L1sigma \"Inductance\";
//   Real singlePhaseTransformerQS1.inductor2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductor2.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.inductor2.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductor2.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.inductor2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductor2.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.inductor2.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductor2.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.inductor2.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor2.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.inductor2.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor2.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.inductor2.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductor2.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.inductor2.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.inductor2.P, singlePhaseTransformerQS1.inductor2.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.inductor2.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.inductor2.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.inductor2.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductor2.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductor2.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Real singlePhaseTransformerQS1.inductor2.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = singlePhaseTransformerQS1.L2sigma \"Inductance\";
//   Real singlePhaseTransformerQS1.resistor1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.resistor1.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.resistor1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.resistor1.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.resistor1.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.resistor1.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.resistor1.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.resistor1.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.resistor1.P, singlePhaseTransformerQS1.resistor1.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.resistor1.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.resistor1.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.resistor1.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor1.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor1.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Boolean singlePhaseTransformerQS1.resistor1.useHeatPort = singlePhaseTransformerQS1.useHeatPort \"=true, if heatPort is enabled\";
//   parameter Real singlePhaseTransformerQS1.resistor1.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = singlePhaseTransformerQS1.TOperational \"Fixed device temperature if useHeatPort = false\";
//   Real singlePhaseTransformerQS1.resistor1.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via heatPort\";
//   Real singlePhaseTransformerQS1.resistor1.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperature of heatPort\";
//   parameter Real singlePhaseTransformerQS1.resistor1.R_ref(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = singlePhaseTransformerQS1.R1 \"Reference resistance at T_ref\";
//   parameter Real singlePhaseTransformerQS1.resistor1.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = singlePhaseTransformerQS1.TRef \"Reference temperature\";
//   parameter Real singlePhaseTransformerQS1.resistor1.alpha_ref(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = singlePhaseTransformerQS1.alpha20_1 \"Temperature coefficient of resistance (R_actual = R_ref*(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.resistor1.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Resistance = R_ref*(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.resistor2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.resistor2.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.resistor2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.resistor2.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.resistor2.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.resistor2.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.resistor2.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.resistor2.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.resistor2.P, singlePhaseTransformerQS1.resistor2.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.resistor2.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.resistor2.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.resistor2.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.resistor2.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.resistor2.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Boolean singlePhaseTransformerQS1.resistor2.useHeatPort = singlePhaseTransformerQS1.useHeatPort \"=true, if heatPort is enabled\";
//   parameter Real singlePhaseTransformerQS1.resistor2.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = singlePhaseTransformerQS1.TOperational \"Fixed device temperature if useHeatPort = false\";
//   Real singlePhaseTransformerQS1.resistor2.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via heatPort\";
//   Real singlePhaseTransformerQS1.resistor2.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperature of heatPort\";
//   parameter Real singlePhaseTransformerQS1.resistor2.R_ref(quantity = \"Resistance\", unit = \"Ohm\", start = 1.0) = singlePhaseTransformerQS1.R2 \"Reference resistance at T_ref\";
//   parameter Real singlePhaseTransformerQS1.resistor2.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = singlePhaseTransformerQS1.TRef \"Reference temperature\";
//   parameter Real singlePhaseTransformerQS1.resistor2.alpha_ref(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = singlePhaseTransformerQS1.alpha20_2 \"Temperature coefficient of resistance (R_actual = R_ref*(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.resistor2.R_actual(quantity = \"Resistance\", unit = \"Ohm\") \"Resistance = R_ref*(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.inductorh.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductorh.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.inductorh.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductorh.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.inductorh.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.inductorh.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.inductorh.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.inductorh.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.inductorh.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductorh.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductorh.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.inductorh.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductorh.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductorh.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.inductorh.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.inductorh.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.inductorh.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.inductorh.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.inductorh.P, singlePhaseTransformerQS1.inductorh.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.inductorh.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.inductorh.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.inductorh.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.inductorh.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.inductorh.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Real singlePhaseTransformerQS1.inductorh.L(quantity = \"Inductance\", unit = \"H\", start = 1.0) = singlePhaseTransformerQS1.Lm \"Inductance\";
//   parameter Real singlePhaseTransformerQS1.idealTransformer.n = singlePhaseTransformerQS1.N1 / singlePhaseTransformerQS1.N2 \"Ratio of primary to secondary voltage\";
//   Real singlePhaseTransformerQS1.idealTransformer.v1.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.v1.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.i1.re(quantity = \"ElectricCurrent\", unit = \"A\") = singlePhaseTransformerQS1.idealTransformer.pin_p1.i.re;
//   Real singlePhaseTransformerQS1.idealTransformer.i1.im(quantity = \"ElectricCurrent\", unit = \"A\") = singlePhaseTransformerQS1.idealTransformer.pin_p1.i.im;
//   Real singlePhaseTransformerQS1.idealTransformer.v2.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.v2.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.i2.re(quantity = \"ElectricCurrent\", unit = \"A\") = singlePhaseTransformerQS1.idealTransformer.pin_p2.i.re;
//   Real singlePhaseTransformerQS1.idealTransformer.i2.im(quantity = \"ElectricCurrent\", unit = \"A\") = singlePhaseTransformerQS1.idealTransformer.pin_p2.i.im;
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p1.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_p2.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n1.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.idealTransformer.pin_n2.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.conductor.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.conductor.v)) \"Magnitude of complex voltage\";
//   Real singlePhaseTransformerQS1.conductor.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.conductor.v), 0.0) \"Argument of complex voltage\";
//   Real singlePhaseTransformerQS1.conductor.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(singlePhaseTransformerQS1.conductor.i)) \"Magnitude of complex current\";
//   Real singlePhaseTransformerQS1.conductor.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(singlePhaseTransformerQS1.conductor.i), 0.0) \"Argument of complex current\";
//   Real singlePhaseTransformerQS1.conductor.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.conductor.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.conductor.i)))) \"Active power\";
//   Real singlePhaseTransformerQS1.conductor.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.conductor.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.conductor.i)))) \"Reactive power\";
//   Real singlePhaseTransformerQS1.conductor.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.conductor.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.conductor.i)))) \"Magnitude of complex apparent power\";
//   Real singlePhaseTransformerQS1.conductor.pf = cos(Modelica.ComplexMath.arg(Complex(singlePhaseTransformerQS1.conductor.P, singlePhaseTransformerQS1.conductor.Q), 0.0)) \"Power factor\";
//   Real singlePhaseTransformerQS1.conductor.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real singlePhaseTransformerQS1.conductor.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.conductor.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.conductor.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.conductor.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   parameter Boolean singlePhaseTransformerQS1.conductor.useHeatPort = singlePhaseTransformerQS1.useHeatPort \"=true, if heatPort is enabled\";
//   parameter Real singlePhaseTransformerQS1.conductor.T(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = singlePhaseTransformerQS1.conductor.T_ref \"Fixed device temperature if useHeatPort = false\";
//   Real singlePhaseTransformerQS1.conductor.LossPower(quantity = \"Power\", unit = \"W\") \"Loss power leaving component via heatPort\";
//   Real singlePhaseTransformerQS1.conductor.T_heatPort(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) \"Temperature of heatPort\";
//   parameter Real singlePhaseTransformerQS1.conductor.G_ref(quantity = \"Conductance\", unit = \"S\", start = 1.0) = singlePhaseTransformerQS1.Gc \"Reference conductance at T_ref\";
//   parameter Real singlePhaseTransformerQS1.conductor.T_ref(quantity = \"ThermodynamicTemperature\", unit = \"K\", displayUnit = \"degC\", min = 0.0, start = 288.15, nominal = 300.0) = 293.15 \"Reference temperature\";
//   parameter Real singlePhaseTransformerQS1.conductor.alpha_ref(quantity = \"LinearTemperatureCoefficient\", unit = \"1/K\") = 0.0 \"Temperature coefficient of conductance (G_actual = G_ref/(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.conductor.G_actual(quantity = \"Conductance\", unit = \"S\") \"Conductance = G_ref/(1 + alpha_ref*(heatPort.T - T_ref))\";
//   Real singlePhaseTransformerQS1.pin_p1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_p1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_p1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_p1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_p1.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.pin_p2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_p2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_p2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_p2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_p2.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.pin_n1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_n1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_n1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_n1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_n1.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real singlePhaseTransformerQS1.pin_n2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_n2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real singlePhaseTransformerQS1.pin_n2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_n2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real singlePhaseTransformerQS1.pin_n2.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real ground1.pin.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real ground1.pin.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real ground1.pin.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real ground1.pin.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real ground1.pin.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real currentSensor2.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor2.v)) \"Magnitude of complex voltage\";
//   Real currentSensor2.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor2.v), 0.0) \"Argument of complex voltage\";
//   Real currentSensor2.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor2.i)) \"Magnitude of complex current\";
//   Real currentSensor2.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor2.i), 0.0) \"Argument of complex current\";
//   Real currentSensor2.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(currentSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor2.i)))) \"Active power\";
//   Real currentSensor2.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(currentSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor2.i)))) \"Reactive power\";
//   Real currentSensor2.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(currentSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(currentSensor2.i)))) \"Magnitude of complex apparent power\";
//   Real currentSensor2.pf = cos(Modelica.ComplexMath.arg(Complex(currentSensor2.P, currentSensor2.Q), 0.0)) \"Power factor\";
//   Real currentSensor2.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real currentSensor2.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real currentSensor2.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real currentSensor2.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real currentSensor2.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real currentSensor2.y.re \"Real part of complex number\";
//   Real currentSensor2.y.im \"Imaginary part of complex number\";
//   Real currentSensor2.abs_y(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(currentSensor2.y)) \"Magnitude of complex current\";
//   Real currentSensor2.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(currentSensor2.y), 0.0) \"Argument of complex current\";
//   Real voltageSource1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.abs_v(quantity = \"ElectricPotential\", unit = \"V\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSource1.v)) \"Magnitude of complex voltage\";
//   Real voltageSource1.arg_v(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSource1.v), 0.0) \"Argument of complex voltage\";
//   Real voltageSource1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.abs_i(quantity = \"ElectricCurrent\", unit = \"A\") = Modelica.ComplexMath.'abs'(/*.Complex*/(voltageSource1.i)) \"Magnitude of complex current\";
//   Real voltageSource1.arg_i(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(voltageSource1.i), 0.0) \"Argument of complex current\";
//   Real voltageSource1.P(quantity = \"Power\", unit = \"W\") = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(voltageSource1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSource1.i)))) \"Active power\";
//   Real voltageSource1.Q(quantity = \"Power\", unit = \"var\") = Modelica.ComplexMath.imag(Complex.'*'.multiply(/*.Complex*/(voltageSource1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSource1.i)))) \"Reactive power\";
//   Real voltageSource1.S(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(Complex.'*'.multiply(/*.Complex*/(voltageSource1.v), Modelica.ComplexMath.conj(/*.Complex*/(voltageSource1.i)))) \"Magnitude of complex apparent power\";
//   Real voltageSource1.pf = cos(Modelica.ComplexMath.arg(Complex(voltageSource1.P, voltageSource1.Q), 0.0)) \"Power factor\";
//   Real voltageSource1.omega(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Angular velocity of reference frame\";
//   Real voltageSource1.pin_p.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.pin_p.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.pin_p.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.pin_p.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.pin_p.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSource1.pin_n.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.pin_n.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real voltageSource1.pin_n.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.pin_n.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real voltageSource1.pin_n.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real voltageSource1.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0) = voltageSource1.pin_p.reference.gamma;
//   parameter Real voltageSource1.f(quantity = \"Frequency\", unit = \"Hz\", start = 1.0) = 50.0 \"frequency of the source\";
//   parameter Real voltageSource1.V(quantity = \"ElectricPotential\", unit = \"V\", start = 1.0) = 98.5 \"RMS voltage of the source\";
//   parameter Real voltageSource1.phi(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\", start = 0.0) \"phase shift of the source\";
//   Real powerSensor1.currentP.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.currentP.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.currentP.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.currentP.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.currentP.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor1.currentN.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.currentN.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.currentN.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.currentN.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.currentN.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor1.voltageP.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.voltageP.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.voltageP.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.voltageP.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.voltageP.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor1.voltageN.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.voltageN.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.voltageN.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.voltageN.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.voltageN.reference.gamma(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\");
//   Real powerSensor1.i.re(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.i.im(quantity = \"ElectricCurrent\", unit = \"A\");
//   Real powerSensor1.v.re(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.v.im(quantity = \"ElectricPotential\", unit = \"V\");
//   Real powerSensor1.y.re \"Real part of complex number\";
//   Real powerSensor1.y.im \"Imaginary part of complex number\";
//   Real powerSensor1.abs_y(quantity = \"Power\", unit = \"VA\") = Modelica.ComplexMath.'abs'(/*.Complex*/(powerSensor1.y)) \"Magnitude of complex apparent power\";
//   Real powerSensor1.arg_y(quantity = \"Angle\", unit = \"rad\", displayUnit = \"deg\") = Modelica.ComplexMath.arg(/*.Complex*/(powerSensor1.y), 0.0) \"Argument of complex apparent power\";
// equation
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(singlePhaseTransformerQS1.conductor.pin_p.reference, singlePhaseTransformerQS1.inductorh.pin_p.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(singlePhaseTransformerQS1.inductor1.pin_n.reference, singlePhaseTransformerQS1.idealTransformer.pin_p1.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(powerSensor1.currentP.reference, powerSensor1.voltageP.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(voltageSensor1.pin_n.reference, ground2.pin.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(currentSensor1.pin_p.reference, voltageSensor1.pin_p.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(singlePhaseTransformerQS1.pin_n2.reference, ground2.pin.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(voltageSensor2.pin_p.reference, powerSensor2.currentN.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(singlePhaseTransformerQS1.pin_p1.reference, powerSensor2.currentN.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(voltageSource1.pin_p.reference, currentSensor2.pin_n.reference) \" equation generated by overconstrained connection graph breaking\";
//   {} = Modelica.Electrical.QuasiStationary.Types.Reference.equalityConstraint(powerSensor2.currentP.reference, powerSensor2.voltageP.reference) \" equation generated by overconstrained connection graph breaking\";
//   powerSensor2.currentP.reference.gamma = powerSensor2.currentN.reference.gamma;
//   powerSensor2.voltageP.reference.gamma = powerSensor2.voltageN.reference.gamma;
//   powerSensor2.currentP.reference.gamma = powerSensor2.voltageP.reference.gamma;
//   Complex.'+'(/*.Complex*/(powerSensor2.currentP.i), /*.Complex*/(powerSensor2.currentN.i)) = Complex(0.0, 0.0);
//   Complex.'-'.subtract(/*.Complex*/(powerSensor2.currentP.v), /*.Complex*/(powerSensor2.currentN.v)) = Complex(0.0, 0.0);
//   powerSensor2.i.re = powerSensor2.currentP.i.re;
//   powerSensor2.i.im = powerSensor2.currentP.i.im;
//   Complex.'+'(/*.Complex*/(powerSensor2.voltageP.i), /*.Complex*/(powerSensor2.voltageN.i)) = Complex(0.0, 0.0);
//   powerSensor2.voltageP.i.re = 0.0;
//   powerSensor2.voltageP.i.im = 0.0;
//   powerSensor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(powerSensor2.voltageP.v), /*.Complex*/(powerSensor2.voltageN.v)));
//   powerSensor2.y = /*.ComplexOutput*/(Complex.'*'.multiply(/*.Complex*/(powerSensor2.v), Modelica.ComplexMath.conj(/*.Complex*/(powerSensor2.i))));
//   voltageSensor2.i.re = 0.0;
//   voltageSensor2.i.im = 0.0;
//   voltageSensor2.y.re = voltageSensor2.v.re;
//   voltageSensor2.y.im = voltageSensor2.v.im;
//   Complex.'+'(/*.Complex*/(voltageSensor2.pin_p.i), /*.Complex*/(voltageSensor2.pin_n.i)) = Complex(0.0, 0.0);
//   voltageSensor2.pin_p.reference.gamma = voltageSensor2.pin_n.reference.gamma;
//   voltageSensor2.omega = der(voltageSensor2.pin_p.reference.gamma);
//   voltageSensor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(voltageSensor2.pin_p.v), /*.Complex*/(voltageSensor2.pin_n.v)));
//   voltageSensor2.i.re = voltageSensor2.pin_p.i.re;
//   voltageSensor2.i.im = voltageSensor2.pin_p.i.im;
//   currentSensor1.v.re = 0.0;
//   currentSensor1.v.im = 0.0;
//   currentSensor1.y.re = currentSensor1.i.re;
//   currentSensor1.y.im = currentSensor1.i.im;
//   Complex.'+'(/*.Complex*/(currentSensor1.pin_p.i), /*.Complex*/(currentSensor1.pin_n.i)) = Complex(0.0, 0.0);
//   currentSensor1.pin_p.reference.gamma = currentSensor1.pin_n.reference.gamma;
//   currentSensor1.omega = der(currentSensor1.pin_p.reference.gamma);
//   currentSensor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(currentSensor1.pin_p.v), /*.Complex*/(currentSensor1.pin_n.v)));
//   currentSensor1.i.re = currentSensor1.pin_p.i.re;
//   currentSensor1.i.im = currentSensor1.pin_p.i.im;
//   if false then
//     ground2.pin.reference.gamma = 0.0;
//   end if;
//   ground2.pin.v.re = 0.0;
//   ground2.pin.v.im = 0.0;
//   voltageSensor1.i.re = 0.0;
//   voltageSensor1.i.im = 0.0;
//   voltageSensor1.y.re = voltageSensor1.v.re;
//   voltageSensor1.y.im = voltageSensor1.v.im;
//   Complex.'+'(/*.Complex*/(voltageSensor1.pin_p.i), /*.Complex*/(voltageSensor1.pin_n.i)) = Complex(0.0, 0.0);
//   voltageSensor1.pin_p.reference.gamma = voltageSensor1.pin_n.reference.gamma;
//   voltageSensor1.omega = der(voltageSensor1.pin_p.reference.gamma);
//   voltageSensor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(voltageSensor1.pin_p.v), /*.Complex*/(voltageSensor1.pin_n.v)));
//   voltageSensor1.i.re = voltageSensor1.pin_p.i.re;
//   voltageSensor1.i.im = voltageSensor1.pin_p.i.im;
//   singlePhaseTransformerQS1.inductor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex.'*'.multiply(Complex.'*'.multiply(Complex(0.0, 1.0), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductor1.omega, 0.0)), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductor1.L, 0.0)), /*.Complex*/(singlePhaseTransformerQS1.inductor1.i)));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.inductor1.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.inductor1.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.inductor1.pin_p.reference.gamma = singlePhaseTransformerQS1.inductor1.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.inductor1.omega = der(singlePhaseTransformerQS1.inductor1.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.inductor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.inductor1.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.inductor1.pin_n.v)));
//   singlePhaseTransformerQS1.inductor1.i.re = singlePhaseTransformerQS1.inductor1.pin_p.i.re;
//   singlePhaseTransformerQS1.inductor1.i.im = singlePhaseTransformerQS1.inductor1.pin_p.i.im;
//   singlePhaseTransformerQS1.inductor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex.'*'.multiply(Complex.'*'.multiply(Complex(0.0, 1.0), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductor2.omega, 0.0)), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductor2.L, 0.0)), /*.Complex*/(singlePhaseTransformerQS1.inductor2.i)));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.inductor2.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.inductor2.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.inductor2.pin_p.reference.gamma = singlePhaseTransformerQS1.inductor2.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.inductor2.omega = der(singlePhaseTransformerQS1.inductor2.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.inductor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.inductor2.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.inductor2.pin_n.v)));
//   singlePhaseTransformerQS1.inductor2.i.re = singlePhaseTransformerQS1.inductor2.pin_p.i.re;
//   singlePhaseTransformerQS1.inductor2.i.im = singlePhaseTransformerQS1.inductor2.pin_p.i.im;
//   assert(1.0 + singlePhaseTransformerQS1.resistor1.alpha_ref * (singlePhaseTransformerQS1.resistor1.T_heatPort - singlePhaseTransformerQS1.resistor1.T_ref) >= 1e-015, \"Temperature outside scope of model!\");
//   singlePhaseTransformerQS1.resistor1.R_actual = singlePhaseTransformerQS1.resistor1.R_ref * (1.0 + singlePhaseTransformerQS1.resistor1.alpha_ref * (singlePhaseTransformerQS1.resistor1.T_heatPort - singlePhaseTransformerQS1.resistor1.T_ref));
//   singlePhaseTransformerQS1.resistor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex.'constructor'.fromReal(singlePhaseTransformerQS1.resistor1.R_actual, 0.0), /*.Complex*/(singlePhaseTransformerQS1.resistor1.i)));
//   singlePhaseTransformerQS1.resistor1.LossPower = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor1.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor1.i))));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.resistor1.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.resistor1.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.resistor1.pin_p.reference.gamma = singlePhaseTransformerQS1.resistor1.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.resistor1.omega = der(singlePhaseTransformerQS1.resistor1.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.resistor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.resistor1.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.resistor1.pin_n.v)));
//   singlePhaseTransformerQS1.resistor1.i.re = singlePhaseTransformerQS1.resistor1.pin_p.i.re;
//   singlePhaseTransformerQS1.resistor1.i.im = singlePhaseTransformerQS1.resistor1.pin_p.i.im;
//   singlePhaseTransformerQS1.resistor1.T_heatPort = singlePhaseTransformerQS1.resistor1.T;
//   assert(1.0 + singlePhaseTransformerQS1.resistor2.alpha_ref * (singlePhaseTransformerQS1.resistor2.T_heatPort - singlePhaseTransformerQS1.resistor2.T_ref) >= 1e-015, \"Temperature outside scope of model!\");
//   singlePhaseTransformerQS1.resistor2.R_actual = singlePhaseTransformerQS1.resistor2.R_ref * (1.0 + singlePhaseTransformerQS1.resistor2.alpha_ref * (singlePhaseTransformerQS1.resistor2.T_heatPort - singlePhaseTransformerQS1.resistor2.T_ref));
//   singlePhaseTransformerQS1.resistor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex.'constructor'.fromReal(singlePhaseTransformerQS1.resistor2.R_actual, 0.0), /*.Complex*/(singlePhaseTransformerQS1.resistor2.i)));
//   singlePhaseTransformerQS1.resistor2.LossPower = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.resistor2.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.resistor2.i))));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.resistor2.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.resistor2.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.resistor2.pin_p.reference.gamma = singlePhaseTransformerQS1.resistor2.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.resistor2.omega = der(singlePhaseTransformerQS1.resistor2.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.resistor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.resistor2.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.resistor2.pin_n.v)));
//   singlePhaseTransformerQS1.resistor2.i.re = singlePhaseTransformerQS1.resistor2.pin_p.i.re;
//   singlePhaseTransformerQS1.resistor2.i.im = singlePhaseTransformerQS1.resistor2.pin_p.i.im;
//   singlePhaseTransformerQS1.resistor2.T_heatPort = singlePhaseTransformerQS1.resistor2.T;
//   singlePhaseTransformerQS1.inductorh.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex.'*'.multiply(Complex.'*'.multiply(Complex(0.0, 1.0), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductorh.omega, 0.0)), Complex.'constructor'.fromReal(singlePhaseTransformerQS1.inductorh.L, 0.0)), /*.Complex*/(singlePhaseTransformerQS1.inductorh.i)));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.inductorh.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.inductorh.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.inductorh.pin_p.reference.gamma = singlePhaseTransformerQS1.inductorh.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.inductorh.omega = der(singlePhaseTransformerQS1.inductorh.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.inductorh.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.inductorh.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.inductorh.pin_n.v)));
//   singlePhaseTransformerQS1.inductorh.i.re = singlePhaseTransformerQS1.inductorh.pin_p.i.re;
//   singlePhaseTransformerQS1.inductorh.i.im = singlePhaseTransformerQS1.inductorh.pin_p.i.im;
//   singlePhaseTransformerQS1.idealTransformer.v1 = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_p1.v), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_n1.v)));
//   singlePhaseTransformerQS1.idealTransformer.v2 = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_p2.v), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_n2.v)));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_p1.i), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_n1.i)) = Complex(0.0, 0.0);
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_p2.i), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.pin_n2.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.idealTransformer.v1 = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'*'.multiply(Complex(singlePhaseTransformerQS1.idealTransformer.n, 0.0), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.v2)));
//   singlePhaseTransformerQS1.idealTransformer.i2 = /*.Modelica.SIunits.ComplexCurrent*/(Complex.'*'.multiply(Complex(-singlePhaseTransformerQS1.idealTransformer.n, 0.0), /*.Complex*/(singlePhaseTransformerQS1.idealTransformer.i1)));
//   singlePhaseTransformerQS1.idealTransformer.pin_p1.reference.gamma = singlePhaseTransformerQS1.idealTransformer.pin_n1.reference.gamma;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.reference.gamma = singlePhaseTransformerQS1.idealTransformer.pin_n2.reference.gamma;
//   singlePhaseTransformerQS1.idealTransformer.pin_p1.reference.gamma = singlePhaseTransformerQS1.idealTransformer.pin_p2.reference.gamma;
//   assert(1.0 + singlePhaseTransformerQS1.conductor.alpha_ref * (singlePhaseTransformerQS1.conductor.T_heatPort - singlePhaseTransformerQS1.conductor.T_ref) >= 1e-015, \"Temperature outside scope of model!\");
//   singlePhaseTransformerQS1.conductor.G_actual = singlePhaseTransformerQS1.conductor.G_ref / (1.0 + singlePhaseTransformerQS1.conductor.alpha_ref * (singlePhaseTransformerQS1.conductor.T_heatPort - singlePhaseTransformerQS1.conductor.T_ref));
//   singlePhaseTransformerQS1.conductor.i = /*.Modelica.SIunits.ComplexCurrent*/(Complex.'*'.multiply(Complex.'constructor'.fromReal(singlePhaseTransformerQS1.conductor.G_actual, 0.0), /*.Complex*/(singlePhaseTransformerQS1.conductor.v)));
//   singlePhaseTransformerQS1.conductor.LossPower = Modelica.ComplexMath.real(Complex.'*'.multiply(/*.Complex*/(singlePhaseTransformerQS1.conductor.v), Modelica.ComplexMath.conj(/*.Complex*/(singlePhaseTransformerQS1.conductor.i))));
//   Complex.'+'(/*.Complex*/(singlePhaseTransformerQS1.conductor.pin_p.i), /*.Complex*/(singlePhaseTransformerQS1.conductor.pin_n.i)) = Complex(0.0, 0.0);
//   singlePhaseTransformerQS1.conductor.pin_p.reference.gamma = singlePhaseTransformerQS1.conductor.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.conductor.omega = der(singlePhaseTransformerQS1.conductor.pin_p.reference.gamma);
//   singlePhaseTransformerQS1.conductor.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(singlePhaseTransformerQS1.conductor.pin_p.v), /*.Complex*/(singlePhaseTransformerQS1.conductor.pin_n.v)));
//   singlePhaseTransformerQS1.conductor.i.re = singlePhaseTransformerQS1.conductor.pin_p.i.re;
//   singlePhaseTransformerQS1.conductor.i.im = singlePhaseTransformerQS1.conductor.pin_p.i.im;
//   singlePhaseTransformerQS1.conductor.T_heatPort = singlePhaseTransformerQS1.conductor.T;
//   if false then
//     ground1.pin.reference.gamma = 0.0;
//   end if;
//   ground1.pin.v.re = 0.0;
//   ground1.pin.v.im = 0.0;
//   currentSensor2.v.re = 0.0;
//   currentSensor2.v.im = 0.0;
//   currentSensor2.y.re = currentSensor2.i.re;
//   currentSensor2.y.im = currentSensor2.i.im;
//   Complex.'+'(/*.Complex*/(currentSensor2.pin_p.i), /*.Complex*/(currentSensor2.pin_n.i)) = Complex(0.0, 0.0);
//   currentSensor2.pin_p.reference.gamma = currentSensor2.pin_n.reference.gamma;
//   currentSensor2.omega = der(currentSensor2.pin_p.reference.gamma);
//   currentSensor2.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(currentSensor2.pin_p.v), /*.Complex*/(currentSensor2.pin_n.v)));
//   currentSensor2.i.re = currentSensor2.pin_p.i.re;
//   currentSensor2.i.im = currentSensor2.pin_p.i.im;
//   voltageSource1.omega = 6.283185307179586 * voltageSource1.f;
//   voltageSource1.v.re = voltageSource1.V * cos(voltageSource1.phi);
//   voltageSource1.v.im = voltageSource1.V * sin(voltageSource1.phi);
//   Complex.'+'(/*.Complex*/(voltageSource1.pin_p.i), /*.Complex*/(voltageSource1.pin_n.i)) = Complex(0.0, 0.0);
//   voltageSource1.pin_p.reference.gamma = voltageSource1.pin_n.reference.gamma;
//   voltageSource1.omega = der(voltageSource1.pin_p.reference.gamma);
//   voltageSource1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(voltageSource1.pin_p.v), /*.Complex*/(voltageSource1.pin_n.v)));
//   voltageSource1.i.re = voltageSource1.pin_p.i.re;
//   voltageSource1.i.im = voltageSource1.pin_p.i.im;
//   powerSensor1.currentP.reference.gamma = powerSensor1.currentN.reference.gamma;
//   powerSensor1.voltageP.reference.gamma = powerSensor1.voltageN.reference.gamma;
//   powerSensor1.currentP.reference.gamma = powerSensor1.voltageP.reference.gamma;
//   Complex.'+'(/*.Complex*/(powerSensor1.currentP.i), /*.Complex*/(powerSensor1.currentN.i)) = Complex(0.0, 0.0);
//   Complex.'-'.subtract(/*.Complex*/(powerSensor1.currentP.v), /*.Complex*/(powerSensor1.currentN.v)) = Complex(0.0, 0.0);
//   powerSensor1.i.re = powerSensor1.currentP.i.re;
//   powerSensor1.i.im = powerSensor1.currentP.i.im;
//   Complex.'+'(/*.Complex*/(powerSensor1.voltageP.i), /*.Complex*/(powerSensor1.voltageN.i)) = Complex(0.0, 0.0);
//   powerSensor1.voltageP.i.re = 0.0;
//   powerSensor1.voltageP.i.im = 0.0;
//   powerSensor1.v = /*.Modelica.SIunits.ComplexVoltage*/(Complex.'-'.subtract(/*.Complex*/(powerSensor1.voltageP.v), /*.Complex*/(powerSensor1.voltageN.v)));
//   powerSensor1.y = /*.ComplexOutput*/(Complex.'*'.multiply(/*.Complex*/(powerSensor1.v), Modelica.ComplexMath.conj(/*.Complex*/(powerSensor1.i))));
//   powerSensor2.currentP.i.re + powerSensor2.voltageP.i.re + currentSensor2.pin_p.i.re = 0.0;
//   powerSensor2.currentP.i.im + powerSensor2.voltageP.i.im + currentSensor2.pin_p.i.im = 0.0;
//   powerSensor2.currentN.i.re + voltageSensor2.pin_p.i.re + singlePhaseTransformerQS1.pin_p1.i.re = 0.0;
//   powerSensor2.currentN.i.im + voltageSensor2.pin_p.i.im + singlePhaseTransformerQS1.pin_p1.i.im = 0.0;
//   powerSensor2.voltageN.i.re + voltageSensor2.pin_n.i.re + singlePhaseTransformerQS1.pin_n1.i.re + ground1.pin.i.re + voltageSource1.pin_n.i.re = 0.0;
//   powerSensor2.voltageN.i.im + voltageSensor2.pin_n.i.im + singlePhaseTransformerQS1.pin_n1.i.im + ground1.pin.i.im + voltageSource1.pin_n.i.im = 0.0;
//   currentSensor1.pin_p.i.re + ground2.pin.i.re + voltageSensor1.pin_p.i.re + voltageSensor1.pin_n.i.re + singlePhaseTransformerQS1.pin_n2.i.re + powerSensor1.voltageN.i.re = 0.0;
//   currentSensor1.pin_p.i.im + ground2.pin.i.im + voltageSensor1.pin_p.i.im + voltageSensor1.pin_n.i.im + singlePhaseTransformerQS1.pin_n2.i.im + powerSensor1.voltageN.i.im = 0.0;
//   currentSensor1.pin_n.i.re + powerSensor1.currentN.i.re = 0.0;
//   currentSensor1.pin_n.i.im + powerSensor1.currentN.i.im = 0.0;
//   singlePhaseTransformerQS1.pin_p2.i.re + powerSensor1.currentP.i.re + powerSensor1.voltageP.i.re = 0.0;
//   singlePhaseTransformerQS1.pin_p2.i.im + powerSensor1.currentP.i.im + powerSensor1.voltageP.i.im = 0.0;
//   singlePhaseTransformerQS1.inductor1.pin_p.i.re + singlePhaseTransformerQS1.resistor1.pin_n.i.re = 0.0;
//   singlePhaseTransformerQS1.inductor1.pin_p.i.im + singlePhaseTransformerQS1.resistor1.pin_n.i.im = 0.0;
//   singlePhaseTransformerQS1.inductor1.pin_n.i.re + singlePhaseTransformerQS1.idealTransformer.pin_p1.i.re + singlePhaseTransformerQS1.conductor.pin_p.i.re + singlePhaseTransformerQS1.inductorh.pin_p.i.re = 0.0;
//   singlePhaseTransformerQS1.inductor1.pin_n.i.im + singlePhaseTransformerQS1.idealTransformer.pin_p1.i.im + singlePhaseTransformerQS1.conductor.pin_p.i.im + singlePhaseTransformerQS1.inductorh.pin_p.i.im = 0.0;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.i.re + singlePhaseTransformerQS1.inductor2.pin_n.i.re = 0.0;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.i.im + singlePhaseTransformerQS1.inductor2.pin_n.i.im = 0.0;
//   (-singlePhaseTransformerQS1.pin_n1.i.re) + singlePhaseTransformerQS1.idealTransformer.pin_n1.i.re + singlePhaseTransformerQS1.conductor.pin_n.i.re + singlePhaseTransformerQS1.inductorh.pin_n.i.re = 0.0;
//   (-singlePhaseTransformerQS1.pin_n1.i.im) + singlePhaseTransformerQS1.idealTransformer.pin_n1.i.im + singlePhaseTransformerQS1.conductor.pin_n.i.im + singlePhaseTransformerQS1.inductorh.pin_n.i.im = 0.0;
//   (-singlePhaseTransformerQS1.pin_n2.i.re) + singlePhaseTransformerQS1.idealTransformer.pin_n2.i.re = 0.0;
//   (-singlePhaseTransformerQS1.pin_n2.i.im) + singlePhaseTransformerQS1.idealTransformer.pin_n2.i.im = 0.0;
//   singlePhaseTransformerQS1.inductor2.pin_p.i.re + singlePhaseTransformerQS1.resistor2.pin_n.i.re = 0.0;
//   singlePhaseTransformerQS1.inductor2.pin_p.i.im + singlePhaseTransformerQS1.resistor2.pin_n.i.im = 0.0;
//   (-singlePhaseTransformerQS1.pin_p1.i.re) + singlePhaseTransformerQS1.resistor1.pin_p.i.re = 0.0;
//   (-singlePhaseTransformerQS1.pin_p1.i.im) + singlePhaseTransformerQS1.resistor1.pin_p.i.im = 0.0;
//   (-singlePhaseTransformerQS1.pin_p2.i.re) + singlePhaseTransformerQS1.resistor2.pin_p.i.re = 0.0;
//   (-singlePhaseTransformerQS1.pin_p2.i.im) + singlePhaseTransformerQS1.resistor2.pin_p.i.im = 0.0;
//   singlePhaseTransformerQS1.pin_p1.reference.gamma = singlePhaseTransformerQS1.resistor1.pin_p.reference.gamma;
//   singlePhaseTransformerQS1.pin_p1.v.re = singlePhaseTransformerQS1.resistor1.pin_p.v.re;
//   singlePhaseTransformerQS1.pin_p1.v.im = singlePhaseTransformerQS1.resistor1.pin_p.v.im;
//   singlePhaseTransformerQS1.inductor1.pin_p.reference.gamma = singlePhaseTransformerQS1.resistor1.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.inductor1.pin_p.v.re = singlePhaseTransformerQS1.resistor1.pin_n.v.re;
//   singlePhaseTransformerQS1.inductor1.pin_p.v.im = singlePhaseTransformerQS1.resistor1.pin_n.v.im;
//   singlePhaseTransformerQS1.inductor2.pin_p.reference.gamma = singlePhaseTransformerQS1.resistor2.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.inductor2.pin_p.v.re = singlePhaseTransformerQS1.resistor2.pin_n.v.re;
//   singlePhaseTransformerQS1.inductor2.pin_p.v.im = singlePhaseTransformerQS1.resistor2.pin_n.v.im;
//   singlePhaseTransformerQS1.inductorh.pin_p.reference.gamma = singlePhaseTransformerQS1.inductor1.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.conductor.pin_p.v.re = singlePhaseTransformerQS1.idealTransformer.pin_p1.v.re;
//   singlePhaseTransformerQS1.conductor.pin_p.v.re = singlePhaseTransformerQS1.inductor1.pin_n.v.re;
//   singlePhaseTransformerQS1.conductor.pin_p.v.re = singlePhaseTransformerQS1.inductorh.pin_p.v.re;
//   singlePhaseTransformerQS1.conductor.pin_p.v.im = singlePhaseTransformerQS1.idealTransformer.pin_p1.v.im;
//   singlePhaseTransformerQS1.conductor.pin_p.v.im = singlePhaseTransformerQS1.inductor1.pin_n.v.im;
//   singlePhaseTransformerQS1.conductor.pin_p.v.im = singlePhaseTransformerQS1.inductorh.pin_p.v.im;
//   singlePhaseTransformerQS1.conductor.pin_n.reference.gamma = singlePhaseTransformerQS1.idealTransformer.pin_n1.reference.gamma;
//   singlePhaseTransformerQS1.conductor.pin_n.reference.gamma = singlePhaseTransformerQS1.inductorh.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.conductor.pin_n.reference.gamma = singlePhaseTransformerQS1.pin_n1.reference.gamma;
//   singlePhaseTransformerQS1.conductor.pin_n.v.re = singlePhaseTransformerQS1.idealTransformer.pin_n1.v.re;
//   singlePhaseTransformerQS1.conductor.pin_n.v.re = singlePhaseTransformerQS1.inductorh.pin_n.v.re;
//   singlePhaseTransformerQS1.conductor.pin_n.v.re = singlePhaseTransformerQS1.pin_n1.v.re;
//   singlePhaseTransformerQS1.conductor.pin_n.v.im = singlePhaseTransformerQS1.idealTransformer.pin_n1.v.im;
//   singlePhaseTransformerQS1.conductor.pin_n.v.im = singlePhaseTransformerQS1.inductorh.pin_n.v.im;
//   singlePhaseTransformerQS1.conductor.pin_n.v.im = singlePhaseTransformerQS1.pin_n1.v.im;
//   singlePhaseTransformerQS1.idealTransformer.pin_n2.reference.gamma = singlePhaseTransformerQS1.pin_n2.reference.gamma;
//   singlePhaseTransformerQS1.idealTransformer.pin_n2.v.re = singlePhaseTransformerQS1.pin_n2.v.re;
//   singlePhaseTransformerQS1.idealTransformer.pin_n2.v.im = singlePhaseTransformerQS1.pin_n2.v.im;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.reference.gamma = singlePhaseTransformerQS1.inductor2.pin_n.reference.gamma;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.v.re = singlePhaseTransformerQS1.inductor2.pin_n.v.re;
//   singlePhaseTransformerQS1.idealTransformer.pin_p2.v.im = singlePhaseTransformerQS1.inductor2.pin_n.v.im;
//   singlePhaseTransformerQS1.pin_p2.reference.gamma = singlePhaseTransformerQS1.resistor2.pin_p.reference.gamma;
//   singlePhaseTransformerQS1.pin_p2.v.re = singlePhaseTransformerQS1.resistor2.pin_p.v.re;
//   singlePhaseTransformerQS1.pin_p2.v.im = singlePhaseTransformerQS1.resistor2.pin_p.v.im;
//   currentSensor2.pin_n.i.re + voltageSource1.pin_p.i.re = 0.0;
//   currentSensor2.pin_n.i.im + voltageSource1.pin_p.i.im = 0.0;
//   voltageSensor1.pin_n.reference.gamma = currentSensor1.pin_p.reference.gamma;
//   powerSensor1.voltageN.reference.gamma = ground2.pin.reference.gamma;
//   currentSensor1.pin_p.v.re = ground2.pin.v.re;
//   currentSensor1.pin_p.v.re = powerSensor1.voltageN.v.re;
//   currentSensor1.pin_p.v.re = singlePhaseTransformerQS1.pin_n2.v.re;
//   currentSensor1.pin_p.v.re = voltageSensor1.pin_n.v.re;
//   currentSensor1.pin_p.v.re = voltageSensor1.pin_p.v.re;
//   currentSensor1.pin_p.v.im = ground2.pin.v.im;
//   currentSensor1.pin_p.v.im = powerSensor1.voltageN.v.im;
//   currentSensor1.pin_p.v.im = singlePhaseTransformerQS1.pin_n2.v.im;
//   currentSensor1.pin_p.v.im = voltageSensor1.pin_n.v.im;
//   currentSensor1.pin_p.v.im = voltageSensor1.pin_p.v.im;
//   ground1.pin.reference.gamma = powerSensor2.voltageN.reference.gamma;
//   ground1.pin.reference.gamma = singlePhaseTransformerQS1.pin_n1.reference.gamma;
//   ground1.pin.reference.gamma = voltageSensor2.pin_n.reference.gamma;
//   ground1.pin.reference.gamma = voltageSource1.pin_n.reference.gamma;
//   ground1.pin.v.re = powerSensor2.voltageN.v.re;
//   ground1.pin.v.re = singlePhaseTransformerQS1.pin_n1.v.re;
//   ground1.pin.v.re = voltageSensor2.pin_n.v.re;
//   ground1.pin.v.re = voltageSource1.pin_n.v.re;
//   ground1.pin.v.im = powerSensor2.voltageN.v.im;
//   ground1.pin.v.im = singlePhaseTransformerQS1.pin_n1.v.im;
//   ground1.pin.v.im = voltageSensor2.pin_n.v.im;
//   ground1.pin.v.im = voltageSource1.pin_n.v.im;
//   singlePhaseTransformerQS1.pin_p2.reference.gamma = powerSensor1.currentP.reference.gamma;
//   powerSensor1.currentP.v.re = powerSensor1.voltageP.v.re;
//   powerSensor1.currentP.v.re = singlePhaseTransformerQS1.pin_p2.v.re;
//   powerSensor1.currentP.v.im = powerSensor1.voltageP.v.im;
//   powerSensor1.currentP.v.im = singlePhaseTransformerQS1.pin_p2.v.im;
//   currentSensor1.pin_n.reference.gamma = powerSensor1.currentN.reference.gamma;
//   currentSensor1.pin_n.v.re = powerSensor1.currentN.v.re;
//   currentSensor1.pin_n.v.im = powerSensor1.currentN.v.im;
//   powerSensor2.currentN.v.re = singlePhaseTransformerQS1.pin_p1.v.re;
//   powerSensor2.currentN.v.re = voltageSensor2.pin_p.v.re;
//   powerSensor2.currentN.v.im = singlePhaseTransformerQS1.pin_p1.v.im;
//   powerSensor2.currentN.v.im = voltageSensor2.pin_p.v.im;
//   powerSensor2.currentP.reference.gamma = currentSensor2.pin_p.reference.gamma;
//   currentSensor2.pin_p.v.re = powerSensor2.currentP.v.re;
//   currentSensor2.pin_p.v.re = powerSensor2.voltageP.v.re;
//   currentSensor2.pin_p.v.im = powerSensor2.currentP.v.im;
//   currentSensor2.pin_p.v.im = powerSensor2.voltageP.v.im;
//   currentSensor2.pin_n.v.re = voltageSource1.pin_p.v.re;
//   currentSensor2.pin_n.v.im = voltageSource1.pin_p.v.im;
// end Transformer.SC1;
// "
// ""
// "Check of Transformer.SC1 completed successfully.
// Class Transformer.SC1 has 393 equation(s) and 393 variable(s).
// 185 of these are trivial equation(s)."
// ""
// endResult
